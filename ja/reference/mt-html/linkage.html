<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180723_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=linkage.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Linkage</span>リンケージ</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The Rust compiler supports various methods to link crates together both statically and dynamically.</span> Rustコンパイラは、静的および動的の両方でクレートをリンクするさまざまな方法をサポートしています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This section will explore the various methods to link Rust crates together, and more information about native libraries can be found in the <a href=#3ffi>FFI section of the book</a> .</span>このセクションでは、Rustクレートをリンクするさまざまな方法について説明します。ネイティブライブラリの詳細について<a href=#3ffi>は、本のFFIセクションを参照してください</a> 。</span> </p><br> <a class=notranslate href=#1../book/ffi.html>ffi</a> <br> <p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In one session of compilation, the compiler can generate multiple artifacts through the usage of either command line flags or the <code>crate_type</code> attribute.</span>コンパイルの1つのセッションでは、コンパイラはコマンドラインフラグまたは<code>crate_type</code>属性のいずれかを使用して複数の成果物を生成できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If one or more command line flags are specified, all <code>crate_type</code> attributes will be ignored in favor of only building the artifacts specified by command line.</span> 1つ以上のコマンドラインフラグが指定されている場合、コマンドラインで指定された成果物を構築するためだけに、すべての<code>crate_type</code>属性は無視されます。</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>--crate-type=bin</code> , <code>#[crate_type = &quot;bin&quot;]</code> - A runnable executable will be produced.</span> <code>--crate-type=bin</code> 、 <code>#[crate_type = &quot;bin&quot;]</code> - 実行可能な実行可能ファイルが生成されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This requires that there is a <code>main</code> function in the crate which will be run when the program begins executing.</span>これには、プログラムが実行を開始するときに実行される<code>main</code>機能がクレートに存在する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This will link in all Rust and native dependencies, producing a distributable binary.</span>これにより、すべてのRustとネイティブの依存関係がリンクされ、配布可能なバイナリが生成されます。</span> </div><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>--crate-type=lib</code> , <code>#[crate_type = &quot;lib&quot;]</code> - A Rust library will be produced.</span> <code>--crate-type=lib</code> 、 <code>#[crate_type = &quot;lib&quot;]</code> -  Rustライブラリが生成されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is an ambiguous concept as to what exactly is produced because a library can manifest itself in several forms.</span>これは、ライブラリがいくつかの形で現れることができるため、正確に何が生成されるのかというあいまいな概念です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The purpose of this generic <code>lib</code> option is to generate the &quot;compiler recommended&quot; style of library.</span>この汎用的な<code>lib</code>オプションの目的は、 &quot;コンパイラが推奨する&quot;スタイルのライブラリを生成することです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The output library will always be usable by rustc, but the actual type of library may change from time-to-time.</span>出力ライブラリは常にrustcで使用可能ですが、実際のライブラリのタイプは時々変更されることがあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The remaining output types are all different flavors of libraries, and the <code>lib</code> type can be seen as an alias for one of them (but the actual one is compiler-defined).</span>残りの出力タイプはすべてライブラリの異なるフレーバであり、 <code>lib</code>タイプはそのうちの1つのエイリアスと<code>lib</code>ことができます（実際のものはコンパイラ定義です）。</span> </div><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>--crate-type=dylib</code> , <code>#[crate_type = &quot;dylib&quot;]</code> - A dynamic Rust library will be produced.</span> <code>--crate-type=dylib</code> 、 <code>#[crate_type = &quot;dylib&quot;]</code> - 動的なRustライブラリが生成されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is different from the <code>lib</code> output type in that this forces dynamic library generation.</span>これは、ダイナミックライブラリ生成を強制する点で、 <code>lib</code>出力タイプとは異なります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The resulting dynamic library can be used as a dependency for other libraries and/or executables.</span>生成された動的ライブラリは、他のライブラリや実行可能ファイルの依存として使用できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This output type will create <code>*.so</code> files on linux, <code>*.dylib</code> files on osx, and <code>*.dll</code> files on windows.</span>この出力タイプは、Linuxでは<code>*.so</code>ファイル、osxでは<code>*.dylib</code>ファイル、Windowsでは<code>*.dll</code>ファイルを作成します。</span> </div><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>--crate-type=staticlib</code> , <code>#[crate_type = &quot;staticlib&quot;]</code> - A static system library will be produced.</span> <code>--crate-type=staticlib</code> 、 <code>#[crate_type = &quot;staticlib&quot;]</code> - 静的システムライブラリが生成されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is different from other library outputs in that the Rust compiler will never attempt to link to <code>staticlib</code> outputs.</span>これは、Rustコンパイラが<code>staticlib</code>出力にリンクしようとしないという点で、他のライブラリの出力とは異なります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The purpose of this output type is to create a static library containing all of the local crate&#39;s code along with all upstream dependencies.</span>この出力タイプの目的は、ローカルクレートのすべてのコードとすべてのアップストリーム依存関係を含む静的ライブラリを作成することです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The static library is actually a <code>*.a</code> archive on linux and osx and a <code>*.lib</code> file on windows.</span>静的ライブラリは、実際にはlinuxとosxの<code>*.a</code>アーカイブとwindowsの<code>*.lib</code>ファイルです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This format is recommended for use in situations such as linking Rust code into an existing non-Rust application because it will not have dynamic dependencies on other Rust code.</span>この形式は、Rustコードを他のRustコードと動的に依存しないため、既存の非Rustアプリケーションにリンクするなどの状況で使用することをお勧めします。</span> </div><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>--crate-type=cdylib</code> , <code>#[crate_type = &quot;cdylib&quot;]</code> - A dynamic system library will be produced.</span> <code>--crate-type=cdylib</code> 、 <code>#[crate_type = &quot;cdylib&quot;]</code> - 動的システムライブラリが生成されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is used when compiling Rust code as a dynamic library to be loaded from another language.</span> Rustコードを別の言語からロードする動的ライブラリとしてコンパイルするときに使用されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This output type will create <code>*.so</code> files on Linux, <code>*.dylib</code> files on macOS, and <code>*.dll</code> files on Windows.</span>この出力タイプは、Linuxでは<code>*.so</code>ファイル、MacOSでは<code>*.dylib</code>ファイル、Windowsでは<code>*.dll</code>ファイルを作成します。</span> </div><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>--crate-type=rlib</code> , <code>#[crate_type = &quot;rlib&quot;]</code> - A &quot;Rust library&quot; file will be produced.</span> <code>--crate-type=rlib</code> 、 <code>#[crate_type = &quot;rlib&quot;]</code> -  &quot;Rust library&quot;ファイルが生成されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is used as an intermediate artifact and can be thought of as a &quot;static Rust library&quot;.</span>これは中間アーティファクトとして使用され、「スタティック・ルスト・ライブラリ」と考えることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These <code>rlib</code> files, unlike <code>staticlib</code> files, are interpreted by the Rust compiler in future linkage.</span>これらの<code>rlib</code>のファイルは、とは異なり<code>staticlib</code>ファイル、今後の連携で錆コンパイラによって解釈されています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This essentially means that <code>rustc</code> will look for metadata in <code>rlib</code> files like it looks for metadata in dynamic libraries.</span>これは、本質的に、 <code>rustc</code>が動的ライブラリのメタデータを探すような<code>rlib</code>ファイルのメタデータを探すことを意味します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This form of output is used to produce statically linked executables as well as <code>staticlib</code> outputs.</span>この形式の出力は、静的にリンクされた実行可能ファイルと<code>staticlib</code>出力を生成するために使用されます。</span> </div><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>--crate-type=proc-macro</code> , <code>#[crate_type = &quot;proc-macro&quot;]</code> - The output produced is not specified, but if a <code>-L</code> path is provided to it then the compiler will recognize the output artifacts as a macro and it can be loaded for a program.</span> <code>--crate-type=proc-macro</code> 、 <code>#[crate_type = &quot;proc-macro&quot;]</code> - 生成される出力は指定されていませんが、 <code>-L</code>パスが指定されている場合、コンパイラは出力成果物をマクロとして認識し、それはプログラムのためにロードすることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If a crate is compiled with the <code>proc-macro</code> crate type it will forbid exporting any items in the crate other than those functions tagged <code>#[proc_macro_derive]</code> and those functions must also be placed at the crate root.</span>クレートが<code>proc-macro</code> crateタイプでコンパイルされている場合は、 <code>#[proc_macro_derive]</code>タグの<code>#[proc_macro_derive]</code>もの以外のクレート内のアイテムの書き出しを禁止し、それらの関数もクレートルートに配置する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Finally, the compiler will automatically set the <code>cfg(proc_macro)</code> annotation whenever any crate type of a compilation is the <code>proc-macro</code> crate type.</span>最後に、コンパイルのいずれかのクレートタイプが<code>proc-macro</code> <code>cfg(proc_macro)</code>タイプである場合、コンパイラは自動的に<code>cfg(proc_macro)</code>アノテーションを設定します。</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that these outputs are stackable in the sense that if multiple are specified, then the compiler will produce each form of output at once without having to recompile.</span>これらの出力は、複数が指定された場合、コンパイル時に各形式の出力を一度に再コンパイルせずに生成できるという意味でスタック可能です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, this only applies for outputs specified by the same method.</span>ただし、これは同じメソッドで指定された出力にのみ適用されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If only <code>crate_type</code> attributes are specified, then they will all be built, but if one or more <code>--crate-type</code> command line flags are specified, then only those outputs will be built.</span> <code>crate_type</code>属性のみが指定されている場合はすべてビルドされますが、1つ以上の<code>--crate-type</code>コマンドラインフラグが指定されていれば、その出力だけが構築されます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">With all these different kinds of outputs, if crate A depends on crate B, then the compiler could find B in various different forms throughout the system.</span>これらの異なる種類のアウトプットの全てで、クレートAがクレートBに依存する場合、コンパイラはシステム全体にわたって様々な異なる形のBを見つけることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The only forms looked for by the compiler, however, are the <code>rlib</code> format and the dynamic library format.</span>ただし、コンパイラが<code>rlib</code>する<code>rlib</code>形式は、 <code>rlib</code>形式と動的ライブラリ形式です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">With these two options for a dependent library, the compiler must at some point make a choice between these two formats.</span>これらの2つのオプションの依存ライブラリーを使用すると、コンパイラーはある時点でこれらの2つの形式を選択する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">With this in mind, the compiler follows these rules when determining what format of dependencies will be used:</span>これを念頭に置いて、コンパイラは、使用される依存関係の形式を決定する際に、次の規則に従います。</span> </p><br><div data-b=1.> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If a static library is being produced, all upstream dependencies are required to be available in <code>rlib</code> formats.</span>静的ライブラリが作成されている場合は、すべての上流依存ファイルが<code>rlib</code>形式で使用可能である必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This requirement stems from the reason that a dynamic library cannot be converted into a static format.</span>この要件は、動的ライブラリを静的フォーマットに変換できないという理由から生じます。</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that it is impossible to link in native dynamic dependencies to a static library, and in this case warnings will be printed about all unlinked native dynamic dependencies.</span>ネイティブの動的依存関係を静的ライブラリにリンクすることは不可能であることに注意してください。この場合、リンクされていないすべてのネイティブ動的依存関係に関する警告が出力されます。</span> </p><br><div data-b=2.> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If an <code>rlib</code> file is being produced, then there are no restrictions on what format the upstream dependencies are available in. It is simply required that all upstream dependencies be available for reading metadata from.</span> <code>rlib</code>ファイルが作成されている場合、アップストリーム依存関係がどの形式で使用できるかに制限はありません。すべてのアップストリーム依存関係をメタデータの読み込みに使用するだけで済みます。</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The reason for this is that <code>rlib</code> files do not contain any of their upstream dependencies.</span>その理由は、 <code>rlib</code>ファイルに上流の依存関係が含まれていないからです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It wouldn&#39;t be very efficient for all <code>rlib</code> files to contain a copy of <code>libstd.rlib</code> !</span>すべての<code>rlib</code>ファイルが<code>libstd.rlib</code>コピーを含むことはあまり効率的ではありません！</span> </p><br><div data-b=3.> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If an executable is being produced and the <code>-C prefer-dynamic</code> flag is not specified, then dependencies are first attempted to be found in the <code>rlib</code> format.</span>実行可能ファイルが生成されており、 <code>-C prefer-dynamic</code>フラグが指定されていない場合、依存関係は<code>rlib</code>形式で最初に見つかるように試みられます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If some dependencies are not available in an rlib format, then dynamic linking is attempted (see below).</span>いくつかの依存関係がrlib形式で利用できない場合、動的リンクが試みられます（下記参照）。</span> </div><br><div data-b=4.> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If a dynamic library or an executable that is being dynamically linked is being produced, then the compiler will attempt to reconcile the available dependencies in either the rlib or dylib format to create a final product.</span>ダイナミックライブラリまたは動的にリンクされている実行可能ファイルが生成されている場合、コンパイラはrlibまたはdylib形式で使用可能な依存関係を調整して最終製品を作成しようとします。</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A major goal of the compiler is to ensure that a library never appears more than once in any artifact.</span>コンパイラの主な目的は、ライブラリがアーティファクトに何度も出現しないようにすることです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, if dynamic libraries B and C were each statically linked to library A, then a crate could not link to B and C together because there would be two copies of A. The compiler allows mixing the rlib and dylib formats, but this restriction must be satisfied.</span>たとえば、ダイナミックライブラリBとCがそれぞれライブラリAに静的にリンクされている場合、Aのコピーが2つ存在するため、クレートはBとCにリンクできませんでした。コンパイラはrlibとdylibのフォーマットを混合できますが、満足しなければならない。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The compiler currently implements no method of hinting what format a library should be linked with.</span>現在のところ、コンパイラは、ライブラリをどの形式にリンクするべきかを示す方法を実装していません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When dynamically linking, the compiler will attempt to maximize dynamic dependencies while still allowing some dependencies to be linked in via an rlib.</span>動的にリンクするとき、コンパイラは動的依存関係を最大化しようとしますが、rlibを介していくつかの依存関係をリンクさせることもできます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For most situations, having all libraries available as a dylib is recommended if dynamically linking.</span>ダイナミックリンクの場合、ほとんどの場合、すべてのライブラリをdylibとして利用可能にすることをお勧めします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For other situations, the compiler will emit a warning if it is unable to determine which formats to link each library with.</span>他の状況では、各ライブラリをどのフォーマットでリンクするかを判断できない場合、コンパイラは警告を発します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In general, <code>--crate-type=bin</code> or <code>--crate-type=lib</code> should be sufficient for all compilation needs, and the other options are just available if more fine-grained control is desired over the output format of a Rust crate.</span>一般に、-- <code>--crate-type=bin</code>または<code>--crate-type=lib</code>はすべてのコンパイルの必要性に十分でなければならず、他のオプションは、Rustクレートの出力フォーマットより細かい制御が必要な場合にのみ使用できます。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Static and dynamic C runtimes</span>静的および動的Cランタイム</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The standard library in general strives to support both statically linked and dynamically linked C runtimes for targets as appropriate.</span>一般的に、標準ライブラリは、静的にリンクされたリンクと動的にリンクされたCランタイムの両方をターゲットとして適切にサポートするよう努めています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example the <code>x86_64-pc-windows-msvc</code> and <code>x86_64-unknown-linux-musl</code> targets typically come with both runtimes and the user selects which one they&#39;d like.</span>たとえば、 <code>x86_64-pc-windows-msvc</code>と<code>x86_64-unknown-linux-musl</code>ターゲットは通常、両方のランタイムが付属しており、ユーザーはどちらを使用するかを選択します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">All targets in the compiler have a default mode of linking to the C runtime.</span>コンパイラのすべてのターゲットには、Cランタイムにリンクするデフォルトのモードがあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Typically targets are linked dynamically by default, but there are exceptions which are static by default such as:</span>通常、ターゲットはデフォルトで動的にリンクされますが、次のようなデフォルトでは静的な例外があります。</span> </p><br><div data-b=*> <code>arm-unknown-linux-musleabi</code> </div> <div data-b=*> <code>arm-unknown-linux-musleabihf</code> </div> <div data-b=*> <code>armv7-unknown-linux-musleabihf</code> </div> <div data-b=*> <code>i686-unknown-linux-musl</code> </div> <div data-b=*> <code>x86_64-unknown-linux-musl</code> </div> <br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The linkage of the C runtime is configured to respect the <code>crt-static</code> target feature.</span> Cランタイムのリンケージは、 <code>crt-static</code>ターゲット機能を尊重するように構成されています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These target features are typically configured from the command line via flags to the compiler itself.</span>これらのターゲット機能は、通常、コマンドラインからフラグを介してコンパイラ自体に設定されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example to enable a static runtime you would execute:</span>たとえば、静的ランタイムを有効にするには、次のように実行します。</span> </p><br><div data-lang=notrust><div data-l="rustc -C target-feature=+crt-static foo.rs"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">whereas to link dynamically to the C runtime you would execute:</span> Cランタイムに動的にリンクするには、次のように実行します。</span> </p><br><div data-lang=notrust><div data-l="rustc -C target-feature=-crt-static foo.rs"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Targets which do not support switching between linkage of the C runtime will ignore this flag.</span> Cランタイムのリンケージ間の切り替えをサポートしていないターゲットは、このフラグを無視します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It&#39;s recommended to inspect the resulting binary to ensure that it&#39;s linked as you would expect after the compiler succeeds.</span>結果のバイナリを調べて、コンパイラが成功した後に期待どおりにリンクされていることを確認することをお勧めします。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Crates may also learn about how the C runtime is being linked.</span> Cratesは、Cランタイムがどのようにリンクされているかを知ることもできます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Code on MSVC, for example, needs to be compiled differently (eg with <code>/MT</code> or <code>/MD</code> ) depending on the runtime being linked.</span>たとえば、MSVC上のコードは、リンクされているランタイムに応じて異なる方法でコンパイルする必要があります（たとえば、 <code>/MT</code>または<code>/MD</code> ）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is exported currently through the <code>target_feature</code> attribute (note this is a nightly feature):</span>これは現在、 <code>target_feature</code>属性を介してエクスポートされてい<code>target_feature</code> （これは夜間の機能です）。</span> </p><br><div data-lang=rust,ignore><div data-l="#[cfg(target_feature = &quot;crt-static&quot;)]"></div><div data-l="fn foo() {"></div><div data-l="    println!(&quot;the C runtime should be statically linked&quot;);"></div><div data-l=}></div><div data-l=""></div><div data-l="#[cfg(not(target_feature = &quot;crt-static&quot;))]"></div><div data-l="fn foo() {"></div><div data-l="    println!(&quot;the C runtime should be dynamically linked&quot;);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Also note that Cargo build scripts can learn about this feature through <a href=#3cargo>environment variables</a> .</span>また、Cargoビルドスクリプトは<a href=#3cargo>環境変数を</a>使ってこの機能について知ることができ<a href=#3cargo>ます</a> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In a build script you can detect the linkage via:</span>ビルドスクリプトでは、次の方法でリンケージを検出できます。</span> </p><br><div data-lang=rust><div data-l="use std::env;"></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let linkage = env::var(&quot;CARGO_CFG_TARGET_FEATURE&quot;).unwrap_or(String::new());"></div><div data-l=""></div><div data-l="    if linkage.contains(&quot;crt-static&quot;) {"></div><div data-l="        println!(&quot;the C runtime will be statically linked&quot;);"></div><div data-l="    } else {"></div><div data-l="        println!(&quot;the C runtime will be dynamically linked&quot;);"></div><div data-l="    }"></div><div data-l=}></div></div><br> <a class=notranslate href=#1http://doc.crates.io/environment-variables.html#environment-variables-cargo-sets-for-build-scripts>cargo</a> <br> <p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To use this feature locally, you typically will use the <code>RUSTFLAGS</code> environment variable to specify flags to the compiler through Cargo.</span>この機能をローカルで使用するには、 <code>RUSTFLAGS</code>環境変数を使用して、Cargoを介してコンパイラにフラグを指定します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example to compile a statically linked binary on MSVC you would execute:</span>たとえば、MSVCで静的にリンクされたバイナリをコンパイルするには、次のコマンドを実行します。</span> </p><br><div data-lang=ignore,notrust><div data-l="RUSTFLAGS='-C target-feature=+crt-static' cargo build --target x86_64-pc-windows-msvc"></div></div><script>_addload(function(){_setupIW('com');_csi('en','ja','linkage.html');});</script>