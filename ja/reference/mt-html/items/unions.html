<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180723_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=unions.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Unions</span>組合</span> </h1><br><blockquote><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><b>&lt;sup&gt;Syntax&lt;/sup&gt;</b> \ <s>Union</s> :\ &amp;nbsp;&amp;nbsp;</span> <b>&lt;sup&gt;構文&lt;/ sup&gt;</b> \ <s>Union</s> ：\＆nbsp;＆nbsp;</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>union</code> <a class=notranslate href=#4IDENTIFIER>IDENTIFIER</a> &amp;nbsp;</span> <code>union</code> <a class=notranslate href=#4IDENTIFIER>IDENTIFIER</a> ＆nbsp;</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a class=notranslate href=#4_Generics_>_Generics_</a> <sup>?</sup></span> <a class=notranslate href=#4_Generics_>_Generics_</a> <sup>？</sup></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a class=notranslate href=#4_WhereClause_>_WhereClause_</a> <sup>?</sup></span> <a class=notranslate href=#4_WhereClause_>_WhereClause_</a> <sup>？</sup></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>{</code> <a class=notranslate href=#4_StructFields_>_StructFields_</a> <code>}</code></span> <code>{</code> <a class=notranslate href=#4_StructFields_>_StructFields_</a> <code>}</code></span> </p></blockquote><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A union declaration uses the same syntax as a struct declaration, except with <code>union</code> in place of <code>struct</code> .</span>共用体宣言は、構造体宣言と同じ構文を使用しますが、構造体の代わりに<code>union</code> <code>struct</code>ます。</span> </p><br><div data-lang=rust><div data-l=#[repr(C)]></div><div data-l="union MyUnion {"></div><div data-l="    f1: u32,"></div><div data-l="    f2: f32,"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The key property of unions is that all fields of a union share common storage.</span>組合の重要な特性は、組合のすべてのフィールドが共通のストレージを共有することです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As a result writes to one field of a union can overwrite its other fields, and size of a union is determined by the size of its largest field.</span>結果として、共用体の1つのフィールドへの書き込みは他のフィールドを上書きすることができ、共用体のサイズは最大のフィールドのサイズによって決まります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A value of a union type can be created using the same syntax that is used for struct types, except that it must specify exactly one field:</span>共用体型の値は、構造体型に使用されるのと同じ構文を使用して作成できます。ただし、1つのフィールドを正確に指定する必要がある点が異なります。</span> </p><br><div data-lang=rust><div data-l="# union MyUnion { f1: u32, f2: f32 }"></div><div data-l=#></div><div data-l="let u = MyUnion { f1: 1 };"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The expression above creates a value of type <code>MyUnion</code> with active field <code>f1</code> .</span>上記の式は、アクティブなフィールド<code>f1</code>持つ<code>MyUnion</code>型の値を作成します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Active field of a union can be accessed using the same syntax as struct fields:</span>共用体のアクティブフィールドは、structフィールドと同じ構文を使用してアクセスできます。</span> </p><br><div data-lang=rust,ignore><div data-l="let f = u.f1;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Inactive fields can be accessed as well (using the same syntax) if they are sufficiently layout compatible with the current value kept by the union.</span>非アクティブなフィールドは、共用体によって保持されている現在の値と十分にレイアウトが互換性がある場合にも同様の構文を使用してアクセスできます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Reading incompatible fields results in undefined behavior.</span>互換性のないフィールドを読み取ると、未定義の動作が発生します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, the active field is not generally known statically, so all reads of union fields have to be placed in <code>unsafe</code> blocks.</span>しかし、アクティブフィールドは一般に静的には知られていないため、すべてのユニオンフィールドの読み込みは<code>unsafe</code>で<code>unsafe</code>ブロックに配置する必要があります。</span> </p><br><div data-lang=rust><div data-l="# union MyUnion { f1: u32, f2: f32 }"></div><div data-l="# let u = MyUnion { f1: 1 };"></div><div data-l=#></div><div data-l="unsafe {"></div><div data-l="    let f = u.f1;"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Writes to <code>Copy</code> union fields do not require reads for running destructors, so these writes don&#39;t have to be placed in <code>unsafe</code> blocks</span> <code>Copy</code>ユニオン・フィールドへの書き込みは、デストラクタを実行するための読み込みを必要としないため、これらの書き込みは<code>unsafe</code>で<code>unsafe</code>ブロックに配置する必要はありません</span> </p><br><div data-lang=rust><div data-l="# union MyUnion { f1: u32, f2: f32 }"></div><div data-l="# let mut u = MyUnion { f1: 1 };"></div><div data-l=#></div><div data-l="u.f1 = 2;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Commonly, code using unions will provide safe wrappers around unsafe union field accesses.</span>一般的に、共用体を使用するコードは、安全でない共用体のフィールド・アクセスの周りに安全なラッパーを提供します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Another way to access union fields is to use pattern matching.</span>ユニオンフィールドにアクセスする別の方法は、パターンマッチングを使用することです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Pattern matching on union fields uses the same syntax as struct patterns, except that the pattern must specify exactly one field.</span>ユニオンフィールドのパターンマッチングでは、構造体パターンと同じ構文を使用しますが、パターンでは正確に1つのフィールドを指定する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Since pattern matching accesses potentially inactive fields it has to be placed in <code>unsafe</code> blocks as well.</span>パターンマッチングは潜在的に非アクティブなフィールドにアクセスするため、 <code>unsafe</code>で<code>unsafe</code>ブロックに配置する必要があります。</span> </p><br><div data-lang=rust><div data-l="# union MyUnion { f1: u32, f2: f32 }"></div><div data-l=#></div><div data-l="fn f(u: MyUnion) {"></div><div data-l="    unsafe {"></div><div data-l="        match u {"></div><div data-l="            MyUnion { f1: 10 } =&gt; { println!(&quot;ten&quot;); }"></div><div data-l="            MyUnion { f2 } =&gt; { println!(&quot;{}&quot;, f2); }"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Pattern matching may match a union as a field of a larger structure.</span>パターンマッチングは、より大きな構造のフィールドとしてユニオンにマッチするかもしれません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In particular, when using a Rust union to implement a C tagged union via FFI, this allows matching on the tag and the corresponding field simultaneously:</span>特に、Rust共用体を使用してFFIを介してCタグ付き共用体を実装する場合、これによりタグと対応するフィールドの同時マッチングが可能になります。</span> </p><br><div data-lang=rust><div data-l=#[repr(u32)]></div><div data-l="enum Tag { I, F }"></div><div data-l=""></div><div data-l=#[repr(C)]></div><div data-l="union U {"></div><div data-l="    i: i32,"></div><div data-l="    f: f32,"></div><div data-l=}></div><div data-l=""></div><div data-l=#[repr(C)]></div><div data-l="struct Value {"></div><div data-l="    tag: Tag,"></div><div data-l="    u: U,"></div><div data-l=}></div><div data-l=""></div><div data-l="fn is_zero(v: Value) -&gt; bool {"></div><div data-l="    unsafe {"></div><div data-l="        match v {"></div><div data-l="            Value { tag: I, u: U { i: 0 } } =&gt; true,"></div><div data-l="            Value { tag: F, u: U { f: 0.0 } } =&gt; true,"></div><div data-l="            _ =&gt; false,"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Since union fields share common storage, gaining write access to one field of a union can give write access to all its remaining fields.</span>共用体のフィールドは共通の記憶域を共有するため、共用体の1つのフィールドへの書込みアクセス権を獲得すると、残りのすべてのフィールドへの書込みアクセスが可能になります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Borrow checking rules have to be adjusted to account for this fact.</span>この事実を考慮に入れて、借り入れチェックルールを調整しなければならない。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As a result, if one field of a union is borrowed, all its remaining fields are borrowed as well for the same lifetime.</span>その結果、組合の1つのフィールドが借用されている場合、残りのフィールドはすべて同じ借用になります。</span> </p><br><div data-lang=rust,ignore><div data-l="#// ERROR: cannot borrow `u` (via `u.f2`) as mutable more than once at a time"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">ERROR: cannot borrow <code>u</code> (via <code>u.f2</code> ) as mutable more than once at a time</span>エラー：一度に複数回mutableを<code>u</code> （ <code>u.f2</code>経由で）から借りることはできません</span> </div><div data-l="fn test() {"></div><div data-l="    let mut u = MyUnion { f1: 1 };"></div><div data-l="    unsafe {"></div><div data-l="        let b1 = &amp;mut u.f1;"></div><div data-l="                      ---- first mutable borrow occurs here (via `u.f1`)"></div><div data-l="        let b2 = &amp;mut u.f2;"></div><div data-l="                      ^^^^ second mutable borrow occurs here (via `u.f2`)"></div><div data-l="        *b1 = 5;"></div><div data-l="    }"></div><div data-l="    - first borrow ends here"></div><div data-l="    assert_eq!(unsafe { u.f1 }, 5);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As you could see, in many aspects (except for layouts, safety and ownership) unions behave exactly like structs, largely as a consequence of inheriting their syntactic shape from structs.</span>レイアウト、安全性、所有権を除いて、多くの面で、構造体から構文的形状を継承した結果、構造体とまったく同じように動作します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is also true for many unmentioned aspects of Rust language (such as privacy, name resolution, type inference, generics, trait implementations, inherent implementations, coherence, pattern checking, etc etc etc).</span>これは、Rust言語の多くの言及されていない側面（プライバシー、名前解決、型推論、ジェネリックス、特性実装、固有の実装、一貫性、パターン検査などなど）にも当てはまります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">More detailed specification for unions, including unstable bits, can be found in <a href=#2https://github.com/rust-lang/rfcs/pull/1897>RFC 1897 &quot;Unions v1.2&quot;</a> .</span>不安定なビットを含む、より詳細な共用体の仕様は、 <a href=#2https://github.com/rust-lang/rfcs/pull/1897>RFC 1897「Unions v1.2」にあり</a>ます。</span> </p><br> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a class=notranslate href=#1identifiers.html>IDENTIFIER</a> <a class=notranslate href=#1items/generics.html>_Generics_</a> <a class=notranslate href=#1items/generics.html#where-clauses>_WhereClause_</a> <a class=notranslate href=#1items/structs.html>_StructFields_</a></span> <a class=notranslate href=#1identifiers.html>IDENTIFIER</a> <a class=notranslate href=#1items/generics.html>_Generics_</a> <a class=notranslate href=#1items/generics.html#where-clauses>_WhereClause_</a> <a class=notranslate href=#1items/structs.html>_StructFields_</a></span><script>_addload(function(){_setupIW('com');_csi('en','ja','unions.html');});</script>