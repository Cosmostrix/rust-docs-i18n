<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180723_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=type-layout.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Type Layout</span>タイプレイアウト</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The layout of a type is its size, alignment, and the relative offsets of its fields.</span>型のレイアウトは、そのサイズ、整列、およびフィールドの相対的なオフセットです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For enums, how the discriminant is laid out and interpreted is also part of type layout.</span>列挙型の場合、判別式がどのようにレイアウトされ、解釈されるかは、レイアウトタイプの一部です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Type layout can be changed with each compilation.</span>タイプのレイアウトは、コンパイルごとに変更できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Instead of trying to document exactly what is done, we only document what is guaranteed today.</span>何が行われたかを正確に文書化しようとするのではなく、今日保証されているものだけを文書化します。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Size and Alignment</span>サイズとアライメント</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">All values have an alignment and size.</span>すべての値にアライメントとサイズがあります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <i>alignment</i> of a value specifies what addresses are valid to store the value at.</span>値の<i>整列</i>は、値を格納するために有効なアドレスを指定します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A value of alignment <code>n</code> must only be stored at an address that is a multiple of n.</span>整列<code>n</code>の値は、nの倍数であるアドレスにのみ格納する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, a value with an alignment of 2 must be stored at an even address, while a value with an alignment of 1 can be stored at any address.</span>たとえば、整列2の値は偶数アドレスに格納する必要があり、整列1の値は任意のアドレスに格納できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Alignment is measured in bytes, and must be at least 1, and always a power of 2. The alignment of a value can be checked with the <a class=notranslate href="#4`align_of_val`">`align_of_val`</a> function.</span>アラインメントはバイト単位で測定され、少なくとも1でなければならず、常に2の累乗でなければなりません。値のアライメントは<a class=notranslate href="#4`align_of_val`">`align_of_val`</a>関数で確認できます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <i>size</i> of a value is the offset in bytes between successive elements in an array with that item type including alignment padding.</span>値の<i>サイズ</i>は、アライメントパディングを含むアイテムタイプの配列内の連続する要素間のバイト単位のオフセットです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The size of a value is always a multiple of its alignment.</span>値のサイズは、常にその配置の倍数です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The size of a value can be checked with the <a class=notranslate href="#4`size_of_val`">`size_of_val`</a> function.</span>値の大きさは<a class=notranslate href="#4`size_of_val`">`size_of_val`</a>関数で調べることができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Types where all values have the same size and alignment known at compile time implement the <a class=notranslate href="#4`Sized`">`Sized`</a> trait and can be checked with the <a class=notranslate href="#4`size_of`">`size_of`</a> and <a class=notranslate href="#4`align_of`">`align_of`</a> functions.</span>すべての値がコンパイル時に知られている同じサイズとアライメントを持っているタイプは、実装<a class=notranslate href="#4`Sized`">`Sized`</a>形質をとで確認することができ<a class=notranslate href="#4`size_of`">`size_of`</a>と<a class=notranslate href="#4`align_of`">`align_of`</a>機能。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Types that are not <a class=notranslate href="#4`Sized`">`Sized`</a> are known as <a class=notranslate href="#4dynamicallysized types">dynamically sized types</a> .</span> <a class=notranslate href="#4`Sized`">`Sized`</a> 」されていないタイプは、 <a class=notranslate href="#4dynamicallysized types">dynamically sized types</a>呼ばれ<a class=notranslate href="#4dynamicallysized types">dynamically sized types</a> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Since all values of a <code>Sized</code> type share the same size and alignment, we refer to those shared values as the size of the type and the alignment of the type respectively.</span> <code>Sized</code>型の値はすべて同じサイズと配置で共有されるため、これらの共有値は型のサイズと型の整列としてそれぞれ参照します。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Primitive Data Layout</span>プリミティブデータレイアウト</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The size of most primitives is given in this table.</span>この表には、ほとんどのプリミティブのサイズが示されています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Type |</span>タイプ|</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>size_of::&lt;Type&gt;()</code> - |</span> <code>size_of::&lt;Type&gt;()</code> -  |</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">- |</span> -  |</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">- bool |</span> - ブール|</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">1 u8 |</span> 1 u8 |</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">1 u16 |</span> 1 u16 |</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">2 u32 |</span> 2 u32 |</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">4 u64 |</span> 4 u64 |</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">8 u128 |</span> 8 u128 |</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">16 i8 |</span> 16 i8 |</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">1 i16 |</span> 1 i16 |</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">2 i32 |</span> 2 i32 |</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">4 i64 |</span> 4 i64 |</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">8 i128 |</span> 8 i128 |</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">16 f32 |</span> 16 f32 |</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">4 f64 |</span> 4 f64 |</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">8 char |</span> 8文字|</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">4</span> 4</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>usize</code> and <code>isize</code> have a size big enough to contain every address on the target platform.</span> <code>usize</code>と<code>isize</code>は、ターゲットプラットフォーム上のすべてのアドレスを格納できる大きさです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, on a 32 bit target, this is 4 bytes and on a 64 bit target, this is 8 bytes.</span>たとえば、32ビットのターゲットでは、これは4バイトで、64ビットのターゲットでは、これは8バイトです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Most primitives are generally aligned to their size, although this is platform-specific behavior.</span>ほとんどのプリミティブは、プラットフォーム固有の動作ですが、一般にサイズに合わせて配置されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In particular, on x86 u64 and f64 are only aligned to 32 bits.</span>特に、x86ではu64とf64は32ビットにしか整列しません。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Pointers and References Layout</span>ポインタと参照のレイアウト</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Pointers and references have the same layout.</span>ポインタと参照は同じレイアウトです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Mutability of the pointer or reference does not change the layout.</span>ポインターまたは参照の変更はレイアウトを変更しません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Pointers to sized types have the same size and alignment as <code>usize</code> .</span>サイズが指定された型へのポインタは、 <code>usize</code>と同じサイズと整列を<code>usize</code>ます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Pointers to unsized types are sized.</span>サイズの指定されていない型へのポインタのサイズが設定されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The size and alignment is guaranteed to be at least equal to the size and alignment of a pointer.</span>サイズと配置は、少なくともポインタのサイズと配置に等しいことが保証されています。</span> </p><br><blockquote><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note: Though you should not rely on this, all pointers to <abbr title="動的にサイズの変更された型">DSTs</abbr> are currently twice the size of the size of <code>usize</code> and have the same alignment.</span>注：このに頼るべきではありませんが<abbr title="動的にサイズの変更された型">、DSTS</abbr>へのすべてのポインタは、現在のサイズの2倍のサイズです<code>usize</code>と同じ配置を持っています。</span> </p></blockquote><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Array Layout</span>配列のレイアウト</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Arrays are laid out so that the <code>nth</code> element of the array is offset from the start of the array by <code>n * the size of the type</code> bytes.</span>配列の<code>nth</code>要素は、配列の先頭から<code>n * the size of the type</code>バイトの<code>n * the size of the type</code>だけオフセットされるように配列が配置されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">An array of <code>[T; n]</code></span> <code>[T; n]</code></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>[T; n]</code> has a size of <code>size_of::&lt;T&gt;() * n</code> and the same alignment of <code>T</code> .</span> <code>[T; n]</code>は<code>size_of::&lt;T&gt;() * n</code>サイズを<code>size_of::&lt;T&gt;() * n</code> 、同じアライメント<code>T</code>持ちます。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Slice Layout</span>スライスレイアウト</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Slices have the same layout as the section of the array they slice.</span>スライスは、スライスした配列のセクションと同じレイアウトです。</span> </p><br><blockquote><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note: This is about the raw <code>[T]</code> type, not pointers ( <code>&amp;[T]</code> , <code>Box&lt;[T]&gt;</code> , etc.) to slices.</span>注：これはスライスへのポインタ（ <code>&amp;[T]</code> 、 <code>Box&lt;[T]&gt;</code>など）ではなく、生の<code>[T]</code>タイプに関するものです。</span> </p></blockquote><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Tuple Layout</span>タプルレイアウト</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Tuples do not have any guarantees about their layout.</span>タプルはそのレイアウトについていかなる保証もしていません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The exception to this is the unit tuple ( <code>()</code> ) which is guaranteed as a zero-sized type to have a size of 0 and an alignment of 1.</span>例外として、サイズが0でアライメントが1のゼロサイズの型として保証されているユニットタプル（ <code>()</code> ）があります。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Trait Object Layout</span>特性オブジェクトのレイアウト</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Trait objects have the same layout as the value the trait object is of.</span>特性オブジェクトは、特性オブジェクトの値と同じレイアウトを持ちます。</span> </p><br><blockquote><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note: This is about the raw trait object types, not pointers ( <code>&amp;Trait</code> , <code>Box&lt;Trait&gt;</code> , etc.) to trait objects.</span>注：これは、生の形質オブジェクトの種類についてのものであり、特性オブジェクトに対するポインタ（ <code>&amp;Trait</code> 、 <code>Box&lt;Trait&gt;</code>など）ではありません。</span> </p></blockquote><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Closure Layout</span>クローズレイアウト</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Closures have no layout guarantees.</span>クロージャにはレイアウト保証はありません。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Representations</span>表現</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">All user-defined composite types ( <code>struct</code> s, <code>enum</code> s, and <code>union</code> s) have a <i>representation</i> that specifies what the layout is for the type.</span>すべてのユーザ定義コンポジット型（ <code>struct</code> s、 <code>enum</code> s、および<code>union</code> s）は、そのレイアウトがその型に対して何であるかを指定する<i>表現</i>を持ちます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The possible representations for a type are the default representation, <code>C</code> , the primitive representations, and <code>packed</code> .</span>型の考えられる表現は、デフォルト表現<code>C</code> 、プリミティブ表現、および<code>packed</code>表現です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Multiple representations can be applied to a single type.</span> 1つのタイプに複数の表現を適用できます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The representation of a type can be changed by applying the <a class=notranslate href="#4`repr` attribute">`repr` attribute</a> to it.</span>型の表現は、 <a class=notranslate href="#4`repr` attribute">`repr` attribute</a>をそれに適用することによって変更することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The following example shows a struct with a <code>C</code> representation.</span>次の例は、 <code>C</code>表現の構造体を示しています。</span> </p><br><div data-lang=""><div data-l=#[repr(C)]></div><div data-l="struct ThreeInts {"></div><div data-l="    first: i16,"></div><div data-l="    second: i8,"></div><div data-l="    third: i32"></div><div data-l=}></div></div><br><blockquote><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note: As a consequence of the representation being an attribute on the item, the representation does not depend on generic parameters.</span>注意：表現がアイテムの属性であるため、表現は汎用パラメータに依存しません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Any two types with the same name have the same representation.</span>同じ名前を持つ2つの型はすべて同じ表現です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, <code>Foo&lt;Bar&gt;</code> and <code>Foo&lt;Baz&gt;</code> both have the same representation.</span>たとえば、 <code>Foo&lt;Bar&gt;</code>と<code>Foo&lt;Baz&gt;</code>どちらも同じ表現をしています。</span> </p></blockquote><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The representation of a type does not change the layout of its fields.</span>型の表現はフィールドのレイアウトを変更しません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, a struct with a <code>C</code> representation that contains a struct <code>Inner</code> with the default representation will not change the layout of Inner.</span>たとえば、デフォルトの表現で構造体<code>Inner</code>を含む<code>C</code>表現の構造体は、 <code>Inner</code>のレイアウトを変更しません。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The Default Representation</span>デフォルト表現</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Nominal types without a <code>repr</code> attribute have the default representation.</span> <code>repr</code>属性を持たない名義型にはデフォルトの表現があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Informally, this representation is also called the <code>rust</code> representation.</span>非公式には、この表現は<code>rust</code>表現とも呼ばれます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There are no guarantees of data layout made by this representation.</span>この表現によってデータレイアウトが保証されることはありません。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>C</code> Representation</span> <code>C</code>表現</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>C</code> representation is designed for dual purposes.</span> <code>C</code>表現は、二重目的のために設計されています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">One purpose is for creating types that are interoptable with the C Language.</span> 1つの目的は、C言語で互換性のある型を作成することです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The second purpose is to create types that you can soundly performing operations that rely on data layout such as reinterpreting values as a different type.</span>第2の目的は、値を別のタイプとして再解釈するなど、データレイアウトに依存する操作を健全に実行できるタイプを作成することです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because of this dual purpose, it is possible to create types that are not useful for interfacing with the C programming language.</span>この2つの目的のために、Cプログラミング言語とのインタフェースには役に立たない型を作成することは可能です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This representation can be applied to structs, unions, and enums.</span>この表現は、構造体、共用体、および列挙型に適用できます。</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">\# <a class=notranslate href=#4repr(C)>repr(C)</a> Structs</span> \ <a class=notranslate href=#4repr(C)>repr(C)</a></span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The alignment of the struct is the alignment of the most-aligned field in it.</span>構造体の配置は、その中で最も整列したフィールドの配置です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The size and offset of fields is determined by the following algorithm.</span>フィールドのサイズおよびオフセットは、以下のアルゴリズムによって決定されます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Start with a current offset of 0 bytes.</span> 0バイトの現在のオフセットで開始します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For each field in declaration order in the struct, first determine the size and alignment of the field.</span>構造体の宣言順の各フィールドについて、まずフィールドのサイズと配置を決定します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If the current offset is not a multiple of the field&#39;s alignment, then add padding bytes to the current offset until it is a multiple of the field&#39;s alignment.</span>現在のオフセットがフィールドの配置の倍数でない場合は、フィールドの配置の倍数になるまで現在のオフセットにパディングバイトを追加します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The offset for the field is what the current offset is now.</span>フィールドのオフセットは現在のオフセットとなります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then increase the current offset by the size of the field.</span>次に、現在のオフセットをフィールドのサイズだけ大きくします。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Finally, the size of the struct is the current offset rounded up to the nearest multiple of the struct&#39;s alignment.</span>最後に、構造体のサイズは、構造体の配置の最も近い倍数に切り上げられた現在のオフセットです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here is this algorithm described in pseudocode.</span>ここに、擬似コードで説明されているアルゴリズムがあります。</span> </p><br><div data-lang=rust,ignore><div data-l="struct.alignment = struct.fields().map(|field| field.alignment).max();"></div><div data-l=""></div><div data-l="let current_offset = 0;"></div><div data-l=""></div><div data-l="for field in struct.fields_in_declaration_order() {"></div><div data-l="#    // Increase the current offset so that it's a multiple of the alignment"></div><div data-l="#    // of this field. For the first field, this will always be zero."></div><div data-l="#    // The skipped bytes are called padding bytes."></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Increase the current offset so that it&#39;s a multiple of the alignment of this field.</span>このフィールドの位置合わせの倍数になるように、現在のオフセットを増やします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For the first field, this will always be zero.</span>最初のフィールドでは、これは常にゼロになります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The skipped bytes are called padding bytes.</span>スキップされたバイトはパディングバイトと呼ばれます。</span> </div><div data-l="    current_offset += field.alignment % current_offset;"></div><div data-l=""></div><div data-l="    struct[field].offset = current_offset;"></div><div data-l=""></div><div data-l="    current_offset += field.size;"></div><div data-l=}></div><div data-l=""></div><div data-l="struct.size = current_offset + current_offset % struct.alignment;"></div></div><br><blockquote><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note: This algorithm can produce zero-sized structs.</span>注：このアルゴリズムはサイズがゼロの構造体を生成できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This differs from C where structs without data still have a size of one byte.</span>これは、データのないstructsのサイズがまだ1バイトであるCとは異なります。</span> </p></blockquote><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">\# <a class=notranslate href=#4repr(C)>repr(C)</a> Unions</span> \ <a class=notranslate href=#4repr(C)>repr(C)</a>共用体</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A union declared with <code>#[repr(C)]</code> will have the same size and alignment as an equivalent C union declaration in the C language for the target platform.</span> <code>#[repr(C)]</code>宣言された共用体は、ターゲットプラットフォームのC言語で同等のC共用体宣言と同じサイズと位置合わせを持ちます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The union will have a size of the maximum size of all of its fields rounded to its alignment, and an alignment of the maximum alignment of all of its fields.</span>共用体は、すべてのフィールドの最大サイズが、その整列に丸められ、すべてのフィールドの最大整列が整列されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These maximums may come from different fields.</span>これらの最大値は、異なるフィールドから来る場合があります。</span> </p><br><div data-lang=""><div data-l=#[repr(C)]></div><div data-l="union Union {"></div><div data-l="    f1: u16,"></div><div data-l="    f2: [u8; 4],"></div><div data-l=}></div><div data-l=""></div><div data-l="#//assert_eq!(std::mem::size_of::&lt;Union&gt;(), 4);  // From f2"></div><div data-l="assert_eq!(std::mem::size_of::&lt;Union&gt;(), 4);  // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">From f2</span> f2から</span> </div><div data-l="#//assert_eq!(std::mem::align_of::&lt;Union&gt;(), 2); // From f1"></div><div data-l="assert_eq!(std::mem::align_of::&lt;Union&gt;(), 2); // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">From f1</span> f1から</span> </div><div data-l=""></div><div data-l=#[repr(C)]></div><div data-l="union SizeRoundedUp {"></div><div data-l="   a: u32,"></div><div data-l="   b: [u16; 3],"></div><div data-l=}></div><div data-l=""></div><div data-l="#//assert_eq!(std::mem::size_of::&lt;SizeRoundedUp&gt;(), 8);  // Size of 6 from b,"></div><div data-l="#                                                      // rounded up to 8 from"></div><div data-l="#                                                      // alignment of a."></div><div data-l="assert_eq!(std::mem::size_of::&lt;SizeRoundedUp&gt;(), 8);  // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Size of 6 from b, rounded up to 8 from alignment of a.</span> bからの6のサイズ、aの整列から8までの切り上げ。</span> </div><div data-l="#//assert_eq!(std::mem::align_of::&lt;SizeRoundedUp&gt;(), 4); // From a"></div><div data-l="assert_eq!(std::mem::align_of::&lt;SizeRoundedUp&gt;(), 4); // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">From a</span>から</span> </div></div><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">\# <a class=notranslate href=#4repr(C)>repr(C)</a> Enums</span> \＃repr <a class=notranslate href=#4repr(C)>repr(C)</a>列挙型</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For <a class=notranslate href="#4C-like enumerations">C-like enumerations</a> , the <code>C</code> representation has the size and alignment of the default <code>enum</code> size and alignment for the target platform&#39;s C ABI.</span> <a class=notranslate href="#4C-like enumerations">C-like enumerations</a>場合、 <code>C</code>表現は、ターゲットプラットフォームのC ABIのデフォルトの<code>enum</code>サイズと配置のサイズと配置を持ちます。</span> </p><br><blockquote><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note: The enum representation in C is implementation defined, so this is really a &quot;best guess&quot;.</span>注：Cでのenum表現は実装定義されているので、これは実際には「最良の推測」です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In particular, this may be incorrect when the C code of interest is compiled with certain flags.</span>特に、関心のあるCコードが特定のフラグでコンパイルされていると、これは正しくない可能性があります。</span> </p></blockquote><br><p><div class=warning></p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Warning: There are crucial differences between an <code>enum</code> in the C language and Rust&#39;s C-like enumerations with this representation.</span>警告：の間に決定的な違いがあります<code>enum</code> 、C言語とこの表現で錆のC-のような列挙型では。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">An <code>enum</code> in C is mostly a <code>typedef</code> plus some named constants;</span> Cの<code>enum</code>は主に<code>typedef</code>といくつかの名前付き定数です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">in other words, an object of an <code>enum</code> type can hold any integer value.</span>つまり、 <code>enum</code>型のオブジェクトは任意の整数値を保持できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, this is often used for bitflags in <code>C</code> .</span>たとえば、これは<code>C</code>ビットフラッグによく使用されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In contrast, Rust&#39;s C-like enumerations can only legally hold the discriminant values, everything else is undefined behaviour.</span>対照的に、RustのCのような列挙型は弁別値を合法的に保持するだけで、他のすべては未定義の振る舞いです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Therefore, using a C-like enumeration in FFI to model a C <code>enum</code> is often wrong.</span>したがって、Cの<code>enum</code>型をモデル化するためにFFIでCのような列挙を使用することは、しばしば間違っています。</span> </p><br><p></div></p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It is an error for <a class=notranslate href="#4zero-variant enumerations">zero-variant enumerations</a> to have the <code>C</code> representation.</span> <a class=notranslate href="#4zero-variant enumerations">zero-variant enumerations</a>が<code>C</code>表現を持つことは誤りです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For all other enumerations, the layout is unspecified.</span>その他のすべての列挙では、レイアウトは指定されていません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Likewise, combining the <code>C</code> representation with a primitive representation, the layout is unspecified.</span>同様に、 <code>C</code>表現をプリミティブ表現と組み合わせると、レイアウトは指定されません。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Primitive representations</span>プリミティブ表現</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <i>primitive representations</i> are the representations with the same names as the primitive integer types.</span> <i>プリミティブ表現</i>はプリミティブ整数型と同じ名前の表現です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That is: <code>u8</code> , <code>u16</code> , <code>u32</code> , <code>u64</code> , <code>usize</code> , <code>i8</code> , <code>i16</code> , <code>i32</code> , <code>i64</code> , and <code>isize</code> .</span>つまり： <code>u8</code> 、 <code>u16</code> 、 <code>u32</code> 、 <code>u64</code> 、 <code>usize</code> 、 <code>i8</code> 、 <code>i16</code> 、 <code>i32</code> 、 <code>i64</code> 、 <code>isize</code>です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Primitive representations can only be applied to enumerations.</span>プリミティブ表現は列挙にのみ適用できます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For <a class=notranslate href="#4C-like enumerations">C-like enumerations</a> , they set the size and alignment to be the same as the primitive type of the same name.</span> <a class=notranslate href="#4C-like enumerations">C-like enumerations</a>では、同じ名前のプリミティブ型と同じになるようにサイズと配置を設定します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, a C-like enumeration with a <code>u8</code> representation can only have discriminants between 0 and 255 inclusive.</span>たとえば、 <code>u8</code>表現を使用したCのような列挙では、0と255の間の判別式を持つことしかできません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It is an error for <a class=notranslate href="#4zero-variant enumerations">zero-variant enumerations</a> to have a primitive representation.</span> <a class=notranslate href="#4zero-variant enumerations">zero-variant enumerations</a>がプリミティブ表現を持つのは誤りです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For all other enumerations, the layout is unspecified.</span>その他のすべての列挙では、レイアウトは指定されていません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Likewise, combining two primitive representations together is unspecified.</span>同様に、2つのプリミティブ表現を組み合わせることも不特定である。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>align</code> Representation</span> <code>align</code>表現</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>align</code> representation can be used on <code>struct</code> s and <code>union</code> s to raise the alignment of the type to a given value.</span> <code>align</code>表現は、 <code>struct</code>および<code>union</code> <code>struct</code>で使用して、型の整列を所定の値に上げることができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Alignment is specified as a parameter in the form of <code>#[repr(align(x))]</code> .</span>アラインメントは<code>#[repr(align(x))]</code>の形式でパラメータとして指定されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The alignment value must be a power of two of type <code>u32</code> .</span>アライメント値は、タイプ<code>u32</code>の2の累乗でなければなりません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>align</code> representation can raise the alignment of a type to be greater than it&#39;s primitive alignment, it cannot lower the alignment of a type.</span> <code>align</code>表現は、型の整列をプリミティブ整列よりも大きくすることができます。型の整列を下げることはできません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>align</code> and <code>packed</code> representations cannot be applied on the same type and a <code>packed</code> type cannot transitively contain another <code>align</code> ed type.</span> <code>align</code>と<code>packed</code>表現は同じ型には適用できません。また、 <code>packed</code>型は別の<code>align</code>型を<code>align</code>的に含むことはできません。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>packed</code> Representation</span> <code>packed</code>表現</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>packed</code> representation can only be used on <code>struct</code> s and <code>union</code> s.</span> <code>packed</code>表現は、 <code>struct</code>および<code>union</code> <code>struct</code>のみ使用できます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It modifies the representation (either the default or <code>C</code> ) by removing any padding bytes and forcing the alignment of the type to <code>1</code> .</span>パディングバイトを削除し、タイプのアラインメントを<code>1</code>強制することによって、表現（デフォルトまたは<code>C</code>いずれか）を変更します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>align</code> and <code>packed</code> representations cannot be applied on the same type and a <code>packed</code> type cannot transitively contain another <code>align</code> ed type.</span> <code>align</code>と<code>packed</code>表現は同じ型には適用できません。また、 <code>packed</code>型は別の<code>align</code>型を<code>align</code>的に含むことはできません。</span> </p><br><p><div class=warning></p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">* <b>Warning:</b> * Dereferencing an unaligned pointer is <a class=notranslate href="#4undefined behaviour">undefined behaviour</a> and it is possible to <a href=#327060>safely create unaligned pointers to <code>packed</code> fields</a> .</span> * <b>警告：</b> *整列されていないポインタを参照解除すると、 <a class=notranslate href="#4undefined behaviour">undefined behaviour</a>となり<a href=#327060>、 <code>packed</code>フィールドへのアラインされていないポインタを安全に作成する</a>ことができ<a href=#327060>ます</a> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Like all ways to create undefined behavior in safe Rust, this is a bug.</span>安全なRustで未定義の動作を作成するすべての方法と同様に、これはバグです。</span> </p><br><p></div></p><br> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a class=notranslate href=#1../std/mem/fn.align_of_val.html>`align_of_val`</a> <a class=notranslate href=#1../std/mem/fn.size_of_val.html>`size_of_val`</a> <a class=notranslate href=#1../std/mem/fn.align_of.html>`align_of`</a> <a class=notranslate href=#1../std/mem/fn.size_of.html>`size_of`</a> <a class=notranslate href=#1../std/marker/trait.Sized.html>`Sized`</a> <a class=notranslate href=#1dynamically-sized-types.html>dynamically sized types</a> <a class=notranslate href="#1 items/enumerations.html#custom-discriminant-values-for-field-less-enumerations">C-like enumerations</a> <a class=notranslate href=#1items/enumerations.html#zero-variant-enums>zero-variant enumerations</a> <a class=notranslate href=#1behavior-considered-undefined.html>undefined behavior</a> <a class=notranslate href=#1https://github.com/rust-lang/rust/issues/27060>27060</a></span> <a class=notranslate href=#1../std/mem/fn.align_of_val.html>`align_of_val`</a> <a class=notranslate href=#1../std/mem/fn.size_of_val.html>`size_of_val`</a> <a class=notranslate href=#1../std/mem/fn.align_of.html>`align_of`</a> <a class=notranslate href=#1../std/mem/fn.size_of.html>`size_of`</a> <a class=notranslate href=#1../std/marker/trait.Sized.html>`Sized`</a> <a class=notranslate href=#1dynamically-sized-types.html>dynamically sized types</a> <a class=notranslate href="#1 items/enumerations.html#custom-discriminant-values-for-field-less-enumerations">C-like enumerations</a> <a class=notranslate href=#1items/enumerations.html#zero-variant-enums>zero-variant enumerations</a> <a class=notranslate href=#1behavior-considered-undefined.html>undefined behavior</a> <a class=notranslate href=#1https://github.com/rust-lang/rust/issues/27060>27060</a></span><script>_addload(function(){_setupIW('com');_csi('en','ja','type-layout.html');});</script>