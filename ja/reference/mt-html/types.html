<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180723_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=types.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Types</span>タイプ</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Every variable, item and value in a Rust program has a type.</span> Rustプログラムのすべての変数、項目、値には型があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <s>type</s> of a <i>value</i> defines the interpretation of the memory holding it.</span> <i>値</i>の<s>型</s>は、それを保持するメモリの解釈を定義します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Built-in types are tightly integrated into the language, in nontrivial ways that are not possible to emulate in user-defined types.</span>組み込み型は、ユーザー定義型ではエミュレートできない重要な方法で、言語に密接に統合されています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">User-defined types have limited capabilities.</span>ユーザー定義型には機能が限られています。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Primitive types</span>プリミティブ型</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Some types are defined by the language, rather than as part of the standard library, these are called <s>primitive types</s> .</span>言語によって定義されるタイプもあれば、標準ライブラリの一部ではなく、 <s>プリミティブタイプ</s>と呼ばれる<s>タイプもあります</s> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Some of these are individual types:</span>これらは個々のタイプです：</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The boolean type <code>bool</code> with values <code>true</code> and <code>false</code> .</span>値が<code>true</code>および<code>false</code>のブール型<code>bool</code> 。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <a class=notranslate href="#4machine types">machine types</a> (integer and floating-point).</span> <a class=notranslate href="#4machine types">machine types</a> （整数と浮動小数点）。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <a class=notranslate href="#4machine-dependent integer types">machine-dependent integer types</a> .</span> <a class=notranslate href="#4machine-dependent integer types">machine-dependent integer types</a> 。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <a class=notranslate href="#4textual types">textual types</a> <code>char</code> and <code>str</code> .</span> <a class=notranslate href="#4textual types">textual types</a> <code>char</code>と<code>str</code> 。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <a class=notranslate href="#4never type">never type</a> <code>€</code></span> <a class=notranslate href="#4never type">never type</a> <code>€</code></span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There are also some primitive constructs for generic types built in to the language:</span>言語に組み込まれたジェネリック型の基本的な構造もいくつかあります。</span> </p><br><div data-b=*> <a class=notranslate href=#4Tuples>Tuples</a> </div> <div data-b=*> <a class=notranslate href=#4Arrays>Arrays</a> </div> <div data-b=*> <a class=notranslate href=#4Slices>Slices</a> </div> <div data-b=*> <a class=notranslate href="#4Function pointers">Function pointers</a> </div> <div data-b=*> <a class=notranslate href=#4References>References</a> </div> <div data-b=*> <a class=notranslate href=#4Pointers>Pointers</a> </div> <br> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a class=notranslate href=#1#machine-types>machine types</a> <a class=notranslate href=#1#machine-dependent-integer-types>machine-dependent integer types</a> <a class=notranslate href=#1#textual-types>textual types</a> <a class=notranslate href=#1#never-type>never-type</a> <a class=notranslate href=#1#tuple-types>Tuples</a> <a class=notranslate href=#1#array-and-slice-types>Arrays</a> <a class=notranslate href=#1#array-and-slice-types>Slices</a> <a class=notranslate href=#1#pointer-types>References</a> <a class=notranslate href=#1#raw-pointers-const-and-mut>Pointers</a> <a class=notranslate href=#1#function-pointer-types>Function pointers</a> <a class=notranslate href=#1#function-types>function</a> <a class=notranslate href=#1#closure-types>closure</a></span> <a class=notranslate href=#1#machine-types>machine types</a> <a class=notranslate href=#1#machine-dependent-integer-types>machine-dependent integer types</a> <a class=notranslate href=#1#textual-types>textual types</a> <a class=notranslate href=#1#never-type>never-type</a> <a class=notranslate href=#1#tuple-types>Tuples</a> <a class=notranslate href=#1#array-and-slice-types>Arrays</a> <a class=notranslate href=#1#array-and-slice-types>Slices</a> <a class=notranslate href=#1#pointer-types>References</a> <a class=notranslate href=#1#raw-pointers-const-and-mut>Pointers</a> <a class=notranslate href=#1#function-pointer-types>Function pointers</a> <a class=notranslate href=#1#function-types>function</a> <a class=notranslate href=#1#closure-types>closure</a></span> <br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Numeric types</span>数値型</span> </h2><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Machine types</span>マシンの種類</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The machine types are the following:</span>マシンの種類は次のとおりです。</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The unsigned word types <code>u8</code> , <code>u16</code> , <code>u32</code> , <code>u64</code> , and <code>u128</code> with values drawn from the integer intervals <a class=notranslate href="#40, 2^8 - 1">0, 2^8 - 1</a> , <a class=notranslate href="#40, 2^16 - 1">0, 2^16 - 1</a> , <a class=notranslate href="#40, 2^32 - 1">0, 2^32 - 1</a> , <a class=notranslate href="#40, 2^64 - 1">0, 2^64 - 1</a> , and <a class=notranslate href="#40, 2^128 - 1">0, 2^128 - 1</a> respectively.</span>符号なしのワードタイプ<code>u8</code> 、 <code>u16</code> 、 <code>u32</code> 、 <code>u64</code> 、および<code>u128</code>整数間隔から引き出された値を<a class=notranslate href="#40, 2^8 - 1">0, 2^8 - 1</a> 、 <a class=notranslate href="#40, 2^16 - 1">0, 2^16 - 1</a> 、 <a class=notranslate href="#40, 2^32 - 1">0, 2^32 - 1</a> 、 <a class=notranslate href="#40, 2^64 - 1">0, 2^64 - 1</a> 、及び<a class=notranslate href="#40, 2^128 - 1">0, 2^128 - 1</a>それぞれ。</span> </div><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The signed two&#39;s complement word types <code>i8</code> , <code>i16</code> , <code>i32</code> , <code>i64</code> , and <code>i128</code> , with values drawn from the integer intervals <a class=notranslate href="#4-(2^7), 2^7 - 1">-(2^7), 2^7 - 1</a> , <a class=notranslate href="#4-(2^15), 2^15 - 1">-(2^15), 2^15 - 1</a> , <a class=notranslate href="#4-(2^31), 2^31 - 1">-(2^31), 2^31 - 1</a> , <a class=notranslate href="#4-(2^63), 2^63 - 1">-(2^63), 2^63 - 1</a> , and <a class=notranslate href="#4-(2^127), 2^127 - 1">-(2^127), 2^127 - 1</a> respectively.</span>符号付き2の補数ワードタイプ<code>i8</code> 、 <code>i16</code> 、 <code>i32</code> 、 <code>i64</code> 、および<code>i128</code> 、整数間隔から引き出された値を有する<a class=notranslate href="#4-(2^7), 2^7 - 1">-(2^7), 2^7 - 1</a> 、 <a class=notranslate href="#4-(2^15), 2^15 - 1">-(2^15), 2^15 - 1</a> 、 <a class=notranslate href="#4-(2^31), 2^31 - 1">-(2^31), 2^31 - 1</a> 、 <a class=notranslate href="#4-(2^63), 2^63 - 1">-(2^63), 2^63 - 1</a> 、 <a class=notranslate href="#4-(2^127), 2^127 - 1">-(2^127), 2^127 - 1</a>ある。</span> </div><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The IEEE 754-2008 &quot;binary32&quot; and &quot;binary64&quot; floating-point types: <code>f32</code> and <code>f64</code> , respectively.</span> IEEE 754-2008の「binary32」浮動小数点型と「binary64」浮動小数点型：それぞれ<code>f32</code>と<code>f64</code>です。</span> </div><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Machine-dependent integer types</span>マシン依存の整数型</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>usize</code> type is an unsigned integer type with the same number of bits as the platform&#39;s pointer type.</span> <code>usize</code>型は、プラットフォームのポインタ型と同じビット数の符号なし整数型です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It can represent every memory address in the process.</span>プロセス内のすべてのメモリアドレスを表すことができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>isize</code> type is a signed integer type with the same number of bits as the platform&#39;s pointer type.</span> <code>isize</code>型は、プラットフォームのポインタ型と同じビット数を持つ符号付き整数型です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The theoretical upper bound on object and array size is the maximum <code>isize</code> value.</span>オブジェクトと配列のサイズに関する理論上の上限は、最大<code>isize</code>値です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This ensures that <code>isize</code> can be used to calculate differences between pointers into an object or array and can address every byte within an object along with one byte past the end.</span>これにより、オブジェクトまたは配列へのポインタ間の相違を計算するために<code>isize</code>を使用できるようになり、オブジェクト内のすべてのバイトを1バイト後に処理することができます。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Textual types</span>テキストタイプ</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The types <code>char</code> and <code>str</code> hold textual data.</span> <code>char</code>型と<code>str</code>型はテキストデータを保持します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A value of type <code>char</code> is a <a href=#2http://www.unicode.org/glossary/#unicode_scalar_value>Unicode scalar value</a> (ie a code point that is not a surrogate), represented as a 32-bit unsigned word in the 0x0000 to 0xD7FF or 0xE000 to 0x10FFFF range.</span> <code>char</code>型の値は、0x0000から0xD7FFまたは0xE000から0x10FFFFまでの範囲内の32ビットの符号なしワードとして表される<a href=#2http://www.unicode.org/glossary/#unicode_scalar_value>Unicodeスカラー値</a> （つまり代理コードではないコードポイント）です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A <code>[char]</code> is effectively a UCS-4 / UTF-32 string.</span> <code>[char]</code>は実質的にUCS-4 / UTF-32文字列です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A value of type <code>str</code> is a Unicode string, represented as an array of 8-bit unsigned bytes holding a sequence of UTF-8 code points.</span> <code>str</code>型の値は、UTF-8コードポイントのシーケンスを保持する8ビットの符号なしバイトの配列として表されるUnicode文字列です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Since <code>str</code> is a <a class=notranslate href="#4dynamically sized type">dynamically sized type</a> , it is not a <s>first-class</s> type, but can only be instantiated through a pointer type, such as <code>&amp;str</code> .</span> <code>str</code>は<a class=notranslate href="#4dynamically sized type">dynamically sized type</a>であるため、 <s>first-class</s>型ではありませんが、 <code>&amp;str</code>ようなポインタ型でのみインスタンス化でき<code>&amp;str</code> 。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Never type</span>入力しない</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The never type <code>€</code> is a type with no values, representing the result of computations that never complete.</span> never型<code>€</code>は、値のない型であり、決して完了しない計算の結果を表します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Expressions of type <code>€</code> can be coerced into any other type.</span>タイプ<code>€</code>式は、他の型に変換できます。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Tuple types</span>タプルタイプ</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A tuple <i>type</i> is a heterogeneous product of other types, called the <i>elements</i> of the tuple.</span>タプル<i>型</i>は、タプルの<i>要素</i>と呼ばれる他の型の異種の製品です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It has no nominal name and is instead structurally typed.</span>名目上の名前はなく、代わりに構造的に型付けされています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Tuple types and values are denoted by listing the types or values of their elements, respectively, in a parenthesized, comma-separated list.</span>タプルの型と値は、要素の型または値をカッコで区切られたコンマで区切られたリストにそれぞれリストして示します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because tuple elements don&#39;t have a name, they can only be accessed by pattern-matching or by using <code>N</code> directly as a field to access the <code>N</code> th element.</span>タプル要素は名前を持たないので、パターンマッチングや<code>N</code>番目の要素にアクセスするためのフィールドとして<code>N</code>直接使用することによってのみアクセスできます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">An example of a tuple type and its use:</span>タプル型とその使用例：</span> </p><br><div data-lang=rust><div data-l="type Pair&lt;'a&gt; = (i32, &amp;'a str);"></div><div data-l="let p: Pair&lt;'static&gt; = (10, &quot;ten&quot;);"></div><div data-l="let (a, b) = p;"></div><div data-l=""></div><div data-l="assert_eq!(a, 10);"></div><div data-l="assert_eq!(b, &quot;ten&quot;);"></div><div data-l="assert_eq!(p.0, 10);"></div><div data-l="assert_eq!(p.1, &quot;ten&quot;);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For historical reasons and convenience, the tuple type with no elements ( <code>()</code> ) is often called &#39;unit&#39; or &#39;the unit type&#39;.</span>歴史的な理由と便宜のために、要素のないタプルタイプ（ <code>()</code> ）は、しばしば「ユニット」または「ユニットタイプ」と呼ばれます。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Array, and Slice types</span>配列、およびスライスタイプ</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust has two different types for a list of items:</span>錆は、アイテムのリストに2つの異なるタイプがあります：</span> </p><br><div data-b=*> <code>[T; N]</code> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>[T; N]</code> , an &#39;array&#39;</span> <code>[T; N]</code> 、 &#39;配列&#39;</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>[T]</code> , a &#39;slice&#39;</span> <code>[T]</code> 、 &#39;スライス&#39;</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">An array has a fixed size, and can be allocated on either the stack or the heap.</span>配列は固定サイズであり、スタックまたはヒープのいずれかに割り当てることができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A slice is a <a class=notranslate href="#4dynamically sized type">dynamically sized type</a> representing a &#39;view&#39; into an array.</span>スライスは、配列への &#39;ビュー&#39;を表す<a class=notranslate href="#4dynamically sized type">dynamically sized type</a>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To use a slice type it generally has to be used behind a pointer for example as</span>スライスタイプを使用するには、一般にポインタの後ろに例えば以下のように使用する必要があります。</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>&amp;[T]</code> , a &#39;shared slice&#39;, often just called a &#39;slice&#39;, it doesn&#39;t own the data it points to, it borrows it.</span> <code>&amp;[T]</code> 、「共有スライス」はしばしば単に「スライス」と呼ばれ、それが指すデータを所有していないので、それを借ります。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>&amp;mut [T]</code> , a &#39;mutable slice&#39;, mutably borrows the data it points to.</span> <code>&amp;mut [T]</code> 、 &#39;mutable slice&#39;は、それが指し示すデータを可変的に借ります。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>Box&lt;[T]&gt;</code> , a &#39;boxed slice&#39;</span> <code>Box&lt;[T]&gt;</code> 、 &#39;boxed slice&#39;</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Examples:</span>例：</span> </p><br><div data-lang=rust><div data-l="#// A stack-allocated array"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A stack-allocated array</span>スタック割り当て配列</span> </div><div data-l="let array: [i32; 3] = [1, 2, 3];"></div><div data-l=""></div><div data-l="#// A heap-allocated array, coerced to a slice"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A heap-allocated array, coerced to a slice</span>スライスに強制的に割り当てられたヒープ割り当て配列</span> </div><div data-l="let boxed_array: Box&lt;[i32]&gt; = Box::new([1, 2, 3]);"></div><div data-l=""></div><div data-l="#// A (shared) slice into an array"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A (shared) slice into an array</span>アレイへの（共有）スライス</span> </div><div data-l="let slice: &amp;[i32] = &amp;boxed_array[..];"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">All elements of arrays and slices are always initialized, and access to an array or slice is always bounds-checked in safe methods and operators.</span>配列やスライスのすべての要素は常に初期化され、配列やスライスへのアクセスは安全なメソッドや演算子で常に境界チェックされます。</span> </p><br><blockquote><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note: The <a class=notranslate href="#4`Vec&lt;T&gt;`">`Vec `</a></span>注： <a class=notranslate href="#4`Vec&lt;T&gt;`">`Vec `</a></span> <T> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a class=notranslate href="#4`Vec&lt;T&gt;`">`Vec `</a> standard library type provides a heap-allocated resizable array type.</span> <a class=notranslate href="#4`Vec&lt;T&gt;`">`Vec `</a>標準ライブラリ型は、ヒープ割り当てのサイズ変更可能な配列型を提供します。</span> </p></blockquote><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Struct types</span>構造体の型</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A <code>struct</code> <i>type</i> is a heterogeneous product of other types, called the <i>fields</i> of the type.</span> <code>struct</code> <i>型</i>は、 <i>型</i>の<i>フィールド</i>と呼ばれる他の型の異種製品です。</span> <a class=notranslate href=#4^structtype>^structtype</a> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">New instances of a <code>struct</code> can be constructed with a <a class=notranslate href=#2expressions/struct-expr.html>struct expression</a> .</span> <code>struct</code>新しいインスタンスは、 <code>struct</code> <a class=notranslate href=#2expressions/struct-expr.html>struct expression</a>構築できます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The memory layout of a <code>struct</code> is undefined by default to allow for compiler optimizations like field reordering, but it can be fixed with the <code>#[repr(...)]</code> attribute.</span> <code>struct</code>のメモリレイアウトは、デフォルトではフィールドの並べ替えのようなコンパイラの最適化を可能にするために未定義ですが、 <code>#[repr(...)]</code>属性で修正できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In either case, fields may be given in any order in a corresponding struct <i>expression</i> ;</span>どちらの場合でも、フィールドは、対応する構造<i>式</i>で任意の順序で指定することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">the resulting <code>struct</code> value will always have the same memory layout.</span>結果の<code>struct</code>値は常に同じメモリレイアウトになります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The fields of a <code>struct</code> may be qualified by <a class=notranslate href=#2visibility-and-privacy.html>visibility modifiers</a> , to allow access to data in a struct outside a module.</span> <code>struct</code>のフィールドは<a class=notranslate href=#2visibility-and-privacy.html>visibility modifiers</a>子によって修飾され、モジュール外の構造体のデータにアクセスすることができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A <s>tuple struct</s> type is just like a struct type, except that the fields are anonymous.</span> <s>タプル構造</s>体型は、構造体型と似ていますが、フィールドは匿名です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A <s>unit-like struct</s> type is like a struct type, except that it has no fields.</span> <s>ユニットのような構造体の</s>型は、構造体の型に似ていますが、フィールドを持たない点が異なります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The one value constructed by the associated <a class=notranslate href="#4struct expression">struct expression</a> is the only value that inhabits such a type.</span>関連する<a class=notranslate href="#4struct expression">struct expression</a>によって構築された1つの値は、そのような型が存在する唯一の値です。</span> </p><br> <a class=notranslate href="#1`struct` types are analogous to `struct` types in C, the">^structtype</a> <p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><i>record</i> types of the ML family, or the <i>struct</i> types of the Lisp family.</span> MLファミリの<i>レコード</i>タイプ、またはLispファミリの<i>構造体</i>タイプを定義します。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Enumerated types</span>列挙型</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">An <i>enumerated type</i> is a nominal, heterogeneous disjoint union type, denoted by the name of an <a href=#2items/enumerations.html><code>enum</code> item</a> .</span> <i>列挙型は、</i>の名前で示される名目、異種のばらばらの共用体型、ある<a href=#2items/enumerations.html><code>enum</code>アイテム</a> 。</span> <a class=notranslate href=#4^enumtype>^enumtype</a> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">An <a href=#2items/enumerations.html><code>enum</code> item</a> declares both the type and a number of <i>variants</i> , each of which is independently named and has the syntax of a struct, tuple struct or unit-like struct.</span> <a href=#2items/enumerations.html><code>enum</code></a>型<a href=#2items/enumerations.html>項目</a>は、 <i>バリアントの</i>型と数の両方を宣言し<i>ます</i> 。各<i>バリアントは</i> 、それぞれ独立して名前が付けられ、構造体、タプル構造体またはユニットのような構造体の構文を持ちます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">New instances of an <code>enum</code> can be constructed in an <a href=#2expressions/enum-variant-expr.html>enumeration variant expression</a> .</span>新しいインスタンスを<code>enum</code>構築することができる<a href=#2expressions/enum-variant-expr.html>列挙変異体発現</a> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Any <code>enum</code> value consumes as much memory as the largest variant for its corresponding <code>enum</code> type, as well as the size needed to store a discriminant.</span> <code>enum</code>値は、対応する<code>enum</code>型の最大の変種と同じくらい多くのメモリと、判別式を格納するのに必要なサイズを消費します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Enum types cannot be denoted <i>structurally</i> as types, but must be denoted by named reference to an <a href=#2items/enumerations.html><code>enum</code> item</a> .</span> Enum型は、型として<i>構造的</i>に指定することはできませんが、 <a href=#2items/enumerations.html><code>enum</code>項目の</a>名前付き参照で指定する必要があり<a href=#2items/enumerations.html>ます</a> 。</span> </p><br> <a class=notranslate href="#1The `enum` type is analogous to a `data` constructor declaration in">^enumtype</a> <p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">ML, or a <i>pick ADT</i> in Limbo.</span> ML、またはLimboの<i>ADT</i>を<i>選択</i>します。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Union types</span>連合型</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A <i>union type</i> is a nominal, heterogeneous C-like union, denoted by the name of a <a href=#2items/unions.html><code>union</code> item</a> .</span> <i>ユニオンタイプ</i>の名前によって示さ公称、異種C状組合であり、 <a href=#2items/unions.html><code>union</code>アイテム</a> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A union contains the value of any one of its fields.</span>共用体には、そのフィールドのいずれかの値が含まれます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Since the accessing the wrong field can cause unexpected or undefined behaviour, <code>unsafe</code> is required to read from a union field or to write to a field that doesn&#39;t implement <a class=notranslate href="#4`Copy`">`Copy`</a> .</span>間違ったフィールドにアクセスすると予期しない動作や未定義の動作が発生する可能性があるので、unionフィールドからの読み取りや<a class=notranslate href="#4`Copy`">`Copy`</a>実装していないフィールドへの書き込みには<code>unsafe</code>はありません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The memory layout of a <code>union</code> is undefined by default, but the <code>#[repr(...)]</code> attribute can be used to fix a layout.</span> <code>union</code>のメモリー・レイアウトはデフォルトでは未定義ですが、 <code>#[repr(...)]</code>属性を使用してレイアウトを修正できます。</span> </p><br> <a class=notranslate href=#1special-types-and-traits.html#copy>`Copy`</a> <br> <h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Recursive types</span>再帰型</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Nominal types &amp;mdash;</span>名義型＆mdash;</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a class=notranslate href=#2#struct-types>structs</a> , <a class=notranslate href=#2#enumerated-types>enumerations</a> and <a class=notranslate href=#2#union-types>unions</a> &amp;mdash;</span> <a class=notranslate href=#2#struct-types>structs</a> 、 <a class=notranslate href=#2#enumerated-types>enumerations</a>および<a class=notranslate href=#2#union-types>unions</a> <a class=notranslate href=#2#struct-types>structs</a></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">may be recursive.</span>再帰的である可能性があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That is, each <code>enum</code> variant or <code>struct</code> or <code>union</code> field may refer, directly or indirectly, to the enclosing <code>enum</code> or <code>struct</code> type itself.</span>つまり、各<code>enum</code>型または<code>struct</code>または<code>union</code>体フィールドは、直接的または間接的に、囲む<code>enum</code>型または<code>struct</code>タイプ自体を参照することがあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Such recursion has restrictions:</span>そのような再帰には制限があります。</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Recursive types must include a nominal type in the recursion (not mere <a href=#2../grammar.html#type-definitions>type definitions</a> , or other structural types such as <a class=notranslate href=#2#array-and-slice-types>arrays</a> or <a class=notranslate href=#2#tuple-types>tuples</a> ).</span>再帰型は、単純<a href=#2../grammar.html#type-definitions>型定義</a> 、または<a class=notranslate href=#2#array-and-slice-types>arrays</a>や<a class=notranslate href=#2#tuple-types>tuples</a>などの他の構造<a href=#2../grammar.html#type-definitions>型で</a>はなく、再帰に名目型を含める必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So <code>type Rec = &amp;&#39;static [Rec]</code> is not allowed.</span>したがって<code>type Rec = &amp;&#39;static [Rec]</code>は許可されません。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The size of a recursive type must be finite;</span>再帰型のサイズは有限でなければなりません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">in other words the recursive fields of the type must be <a href=#2#pointer-types>pointer types</a> .</span>つまり、型の再帰的フィールドは<a href=#2#pointer-types>ポインタ</a>型でなければなりません。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Recursive type definitions can cross module boundaries, but not module</span>再帰型定義はモジュール境界を越えることができますが、モジュールは通過できません</span> </div><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><i>visibility</i> boundaries, or crate boundaries (in order to simplify the module system and type checker).</span> <i>可視の</i>境界、またはクレート境界（モジュールシステムおよびタイプチェックを簡単にするために）。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">An example of a <i>recursive</i> type and its use:</span> <i>再帰</i>型とその使用例：</span> </p><br><div data-lang=rust><div data-l="enum List&lt;T&gt; {"></div><div data-l="    Nil,"></div><div data-l="    Cons(T, Box&lt;List&lt;T&gt;&gt;)"></div><div data-l=}></div><div data-l=""></div><div data-l="let a: List&lt;i32&gt; = List::Cons(7, Box::new(List::Cons(13, Box::new(List::Nil))));"></div></div><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Pointer types</span>ポインタの種類</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">All pointers in Rust are explicit first-class values.</span> Rustのすべてのポインタは明示的なファーストクラスの値です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">They can be moved or copied, stored into data structs, and returned from functions.</span>それらは移動またはコピーし、データ構造体に格納し、関数から返すことができます。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Shared references ( <code>&amp;</code> )</span>共有参照（ <code>&amp;</code> ）</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These point to memory <s>owned by some other value</s> .</span>これらは<s>、他の値が所有</s>するメモリを指し<s>ます</s> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When a shared reference to a value is created it prevents direct mutation of the value.</span>値への共有参照が作成されると、値の直接的な変更が防止されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a class=notranslate href=#2interior-mutability.html>Interior mutability</a> provides an exception for this in certain circumstances.</span> <a class=notranslate href=#2interior-mutability.html>Interior mutability</a>は、特定の状況でこれに対して例外を提供します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As the name suggests, any number of shared references to a value may exit.</span>名前が示すように、値に対する共有参照はいくつでも終了することがあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A shared reference type is written <code>&amp;type</code> , or <code>&amp;&#39;a type</code> when you need to specify an explicit lifetime.</span>共有参照型が書かれている<code>&amp;type</code> 、または<code>&amp;&#39;a type</code>明示的な寿命を指定する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Copying a reference is a &quot;shallow&quot; operation: it involves only copying the pointer itself, that is, pointers are <code>Copy</code> .</span>参照をコピーすることは、「浅い」操作です。ポインタ自体をコピーするだけです。つまり、ポインタは<code>Copy</code>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Releasing a reference has no effect on the value it points to, but referencing of a <a href=#2expressions.html#temporary-lifetimes>temporary value</a> will keep it alive during the scope of the reference itself.</span>参照を解放することは、その参照先の値には影響を与えませんが、 <a href=#2expressions.html#temporary-lifetimes>一時的な値</a>を参照することは、参照自体の有効範囲内で有効にします。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Mutable references ( <code>&amp;mut</code> )</span>変更可能な参照（ <code>&amp;mut</code> ）</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These also point to memory owned by some other value.</span>これらはまた、他の値が所有するメモリを指しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A mutable reference type is written <code>&amp;mut type</code> or <code>&amp;&#39;a mut type</code> .</span>変更可能な参照型は<code>&amp;mut type</code>または<code>&amp;&#39;a mut type</code>記述されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A mutable reference (that hasn&#39;t been borrowed) is the only way to access the value it points to, so is not <code>Copy</code> .</span>参照する値（借用されていない）は、参照する値にアクセスする唯一の方法であるため、 <code>Copy</code>はありません。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Raw pointers ( <code>*const</code> and <code>*mut</code> )</span>生ポインタ（ <code>*const</code>と<code>*mut</code> ）</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Raw pointers are pointers without safety or liveness guarantees.</span>生ポインタは、安全性または生存保証のないポインタです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Raw pointers are written as <code>*const T</code> or <code>*mut T</code> , for example <code>*const i32</code> means a raw pointer to a 32-bit integer.</span>生ポインタは、 <code>*const T</code>または<code>*mut T</code>として記述されます。例えば、 <code>*const i32</code>は、32ビット整数への生ポインタを意味します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Copying or dropping a raw pointer has no effect on the lifecycle of any other value.</span>ローポインタをコピーまたはドロップしても、他の値のライフサイクルに影響はありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Dereferencing a raw pointer is an <a class=notranslate href=#2unsafe-functions.html><code>unsafe</code> operation</a> , this can also be used to convert a raw pointer to a reference by reborrowing it ( <code>&amp;*</code> or <code>&amp;mut *</code> ).</span>未処理のポインタを参照解除することは<a class=notranslate href=#2unsafe-functions.html><code>unsafe operation</code></a>はあり<a class=notranslate href=#2unsafe-functions.html><code>unsafe operation</code></a> 。これを使用して未使用のポインタを再借用して参照に変換することもできます（ <code>&amp;*</code>または<code>&amp;mut *</code> ）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Raw pointers are generally discouraged in Rust code;</span>生ポインタは一般に錆コードでは推奨されません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">they exist to support interoperability with foreign code, and writing performance-critical or low-level functions.</span>外部コードとの相互運用性をサポートし、パフォーマンスクリティカルまたは低レベルの機能を記述するために存在します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When comparing pointers they are compared by their address, rather than by what they point to.</span>ポインタを比較するときには、ポインターで比較するのではなく、アドレスで比較します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When comparing pointers to <a href=#2dynamically-sized-types.html>dynamically sized types</a> they also have their addition data compared.</span> <a href=#2dynamically-sized-types.html>動的なサイズの型</a>へのポインタを比較するときには、それらの比較データも比較されます。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Smart Pointers</span>スマートポインタ</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The standard library contains additional &#39;smart pointer&#39; types beyond references and raw pointers.</span>標準ライブラリには、参照や生ポインタ以外の「スマートポインタ」タイプが追加されています。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Function item types</span>機能項目タイプ</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When referred to, a function item, or the constructor of a tuple-like struct or enum variant, yields a zero-sized value of its <s>function item type</s> .</span>参照されると、関数項目、またはタプルのような構造体または列挙型のコンストラクタは、その<s>関数項目型の</s>サイズがゼロの値を生成します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That type explicitly identifies the function - its name, its type arguments, and its early-bound lifetime arguments (but not its late-bound lifetime arguments, which are only assigned when the function is called) - so the value does not need to contain an actual function pointer, and no indirection is needed when the function is called.</span>その型は明示的にその名前、型引数、およびその初期バインドされた存続時間引数（関数が呼び出されたときにのみ割り当てられる後期バインドされた存続時間引数ではない）を識別します。実際の関数ポインタ、関数が呼び出されたときの間接参照は必要ありません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There is no syntax that directly refers to a function item type, but the compiler will display the type as something like <code>fn(u32) -&gt; i32 {fn_name}</code> in error messages.</span>関数項目の型を直接参照する構文はありませんが、コンパイラはそのタイプをエラーメッセージに<code>fn(u32) -&gt; i32 {fn_name}</code>に表示します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because the function item type explicitly identifies the function, the item types of different functions - different items, or the same item with different generics - are distinct, and mixing them will create a type error:</span>関数アイテムタイプは明示的に関数を識別するので、異なる関数のアイテムタイプ（異なるアイテムまたは異なるジェネリックの同じアイテム）が区別され、それらを混合するとタイプエラーが生成されます：</span> </p><br><div data-lang=rust,compile_fail,E0308><div data-l="fn foo&lt;T&gt;() { }"></div><div data-l="let x = &amp;mut foo::&lt;i32&gt;;"></div><div data-l="*x = foo::&lt;u32&gt;; //~ ERROR mismatched types"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, there is a <a class=notranslate href=#4coercion>coercion</a> from function items to <a class=notranslate href=#2#function-pointer-types>function pointers</a> with the same signature, which is triggered not only when a function item is used when a function pointer is directly expected, but also when different function item types with the same signature meet in different arms of the same <code>if</code> or <code>match</code> :</span>しかし、機能項目が直接期待されるときに機能項目が使用されるときだけでなく、同じ署名を持つ異なる機能項目タイプが異なるときにトリガされる、同じ項目を<a class=notranslate href=#2#function-pointer-types>function pointers</a>関数項目への<a class=notranslate href=#4coercion>coercion</a>がある同じ<code>if</code>または<code>match</code> <code>if</code>腕：</span> </p><br> <a class=notranslate href=#1type-coercions.html>coercion</a> <br> <div data-lang=rust><div data-l="# let want_i32 = false;"></div><div data-l="# fn foo&lt;T&gt;() { }"></div><div data-l=""></div><div data-l="#// `foo_ptr_1` has function pointer type `fn()` here"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>foo_ptr_1</code> has function pointer type <code>fn()</code> here</span> <code>foo_ptr_1</code>は関数ポインタ型<code>fn()</code>ます</span> </div><div data-l="let foo_ptr_1: fn() = foo::&lt;i32&gt;;"></div><div data-l=""></div><div data-l="#// ... and so does `foo_ptr_2` - this type-checks."></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">... and so does <code>foo_ptr_2</code> - this type-checks.</span> ...そして<code>foo_ptr_2</code>もそう<code>foo_ptr_2</code> - このタイプはチェックします。</span> </div><div data-l="let foo_ptr_2 = if want_i32 {"></div><div data-l="    foo::&lt;i32&gt;"></div><div data-l="} else {"></div><div data-l="    foo::&lt;u32&gt;"></div><div data-l=};></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">All function items implement <a class=notranslate href="#4`Fn`">`Fn`</a> , <a class=notranslate href="#4`FnMut`">`FnMut`</a> , <a class=notranslate href="#4`FnOnce`">`FnOnce`</a> , <a class=notranslate href="#4`Copy`">`Copy`</a> , <a class=notranslate href="#4`Clone`">`Clone`</a> , <a class=notranslate href="#4`Send`">`Send`</a> , and <a class=notranslate href="#4`Sync`">`Sync`</a> .</span>すべての関数項目は<a class=notranslate href="#4`Fn`">`Fn`</a> 、 <a class=notranslate href="#4`FnMut`">`FnMut`</a> 、 <a class=notranslate href="#4`FnOnce`">`FnOnce`</a> 、 <a class=notranslate href="#4`Copy`">`Copy`</a> 、 <a class=notranslate href="#4`Clone`">`Clone`</a> 、 <a class=notranslate href="#4`Send`">`Send`</a> 、 <a class=notranslate href="#4`Sync`">`Sync`</a>ます。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Function pointer types</span>関数ポインタ型</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Function pointer types, written using the <code>fn</code> keyword, refer to a function whose identity is not necessarily known at compile-time.</span> <code>fn</code>キーワードを使用して記述された関数ポインタ型は、コンパイル時にその識別情報が必ずしもわからない関数を指します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">They can be created via a coercion from both <a href=#2#function-item-types>function items</a> and non-capturing <a class=notranslate href=#2#closure-types>closures</a> .</span>これらは、 <a href=#2#function-item-types>機能項目</a>と非キャプチャ<a class=notranslate href=#2#closure-types>closures</a>両方からの強制によって作成することができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A function pointer type consists of a possibly-empty set of function-type modifiers (such as <code>unsafe</code> or <code>extern</code> ), a sequence of input types and an output type.</span>関数ポインタ型は、おそらく空の関数型修飾子（ <code>unsafe</code>や<code>extern</code> ）、一連の入力型、および出力型で構成されます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">An example where <code>Binop</code> is defined as a function pointer type:</span> <code>Binop</code>が関数ポインタ型として定義されている例：</span> </p><br><div data-lang=rust><div data-l="fn add(x: i32, y: i32) -&gt; i32 {"></div><div data-l="    x + y"></div><div data-l=}></div><div data-l=""></div><div data-l="let mut x = add(5,7);"></div><div data-l=""></div><div data-l="type Binop = fn(i32, i32) -&gt; i32;"></div><div data-l="let bo: Binop = add;"></div><div data-l="x = bo(5,7);"></div></div><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Closure types</span>クロージャタイプ</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A <a class=notranslate href="#4closure expression">closure expression</a> produces a closure value with a unique, anonymous type that cannot be written out.</span> <a class=notranslate href="#4closure expression">closure expression</a>は、書き出すことができない一意の匿名型のクロージャ値を生成します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A closure type is approximately equivalent to a struct which contains the captured variables.</span>クロージャ型は、キャプチャされた変数を含む構造体とほぼ同等です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For instance, the following closure:</span>たとえば、次のようなクロージャがあります。</span> </p><br><div data-lang=rust><div data-l="fn f&lt;F : FnOnce() -&gt; String&gt; (g: F) {"></div><div data-l="    println!(&quot;{}&quot;, g());"></div><div data-l=}></div><div data-l=""></div><div data-l="let mut s = String::from(&quot;foo&quot;);"></div><div data-l="let t = String::from(&quot;bar&quot;);"></div><div data-l=""></div><div data-l="f(|| {"></div><div data-l="    s += &amp;*t;"></div><div data-l="    s"></div><div data-l=});></div><div data-l="#// Prints &quot;foobar&quot;."></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Prints &quot;foobar&quot;.</span> &quot;foobar&quot;を表示します。</span> </div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">generates a closure type roughly like the following:</span>次のような閉包型を生成します。</span> </p><br><div data-lang=rust,ignore><div data-l="struct Closure&lt;'a&gt; {"></div><div data-l="    s : String,"></div><div data-l="    t : &amp;'a String,"></div><div data-l=}></div><div data-l=""></div><div data-l="impl&lt;'a&gt; (FnOnce() -&gt; String) for Closure&lt;'a&gt; {"></div><div data-l="    fn call_once(self) -&gt; String {"></div><div data-l="        self.s += &amp;*self.t;"></div><div data-l="        self.s"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">so that the call to <code>f</code> works as if it were:</span> <code>f</code>への呼び出しは、次のように動作します。</span> </p><br><div data-lang=rust,ignore><div data-l="f(Closure{s: s, t: &amp;t});"></div></div><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Capture modes</span>撮影モード</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The compiler prefers to capture a closed-over variable by immutable borrow, followed by unique immutable borrow (see below), by mutable borrow, and finally by move.</span>コンパイラは、変更不能な借用によって閉鎖された変数を取得し、続いて一意の不変の借用（以下を参照）、変更可能な借用、および最後に移動によって取得することを好みます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It will pick the first choice of these that allows the closure to compile.</span>クロージャーをコンパイルできるようにする最初の選択肢が選択されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The choice is made only with regards to the contents of the closure expression;</span>選択はクロージャ式の内容に関してのみ行われます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">the compiler does not take into account surrounding code, such as the lifetimes of involved variables.</span>コンパイラは、関与する変数の存続期間など、周囲のコードを考慮しません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If the <code>move</code> keyword is used, then all captures are by move or, for <code>Copy</code> types, by copy, regardless of whether a borrow would work.</span> <code>move</code>キーワードが使用されている場合、すべてのキャプチャはmoveによって行われます。また、 <code>Copy</code>タイプでは、コピーによって、借用が機能するかどうかに関係なくコピーされます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>move</code> keyword is usually used to allow the closure to outlive the captured values, such as if the closure is being returned or used to spawn a new thread.</span> <code>move</code>キーワードは、通常、クロージャが返されたり新しいスレッドを生成するために使用された場合など、クロージャがキャプチャされた値よりも長生きできるようにするために使用されます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Composite types such as structs, tuples, and enums are always captured entirely, not by individual fields.</span>構造体、タプル、列挙型などの複合型は、常に個々のフィールドではなく、完全に取り込まれます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It may be necessary to borrow into a local variable in order to capture a single field:</span> 1つのフィールドを取得するには、ローカル変数に借りる必要があります。</span> </p><br><div data-lang=rust><div data-l="# use std::collections::HashSet;"></div><div data-l=#></div><div data-l="struct SetVec {"></div><div data-l="    set: HashSet&lt;u32&gt;,"></div><div data-l="    vec: Vec&lt;u32&gt;"></div><div data-l=}></div><div data-l=""></div><div data-l="impl SetVec {"></div><div data-l="    fn populate(&amp;mut self) {"></div><div data-l="        let vec = &amp;mut self.vec;"></div><div data-l="        self.set.iter().for_each(|&amp;n| {"></div><div data-l="            vec.push(n);"></div><div data-l="        })"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If, instead, the closure were to use <code>self.vec</code> directly, then it would attempt to capture <code>self</code> by mutable reference.</span>代わりに、クロージャが<code>self.vec</code>直接使用する場合は、変更可能な参照によって<code>self</code>をキャプチャしようとします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But since <code>self.set</code> is already borrowed to iterate over, the code would not compile.</span>しかし、 <code>self.set</code>はすでに反復処理のために借りているので、コードはコンパイルされません。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Unique immutable borrows in captures</span>ユニークな不変のキャプチャでの借用</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Captures can occur by a special kind of borrow called a <s>unique immutable borrow</s> , which cannot be used anywhere else in the language and cannot be written out explicitly.</span>キャプチャは、言語の他の場所では使用できず、明示的に書き出すことができない<s>独自の不変の</s>借用と呼ばれる特別な種類の借用によって行われます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It occurs when modifying the referent of a mutable reference, as in the following example:</span>次の例のように、可変参照の参照先を変更するときに発生します。</span> </p><br><div data-lang=rust><div data-l="let mut b = false;"></div><div data-l="let x = &amp;mut b;"></div><div data-l={></div><div data-l="    let mut c = || { *x = true; };"></div><div data-l="#    // The following line is an error:"></div><div data-l="#    // let y = &amp;x;"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The following line is an error: let y = &amp;x;</span>次の行はエラーです。let y =＆x;</span> </div><div data-l="    c();"></div><div data-l=}></div><div data-l="let z = &amp;x;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this case, borrowing <code>x</code> mutably is not possible, because <code>x</code> is not <code>mut</code> .</span>この場合、 <code>x</code>は<code>mut</code>はないため、 <code>x</code>可変的に借用することはできません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But at the same time, borrowing <code>x</code> immutably would make the assignment illegal, because a <code>&amp; &amp;mut</code> reference may not be unique, so it cannot safely be used to modify a value.</span>しかし、同時に<code>&amp; &amp;mut</code> <code>x</code> <code>&amp; &amp;mut</code>リファレンスは一意ではない可能性があるので、 <code>x</code>無条件に借用すると、割り当てが不正になるので、値を変更するために安全に使用することはできません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So a unique immutable borrow is used: it borrows <code>x</code> immutably, but like a mutable borrow, it must be unique.</span>したがって、一意の不変の借用が使用されます<code>x</code>は不変に借りますが、変更可能な借用のように、それは一意でなければなりません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In the above example, uncommenting the declaration of <code>y</code> will produce an error because it would violate the uniqueness of the closure&#39;s borrow of <code>x</code> ;</span>上記の例では、 <code>y</code>の宣言のコメントを解除すると、 <code>x</code>クロージャの借用の一意性に違反するため、エラーが生成されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">the declaration of z is valid because the closure&#39;s lifetime has expired at the end of the block, releasing the borrow.</span>ブロックの終わりにクロージャーの存続期間が切れて、借用を解放するので、zの宣言は有効です。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Call traits and coercions</span>コール特性と強制</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Closure types all implement <a class=notranslate href="#4`FnOnce`">`FnOnce`</a> , indicating that they can be called once by consuming ownership of the closure.</span> Closure型はすべて<a class=notranslate href="#4`FnOnce`">`FnOnce`</a>実装して<a class=notranslate href="#4`FnOnce`">`FnOnce`</a> 、Closureの所有権を消費することで一度呼び出すことができることを示しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Additionally, some closures implement more specific call traits:</span>さらに、クロージャによっては、より具体的なコール特性を実装するものもあります。</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A closure which does not move out of any captured variables implements <a class=notranslate href="#4`FnMut`">`FnMut`</a> , indicating that it can be called by mutable reference.</span>キャプチャされた変数から移動しないクロージャは、 <a class=notranslate href="#4`FnMut`">`FnMut`</a>実装しています。これは、可変参照によって呼び出すことができることを示しています。</span> </div><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A closure which does not mutate or move out of any captured variables implements <a class=notranslate href="#4`Fn`">`Fn`</a> , indicating that it can be called by shared reference.</span>キャプチャされた変数から変化したり移動したりしないクロージャは、共有参照によって呼び出すことができることを示す<a class=notranslate href="#4`Fn`">`Fn`</a>実装します。</span> </div><br><blockquote><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note: <code>move</code> closures may still implement <a class=notranslate href="#4`Fn`">`Fn`</a> or <a class=notranslate href="#4`FnMut`">`FnMut`</a> , even though they capture variables by move.</span>注意： <code>move</code>クロージャは、移動によって変数を取得しても、 <a class=notranslate href="#4`Fn`">`Fn`</a>または<a class=notranslate href="#4`FnMut`">`FnMut`</a>実装することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is because the traits implemented by a closure type are determined by what the closure does with captured values, not how it captures them.</span>これは、クロージャータイプによって実装された特性は、クロージャーがキャプチャされた値によってどのように処理されるかによって決定され、キャプチャの方法では決まらないからです。</span> </p></blockquote><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><i>Non-capturing closures</i> are closures that don&#39;t capture anything from their environment.</span> <i>非キャプチャクロージャ</i>は、環境から何もキャプチャしないクロージャです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">They can be coerced to function pointers ( <code>fn</code> ) with the matching signature.</span>一致するシグニチャを使用してポインター（ <code>fn</code> ）を機能させるように強制できます。</span> </p><br><div data-lang=rust><div data-l="let add = |x, y| x + y;"></div><div data-l=""></div><div data-l="let mut x = add(5,7);"></div><div data-l=""></div><div data-l="type Binop = fn(i32, i32) -&gt; i32;"></div><div data-l="let bo: Binop = add;"></div><div data-l="x = bo(5,7);"></div></div><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Other traits</span>その他の特色</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">All closure types implement <a class=notranslate href="#4`Sized`">`Sized`</a> .</span>すべてのクロージャタイプは<a class=notranslate href="#4`Sized`">`Sized`</a>実装しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Additionally, closure types implement the following traits if allowed to do so by the types of the captures it stores:</span>さらに、格納されているキャプチャの種類によって許可されている場合、クロージャ型は次の特性を実装します。</span> </p><br><div data-b=*> <a class=notranslate href="#4`Clone`">`Clone`</a> </div> <div data-b=*> <a class=notranslate href="#4`Copy`">`Copy`</a> </div> <div data-b=*> <a class=notranslate href="#4`Sync`">`Sync`</a> </div> <div data-b=*> <a class=notranslate href="#4`Send`">`Send`</a> </div> <br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The rules for <a class=notranslate href="#4`Send`">`Send`</a> and <a class=notranslate href="#4`Sync`">`Sync`</a> match those for normal struct types, while <a class=notranslate href="#4`Clone`">`Clone`</a> and <a class=notranslate href="#4`Copy`">`Copy`</a> behave as if <a class=notranslate href=#3derive>derived</a> .</span> <a class=notranslate href="#4`Send`">`Send`</a>と<a class=notranslate href="#4`Sync`">`Sync`</a>のルールは通常のstructタイプのルールと一致し、 <a class=notranslate href="#4`Clone`">`Clone`</a>と<a class=notranslate href="#4`Copy`">`Copy`</a> <a class=notranslate href=#3derive>derived</a>れたかのように動作します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For <a class=notranslate href="#4`Clone`">`Clone`</a> , the order of cloning of the captured variables is left unspecified.</span> <a class=notranslate href="#4`Clone`">`Clone`</a>では、キャプチャされた変数のクローンの順序は不定のままです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because captures are often by reference, the following general rules arise:</span>キャプチャはしばしば参考になるため、次の一般的な規則が発生します。</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A closure is <a class=notranslate href="#4`Sync`">`Sync`</a> if all captured variables are <a class=notranslate href="#4`Sync`">`Sync`</a> .</span>キャプチャされたすべての変数が<a class=notranslate href="#4`Sync`">`Sync`</a>場合、クロージャは<a class=notranslate href="#4`Sync`">`Sync`</a>です。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A closure is <a class=notranslate href="#4`Send`">`Send`</a> if all variables captured by non-unique immutable reference are <a class=notranslate href="#4`Sync`">`Sync`</a> , and all values captured by unique immutable or mutable reference, copy, or move are <a class=notranslate href="#4`Send`">`Send`</a> .</span>クロージャは<a class=notranslate href="#4`Send`">`Send`</a>非固有の不変参照によって取り込まれたすべての変数がある場合<a class=notranslate href="#4`Sync`">`Sync`</a> 、ユニークな不変又は可変参照、コピー、または移動によって捕捉すべての値である<a class=notranslate href="#4`Send`">`Send`</a> 。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A closure is <a class=notranslate href="#4`Clone`">`Clone`</a> or <a class=notranslate href="#4`Copy`">`Copy`</a> if it does not capture any values by unique immutable or mutable reference, and if all values it captures by copy or move are <a class=notranslate href="#4`Clone`">`Clone`</a> or <a class=notranslate href="#4`Copy`">`Copy`</a> , respectively.</span>閉鎖はある<a class=notranslate href="#4`Clone`">`Clone`</a>または<a class=notranslate href="#4`Copy`">`Copy`</a>それが独特の不変または可変参照することにより任意の値をキャプチャしていない場合は、コピーまたは移動することによって、それはキャプチャすべての値がある場合は<a class=notranslate href="#4`Clone`">`Clone`</a>または<a class=notranslate href="#4`Copy`">`Copy`</a>それぞれ。</span> </div><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Trait objects</span>特性オブジェクト</span> </h2><br><blockquote><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><b>&lt;sup&gt;Syntax&lt;/sup&gt;</b> <s>TraitObjectType</s> : &amp;nbsp;&amp;nbsp;</span> <b>&lt;sup&gt;構文&lt;/ sup&gt;</b> <s>TraitObjectType</s> ：＆nbsp;＆nbsp;</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>dyn</code> <sup>?</sup></span> <code>dyn</code> <sup>？</sup></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><s>TypeParamBounds</s></span> <s>TypeParamBounds</s></span> </p></blockquote><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A <i>trait object</i> is an opaque value of another type that implements a set of traits.</span> <i>特性オブジェクト</i>は、一連の特性を実装する別のタイプの不透明な値です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The set of traits is made up of an <a class=notranslate href="#4object safe">object safe</a> <i>base trait</i> plus any number of <a class=notranslate href="#4auto traits">auto traits</a> .</span>特性のセットは、 <a class=notranslate href="#4object safe">object safe</a> <i>ベースの特性</i>と任意の数の<a class=notranslate href="#4auto traits">auto traits</a>ます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Trait objects implement the base trait, its auto traits, and any <a class=notranslate href=#4supertraits>supertraits</a> of the base trait.</span> Traitオブジェクトは、基本特性、その自動特性、および基本特性の任意の<a class=notranslate href=#4supertraits>supertraits</a>基準を実装します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Trait objects are written as the optional keyword <code>dyn</code> followed by a set of trait bounds, but with the following restrictions on the trait bounds.</span>特性オブジェクトは、オプションのキーワード<code>dyn</code>それに続く特性境界のセットとして記述されますが、特性境界には以下の制限があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">All traits except the first trait must be auto traits, there may not be more than one lifetime, and opt-out bounds (eg <code>?sized</code> ) are not allowed.</span>最初の形質を除くすべての形質は自動形質でなければならず、複数の生存期間が存在せず、オプトアウト範囲（例えば、 <code>?sized</code> ）は認められない。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Furthermore, paths to traits may be parenthesized.</span>さらに、形質への経路はカッコで囲むことができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, given a trait <code>Trait</code> , the following are all trait objects:</span>たとえば、特性<code>Trait</code>指定すると、以下のすべてが特性オブジェクトです。</span> </p><br><div data-b=*> <code>Trait</code> </div> <div data-b=*> <code>dyn Trait</code> </div> <div data-b=*> <code>dyn Trait + Send</code> </div> <div data-b=*> <code>dyn Trait + Send + Sync</code> </div> <div data-b=*> <code>dyn Trait + &#39;static</code> </div> <div data-b=*> <code>dyn Trait + Send + &#39;static</code> </div> <div data-b=*> <code>dyn Trait +</code> </div> <div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>dyn &#39;static + Trait</code> .</span> <code>dyn &#39;static + Trait</code> 。</span> </div><div data-b=*> <code>dyn (Trait)</code> </div> <br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If the first bound of the trait object is a path that starts with <code>::</code> , then the <code>dyn</code> will be treated as a part of the path.</span>特性オブジェクトの最初の境界が<code>::</code>で始まるパスである場合、 <code>dyn</code>はパスの一部として扱われます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The first path can be put in parenthesis to get around this.</span>これを回避するために、最初のパスを括弧で入れることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As such, if you want a trait object with the trait <code>::your_module::Trait</code> , you should write it as <code>dyn (::your_module::Trait)</code> .</span>そのため、trait <code>::your_module::Trait</code>で形質オブジェクトが必要な場合は、 <code>dyn (::your_module::Trait)</code>記述する必要があります。</span> </p><br><blockquote><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note: For clarity, it is recommended to always use the <code>dyn</code> keyword on your trait objects unless your codebase supports compiling with Rust 1.26 or lower.</span>注意：コードベースがRust 1.26以下のコンパイルをサポートしていない限り、明快にするために、traitオブジェクトに常に<code>dyn</code>キーワードを使用することをお勧めします。</span> </p></blockquote><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Two trait object types alias each other if the base traits alias each other and if the sets of auto traits are the same and the lifetime bounds are the same.</span>基本特性がお互いに別名であり、かつ自動特性の集合が同じであり、生涯の境界が同じである場合、2つの特性オブジェクト型は互いにエイリアスする。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, <code>dyn Trait + Send + UnwindSafe</code> is the same as <code>dyn Trait + Unwindsafe + Send</code> .</span>たとえば、 <code>dyn Trait + Send + UnwindSafe</code>は<code>dyn Trait + Unwindsafe + Send</code>と同じです。</span> </p><br><p><div class=warning></p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">* <b>Warning:</b> * With two trait object types, even when the complete set of traits is the same, if the base traits differ, the type is different.</span> * <b>警告：</b> * 2つの形質オブジェクト型では、完全な形質セットが同じであっても、基本形質が異なる場合、型が異なります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, <code>dyn Send + Sync</code> is a different type from <code>dyn Sync + Send</code> .</span>たとえば、 <code>dyn Send + Sync</code>は<code>dyn Sync + Send</code>とは異なるタイプです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">See <a class=notranslate href="#4issue 33140">issue 33140</a> .</span> <a class=notranslate href="#4issue 33140">issue 33140</a>参照してください。</span> </p><br><p></div></p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Due to the opaqueness of which concrete type the value is of, trait objects are <a class=notranslate href="#4dynamically sized types">dynamically sized types</a> .</span>値がどのような具体的な型であるかの不透明さのため、特性オブジェクトは<a class=notranslate href="#4dynamically sized types">dynamically sized types</a> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Like all <abbr title="動的にサイズを指定する型">DSTs</abbr> , trait objects are used behind some type of pointer;</span>すべての<abbr title="動的にサイズを指定する型">DST</abbr>と同様、特性オブジェクトはある種のポインタの後ろで使用されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">for example <code>&amp;dyn SomeTrait</code> or <code>Box&lt;dyn SomeTrait&gt;</code> .</span>たとえば、 <code>&amp;dyn SomeTrait</code>または<code>Box&lt;dyn SomeTrait&gt;</code> <code>&amp;dyn SomeTrait</code> （ <code>Box&lt;dyn SomeTrait&gt;</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Each instance of a pointer to a trait object includes:</span> traitオブジェクトへのポインタの各インスタンスには、次のものが含まれます。</span> </p><br><div data-b=" -"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">a pointer to an instance of a type <code>T</code> that implements <code>SomeTrait</code></span> <code>SomeTrait</code>を実装する<code>T</code>型のインスタンスへのポインタ</span> </div><div data-b=" -"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">a <s>virtual method table</s> , often just called a <s>vtable</s> , which contains, for each method of <code>SomeTrait</code> and its <a class=notranslate href=#4supertraits>supertraits</a> that <code>T</code> implements, a pointer to <code>T</code> &#39;s implementation (ie a function pointer).</span> <code>SomeTrait</code>各メソッドと<code>T</code>実装する<a class=notranslate href=#4supertraits>supertraits</a> <code>SomeTrait</code> 、 <code>T</code>の実装（つまり、関数ポインタ）へのポインタを含む<s>vtable</s>と呼ばれる<s>仮想メソッドテーブル</s>です。</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The purpose of trait objects is to permit &quot;late binding&quot; of methods.</span>特性オブジェクトの目的は、メソッドの「レイトバインディング」を可能にすることです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Calling a method on a trait object results in virtual dispatch at runtime: that is, a function pointer is loaded from the trait object vtable and invoked indirectly.</span> traitオブジェクトのメソッドを呼び出すと、実行時に仮想ディスパッチが行われます。つまり、関数ポインタがtraitオブジェクトvtableからロードされ、間接的に呼び出されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The actual implementation for each vtable entry can vary on an object-by-object basis.</span>各vtableエントリの実際の実装は、オブジェクトごとに異なる可能性があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">An example of a trait object:</span>形質オブジェクトの例：</span> </p><br><div data-lang=rust><div data-l="trait Printable {"></div><div data-l="    fn stringify(&amp;self) -&gt; String;"></div><div data-l=}></div><div data-l=""></div><div data-l="impl Printable for i32 {"></div><div data-l="    fn stringify(&amp;self) -&gt; String { self.to_string() }"></div><div data-l=}></div><div data-l=""></div><div data-l="fn print(a: Box&lt;dyn Printable&gt;) {"></div><div data-l="    println!(&quot;{}&quot;, a.stringify());"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    print(Box::new(10) as Box&lt;dyn Printable&gt;);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this example, the trait <code>Printable</code> occurs as a trait object in both the type signature of <code>print</code> , and the cast expression in <code>main</code> .</span>この例では、 <code>Printable</code>という特性は、 <code>print</code>の型シグネチャと<code>main</code>キャスト式の両方で、traitオブジェクトとして発生します。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Trait Object Lifetime Bounds</span>特性オブジェクトの寿命</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Since a trait object can contain references, the lifetimes of those references need to be expressed as part of the trait object.</span>特性オブジェクトは参照を含むことができるので、これらの参照の寿命は特性オブジェクトの一部として表現する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This lifetime is written as <code>Trait + &#39;a</code> .</span>この生涯は<code>Trait + &#39;a</code>として書かれ<code>Trait + &#39;a</code>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There are <a class=notranslate href=#4defaults>defaults</a> that allow this lifetime to usually be inferred with a sensible choice.</span>通常、この生涯を賢明な選択で推論することができる<a class=notranslate href=#4defaults>defaults</a>があります。</span> </p><br> <a class=notranslate href=#1lifetime-elision.html#default-trait-object-lifetimes>defaults</a> <br> <h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Type parameters</span>タイプパラメータ</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Within the body of an item that has type parameter declarations, the names of its type parameters are types:</span>型パラメータ宣言を持つ項目の本体内では、型パラメータの名前は型です。</span> </p><br><div data-lang=rust><div data-l="fn to_vec&lt;A: Clone&gt;(xs: &amp;[A]) -&gt; Vec&lt;A&gt; {"></div><div data-l="    if xs.is_empty() {"></div><div data-l="        return vec![];"></div><div data-l="    }"></div><div data-l="    let first: A = xs[0].clone();"></div><div data-l="    let mut rest: Vec&lt;A&gt; = to_vec(&amp;xs[1..]);"></div><div data-l="    rest.insert(0, first);"></div><div data-l="    rest"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here, <code>first</code> has type <code>A</code> , referring to <code>to_vec</code> &#39;s <code>A</code> type parameter;</span>ここでは、 <code>first</code>に<code>to_vec</code>の<code>A</code>型パラメータを参照する型<code>A</code>あります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">and <code>rest</code> has type <code>Vec&lt;A&gt;</code> , a vector with element type <code>A</code> .</span> <code>rest</code>は要素型<code>A</code>ベクトルである<code>Vec&lt;A&gt;</code>型があります。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Anonymous type parameters</span>匿名型のパラメータ</span> </h2><br><blockquote><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note: This section is a placeholder for more comprehensive reference material.</span>注：このセクションは、より包括的なリファレンス資料のプレースホルダーです。</span> </p></blockquote><br><blockquote><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note: This is often called &quot;impl Trait in argument position&quot;.</span>注：これはしばしば「引数位置のimpl Trait」と呼ばれます。</span> </p></blockquote><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Functions can declare an argument to be an anonymous type parameter where the callee must provide a type that has the bounds declared by the anonymous type parameter and the function can only use the methods available by the trait bounds of the anonymous type parameter.</span>関数は、匿名型パラメータである引数を宣言することができ、匿名型パラメータによって宣言された境界を持つ型を呼び出し元が提供しなければならず、関数は匿名型パラメータの特性境界によって使用可能なメソッドのみを使用できます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">They are written as <code>impl</code> followed by a set of trait bounds.</span>彼らは次のように書かれている<code>impl</code>形質境界のセットが続きます。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Abstract return types</span>抽象型の戻り値の型</span> </h2><br><blockquote><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note: This section is a placeholder for more comprehensive reference material.</span>注：このセクションは、より包括的なリファレンス資料のプレースホルダーです。</span> </p></blockquote><br><blockquote><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note: This is often called &quot;impl Trait in return position&quot;.</span>注：これは、しばしば &quot;戻り位置でのインプット特性&quot;と呼ばれます。</span> </p></blockquote><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Functions, except for associated trait functions, can return an abstract return type.</span>関連する特性関数を除く関数は、抽象型の戻り値を返すことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These types stand in for another concrete type where the use-site may only use the trait methods declared by the trait bounds of the type.</span>これらの型は、使用サイトがその型の特性境界によって宣言された形質メソッドのみを使用することができる別の具体的な型のために存在します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">They are written as <code>impl</code> followed by a set of trait bounds.</span>彼らは次のように書かれている<code>impl</code>形質境界のセットが続きます。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Self types</span>セルフタイプ</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The special type <code>Self</code> has a meaning within traits and implementations: it refers to the implementing type.</span>特殊型の<code>Self</code>は、特性や実装の中で意味を持ちます。実装型を指します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, in:</span>たとえば、次のようになります。</span> </p><br><div data-lang=rust><div data-l="pub trait From&lt;T&gt; {"></div><div data-l="    fn from(T) -&gt; Self;"></div><div data-l=}></div><div data-l=""></div><div data-l="impl From&lt;i32&gt; for String {"></div><div data-l="    fn from(x: i32) -&gt; Self {"></div><div data-l="        x.to_string()"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The notation <code>Self</code> in the impl refers to the implementing type: <code>String</code> .</span>表記<code>Self</code> ：IMPLでは、実装タイプを意味する<code>String</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In another example:</span>別の例では：</span> </p><br><div data-lang=rust><div data-l="trait Printable {"></div><div data-l="    fn make_string(&amp;self) -&gt; String;"></div><div data-l=}></div><div data-l=""></div><div data-l="impl Printable for String {"></div><div data-l="    fn make_string(&amp;self) -&gt; String {"></div><div data-l="        (*self).clone()"></div><div data-l="    }"></div><div data-l=}></div></div><br><blockquote><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note: The notation <code>&amp;self</code> is a shorthand for <code>self: &amp;Self</code> .</span>注記： <code>&amp;self</code>という表記は、 <code>self: &amp;Self</code>略語です。</span> </p></blockquote><br> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a class=notranslate href=#1../std/ops/trait.Fn.html>`Fn`</a> <a class=notranslate href=#1../std/ops/trait.FnMut.html>`FnMut`</a> <a class=notranslate href=#1../std/ops/trait.FnOnce.html>`FnOnce`</a> <a class=notranslate href=#1special-types-and-traits.html#copy>`Copy`</a> <a class=notranslate href=#1special-types-and-traits.html#clone>`Clone`</a> <a class=notranslate href=#1special-types-and-traits.html#send>`Send`</a> <a class=notranslate href=#1special-types-and-traits.html#sync>`Sync`</a> <a class=notranslate href=#1special-types-and-traits.html#sized>`Sized`</a> <a class=notranslate href=#1attributes.html#derive>derive</a> <a class=notranslate href=#1../std/vec/struct.Vec.html>`Vec&lt;T&gt;`</a> <a class=notranslate href=#1dynamically-sized-types.html>dynamically sized type</a> <a class=notranslate href=#1dynamically-sized-types.html>dynamically sized types</a> <a class=notranslate href=#1expressions/struct-expr.html>struct expression</a> <a class=notranslate href=#1expressions/closure-expr.html>closure expression</a> <a class=notranslate href=#1special-types-and-traits.html#auto-traits>auto traits</a> <a class=notranslate href=#1items/traits.html#object-safety>object safe</a> <a class=notranslate href=#1https://github.com/rust-lang/rust/issues/47010>issue 47010</a> <a class=notranslate href=#1https://github.com/rust-lang/rust/issues/33140>issue 33140</a> <a class=notranslate href=#1paths.html>_PATH_</a> <a class=notranslate href=#1tokens.html#lifetimes-and-loop-labels>_LIFETIME_OR_LABEL_</a> <a class=notranslate href=#1items/traits.html#supertraits>supertraits</a></span> <a class=notranslate href=#1../std/ops/trait.Fn.html>`Fn`</a> <a class=notranslate href=#1../std/ops/trait.FnMut.html>`FnMut`</a> <a class=notranslate href=#1../std/ops/trait.FnOnce.html>`FnOnce`</a> <a class=notranslate href=#1special-types-and-traits.html#copy>`Copy`</a> <a class=notranslate href=#1special-types-and-traits.html#clone>`Clone`</a> <a class=notranslate href=#1special-types-and-traits.html#send>`Send`</a> <a class=notranslate href=#1special-types-and-traits.html#sync>`Sync`</a> <a class=notranslate href=#1special-types-and-traits.html#sized>`Sized`</a> <a class=notranslate href=#1attributes.html#derive>derive</a> <a class=notranslate href=#1../std/vec/struct.Vec.html>`Vec&lt;T&gt;`</a> <a class=notranslate href=#1dynamically-sized-types.html>dynamically sized type</a> <a class=notranslate href=#1dynamically-sized-types.html>dynamically sized types</a> <a class=notranslate href=#1expressions/struct-expr.html>struct expression</a> <a class=notranslate href=#1expressions/closure-expr.html>closure expression</a> <a class=notranslate href=#1special-types-and-traits.html#auto-traits>auto traits</a> <a class=notranslate href=#1items/traits.html#object-safety>object safe</a> <a class=notranslate href=#1https://github.com/rust-lang/rust/issues/47010>issue 47010</a> <a class=notranslate href=#1https://github.com/rust-lang/rust/issues/33140>issue 33140</a> <a class=notranslate href=#1paths.html>_PATH_</a> <a class=notranslate href=#1tokens.html#lifetimes-and-loop-labels>_LIFETIME_OR_LABEL_</a> <a class=notranslate href=#1items/traits.html#supertraits>supertraits</a></span><script>_addload(function(){_setupIW('com');_csi('en','ja','types.html');});</script>