<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180723_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=type-coercions.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Type coercions</span>型変換</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Coercions are defined in <a class=notranslate href="#4RFC 401">RFC 401</a> .</span>強制は<a class=notranslate href="#4RFC 401">RFC 401</a>定義されてい<a class=notranslate href="#4RFC 401">RFC 401</a> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a class=notranslate href="#4RFC 1558">RFC 1558</a> then expanded on that.</span> <a class=notranslate href="#4RFC 1558">RFC 1558</a> 、それを拡張しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A coercion is implicit and has no syntax.</span>強制は暗黙であり、構文はありません。</span> </p><br> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a class=notranslate href=#1https://github.com/rust-lang/rfcs/blob/master/text/0401-coercions.md>RFC 401</a> <a class=notranslate href=#1https://github.com/rust-lang/rfcs/blob/master/text/1558-closure-to-fn-coercion.md>RFC 1558</a></span> <a class=notranslate href=#1https://github.com/rust-lang/rfcs/blob/master/text/0401-coercions.md>RFC 401</a> <a class=notranslate href=#1https://github.com/rust-lang/rfcs/blob/master/text/1558-closure-to-fn-coercion.md>RFC 1558</a></span> <br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Coercion sites</span>強制的なサイト</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A coercion can only occur at certain coercion sites in a program;</span>強制は、プログラム内の特定の強制的なサイトでのみ発生する可能性があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">these are typically places where the desired type is explicit or can be derived by propagation from explicit types (without type inference).</span>これらは典型的には、所望の型が明示的であるか、明示型（型推論なし）からの伝播によって派生することができる場所である。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Possible coercion sites are:</span>可能性のある強制的なサイトは次のとおりです。</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>let</code> statements where an explicit type is given.</span>明示的な型が与えられている文を<code>let</code>ます。</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, <code>42</code> is coerced to have type <code>i8</code> in the following:</span>たとえば、 <code>42</code>は次のようにタイプ<code>i8</code>を持つように強制されます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">` <code class=2>rust let _: i8 = 42;</code></span> ` <code class=2>rust let _: i8 = 42;</code></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">`</span> `</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>static</code> and <code>const</code> statements (similar to <code>let</code> statements).</span> <code>static</code>文と<code>const</code>文（ <code>let</code>文に似ています）。</span> </div><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Arguments for function calls</span>関数呼び出しの引数</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The value being coerced is the actual parameter, and it is coerced to the type of the formal parameter.</span>強制される値は実際のパラメータであり、仮パラメータの型に変換されます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, <code>42</code> is coerced to have type <code>i8</code> in the following:</span>たとえば、 <code>42</code>は次のようにタイプ<code>i8</code>を持つように強制されます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">` <code class=2>rust fn bar(_: i8) { } fn main() { bar(42); }</code></span> ` <code class=2>rust fn bar(_: i8) { } fn main() { bar(42); }</code></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code class=2>rust fn bar(_: i8) { } fn main() { bar(42); }</code> `</span> <code class=2>rust fn bar(_: i8) { } fn main() { bar(42); }</code> `</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For method calls, the receiver ( <code>self</code> parameter) can only take advantage of <a href=#2#unsized-coercions>unsized coercions</a> .</span>メソッド呼び出しの場合、受信側（ <code>self</code>パラメータ）は<a href=#2#unsized-coercions>unsized型変換</a>のみを利用できます。</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Instantiations of struct or variant fields</span> structまたはvariantフィールドのインスタンス化</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, <code>42</code> is coerced to have type <code>i8</code> in the following:</span>たとえば、 <code>42</code>は次のようにタイプ<code>i8</code>を持つように強制されます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">` <code class=2>rust struct Foo { x: i8 } fn main() { Foo { x: 42 }; }</code></span> ` <code class=2>rust struct Foo { x: i8 } fn main() { Foo { x: 42 }; }</code></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code class=2>rust struct Foo { x: i8 } fn main() { Foo { x: 42 }; }</code> `</span> <code class=2>rust struct Foo { x: i8 } fn main() { Foo { x: 42 }; }</code> `</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Function results, either the final line of a block if it is not semicolon-terminated or any expression in a <code>return</code> statement</span>関数の結果。セミコロンで終了していないブロックの最終行または<code>return</code>文の式のいずれか</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, <code>42</code> is coerced to have type <code>i8</code> in the following:</span>たとえば、 <code>42</code>は次のようにタイプ<code>i8</code>を持つように強制されます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">` <code class=2>rust fn foo() -&gt; i8 { 42 }</code> `</span> ` <code class=2>rust fn foo() -&gt; i8 { 42 }</code> `</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If the expression in one of these coercion sites is a coercion-propagating expression, then the relevant sub-expressions in that expression are also coercion sites.</span>これらの強制変換サイトの1つの式が強制変換式である場合、その式の関連するサブ式も強制変換サイトです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Propagation recurses from these new coercion sites.</span>伝播は、これらの新しい強制的なサイトから繰り返されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Propagating expressions and their relevant sub-expressions are:</span>式とその関連するサブ式の伝播は次のとおりです。</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Array literals, where the array has type <code>[U; n]</code></span>配列リテラル<code>[U; n]</code>配列の型は<code>[U; n]</code></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>[U; n]</code> .</span> <code>[U; n]</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Each sub-expression in</span>各サブ式は</span> </div><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">the array literal is a coercion site for coercion to type <code>U</code> .</span>配列リテラルは型<code>U</code>への強制変換の強制サイトです。</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Array literals with repeating syntax, where the array has type <code>[U; n]</code></span>繰り返しの構文を持つ配列リテラル<code>[U; n]</code>配列の型は<code>[U; n]</code></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>[U; n]</code> .</span> <code>[U; n]</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The</span>ザ</span> </div><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">repeated sub-expression is a coercion site for coercion to type <code>U</code> .</span>反復された部分式は、 <code>U</code>型への強制変換のための強制変換サイトです。</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Tuples, where a tuple is a coercion site to type <code>(U_0, U_1, ..., U_n)</code> .</span>タプルは、タプルがタイプする強制サイトです<code>(U_0, U_1, ..., U_n)</code> 。</span> </div><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Each sub-expression is a coercion site to the respective type, eg the zeroth sub-expression is a coercion site to type <code>U_0</code> .</span>各部分式は、それぞれの型への強制的なサイトです。たとえば、0番目の部分式は、 <code>U_0</code>と入力する強制サイト<code>U_0</code> 。</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Parenthesized sub-expressions ( <code>(e)</code> ): if the expression has type <code>U</code> , then</span>括弧で囲まれた部分式（ <code>(e)</code> ）：式が<code>U</code>型の場合、</span> </div><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">the sub-expression is a coercion site to <code>U</code> .</span>サブ式は<code>U</code>への強制的なサイトです。</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Blocks: if a block has type <code>U</code> , then the last expression in the block (if</span>ブロック：ブロックにタイプ<code>U</code>がある場合、ブロックの最後の式（if</span> </div><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">it is not semicolon-terminated) is a coercion site to <code>U</code> .</span>それはセミコロンで終わらない）は<code>U</code>への強制的なサイトです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This includes blocks which are part of control flow statements, such as <code>if</code> / <code>else</code> , if the block has a known type.</span>これには、ブロックが既知の型を持つかどう<code>if</code>など、 <code>if</code> / <code>else</code>などの制御フロー文の一部であるブロックが含まれます。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Coercion types</span>強制型</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Coercion is allowed between the following types:</span>以下のタイプの間で強制が許されます：</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>T</code> to <code>U</code> if <code>T</code> is a subtype of <code>U</code> ( <i>reflexive case</i> )</span> <code>T</code>が<code>U</code>のサブタイプであれば<code>T</code>から<code>U</code> （ <i>反射的ケース</i> ）</span> </div><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>T_1</code> to <code>T_3</code> where <code>T_1</code> coerces to <code>T_2</code> and <code>T_2</code> coerces to <code>T_3</code></span> <code>T_1</code>へ<code>T_3</code> <code>T_1</code>に強制変換<code>T_2</code>と<code>T_2</code>に強制し<code>T_3</code></span> </div><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">( <i>transitive case</i> )</span> （ <i>推移的なケース</i> ）</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that this is not fully supported yet</span>これは完全にサポートされていないことに注意してください</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>&amp;mut T</code> to <code>&amp;T</code></span> <code>&amp;mut T</code>から<code>&amp;T</code>への<code>&amp;mut T</code></span> </div><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>*mut T</code> to <code>*const T</code></span> <code>*mut T</code>から<code>*const T</code></span> </div><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>&amp;T</code> to <code>*const T</code></span> <code>&amp;T</code>から<code>*const T</code></span> </div><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>&amp;mut T</code> to <code>*mut T</code></span> <code>&amp;mut T</code>から<code>*mut T</code></span> </div><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>&amp;T</code> or <code>&amp;mut T</code> to <code>&amp;U</code> if <code>T</code> implements <code>Deref&lt;Target = U&gt;</code> .</span> <code>&amp;T</code>または<code>&amp;mut T</code>に<code>&amp;U</code>場合は<code>T</code>実装<code>Deref&lt;Target = U&gt;</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example:</span>例えば：</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">` <code class=2>rust use std::ops::Deref; struct CharContainer { value: char, } impl Deref for CharContainer { type Target = char; fn deref&lt;&#39;a&gt;(&amp;&#39;a self) -&gt; &amp;&#39;a char { &amp;self.value } } fn foo(arg: &amp;char) {} fn main() { let x = &amp;mut CharContainer { value: &#39;y&#39; }; foo(x); //&amp;mut CharContainer is coerced to &amp;char. }</code></span> ` <code class=2>rust use std::ops::Deref; struct CharContainer { value: char, } impl Deref for CharContainer { type Target = char; fn deref&lt;&#39;a&gt;(&amp;&#39;a self) -&gt; &amp;&#39;a char { &amp;self.value } } fn foo(arg: &amp;char) {} fn main() { let x = &amp;mut CharContainer { value: &#39;y&#39; }; foo(x); //&amp;mut CharContainer is coerced to &amp;char. }</code></span> <code class=2>rust use std::ops::Deref; struct CharContainer { value: char, } impl Deref for CharContainer { type Target = char; fn deref&lt;&#39;a&gt;(&amp;&#39;a self) -&gt; &amp;&#39;a char { &amp;self.value } } fn foo(arg: &amp;char) {} fn main() { let x = &amp;mut CharContainer { value: &#39;y&#39; }; foo(x); //&amp;mut CharContainer is coerced to &amp;char. }</code> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code class=2>rust use std::ops::Deref; struct CharContainer { value: char, } impl Deref for CharContainer { type Target = char; fn deref&lt;&#39;a&gt;(&amp;&#39;a self) -&gt; &amp;&#39;a char { &amp;self.value } } fn foo(arg: &amp;char) {} fn main() { let x = &amp;mut CharContainer { value: &#39;y&#39; }; foo(x); //&amp;mut CharContainer is coerced to &amp;char. }</code> `</span> <code class=2>rust use std::ops::Deref; struct CharContainer { value: char, } impl Deref for CharContainer { type Target = char; fn deref&lt;&#39;a&gt;(&amp;&#39;a self) -&gt; &amp;&#39;a char { &amp;self.value } } fn foo(arg: &amp;char) {} fn main() { let x = &amp;mut CharContainer { value: &#39;y&#39; }; foo(x); //&amp;mut CharContainer is coerced to &amp;char. }</code> `</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>&amp;mut T</code> to <code>&amp;mut U</code> if <code>T</code> implements <code>DerefMut&lt;Target = U&gt;</code> .</span> <code>&amp;mut T</code>する<code>&amp;mut U</code>場合は<code>T</code>実装<code>DerefMut&lt;Target = U&gt;</code> 。</span> </div><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">TyCtor( <code>T</code> ) to TyCtor( <code>U</code> ), where TyCtor( <code>T</code> ) is one of</span> TyCtor（ <code>T</code> ）をTyCtor（ <code>U</code> ）に変換する。ここで、TyCtor（ <code>T</code> ）は</span> </div><div data-b="    -"> <code>&amp;T</code> </div> <div data-b="    -"> <code>&amp;mut T</code> </div> <div data-b="    -"> <code>*const T</code> </div> <div data-b="    -"> <code>*mut T</code> </div> <div data-b="    -"> <code>Box&lt;T&gt;</code> </div> <br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">and where <code>T</code> can obtained from <code>U</code> by <a href=#2#unsized-coercions>unsized coercion</a> .</span>ここで、 <code>T</code>は<a href=#2#unsized-coercions>小文字の強制</a>によって<code>U</code>から得られる。</span> </p><br><p><!--In the future, coerce_inner will be recursively extended to tuples and
    structs. In addition, coercions from sub-traits to super-traits will be
    added. See [RFC 401] for more details.--></p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Non capturing closures to <code>fn</code> pointers</span> <code>fn</code>ポインタへの非キャプチャクロージャ</span> </div><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>€</code> to any <code>T</code></span> <code>€</code>から任意の<code>T</code></span> </div><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Unsized Coercions</span>サイズのない強制</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The following coercions are called <code>unsized coercions</code> , since they relate to converting sized types to unsized types, and are permitted in a few cases where other coercions are not, as described above.</span>以下の型変換が呼び出される<code>unsized coercions</code>それらは無サイズの型にサイズタイプの変換に関係するので、上述したように、他の強制はされないいくつかのケースで許可されています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">They can still happen anywhere else a coercion can occur.</span>彼らは強制的に起こりうる他のどこでも起こり得る。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Two traits, <a class=notranslate href="#4`Unsize`">`Unsize`</a> and <a class=notranslate href="#4`CoerceUnsized`">`CoerceUnsized`</a> , are used to assist in this process and expose it for library use.</span>二つの特性、 <a class=notranslate href="#4`Unsize`">`Unsize`</a>と<a class=notranslate href="#4`CoerceUnsized`">`CoerceUnsized`</a> 、このプロセスを支援し、ライブラリを使用する際に、それを公開するために使用されています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The compiler following coercions are built-in and, if <code>T</code> can be coerced to <code>U</code> with one of the, then the compiler will provide an implementation of <code>Unsize&lt;U&gt;</code> for <code>T</code> :</span>変換後のコンパイラが組み込まれていて、 <code>T</code>を<code>U</code> 1つで強制的に<code>U</code>変換できる場合、コンパイラは<code>Unsize&lt;U&gt;</code>の<code>T</code>実装を提供します。</span> </p><br><div data-b=*> <code>[T; n]</code> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>[T; n]</code> to <code>[T]</code> .</span> <code>[T; n]</code>を<code>[T]</code> 。</span> </div><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>T</code> to <code>U</code> , when <code>U</code> is a trait object type and either <code>T</code> implements <code>U</code> or <code>T</code> is a trait object for a subtrait of <code>U</code> .</span> <code>T</code>から<code>U</code>まで、 <code>U</code>が形質オブジェクトタイプであり、 <code>T</code>が<code>U</code>または<code>T</code>実装する場合は、 <code>U</code>サブトラクトの形質オブジェクトである。</span> </div><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>Foo&lt;..., T, ...&gt;</code> to <code>Foo&lt;..., U, ...&gt;</code> , when:</span> <code>Foo&lt;..., T, ...&gt;</code>を<code>Foo&lt;..., U, ...&gt;</code> 、</span> </div><div data-b="    *"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>Foo</code> is a struct.</span> <code>Foo</code>は構造体です。</span> </div><div data-b="    *"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>T</code> implements <code>Unsize&lt;U&gt;</code> .</span> <code>T</code>は<code>Unsize&lt;U&gt;</code>実装します。</span> </div><div data-b="    *"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The last field of <code>Foo</code> has a type involving <code>T</code> .</span> <code>Foo</code>の最後のフィールドには<code>T</code>含む型があります。</span> </div><div data-b="    *"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If that field has type <code>Bar&lt;T&gt;</code> , then <code>Bar&lt;T&gt;</code> implements <code>Unsized&lt;Bar&lt;U&gt;&gt;</code> .</span>そのフィールドが<code>Bar&lt;T&gt;</code>型の場合、 <code>Bar&lt;T&gt;</code>は<code>Unsized&lt;Bar&lt;U&gt;&gt;</code> <code>Bar&lt;T&gt;</code>実装し<code>Unsized&lt;Bar&lt;U&gt;&gt;</code> 。</span> </div><div data-b="    *"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">T is not part of the type of any other fields.</span> Tは、他のフィールドの型の一部ではありません。</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Additionally, a type <code>Foo&lt;T&gt;</code> can implement <code>CoerceUnsized&lt;Foo&lt;U&gt;&gt;</code> when <code>T</code> implements <code>Unsize&lt;U&gt;</code> or <code>CoerceUnsized&lt;Foo&lt;U&gt;&gt;</code> .</span>また、タイプ<code>Foo&lt;T&gt;</code>を実装することができる<code>CoerceUnsized&lt;Foo&lt;U&gt;&gt;</code>とき<code>T</code>実装<code>Unsize&lt;U&gt;</code>または<code>CoerceUnsized&lt;Foo&lt;U&gt;&gt;</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This allows it to provide a unsized coercion to <code>Foo&lt;U&gt;</code> .</span>これにより、 <code>Foo&lt;U&gt;</code>サイズの小さい強制を提供することができます。</span> </p><br><blockquote><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note: While the definition of the unsized coercions and their implementation has been stabilized, the traits themselves are not yet stable and therefore can&#39;t be used directly in stable Rust.</span>注：サイズの定められていない強制とその実装の定義は安定しているが、特性自体はまだ安定していないため、安定したRustでは直接使用することはできない。</span> </p></blockquote><br> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a class=notranslate href=#1../std/marker/trait.Unsize.html>Unsize</a> <a class=notranslate href=#1../std/ops/trait.CoerceUnsized.html>CoerceUnsized</a></span> <a class=notranslate href=#1../std/marker/trait.Unsize.html>Unsize</a> <a class=notranslate href=#1../std/ops/trait.CoerceUnsized.html>CoerceUnsized</a></span><script>_addload(function(){_setupIW('com');_csi('en','ja','type-coercions.html');});</script>