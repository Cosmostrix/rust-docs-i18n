<!DOCTYPE html>
<h1>Emitting Diagnostics</h1>
<br>
<p>A lot of effort has been put into making <code>rustc</code> have great error messages.
This chapter is about how to emit compile errors and lints from the compiler.</p>
<br>
<h2><code>Span</code></h2>
<br>
<p><a class="notranslate" href="#3span"><code>Span</code></a> is the primary data structure in <code>rustc</code> used to represent a
location in the code being compiled. <code>Span</code>s are attached to most constructs in
HIR and MIR, allowing for more informative error reporting.</p>
<br>
<a class="notranslate" href="#1https://doc.rust-lang.org/nightly/nightly-rustc/syntax/codemap/struct.Span.html">span</a>
<br>
<p>A <code>Span</code> can be looked up in a <a class="notranslate" href="#3codemap"><code>CodeMap</code></a> to get a &quot;snippet&quot; useful
for displaying errors with <a class="notranslate" href="#3sptosnip"><code>span_to_snippet</code></a> and other similar
methods on the <code>CodeMap</code>.</p>
<br>
<a class="notranslate" href="#1https://doc.rust-lang.org/nightly/nightly-rustc/syntax/codemap/struct.CodeMap.html">codemap</a>
<a class="notranslate" href="#1https://doc.rust-lang.org/nightly/nightly-rustc/syntax/codemap/struct.CodeMap.html#method.span_to_snippet">sptosnip</a>
<br>
<h2>Error messages</h2>
<br>
<p>The <a class="notranslate" href="#3errors"><code>rustc_errors</code></a> crate defines most of the utilities used for
reporting errors.</p>
<br>
<a class="notranslate" href="#1https://doc.rust-lang.org/nightly/nightly-rustc/rustc_errors/index.html">errors</a>
<br>
<p><a class="notranslate" href="#3session"><code>Session</code></a> and <a class="notranslate" href="#3parsesses"><code>ParseSess</code></a> have
methods (or fields with methods) that allow reporting errors. These methods
usually have names like <code>span_err</code> or <code>struct_span_err</code> or <code>span_warn</code>, etc...
There are lots of them; they emit different types of &quot;errors&quot;, such as
warnings, errors, fatal errors, suggestions, etc.</p>
<br>
<a class="notranslate" href="#1https://doc.rust-lang.org/nightly/nightly-rustc/syntax/parse/struct.ParseSess.html">parsesses</a>
<a class="notranslate" href="#1https://doc.rust-lang.org/nightly/nightly-rustc/rustc/session/struct.Session.html">session</a>
<br>
<p>In general, there are two class of such methods: ones that emit an error
directly and ones that allow finer control over what to emit. For example,
<a class="notranslate" href="#3spanerr"><code>span_err</code></a> emits the given error message at the given <code>Span</code>, but
<a class="notranslate" href="#3strspanerr"><code>struct_span_err</code></a> instead returns a
<a class="notranslate" href="#3diagbuild"><code>DiagnosticBuilder</code></a>.</p>
<br>
<p><code>DiagnosticBuilder</code> allows you to add related notes and suggestions to an error
before emitting it by calling the <a class="notranslate" href="#3emit"><code>emit</code></a> method. (Failing to either
emit or <a class="notranslate" href="#3cancel">cancel</a> a <code>DiagnosticBuilder</code> will result in an ICE.) See the
<a class="notranslate" href="#3diagbuild">docs</a> for more info on what you can do.</p>
<br>
<a class="notranslate" href="#1https://doc.rust-lang.org/nightly/nightly-rustc/rustc/session/struct.Session.html#method.span_err">spanerr</a>
<a class="notranslate" href="#1https://doc.rust-lang.org/nightly/nightly-rustc/rustc/session/struct.Session.html#method.struct_span_err">strspanerr</a>
<a class="notranslate" href="#1https://doc.rust-lang.org/nightly/nightly-rustc/rustc_errors/diagnostic_builder/struct.DiagnosticBuilder.html">diagbuild</a>
<a class="notranslate" href="#1https://doc.rust-lang.org/nightly/nightly-rustc/rustc_errors/diagnostic_builder/struct.DiagnosticBuilder.html#method.emit">emit</a>
<a class="notranslate" href="#1https://doc.rust-lang.org/nightly/nightly-rustc/rustc_errors/struct.Diagnostic.html#method.cancel">cancel</a>
<br>
<div data-lang="rust,ignore"><div data-l="#// Get a DiagnosticBuilder. This does _not_ emit an error yet."></div><div data-l="// ">Get a DiagnosticBuilder. This does <s>not</s> emit an error yet.</div><div data-l="let mut err = sess.struct_span_err(sp, &quot;oh no! this is an error!&quot;);"></div><div data-l=""></div><div data-l="#// In some cases, you might need to check if `sp` is generated by a macro to"></div><div data-l="#// avoid printing weird errors about macro-generated code."></div><div data-l="// ">In some cases, you might need to check if <code>sp</code> is generated by a macro to avoid printing weird errors about macro-generated code.</div><div data-l=""></div><div data-l="if let Ok(snippet) = sess.codemap().span_to_snippet(sp) {"></div><div data-l="#    // Use the snippet to generate a suggested fix"></div><div data-l="    // ">Use the snippet to generate a suggested fix</div><div data-l="    err.span_suggestion(suggestion_sp, &quot;try using a qux here&quot;, format!(&quot;qux {}&quot;, snip));"></div><div data-l="} else {"></div><div data-l="#    // If we weren't able to generate a snippet, then emit a &quot;help&quot; message"></div><div data-l="#    // instead of a concrete &quot;suggestion&quot;. In practice this is unlikely to be"></div><div data-l="#    // reached."></div><div data-l="    // ">If we weren't able to generate a snippet, then emit a &quot;help&quot; message instead of a concrete &quot;suggestion&quot;. In practice this is unlikely to be reached.</div><div data-l="    err.span_help(suggestion_sp, &quot;you could use a qux here instead&quot;);"></div><div data-l="}"></div><div data-l=""></div><div data-l="#// emit the error"></div><div data-l="// ">emit the error</div><div data-l="err.emit();"></div></div>
<br>
<h2>Suggestions</h2>
<br>
<p>In addition to telling the user exactly <s>why</s> their code is wrong, it's
oftentimes furthermore possible to tell them how to fix it. To this end,
<code>DiagnosticBuilder</code> offers a structured suggestions API, which formats code
suggestions pleasingly in the terminal, or (when the <code>--error-format json</code> flag
is passed) as JSON for consumption by tools, most notably the <a href="#3rls">Rust Language
Server</a> and <a class="notranslate" href="#3rustfix"><code>rustfix</code></a>.</p>
<br>
<a class="notranslate" href="#1https://github.com/rust-lang-nursery/rls">rls</a>
<a class="notranslate" href="#1https://github.com/rust-lang-nursery/rustfix">rustfix</a>
<br>
<p>Not all suggestions should be applied mechanically. Use the
<a class="notranslate" href="#3sswa"><code>span_suggestion_with_applicability</code></a> method of <code>DiagnosticBuilder</code> to
make a suggestion while providing a hint to tools whether the suggestion is
mechanically applicable or not.</p>
<br>
<a class="notranslate" href="#1https://doc.rust-lang.org/nightly/nightly-rustc/rustc_errors/struct.DiagnosticBuilder.html#method.span_suggestion_with_applicability">sswa</a>
<br>
<p>For example, to make our <code>qux</code> suggestion machine-applicable, we would do:</p>
<br>
<div data-lang="rust,ignore"><div data-l="let mut err = sess.struct_span_err(sp, &quot;oh no! this is an error!&quot;);"></div><div data-l=""></div><div data-l="if let Ok(snippet) = sess.codemap().span_to_snippet(sp) {"></div><div data-l="#    // Add applicability info!"></div><div data-l="    // ">Add applicability info!</div><div data-l="    err.span_suggestion_with_applicability("></div><div data-l="        suggestion_sp,"></div><div data-l="        &quot;try using a qux here&quot;,"></div><div data-l="        format!(&quot;qux {}&quot;, snip),"></div><div data-l="        Applicability::MachineApplicable,"></div><div data-l="    );"></div><div data-l="} else {"></div><div data-l="    err.span_help(suggestion_sp, &quot;you could use a qux here instead&quot;);"></div><div data-l="}"></div><div data-l=""></div><div data-l="err.emit();"></div></div>
<br>
<p>This might emit an error like</p>
<br>
<div data-lang="console"><div data-l="$ rustc mycode.rs"></div><div data-l="error[E0999]: oh no! this is an error!"></div><div data-l=" --&gt; mycode.rs:3:5"></div><div data-l="  |"></div><div data-l="3 |     sad()"></div><div data-l="  |     ^ help: try using a qux here: `qux sad()`"></div><div data-l=""></div><div data-l="error: aborting due to previous error"></div><div data-l=""></div><div data-l="For more information about this error, try `rustc --explain E0999`."></div></div>
<br>
<p>In some cases, like when the suggestion spans multiple lines or when there are
multiple suggestions, the suggestions are displayed on their own:</p>
<br>
<div data-lang="console"><div data-l="error[E0999]: oh no! this is an error!"></div><div data-l=" --&gt; mycode.rs:3:5"></div><div data-l="  |"></div><div data-l="3 |     sad()"></div><div data-l="  |     ^"></div><div data-l="help: try using a qux here:"></div><div data-l="  |"></div><div data-l="3 |     qux sad()"></div><div data-l="  |     ^^^"></div><div data-l=""></div><div data-l="error: aborting due to previous error"></div><div data-l=""></div><div data-l="For more information about this error, try `rustc --explain E0999`."></div></div>
<br>
<p>There are a few other <a class="notranslate" href="#3appl"><code>Applicability</code></a> possibilities:</p>
<br>
<div data-b="-"><code>MachineApplicable</code>: Can be applied mechanically.</div>
<div data-b="-"><code>HasPlaceholders</code>: Cannot be applied mechanically because it has placeholder
text in the suggestions. For example, &quot;Try adding a type: \<code>let x:
  \&lt;type\&gt;\</code>&quot;.</div>
<div data-b="-"><code>MaybeIncorrect</code>: Cannot be applied mechanically because the suggestion may
or may not be a good one.</div>
<div data-b="-"><code>Unspecified</code>: Cannot be applied mechanically because we don't know which
of the above cases it falls into.</div>
<br>
<a class="notranslate" href="#1https://doc.rust-lang.org/nightly/nightly-rustc/rustc_errors/enum.Applicability.html">appl</a>
<br>
<h2>Lints</h2>
<br>
<p>The compiler linting infrastructure is defined in the <a class="notranslate" href="#3rlint"><code>rustc::lint</code></a>
module.</p>
<br>
<a class="notranslate" href="#1https://doc.rust-lang.org/nightly/nightly-rustc/rustc/lint/index.html">rlint</a>
<br>
<h3>Declaring a lint</h3>
<br>
<p>The built-in compiler lints are defined in the <a class="notranslate" href="#3builtin"><code>rustc_lint</code></a>
crate.</p>
<br>
<a class="notranslate" href="#1https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/index.html">builtin</a>
<br>
<p>Each lint is defined as a <code>struct</code> that implements the <code>LintPass</code> <code>trait</code>. The
trait implementation allows you to check certain syntactic constructs the
linter walks the source code. You can then choose to emit lints in a very
similar way to compile errors. Finally, you register the lint to actually get
it to be run by the compiler by using the <code>declare_lint€</code> macro.</p>
<br>
<p>For example, the following lint checks for uses
of <code>while true { ... }</code> and suggests using <code>loop { ... }</code> instead.</p>
<br>
<div data-lang="rust,ignore"><div data-l="#// Declare a lint called `WHILE_TRUE`"></div><div data-l="// ">Declare a lint called <code>WHILE_TRUE</code></div><div data-l="declare_lint! {"></div><div data-l="    WHILE_TRUE,"></div><div data-l=""></div><div data-l="#    // warn-by-default"></div><div data-l="    // ">warn-by-default</div><div data-l="    Warn,"></div><div data-l=""></div><div data-l="#    // This string is the lint description"></div><div data-l="    // ">This string is the lint description</div><div data-l="    &quot;suggest using `loop { }` instead of `while true { }`&quot;"></div><div data-l="}"></div><div data-l=""></div><div data-l="#// Define a struct and `impl LintPass` for it."></div><div data-l="// ">Define a struct and <code>impl LintPass</code> for it.</div><div data-l="#[derive(Copy, Clone)]"></div><div data-l="pub struct WhileTrue;"></div><div data-l=""></div><div data-l="impl LintPass for WhileTrue {"></div><div data-l="    fn get_lints(&amp;self) -&gt; LintArray {"></div><div data-l="        lint_array!(WHILE_TRUE)"></div><div data-l="    }"></div><div data-l="}"></div><div data-l=""></div><div data-l="#// LateLintPass has lots of methods. We only override the definition of"></div><div data-l="#// `check_expr` for this lint because that's all we need, but you could"></div><div data-l="#// override other methods for your own lint. See the rustc docs for a full"></div><div data-l="#// list of methods."></div><div data-l="// ">LateLintPass has lots of methods. We only override the definition of <code>check_expr</code> for this lint because that's all we need, but you could override other methods for your own lint. See the rustc docs for a full list of methods.</div><div data-l="impl&lt;'a, 'tcx&gt; LateLintPass&lt;'a, 'tcx&gt; for WhileTrue {"></div><div data-l="    fn check_expr(&amp;mut self, cx: &amp;LateContext, e: &amp;hir::Expr) {"></div><div data-l="        if let hir::ExprWhile(ref cond, ..) = e.node {"></div><div data-l="            if let hir::ExprLit(ref lit) = cond.node {"></div><div data-l="                if let ast::LitKind::Bool(true) = lit.node {"></div><div data-l="                    if lit.span.ctxt() == SyntaxContext::empty() {"></div><div data-l="                        let msg = &quot;denote infinite loops with `loop { ... }`&quot;;"></div><div data-l="                        let condition_span = cx.tcx.sess.codemap().def_span(e.span);"></div><div data-l="                        let mut err = cx.struct_span_lint(WHILE_TRUE, condition_span, msg);"></div><div data-l="                        err.span_suggestion_short(condition_span, &quot;use `loop`&quot;, &quot;loop&quot;.to_owned());"></div><div data-l="                        err.emit();"></div><div data-l="                    }"></div><div data-l="                }"></div><div data-l="            }"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l="}"></div></div>
<br>
<h3>Edition-gated Lints</h3>
<br>
<p>Sometimes we want to change the behavior of a lint in a new edition. To do this,
we just add the transition to our invocation of <code>declare_lint€</code>:</p>
<br>
<div data-lang="rust,ignore"><div data-l="declare_lint! {"></div><div data-l="    pub ANONYMOUS_PARAMETERS,"></div><div data-l="    Allow,"></div><div data-l="    &quot;detects anonymous parameters&quot;,"></div><div data-l="    Edition::Edition2018 =&gt; Warn,"></div><div data-l="}"></div></div>
<br>
<p>This makes the <code>ANONYMOUS_PARAMETERS</code> lint allow-by-default in the 2015 edition
but warn-by-default in the 2018 edition.</p>
<br>
<p>Lints that represent an incompatibility (i.e. error) in the upcoming edition
should also be registered as <code>FutureIncompatibilityLint</code>s in
<a class="notranslate" href="#3rbuiltins"><code>register_builtins</code></a> function in <a class="notranslate" href="#3builtin"><code>rustc_lint::lib</code></a>.</p>
<br>
<h3>Lint Groups</h3>
<br>
<p>Lints can be turned on in groups. These groups are declared in the
<a class="notranslate" href="#3rbuiltins"><code>register_builtins</code></a> function in <a class="notranslate" href="#3builtin"><code>rustc_lint::lib</code></a>. The
<code>add_lint_group€</code> macro is used to declare a new group.</p>
<br>
<a class="notranslate" href="#1https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/fn.register_builtins.html">rbuiltins</a>
<br>
<p>For example,</p>
<br>
<div data-lang="rust,ignore"><div data-l="    add_lint_group!(sess,"></div><div data-l="                    &quot;nonstandard_style&quot;,"></div><div data-l="                    NON_CAMEL_CASE_TYPES,"></div><div data-l="                    NON_SNAKE_CASE,"></div><div data-l="                    NON_UPPER_CASE_GLOBALS);"></div></div>
<br>
<p>This defines the <code>nonstandard_style</code> group which turns on the listed lints. A
user can turn on these lints with a <code>€#[warn(nonstandard_style)]</code> attribute in
the source code, or by passing <code>-W nonstandard-style</code> on the command line.</p>
<br>
<h3>Linting early in the compiler</h3>
<br>
<p>On occasion, you may need to define a lint that runs before the linting system
has been initialized (e.g. during parsing or macro expansion). This is
problematic because we need to have computed lint levels to know whether we
should emit a warning or an error or nothing at all.</p>
<br>
<p>To solve this problem, we buffer the lints until the linting system is
processed. <a class="notranslate" href="#3sessbl"><code>Session</code></a> and <a class="notranslate" href="#3parsebl"><code>ParseSess</code></a> both have
<code>buffer_lint</code> methods that allow you to buffer a lint for later. The linting
system automatically takes care of handling buffered lints later.</p>
<br>
<a class="notranslate" href="#1https://doc.rust-lang.org/nightly/nightly-rustc/rustc/session/struct.Session.html#method.buffer_lint">sessbl</a>
<a class="notranslate" href="#1https://doc.rust-lang.org/nightly/nightly-rustc/syntax/parse/struct.ParseSess.html#method.buffer_lint">parsebl</a>
<br>
<p>Thus, to define a lint that runs early in the compilation, one defines a lint
like normal but invokes the lint with <code>buffer_lint</code>.</p>
<br>
<h4>Linting even earlier in the compiler</h4>
<br>
<p>The parser (<code>libsyntax</code>) is interesting in that it cannot have dependencies on
any of the other <code>librustc*</code> crates. In particular, it cannot depend on
<code>librustc::lint</code> or <code>librustc_lint</code>, where all of the compiler linting
infrastructure is defined. That's troublesome!</p>
<br>
<p>To solve this, <code>libsyntax</code> defines its own buffered lint type, which
<code>ParseSess::buffer_lint</code> uses. After macro expansion, these buffered lints are
then dumped into the <code>Session::buffered_lints</code> used by the rest of the compiler.</p>
<br>
<p>Usage for buffered lints in <code>libsyntax</code> is pretty much the same as the rest of
the compiler with one exception because we cannot import the <code>LintId</code>s for
lints we want to emit. Instead, the <a class="notranslate" href="#4`BufferedEarlyLintId`">`BufferedEarlyLintId`</a> type is used. If you
are defining a new lint, you will want to add an entry to this enum. Then, add
an appropriate mapping to the body of <a class="notranslate" href="#3fplid"><code>Lint::from_parser_lint_id</code></a>.</p>
<br>
<a class="notranslate" href="#1https://doc.rust-lang.org/nightly/nightly-rustc/syntax/early_buffered_lints/struct.BufferedEarlyLintId.html">`BufferedEarlyLintId`</a>
<a class="notranslate" href="#1https://doc.rust-lang.org/nightly/nightly-rustc/rustc/lint/struct.Lint.html#from_parser_lint_id">fplid</a>