<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180723_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=stupid-stats.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Appendix A: A tutorial on creating a drop-in replacement for rustc</span>付録A：rustcのドロップイン置換の作成に関するチュートリアル</span> </h1><br><blockquote><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><b>Note:</b> This is a copy of <code>@nrc</code> &#39;s amazing <a class=notranslate href=#4stupid-stats>stupid-stats</a> .</span> <b>注：</b>これは<code>@nrc</code>の素晴らしい<a class=notranslate href=#4stupid-stats>stupid-stats</a>のコピーです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You should find a copy of the code on the GitHub repository although due to the compiler&#39;s constantly evolving nature, there is no guarantee it&#39;ll compile on the first go.</span> GitHubリポジトリにコードのコピーがあるはずですが、コンパイラが常に進化している性質のため、最初にコンパイルする保証はありません。</span> </p></blockquote><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Many tools benefit from being a drop-in replacement for a compiler.</span>多くのツールは、コンパイラの代わりに使用できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">By this, I mean that any user of the tool can use <code>mytool</code> in all the ways they would normally use <code>rustc</code> - whether manually compiling a single file or as part of a complex make project or Cargo build, etc. That could be a lot of work;</span>これにより、ツールのどのユーザーも、手動で単一のファイルをコンパイルするか、複雑なmakeプロジェクトやCargoビルドの一部として、通常<code>rustc</code>使用するすべての方法で<code>mytool</code>を使用できることを意味します。作業;</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">rustc, like most compilers, takes a large number of command line arguments which can affect compilation in complex and interacting ways.</span> rustcは、ほとんどのコンパイラと同様に、複雑で相互作用的な方法でコンパイルに影響するコマンドライン引数を多数取ります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Emulating all of this behaviour in your tool is annoying at best, especically if you are making many of the same calls into librustc that the compiler is.</span>あなたのツールでこのような動作をすべてエミュレートするのは、せいぜい厄介なことです。特に、コンパイラと同じ呼び出しを多数作成している場合は特にそうです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The kind of things I have in mind are tools like rustdoc or a future rustfmt.</span>私が念頭に置いているのは、rustdocやfuture rustfmtのようなツールです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These want to operate as closely as possible to real compilation, but have totally different outputs (documentation and formatted source code, respectively).</span>これらは、実際のコンパイルとできるだけ近いところで動作したいが、全く異なる出力（それぞれドキュメントと書式化されたソースコード）を持っている。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Another use case is a customised compiler.</span>もう1つのユースケースはカスタマイズされたコンパイラです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Say you want to add a custom code generation phase after macro expansion, then creating a new tool should be easier than forking the compiler (and keeping it up to date as the compiler evolves).</span>マクロ展開後にカスタムコード生成フェーズを追加したい場合、コンパイラをフォークするよりも簡単に新しいツールを作成する必要があります（コンパイラが進化するにつれて最新の状態に保つ）。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">I have gradually been trying to improve the API of librustc to make creating a drop-in tool easier to produce (many others have also helped improve these interfaces over the same time frame).</span>私は、ドロップインツールの作成を容易にするために、ライブラリのAPIを徐々に改善しようとしてきました（他の多くのツールも、同じ時間枠でこれらのインターフェイスを改善するのに役立っています）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It is now pretty simple to make a tool which is as close to rustc as you want it to be.</span>あなたが望むように錆びたものに近いツールを作るのはかなり簡単です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this tutorial I&#39;ll show how.</span>このチュートリアルでは、どのように表示するかを説明します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note/warning, everything I talk about in this tutorial is internal API for rustc.</span>注意/警告、私がこのチュートリアルで話すことはすべて、rustcの内部APIです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It is all extremely unstable and likely to change often and in unpredictable ways.</span>それはすべて非常に不安定で、頻繁に、そして予測不能な方法で変更される可能性があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Maintaining a tool which uses these APIs will be non- trivial, although hopefully easier than maintaining one that does similar things without using them.</span>これらのAPIを使用するツールを維持することは、些細なことではありませんが、似たようなことを使わずに行うものを維持するよりも簡単です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This tutorial starts with a very high level view of the rustc compilation process and of some of the code that drives compilation.</span>このチュートリアルは、rustcのコンパイルプロセスとコンパイルを駆動するコードの非常に高いレベルのビューから始まります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then I&#39;ll describe how that process can be customised.</span>次に、そのプロセスをカスタマイズする方法について説明します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In the final section of the tutorial, I&#39;ll go through an example - stupid-stats - which shows how to build a drop-in tool.</span>チュートリアルの最後のセクションでは、ドロップインツールを作成する方法を示す例（stupid-stats）を紹介します。</span> </p><br><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Overview of the compilation process</span>コンパイルプロセスの概要</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Compilation using rustc happens in several phases.</span> rustcを使ったコンパイルはいくつかの段階で起こります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We start with parsing, this includes lexing.</span>まず構文解析から始めます。これにはレキシングが含まれます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The output of this phase is an AST (abstract syntax tree).</span>このフェーズの出力は、AST（抽象構文ツリー）です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There is a single AST for each crate (indeed, the entire compilation process operates over a single crate).</span>各クレートには1つのASTがあります（実際には、コンパイルプロセス全体が1つのクレートで動作します）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Parsing abstracts away details about individual files which will all have been read in to the AST in this phase.</span>パーシングは、このフェーズでASTにすべて読み込まれた個々のファイルの詳細を抽象化します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">At this stage the AST includes all macro uses, attributes will still be present, and nothing will have been eliminated due to <code>cfg</code> s.</span>この段階では、ASTにはすべてのマクロの使用が含まれ、属性は引き続き存在し、 <code>cfg</code>によって何も削除されません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The next phase is configuration and macro expansion.</span>次のフェーズは構成とマクロ展開です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This can be thought of as a function over the AST.</span>これは、AST上の関数と考えることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The unexpanded AST goes in and an expanded AST comes out.</span>拡張されていないASTが入り、拡張ASTが出ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Macros and syntax extensions are expanded, and <code>cfg</code> attributes will cause some code to disappear.</span>マクロとシンタックス拡張が拡張され、 <code>cfg</code>属性によっていくつかのコードが消えます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The resulting AST won&#39;t have any macros or macro uses left in.</span>結果のASTには、マクロまたはマクロの使用は残されません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The code for these first two phases is in <a class=notranslate href=#2https://github.com/rust-lang/rust/tree/master/src/libsyntax>libsyntax</a> .</span>これらの最初の2つの段階のコードは<a class=notranslate href=#2https://github.com/rust-lang/rust/tree/master/src/libsyntax>libsyntax</a>ます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">After this phase, the compiler allocates ids to each node in the AST (technically not every node, but most of them).</span>このフェーズの後、コンパイラはASTの各ノードにIDを割り当てます（技術的にすべてのノードではなく、ほとんどのノード）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we are writing out dependencies, that happens now.</span>依存関係を書き出している場合は、それが今起こります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The next big phase is analysis.</span>次の大きな段階は分析です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is the most complex phase and uses the bulk of the code in rustc.</span>これは最も複雑な段階で、rustcのコードの大半を使用します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This includes name resolution, type checking, borrow checking, type and lifetime inference, trait selection, method selection, linting, and so forth.</span>これには、名前解決、型チェック、借用チェック、型と存続時間推論、特性選択、メソッド選択、リンピングなどが含まれます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Most error detection is done in this phase (although parse errors are found during parsing).</span>ほとんどのエラー検出はこのフェーズで実行されます（解析エラーは解析中に検出されます）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The &#39;output&#39; of this phase is a bunch of side tables containing semantic information about the source program.</span>このフェーズの「出力」は、ソースプログラムに関する意味情報を含む一連のサイドテーブルです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The analysis code is in <a class=notranslate href=#2https://github.com/rust-lang/rust/tree/master/src/librustc>librustc</a> and a bunch of other crates with the &#39;librustc_&#39; prefix.</span>分析コードは<a class=notranslate href=#2https://github.com/rust-lang/rust/tree/master/src/librustc>librustc</a>あり、librustc_という接頭辞を持つ他のクレートの束です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Next is translation, this translates the AST (and all those side tables) into LLVM IR (intermediate representation).</span>次は翻訳で、これはAST（およびそれらのすべてのサイドテーブル）をLLVM IR（中間表現）に変換します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We do this by calling into the LLVM libraries, rather than actually writing IR directly to a file.</span>実際に直接IRをファイルに書くのではなく、LLVMライブラリを呼び出すことでこれを行います。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The code for this is in <a class=notranslate href=#2https://github.com/rust-lang/rust/tree/master/src/librustc_trans>librustc_trans</a> .</span>このコードは<a class=notranslate href=#2https://github.com/rust-lang/rust/tree/master/src/librustc_trans>librustc_trans</a>ます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The next phase is running the LLVM backend.</span>次の段階では、LLVMバックエンドを実行しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This runs LLVM&#39;s optimisation passes on the generated IR and then generates machine code.</span>これにより、生成されたIRに対してLLVMの最適化パスが実行され、マシンコードが生成されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The result is object files.</span>結果はオブジェクトファイルです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This phase is all done by LLVM, it is not really part of the rust compiler.</span>このフェーズはすべてLLVMによって実行されますが、それは本当にrustコンパイラの一部ではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The interface between LLVM and rustc is in <a class=notranslate href=#2https://github.com/rust-lang/rust/tree/master/src/librustc_llvm>librustc_llvm</a> .</span> LLVMとrustcの間のインタフェースは<a class=notranslate href=#2https://github.com/rust-lang/rust/tree/master/src/librustc_llvm>librustc_llvm</a>ます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Finally, we link the object files into an executable.</span>最後に、オブジェクトファイルを実行可能ファイルにリンクします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Again we outsource this to other programs and it&#39;s not really part of the rust compiler.</span>ここでも、これを他のプログラムに委託しています。それは実際には錆びたコンパイラの一部ではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The interface is in <a class=notranslate href=#2https://github.com/rust-lang/rust/tree/master/src/librustc_back>librustc_back</a> (which also contains some things used primarily during translation).</span>インタフェースは<a class=notranslate href=#2https://github.com/rust-lang/rust/tree/master/src/librustc_back>librustc_back</a> （主に翻訳時に使用されるものも含まれています）にあります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">All these phases are coordinated by the driver.</span>これらのフェーズはすべてドライバによって調整されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To see the exact sequence, look at <a href=#3compile-input>the <code>compile_input</code> function in <code>librustc_driver</code></a> .</span>正確な配列を確認するには、見<a href=#3compile-input><code>compile_inputの</code>中の関数<code>compile_input</code> <code>librustc_driver</code></a> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The driver handles all the highest level coordination of compilation - 1. handling command-line arguments 2. maintaining compilation state (primarily in the <code>Session</code> ) 3. calling the appropriate code to run each phase of compilation 4. handles high level coordination of pretty printing and testing.</span>ドライバは、コンパイルの最高レベルの調整をすべて処理します。1.コマンドライン引数の処理2.コンパイル状態の維持（主に<code>Session</code> ）3.コンパイルの各段階を実行するための適切なコードの呼び出し4.きれいな印刷テスト。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To create a drop-in compiler replacement or a compiler replacement, we leave most of compilation alone and customise the driver using its APIs.</span>ドロップインコンパイラの置き換えやコンパイラの置き換えを作成するには、ほとんどのコンパイルをそのままにして、そのAPIを使用してドライバをカスタマイズします。</span> </p><br> <a class=notranslate href=#1https://doc.rust-lang.org/nightly/nightly-rustc/rustc_driver/driver/fn.compile_input.html>compile-input</a> <br> <br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The driver customisation APIs</span>ドライバのカスタマイズAPI</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There are two primary ways to customise compilation - high level control of the driver using <code>CompilerCalls</code> and controlling each phase of compilation using a <code>CompileController</code> .</span>コンパイルをカスタマイズするには、 <code>CompilerCalls</code>を使用してドライバを高水準で制御し、 <code>CompileController</code>を使用してコンパイルの各フェーズを制御する2つの主な方法があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The former lets you customise handling of command line arguments etc., the latter lets you stop compilation early or execute code between phases.</span>前者では、コマンドライン引数などの処理をカスタマイズできます。後者では、コンパイルを早期に中止したり、フェーズ間でコードを実行したりできます。</span> </p><br><br><h3> <code>CompilerCalls</code> </h3> <br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>CompilerCalls</code> is a trait that you implement in your tool.</span> <code>CompilerCalls</code>は、あなたのツールに実装する特性です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It contains a fairly ad-hoc set of methods to hook in to the process of processing command line arguments and driving the compiler.</span>コマンドライン引数を処理してコンパイラを起動するプロセスにフックする方法のかなりアドホックなセットが含まれています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For details, see the comments in <a class=notranslate href=#2https://doc.rust-lang.org/nightly/nightly-rustc/rustc_driver/index.html>librustc_driver/lib.rs</a> .</span>詳細は、 <a class=notranslate href=#2https://doc.rust-lang.org/nightly/nightly-rustc/rustc_driver/index.html>librustc_driver/lib.rs</a>コメントを参照してください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">I&#39;ll summarise the methods here.</span>ここではその方法を要約します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>early_callback</code> and <code>late_callback</code> let you call arbitrary code at different points - early is after command line arguments have been parsed, but before anything is done with them;</span> <code>early_callback</code>と<code>late_callback</code>は、異なるポイントで任意のコードを呼び出すことができます。早い段階でコマンドライン引数が解析された後で、何か処理が完了する前に実行されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">late is pretty much the last thing before compilation starts, ie, after all processing of command line arguments, etc. is done.</span>後半は、コンパイルが始まる前の最後のことです。つまり、コマンドライン引数などの処理がすべて完了した後です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Currently, you get to choose whether compilation stops or continues at each point, but you don&#39;t get to change anything the driver has done.</span>現在のところ、コンパイルが停止するか、各ポイントで続行するかを選択できますが、ドライバが行ったことは何も変更する必要はありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can record some info for later, or perform other actions of your own.</span>あとで情報を記録したり、自分の他のアクションを実行することができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>some_input</code> and <code>no_input</code> give you an opportunity to modify the primary input to the compiler (usually the input is a file containing the top module for a crate, but it could also be a string).</span> <code>some_input</code>と<code>no_input</code>は、コンパイラへのプライマリ入力を変更する機会を与えます（通常、入力はクレートのトップモジュールを含むファイルですが、文字列でも可能です）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You could record the input or perform other actions of your own.</span>あなたは入力を記録したり、あなた自身の他のアクションを実行することができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Ignore <code>parse_pretty</code> , it is unfortunate and hopefully will get improved.</span> <code>parse_pretty</code>無視すると、残念ですが、うまくいけば改善されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There is a default implementation, so you can pretend it doesn&#39;t exist.</span>デフォルトの実装があるため、存在しないふりをすることができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>build_controller</code> returns a <code>CompileController</code> object for more fine-grained control of compilation, it is described next.</span> <code>build_controller</code>は、 <code>CompileController</code>より細かい制御のために<code>CompileController</code>オブジェクトを返します。次に説明します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We might add more options in the future.</span>将来、より多くのオプションを追加する可能性があります。</span> </p><br><br><h3> <code>CompilerController</code> </h3> <br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>CompilerController</code> is a struct consisting of <code>PhaseController</code> s and flags.</span> <code>CompilerController</code>は<code>PhaseController</code>とフラグで構成される構造体です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Currently, there is only flag, <code>make_glob_map</code> which signals whether to produce a map of glob imports (used by save-analysis and potentially other tools).</span>現在はglobインポートのマップを生成するかどうかを示すフラグ<code>make_glob_map</code>しかありません（save-analysisや他のツールで使用される）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There are probably flags in the session that should be moved here.</span>おそらく、ここに移動する必要のあるフラグがセッション内にあります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There is a <code>PhaseController</code> for each of the phases described in the above summary of compilation (and we could add more in the future for finer-grained control).</span>上のコンパイルの要約で説明したフェーズごとに<code>PhaseController</code>があります（さらに細かい制御のために将来追加することもできます）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">They are all <code>after_</code> a phase because they are checked at the end of a phase (again, that might change), eg, <code>CompilerController::after_parse</code> controls what happens immediately after parsing (and before macro expansion).</span>彼らはすべてある<code>after_</code>それらは（変更される可能性があること、再び）フェーズの終了時にチェックされているため、例えば、相<code>CompilerController::after_parse</code>解析した直後に何が起こるかをコントロール（およびマクロ展開の前に）。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Each <code>PhaseController</code> contains a flag called <code>stop</code> which indicates whether compilation should stop or continue, and a callback to be executed at the point indicated by the phase.</span>各<code>PhaseController</code>は、コンパイルを停止するか継続するかを示す<code>stop</code>というフラグと、フェーズが示すポイントで実行されるコールバックが含まれています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The callback is called whether or not compilation continues.</span>コールバックは、コンパイルが続行されるかどうかによって呼び出されます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Information about the state of compilation is passed to these callbacks in a <code>CompileState</code> object.</span>コンパイルの状態に関する情報は、 <code>CompileState</code>オブジェクトのこれらのコールバックに渡されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This contains all the information the compiler has.</span>これには、コンパイラーが持つすべての情報が含まれています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that this state information is immutable - your callback can only execute code using the compiler state, it can&#39;t modify the state.</span>この状態情報は不変であることに注意してください。コールバックはコンパイラ状態を使用してコードを実行するだけで、状態を変更することはできません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">(If there is demand, we could change that).</span> （もし需要があれば、それを変えることができる）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The state available to a callback depends on where during compilation the callback is called.</span>コールバックで使用可能な状態は、コンパイル時にコールバックが呼び出される場所によって異なります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, after parsing there is an AST but no semantic analysis (because the AST has not been analysed yet).</span>たとえば、構文解析後にはASTは存在しますが、意味解析は行われません（ASTはまだ解析されていないため）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">After translation, there is translation info, but no AST or analysis info (since these have been consumed/forgotten).</span>翻訳後、翻訳情報がありますが、ASTや分析情報はありません（これらは消費/忘れられているため）。</span> </p><br><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">An example - stupid-stats</span>例 -  stupid-stats</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Our example tool is very simple, it simply collects some simple and not very useful statistics about a program;</span>私たちのサンプルツールは非常にシンプルで、プログラムに関する簡単で有用ではない統計を収集するだけです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">it is called stupid-stats.</span>それは愚かな統計と呼ばれています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can find the (more heavily commented) complete source for the example on <a class=notranslate href=#2https://github.com/nick29581/stupid-stats/blob/master/src>Github</a> .</span>あなたは<a class=notranslate href=#2https://github.com/nick29581/stupid-stats/blob/master/src>Github</a>の例の完全なソース（より多くコメントされている）を見つけることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To build, just do <code>cargo build</code> .</span>ビルドするには、 <code>cargo build</code>行うだけです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To run on a file <code>foo.rs</code> , do <code>cargo run foo.rs</code> (assuming you have a Rust program called <code>foo.rs</code> . You can also pass any command line arguments that you would normally pass to rustc).</span>ファイル上で実行するには<code>foo.rs</code> 、やる<code>cargo run foo.rs</code> （あなたが呼ばれる錆プログラム持っていると仮定し<code>foo.rs</code> 。また、あなたが正常にrustcに渡す任意のコマンドライン引数を渡すことができます）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When you run it you&#39;ll see output similar to</span>それを実行すると、次のような出力が表示されます</span> </p><br><div data-lang=text><div data-l="In crate: foo,"></div><div data-l=""></div><div data-l="Found 12 uses of `println!`;"></div><div data-l="The most common number of arguments is 1 (67% of all functions);"></div><div data-l="25% of functions have four or more arguments."></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To make things easier, when we talk about functions, we&#39;re excluding methods and closures.</span>物事を簡単にするために、関数について話すとき、メソッドとクロージャを除外します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can also use the executable as a drop-in replacement for rustc, because after all, that is the whole point of this exercise.</span>結局、実行可能ファイルをrustcのドロップイン置換として使用することもできます。なぜなら、これはこのエクササイズの要点ですからです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So, however you use rustc in your makefile setup, you can use <code>target/stupid</code> (or whatever executable you end up with) instead.</span>ですから、あなたはmakefileの設定でrustcを使いますが、 <code>target/stupid</code> （またはあなたが最後に実行した実行可能ファイル）を代わりに使うことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That might mean setting an environment variable or it might mean renaming your executable to <code>rustc</code> and setting your PATH.</span>それは環境変数を設定することを意味するかもしれませんし、実行可能ファイルの名前を<code>rustc</code>変更してPATHを設定することを意味するかもしれません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Similarly, if you&#39;re using Cargo, you&#39;ll need to rename the executable to rustc and set the PATH.</span>同様に、Cargoを使用している場合は、実行可能ファイルの名前をrustcに変更し、PATHを設定する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Alternatively, you should be able to use <a class=notranslate href=#2https://github.com/brson/multirust>multirust</a> to get around all the PATH stuff (although I haven&#39;t actually tried that).</span>あるいは、 <a class=notranslate href=#2https://github.com/brson/multirust>multirust</a>を使用してPATHのすべての<a class=notranslate href=#2https://github.com/brson/multirust>multirust</a>を行うことができます（実際には試していませんが）。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">(Note that this example prints to stdout. I&#39;m not entirely sure what Cargo does with stdout from rustc under different circumstances. If you don&#39;t see any output, try inserting a <code>panic€</code> after the <code>println€</code> s to error out, then Cargo should dump stupid-stats&#39; stdout to Cargo&#39;s stdout).</span> （この例ではstdoutに出力していますが、Cargoがさまざまな状況下でstdoutを使ってstdoutを実行しているかどうかは完全にはわかりませんが出力が表示されない場合は<code>println€</code>後に<code>panic€</code>挿入してください貨物は、愚かな統計の貨物の標準にダンプする必要があります）。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s start with the <code>main</code> function for our tool, it is pretty simple:</span>私たちのツールの<code>main</code>機能から始めてみましょう。これはとても簡単です：</span> </p><br><div data-lang=rust,ignore><div data-l="fn main() {"></div><div data-l="    let args: Vec&lt;_&gt; = std::env::args().collect();"></div><div data-l="    rustc_driver::run_compiler(&amp;args, &amp;mut StupidCalls::new());"></div><div data-l="    std::env::set_exit_status(0);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The first line grabs any command line arguments.</span>最初の行はコマンドライン引数を取得します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The second line calls the compiler driver with those arguments.</span> 2行目は、これらの引数を使用してコンパイラドライバを呼び出します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The final line sets the exit code for the program.</span>最後の行は、プログラムの終了コードを設定します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The only interesting thing is the <code>StupidCalls</code> object we pass to the driver.</span>興味深いのは、私たちがドライバに渡す<code>StupidCalls</code>オブジェクトだけです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is our implementation of the <code>CompilerCalls</code> trait and is what will make this tool different from rustc.</span>これは<code>CompilerCalls</code>特性を実装したもので、このツールをrustcとは異なるものにするものです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>StupidCalls</code> is a mostly empty struct:</span> <code>StupidCalls</code>はほとんど空の構造体です：</span> </p><br><div data-lang=rust,ignore><div data-l="struct StupidCalls {"></div><div data-l="    default_calls: RustcDefaultCalls,"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This tool is so simple that it doesn&#39;t need to store any data here, but usually you would.</span>このツールはシンプルなので、ここにデータを格納する必要はありませんが、通常はそうです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We embed a <code>RustcDefaultCalls</code> object to delegate to in our impl when we want exactly the same behaviour as the Rust compiler.</span>私たちは、Rustコンパイラとまったく同じ振る舞いが必要なときに、私たちのimplに委譲する<code>RustcDefaultCalls</code>オブジェクトを埋め込みます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Mostly you don&#39;t want to do that (or at least don&#39;t need to) in a tool.</span>ほとんどの場合、ツールでそれをしたくない（または少なくとも行う必要はありません）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, Cargo calls rustc with the <code>--print file-names</code> , so we delegate in <code>late_callback</code> and <code>no_input</code> to keep Cargo happy.</span>しかし、Cargoは--print <code>--print file-names</code>で<code>late_callback</code>を<code>no_input</code>ので、 <code>late_callback</code>と<code>no_input</code>して、Cargoを幸せに保ちます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Most of the rest of the impl of <code>CompilerCalls</code> is trivial:</span> <code>CompilerCalls</code>その他のインプリメントのほとんどは自明です。</span> </p><br><div data-lang=rust,ignore><div data-l="impl&lt;'a&gt; CompilerCalls&lt;'a&gt; for StupidCalls {"></div><div data-l="    fn early_callback(&amp;mut self,"></div><div data-l="                        _: &amp;getopts::Matches,"></div><div data-l="                        _: &amp;config::Options,"></div><div data-l="                        _: &amp;diagnostics::registry::Registry,"></div><div data-l="                        _: ErrorOutputType)"></div><div data-l="                      -&gt; Compilation {"></div><div data-l="        Compilation::Continue"></div><div data-l="    }"></div><div data-l=""></div><div data-l="    fn late_callback(&amp;mut self,"></div><div data-l="                     t: &amp;TransCrate,"></div><div data-l="                     m: &amp;getopts::Matches,"></div><div data-l="                     s: &amp;Session,"></div><div data-l="                     c: &amp;CrateStore,"></div><div data-l="                     i: &amp;Input,"></div><div data-l="                     odir: &amp;Option&lt;PathBuf&gt;,"></div><div data-l="                     ofile: &amp;Option&lt;PathBuf&gt;)"></div><div data-l="                     -&gt; Compilation {"></div><div data-l="        self.default_calls.late_callback(t, m, s, c, i, odir, ofile);"></div><div data-l="        Compilation::Continue"></div><div data-l="    }"></div><div data-l=""></div><div data-l="    fn some_input(&amp;mut self,"></div><div data-l="                  input: Input,"></div><div data-l="                  input_path: Option&lt;Path&gt;)"></div><div data-l="                  -&gt; (Input, Option&lt;Path&gt;) {"></div><div data-l="        (input, input_path)"></div><div data-l="    }"></div><div data-l=""></div><div data-l="    fn no_input(&amp;mut self,"></div><div data-l="                m: &amp;getopts::Matches,"></div><div data-l="                o: &amp;config::Options,"></div><div data-l="                odir: &amp;Option&lt;Path&gt;,"></div><div data-l="                ofile: &amp;Option&lt;Path&gt;,"></div><div data-l="                r: &amp;diagnostics::registry::Registry)"></div><div data-l="                -&gt; Option&lt;(Input, Option&lt;Path&gt;)&gt; {"></div><div data-l="        self.default_calls.no_input(m, o, odir, ofile, r);"></div><div data-l=""></div><div data-l="#        // This is not optimal error handling."></div><div data-l="        // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is not optimal error handling.</span>これは最適なエラー処理ではありません。</span> </div><div data-l="        panic!(&quot;No input supplied to stupid-stats&quot;);"></div><div data-l="    }"></div><div data-l=""></div><div data-l="    fn build_controller(&amp;mut self, _: &amp;Session) -&gt; driver::CompileController&lt;'a&gt; {"></div><div data-l="        ..."></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We don&#39;t do anything for either of the callbacks, nor do we change the input if the user supplies it.</span>いずれかのコールバックに対しては何もしませんし、ユーザーが入力した場合は入力を変更しません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If they don&#39;t, we just <code>panic€</code> , this is the simplest way to handle the error, but not very user-friendly, a real tool would give a constructive message or perform a default action.</span>そうでない場合は、我々だけで<code>panic€</code> 、これは非常にユーザーフレンドリーエラーを処理するための最も簡単な方法ですが、ではない、本当のツールは、建設的なメッセージを与えるか、またはデフォルトのアクションを実行します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In <code>build_controller</code> we construct our <code>CompileController</code> .</span>で<code>build_controller</code>我々は我々の構築<code>CompileController</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We only want to parse, and we want to inspect macros before expansion, so we make compilation stop after the first phase (parsing).</span>私たちは解析したいだけで、展開前にマクロを検査したいので、最初の段階（解析）後にコンパイルを停止します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The callback after that phase is where the tool does it&#39;s actual work by walking the AST.</span>その段階の後のコールバックは、ツールがASTを歩いて実際の作業を行う場所です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We do that by creating an AST visitor and making it walk the AST from the top (the crate root).</span>私たちはAST訪問者を作成し、ASTを上から（クレートルート）歩くようにします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Once we&#39;ve walked the crate, we print the stats we&#39;ve collected:</span>クレートを歩いたら、収集した統計を印刷します：</span> </p><br><div data-lang=rust,ignore><div data-l="fn build_controller(&amp;mut self, _: &amp;Session) -&gt; driver::CompileController&lt;'a&gt; {"></div><div data-l="#    // We mostly want to do what rustc does, which is what basic() will return."></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We mostly want to do what rustc does, which is what basic() will return.</span>私たちは、ほとんどの場合、rustcがやることをしたいと思います。これはbasic（）が返すものです。</span> </div><div data-l="    let mut control = driver::CompileController::basic();"></div><div data-l="#    // But we only need the AST, so we can stop compilation after parsing."></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But we only need the AST, so we can stop compilation after parsing.</span>しかし、ASTだけが必要なので、解析後にコンパイルを停止することができます。</span> </div><div data-l="    control.after_parse.stop = Compilation::Stop;"></div><div data-l=""></div><div data-l="#    // And when we stop after parsing we'll call this closure."></div><div data-l="#    // Note that this will give us an AST before macro expansions, which is"></div><div data-l="#    // not usually what you want."></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">And when we stop after parsing we&#39;ll call this closure.</span>そして解析後に停止するときに、このクロージャーを呼び出します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that this will give us an AST before macro expansions, which is not usually what you want.</span>これはマクロ拡張の前にASTを与えてくれることに注意してください。通常はあなたが望むものではありません。</span> </div><div data-l="    control.after_parse.callback = box |state| {"></div><div data-l="#        // Which extracts information about the compiled crate..."></div><div data-l="        // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Which extracts information about the compiled crate...</span>コンパイル済みのクレートに関する情報を抽出します...</span> </div><div data-l="        let krate = state.krate.unwrap();"></div><div data-l=""></div><div data-l="#        // ...and walks the AST, collecting stats."></div><div data-l="        // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">...and walks the AST, collecting stats.</span> ... ASTを歩き、統計を収集します。</span> </div><div data-l="        let mut visitor = StupidVisitor::new();"></div><div data-l="        visit::walk_crate(&amp;mut visitor, krate);"></div><div data-l=""></div><div data-l="#        // And finally prints out the stupid stats that we collected."></div><div data-l="        // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">And finally prints out the stupid stats that we collected.</span>最後に私たちが収集したばかげた統計を表示します。</span> </div><div data-l="        let cratename = match attr::find_crate_name(&amp;krate.attrs[]) {"></div><div data-l="            Some(name) =&gt; name.to_string(),"></div><div data-l="            None =&gt; String::from_str(&quot;unknown_crate&quot;),"></div><div data-l="        };"></div><div data-l="        println!(&quot;In crate: {},\n&quot;, cratename);"></div><div data-l="        println!(&quot;Found {} uses of `println!`;&quot;, visitor.println_count);"></div><div data-l=""></div><div data-l="        let (common, common_percent, four_percent) = visitor.compute_arg_stats();"></div><div data-l="        println!(&quot;The most common number of arguments is {} ({:.0}% of all functions);&quot;,"></div><div data-l="                 common, common_percent);"></div><div data-l="        println!(&quot;{:.0}% of functions have four or more arguments.&quot;, four_percent);"></div><div data-l="    };"></div><div data-l=""></div><div data-l="    control"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That is all it takes to create your own drop-in compiler replacement or custom compiler!</span>それはあなた自身のドロップインコンパイラ置換またはカスタムコンパイラを作成するために必要なすべてです！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For the sake of completeness I&#39;ll go over the rest of the stupid-stats tool.</span>完全性のために、私は愚かな統計ツールの残りの部分について説明します。</span> </p><br><div data-lang=rust><div data-l="struct StupidVisitor {"></div><div data-l="    println_count: usize,"></div><div data-l="    arg_counts: Vec&lt;usize&gt;,"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>StupidVisitor</code> struct just keeps track of the number of <code>println€</code> s it has seen and the count for each number of arguments.</span> <code>StupidVisitor</code>構造体は、見た<code>println€</code>数と引数の数ごとの数を追跡します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It implements <code>syntax::visit::Visitor</code> to walk the AST.</span> ASTを歩くために<code>syntax::visit::Visitor</code>を実装してい<code>syntax::visit::Visitor</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Mostly we just use the default methods, these walk the AST taking no action.</span>ほとんどの場合、デフォルトのメソッドを使用しています。これらは、アクションを取らずにASTを実行します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We override <code>visit_item</code> and <code>visit_mac</code> to implement custom behaviour when we walk into items (items include functions, modules, traits, structs, and so forth, we&#39;re only interested in functions) and macros:</span>私たちがアイテム（関数、モジュール、特性、構造体などを含む項目、関数にのみ関心がある項目）とマクロに<code>visit_mac</code>したときのカスタム動作を実装するために<code>visit_item</code>と<code>visit_mac</code>をオーバーライドします。</span> </p><br><div data-lang=rust,ignore><div data-l="impl&lt;'v&gt; visit::Visitor&lt;'v&gt; for StupidVisitor {"></div><div data-l="    fn visit_item(&amp;mut self, i: &amp;'v ast::Item) {"></div><div data-l="        match i.node {"></div><div data-l="            ast::Item_::ItemFn(ref decl, _, _, _, _) =&gt; {"></div><div data-l="#                // Record the number of args."></div><div data-l="                // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Record the number of args.</span> argsの数を記録します。</span> </div><div data-l="                self.increment_args(decl.inputs.len());"></div><div data-l="            }"></div><div data-l="            _ =&gt; {}"></div><div data-l="        }"></div><div data-l=""></div><div data-l="#        // Keep walking."></div><div data-l="        // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Keep walking.</span>歩き続ける。</span> </div><div data-l="        visit::walk_item(self, i)"></div><div data-l="    }"></div><div data-l=""></div><div data-l="    fn visit_mac(&amp;mut self, mac: &amp;'v ast::Mac) {"></div><div data-l="#        // Find its name and check if it is &quot;println&quot;."></div><div data-l="        // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Find its name and check if it is &quot;println&quot;.</span>その名前を見つけ、それが &quot;println&quot;であるかどうかを確認します。</span> </div><div data-l="        let ast::Mac_::MacInvocTT(ref path, _, _) = mac.node;"></div><div data-l="        if path_to_string(path) == &quot;println&quot; {"></div><div data-l="            self.println_count += 1;"></div><div data-l="        }"></div><div data-l=""></div><div data-l="#        // Keep walking."></div><div data-l="        // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Keep walking.</span>歩き続ける。</span> </div><div data-l="        visit::walk_mac(self, mac)"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>increment_args</code> method increments the correct count in <code>StupidVisitor::arg_counts</code> .</span> <code>increment_args</code>メソッドは、 <code>StupidVisitor::arg_counts</code>正しいカウントをインクリメントします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">After we&#39;re done walking, <code>compute_arg_stats</code> does some pretty basic maths to come up with the stats we want about arguments.</span>歩き終わった後、 <code>compute_arg_stats</code>は、引数に関して必要な統計を思い付くためのかなり基本的な数学を行います。</span> </p><br><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">What next?</span>次は何？</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These APIs are pretty new and have a long way to go until they&#39;re really good.</span>これらのAPIはかなり新しく、本当に良い状態になるまではまだまだ進んでいます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If there are improvements you&#39;d like to see or things you&#39;d like to be able to do, let me know in a comment or <a href=#2https://github.com/rust-lang/rust/issues>GitHub issue</a> .</span>あなたが見たい改善がある場合、あるいはできるようにしたいことがある場合は、コメントや<a href=#2https://github.com/rust-lang/rust/issues>GitHubの問題</a>で教えてください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In particular, it&#39;s not clear to me exactly what extra flexibility is required.</span>特に、余分な柔軟性が必要であることは私にはっきりしていません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you have an existing tool that would be suited to this setup, please try it out and let me know if you have problems.</span>この設定に適した既存のツールがある場合は、それを試して問題がある場合にお知らせください。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It&#39;d be great to see Rustdoc converted to using these APIs, if that is possible (although long term, I&#39;d prefer to see Rustdoc run on the output from save- analysis, rather than doing its own analysis).</span>可能であれば、RustdocがこれらのAPIを使用するように変換されていることを確認することは素晴らしいことです（長期間は、独自の分析を行うのではなく、保存分析からRustdocが実行されることを望みます）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Other parts of the compiler (eg, pretty printing, testing) could be refactored to use these APIs internally (I already changed save-analysis to use <code>CompilerController</code> ).</span>コンパイラの他の部分（例えば、かなりの印刷、テスト）は、内部的にこれらのAPIを使用するようにリファクタリングすることができます（私は既に<code>CompilerController</code>を使用するように保存分析を変更しました）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">I&#39;ve been experimenting with a prototype rustfmt which also uses these APIs.</span>私は、これらのAPIも使用するprototype rustfmtを試してきました。</span> </p><br> <a class=notranslate href=#1https://github.com/nrc/stupid-stats>stupid-stats</a><script>_addload(function(){_setupIW('com');_csi('en','ja','stupid-stats.html');});</script>