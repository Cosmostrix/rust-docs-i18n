<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180723_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=method-lookup.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Method lookup</span>メソッドルックアップ</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Method lookup can be rather complex due to the interaction of a number of factors, such as self types, autoderef, trait lookup, etc. This file provides an overview of the process.</span>メソッドのルックアップは、自己タイプ、自動修正、特性検索など、いくつかの要因の相互作用のためにかなり複雑になる可能性があります。このファイルはプロセスの概要を提供します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">More detailed notes are in the code itself, naturally.</span>より詳細なノートは、コード自体に自然にあります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">One way to think of method lookup is that we convert an expression of the form:</span>メソッドルックアップを考える方法の1つは、フォームの式を変換することです。</span> </p><br><div data-lang=rust,ignore><div data-l=receiver.method(...)></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">into a more explicit <a class=notranslate href=#4UFCS>UFCS</a> form:</span>より明示的な<a class=notranslate href=#4UFCS>UFCS</a>形式に変換します。</span> </p><br><div data-lang=rust,ignore><div data-l="#//Trait::method(ADJ(receiver), ...) // for a trait call"></div><div data-l="Trait::method(ADJ(receiver), ...) // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">for a trait call</span>形質呼び出しのために</span> </div><div data-l="#//ReceiverType::method(ADJ(receiver), ...) // for an inherent method call"></div><div data-l="ReceiverType::method(ADJ(receiver), ...) // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">for an inherent method call</span>固有のメソッド呼び出し</span> </div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here <code>ADJ</code> is some kind of adjustment, which is typically a series of autoderefs and then possibly an autoref (eg, <code>&amp;**receiver</code> ).</span>ここで、 <code>ADJ</code>はある種の調整ですが、これは一般的には一連のautoderefsであり、おそらくautoref（例： <code>&amp;**receiver</code> ）です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However we sometimes do other adjustments and coercions along the way, in particular unsizing (eg, converting from <code>[T; n]</code> to <code>[T]</code> ).</span>しかし、途中で他の調整や強制を行う場合があります（特に<code>[T; n]</code>から<code>[T]</code>への変換）。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Method lookup is divided into two major phases:</span>メソッドルックアップは2つの主要な段階に分かれています。</span> </p><br><div data-b=1.> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Probing ( <a class=notranslate href=#3probe><code>probe.rs</code></a> ).</span>プローブ（プローブ<a class=notranslate href=#3probe><code>probe.rs</code></a> ）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The probe phase is when we decide what method to call and how to adjust the receiver.</span>プローブフェーズは、どのメソッドを呼び出すか、受信側の調整方法を決定するときです。</span> </div><div data-b=2.> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Confirmation ( <a class=notranslate href=#3confirm><code>confirm.rs</code></a> ).</span>確認（ <a class=notranslate href=#3confirm><code>confirm.rs</code></a> ）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The confirmation phase &quot;applies&quot; this selection, updating the side-tables, unifying type variables, and otherwise doing side-effectful things.</span>確認フェーズは、この選択を「適用」し、サイドテーブルを更新し、型変数を統一し、そうでなければ副作用を実行します。</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">One reason for this division is to be more amenable to caching.</span>この部門の1つの理由は、キャッシングにもっと順応することです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The probe phase produces a &quot;pick&quot; ( <code>probe::Pick</code> ), which is designed to be cacheable across method-call sites.</span>プローブフェーズでは、 &quot;pick&quot;（ <code>probe::Pick</code> ）が生成されます。これは、メソッド呼び出しサイト間でキャッシュ可能に設計されています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Therefore, it does not include inference variables or other information.</span>したがって、推論変数やその他の情報は含まれません。</span> </p><br> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a class=notranslate href=#1https://github.com/rust-lang/rfcs/blob/master/text/0132-ufcs.md>UFCS</a> <a class=notranslate href=#1https://doc.rust-lang.org/nightly/nightly-rustc/rustc_typeck/check/method/probe/>probe</a> <a class=notranslate href=#1https://doc.rust-lang.org/nightly/nightly-rustc/rustc_typeck/check/method/confirm/>confirm</a></span> <a class=notranslate href=#1https://github.com/rust-lang/rfcs/blob/master/text/0132-ufcs.md>UFCS</a> <a class=notranslate href=#1https://doc.rust-lang.org/nightly/nightly-rustc/rustc_typeck/check/method/probe/>probe</a> <a class=notranslate href=#1https://doc.rust-lang.org/nightly/nightly-rustc/rustc_typeck/check/method/confirm/>confirm</a></span> <br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The Probe phase</span>プローブフェーズ</span> </h2><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Steps</span>ステップ</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The first thing that the probe phase does is to create a series of <i>steps</i> .</span>プローブフェーズが最初に行うことは、一連の<i>ステップ</i>を作成すること<i>です</i> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is done by progressively dereferencing the receiver type until it cannot be deref&#39;d anymore, as well as applying an optional &quot;unsize&quot; step.</span>これは、受信機のタイプを、それがもはやderef&#39;dできなくなるまで漸進的に逆参照し、オプションの「サイズ決め」ステップを適用することによって行われる。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So if the receiver has type <code>Rc&lt;Box&lt;[T; 3]&gt;&gt;</code></span>したがって、受信機がタイプ<code>Rc&lt;Box&lt;[T; 3]&gt;&gt;</code></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>Rc&lt;Box&lt;[T; 3]&gt;&gt;</code> , this might yield:</span> <code>Rc&lt;Box&lt;[T; 3]&gt;&gt;</code> 、次のようになります。</span> </p><br><div data-lang=rust,ignore><div data-l="Rc&lt;Box&lt;[T; 3]&gt;&gt;"></div><div data-l="Box&lt;[T; 3]&gt;"></div><div data-l="[T; 3]"></div><div data-l=[T]></div></div><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Candidate assembly</span>候補組立</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We then search along those steps to create a list of <i>candidates</i> .</span>それらのステップに沿って検索し、 <i>候補</i>リストを作成します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A <code>Candidate</code> is a method item that might plausibly be the method being invoked.</span> <code>Candidate</code>は、呼び出されるメソッドである可能性が高いメソッド項目です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For each candidate, we&#39;ll derive a &quot;transformed self type&quot; that takes into account explicit self.</span>それぞれの候補について、明示的な自己を考慮に入れた「変形された自己タイプ」を導き出します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Candidates are grouped into two kinds, inherent and extension.</span>候補者は、内在と拡張の2種類に分類されます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><b>Inherent candidates</b> are those that are derived from the type of the receiver itself.</span> <b>固有の候補</b>は、受信機自体のタイプから導出されるものである。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So, if you have a receiver of some nominal type <code>Foo</code> (eg, a struct), any methods defined within an impl like <code>impl Foo</code> are inherent methods.</span>だから、公称型の<code>Foo</code> （例えばstruct）のレシーバを持っていれば、 <code>impl Foo</code>ような<code>impl Foo</code>内に定義されたメソッドはすべて固有のメソッドです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Nothing needs to be imported to use an inherent method, they are associated with the type itself (note that inherent impls can only be defined in the same module as the type itself).</span>固有のメソッドを使用するためにインポートする必要はありません。型自体に関連付けられています（固有のimplsは型自体と同じモジュール内でのみ定義できます）。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">FIXME: Inherent candidates are not always derived from impls.</span> FIXME：内在する候補は、常にインプルメントから派生しているとは限りません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you have a trait object, such as a value of type <code>Box&lt;ToString&gt;</code> , then the trait methods ( <code>to_string()</code> , in this case) are inherently associated with it.</span>タイプ<code>Box&lt;ToString&gt;</code>値などの特性オブジェクトがある場合、特性メソッド（この場合は<code>to_string()</code> ）が本来それに関連付けられます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Another case is type parameters, in which case the methods of their bounds are inherent.</span>もう1つのケースは型パラメータです。その場合、その境界のメソッドは固有のものです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, this part of the rules is subject to change: when DST&#39;s &quot;impl Trait for Trait&quot; is complete, trait object dispatch could be subsumed into trait matching, and the type parameter behavior should be reconsidered in light of where clauses.</span>ただし、ルールのこの部分は変更される可能性があります。DSTの「インプライの特性」が完了したとき、特性オブジェクトのディスパッチが特性マッチングに組み込まれる可能性があり、タイプパラメータの動作はwhere句に照らして再考する必要があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">TODO: Is this FIXME still accurate?</span> TODO：このFIXMEはまだ正確ですか？</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><b>Extension candidates</b> are derived from imported traits.</span> <b>延長候補</b>は、輸入された形質から得られる。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If I have the trait <code>ToString</code> imported, and I call <code>to_string()</code> on a value of type <code>T</code> , then we will go off to find out whether there is an impl of <code>ToString</code> for <code>T</code> .</span>私は形質を持っている場合<code>ToString</code>輸入、と私は呼ん<code>to_string()</code>タイプの値に<code>T</code> 、そして我々は独自の実装があるかどうかを調べるために消灯します<code>ToString</code>のための<code>T</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These kinds of method calls are called &quot;extension methods&quot;.</span>このようなメソッド呼び出しを「拡張メソッド」と呼びます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">They can be defined in any module, not only the one that defined <code>T</code> .</span>それらは、 <code>T</code>を定義したモジュールだけでなく、どのモジュールでも定義できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Furthermore, you must import the trait to call such a method.</span>さらに、このようなメソッドを呼び出すためには、特性をインポートする必要があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So, let&#39;s continue our example.</span>だから、私たちの例を続けましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Imagine that we were calling a method <code>foo</code> with the receiver <code>Rc&lt;Box&lt;[T; 3]&gt;&gt;</code></span>私たちは、メソッド呼び出したことを想像し<code>foo</code>受信機で<code>Rc&lt;Box&lt;[T; 3]&gt;&gt;</code></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>Rc&lt;Box&lt;[T; 3]&gt;&gt;</code> and there is a trait <code>Foo</code> that defines it with <code>&amp;self</code> for the type <code>Rc&lt;U&gt;</code> as well as a method on the type <code>Box</code> that defines <code>Foo</code> but with <code>&amp;mut self</code> .</span> <code>Rc&lt;Box&lt;[T; 3]&gt;&gt;</code>及び形質ある<code>Foo</code>とそれを定義する<code>&amp;self</code>タイプの<code>Rc&lt;U&gt;</code>と同様型のメソッド<code>Box</code>定義<code>Foo</code>けれども有する<code>&amp;mut self</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then we might have two candidates: ` <code class=2>text &amp;Rc&lt;Box&lt;[T; 3]&gt;&gt; from the impl of `Foo` for `Rc&lt;U&gt;` where `U=Box&lt;T; 3]&gt; &amp;mut Box&lt;[T; 3]&gt;&gt; from the inherent impl on `Box&lt;U&gt;` where `U=[T; 3]`</code></span>それでは、2つの候補があり<code class=2>text &amp;Rc&lt;Box&lt;[T; 3]&gt;&gt; from the impl of `Foo` for `Rc&lt;U&gt;` where `U=Box&lt;T; 3]&gt; &amp;mut Box&lt;[T; 3]&gt;&gt; from the inherent impl on `Box&lt;U&gt;` where `U=[T; 3]`</code> ： ` <code class=2>text &amp;Rc&lt;Box&lt;[T; 3]&gt;&gt; from the impl of `Foo` for `Rc&lt;U&gt;` where `U=Box&lt;T; 3]&gt; &amp;mut Box&lt;[T; 3]&gt;&gt; from the inherent impl on `Box&lt;U&gt;` where `U=[T; 3]`</code></span> <code class=2>text &amp;Rc&lt;Box&lt;[T; 3]&gt;&gt; from the impl of `Foo` for `Rc&lt;U&gt;` where `U=Box&lt;T; 3]&gt; &amp;mut Box&lt;[T; 3]&gt;&gt; from the inherent impl on `Box&lt;U&gt;` where `U=[T; 3]`</code> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code class=2>text &amp;Rc&lt;Box&lt;[T; 3]&gt;&gt; from the impl of `Foo` for `Rc&lt;U&gt;` where `U=Box&lt;T; 3]&gt; &amp;mut Box&lt;[T; 3]&gt;&gt; from the inherent impl on `Box&lt;U&gt;` where `U=[T; 3]`</code> `</span> <code class=2>text &amp;Rc&lt;Box&lt;[T; 3]&gt;&gt; from the impl of `Foo` for `Rc&lt;U&gt;` where `U=Box&lt;T; 3]&gt; &amp;mut Box&lt;[T; 3]&gt;&gt; from the inherent impl on `Box&lt;U&gt;` where `U=[T; 3]`</code> `</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Candidate search</span>候補検索</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Finally, to actually pick the method, we will search down the steps, trying to match the receiver type against the candidate types.</span>最後に、実際にメソッドを選択するために、レシーバータイプと候補タイプを一致させようと、ステップを検索します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">At each step, we also consider an auto-ref and auto-mut-ref to see whether that makes any of the candidates match.</span>各ステップでは、auto-refおよびauto-mut-refも考慮して候補のいずれかが一致するかどうかを確認します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We pick the first step where we find a match.</span>私たちはマッチを見つける最初のステップを選びます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In the case of our example, the first step is <code>Rc&lt;Box&lt;[T; 3]&gt;&gt;</code></span>この例の場合、最初のステップは<code>Rc&lt;Box&lt;[T; 3]&gt;&gt;</code></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>Rc&lt;Box&lt;[T; 3]&gt;&gt;</code> , which does not itself match any candidate.</span> <code>Rc&lt;Box&lt;[T; 3]&gt;&gt;</code>と一致しません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But when we autoref it, we get the type <code>&amp;Rc&lt;Box&lt;[T; 3]&gt;&gt;</code></span>しかし、それを自動化すると、 <code>&amp;Rc&lt;Box&lt;[T; 3]&gt;&gt;</code></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>&amp;Rc&lt;Box&lt;[T; 3]&gt;&gt;</code> which does match.</span> <code>&amp;Rc&lt;Box&lt;[T; 3]&gt;&gt;</code>と一致します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We would then recursively consider all where-clauses that appear on the impl: if those match (or we cannot rule out that they do), then this is the method we would pick.</span>次に、implに現れるすべてのwhere節を再帰的に検討します。もし一致すれば（または、それが排除できない場合）、これが私たちが選ぶ方法です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Otherwise, we would continue down the series of steps.</span>それ以外の場合は、一連の手順を続行します。</span> </p><script>_addload(function(){_setupIW('com');_csi('en','ja','method-lookup.html');});</script>