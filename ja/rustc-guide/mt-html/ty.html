<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180723_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=ty.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>ty</code> module: representing types</span> <code>ty</code>モジュール：型の表現</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>ty</code> module defines how the Rust compiler represents types internally.</span> <code>ty</code>モジュールは、Rustコンパイラが型を内部的にどのように表現するかを定義します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It also defines the <i>typing context</i> ( <code>tcx</code> or <code>TyCtxt</code> ), which is the central data structure in the compiler.</span>また、 <i>タイピングコンテキスト</i> （ <code>tcx</code>または<code>TyCtxt</code> ）も定義されてい<i>ます</i> 。これは、コンパイラの中心的なデータ構造です。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The tcx and how it uses lifetimes</span> tcxとそのライフタイムの使い方</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>tcx</code> (&quot;typing context&quot;) is the central data structure in the compiler.</span> <code>tcx</code> （ &quot;typing context&quot;）は、コンパイラの中心的なデータ構造です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It is the context that you use to perform all manner of queries.</span>これは、あらゆる方法でクエリを実行するために使用するコンテキストです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The struct <code>TyCtxt</code> defines a reference to this shared context:</span> struct <code>TyCtxt</code>は、この共有コンテキストへの参照を定義します。</span> </p><br><div data-lang=rust,ignore><div data-l="tcx: TyCtxt&lt;'a, 'gcx, 'tcx&gt;"></div><div data-l="#//          --  ----  ----"></div><div data-l="#//          |   |     |"></div><div data-l="#//          |   |     innermost arena lifetime (if any)"></div><div data-l="#//          |   &quot;global arena&quot; lifetime"></div><div data-l="#//          lifetime of this reference"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">-- ---- ---- |</span> -  ---- ---- |</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">|</span> |</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">|</span> |</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">|</span> |</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">|</span> |</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">innermost arena lifetime (if any) |</span>最も内側のアリーナ生涯（もしあれば）|</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">&quot;global arena&quot; lifetime lifetime of this reference</span>この参照の「グローバルアリーナ」生涯</span> </div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As you can see, the <code>TyCtxt</code> type takes three lifetime parameters.</span>ご覧のとおり、 <code>TyCtxt</code>タイプには3つのライフタイムパラメータがあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These lifetimes are perhaps the most complex thing to understand about the tcx.</span>これらの寿命はおそらく、tcxについて理解するのに最も複雑なものです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">During Rust compilation, we allocate most of our memory in <b>arenas</b> , which are basically pools of memory that get freed all at once.</span>錆のコンパイル中に、私たちは大部分のメモリを<b>アリーナ</b>に割り当てます。 <b>アリーナ</b>は基本的に一度に解放されるメモリのプールです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When you see a reference with a lifetime like <code>&#39;tcx</code> or <code>&#39;gcx</code> , you know that it refers to arena-allocated data (or data that lives as long as the arenas, anyhow).</span> <code>&#39;tcx</code>や<code>&#39;gcx</code> <code>&#39;tcx</code>ような生涯の参照を見ると、アリーナが割り当てたデータ（またはアリーナと同じくらい長い間生存しているデータ）を参照していることがわかります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We use two distinct levels of arenas.</span>我々は2つの異なるレベルのアリーナを使用する。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The outer level is the &quot;global arena&quot;.</span>外部レベルは「グローバルアリーナ」です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This arena lasts for the entire compilation: so anything you allocate in there is only freed once compilation is basically over (actually, when we shift to executing LLVM).</span>このアリーナはコンパイル全体に適用されます。つまり、コンパイルが基本的に終了すると（実際には、LLVMの実行に移ると）、そこに割り当てられるものはすべて解放されます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To reduce peak memory usage, when we do type inference, we also use an inner level of arena.</span>ピークメモリ使用量を減らすために、型推論を行うときには、内部レベルのアリーナも使用します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These arenas get thrown away once type inference is over.</span>型推論が終わると、これらのアリーナは投げ捨てられます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is done because type inference generates a lot of &quot;throw-away&quot; types that are not particularly interesting after type inference completes, so keeping around those allocations would be wasteful.</span>これは、型推論が型推論の完了後に特に興味深いものではない、多くの &quot;スローアウェイ&quot;型を生成するために行われます。したがって、その割り当てを回避することは無駄です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Often, we wish to write code that explicitly asserts that it is not taking place during inference.</span>しばしば、推論の間に起こっていないことを明示的に宣言するコードを記述したい。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In that case, there is no &quot;local&quot; arena, and all the types that you can access are allocated in the global arena.</span>その場合、「ローカル」アリーナはなく、アクセスできるすべてのタイプはグローバルアリーナに割り当てられます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To express this, the idea is to use the same lifetime for the <code>&#39;gcx</code> and <code>&#39;tcx</code> parameters of <code>TyCtxt</code> .</span>これを表現するために、アイデアがために同じ寿命を使用することです<code>&#39;gcx</code>と<code>&#39;tcx</code>のパラメータ<code>TyCtxt</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Just to be a touch confusing, we tend to use the name <code>&#39;tcx</code> in such contexts.</span>わかりやすくするために、私たちはこのような文脈で<code>&#39;tcx</code>という名前を使う傾向があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here is an example:</span>次に例を示します。</span> </p><br><div data-lang=rust,ignore><div data-l="fn not_in_inference&lt;'a, 'tcx&gt;(tcx: TyCtxt&lt;'a, 'tcx, 'tcx&gt;, def_id: DefId) {"></div><div data-l="#    //                                        ----  ----"></div><div data-l="#    //                                        Using the same lifetime here asserts"></div><div data-l="#    //                                        that the innermost arena accessible through"></div><div data-l="#    //                                        this reference *is* the global arena."></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">---- ---- Using the same lifetime here asserts that the innermost arena accessible through this reference <i>is</i> the global arena.</span> ---- ----ここに同じ寿命を使用すると、この参照を介してアクセス可能な最も内側の舞台がグローバルアリーナ<i>である</i>と主張しています。</span> </div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In contrast, if we want to code that can be usable during type inference, then you need to declare a distinct <code>&#39;gcx</code> and <code>&#39;tcx</code> lifetime parameter:</span>対照的に、型推論の際に使用できるコードを作成したい場合は、別の<code>&#39;gcx</code>および<code>&#39;tcx</code> lifetimeパラメータを宣言する必要があります。</span> </p><br><div data-lang=rust,ignore><div data-l="fn maybe_in_inference&lt;'a, 'gcx, 'tcx&gt;(tcx: TyCtxt&lt;'a, 'gcx, 'tcx&gt;, def_id: DefId) {"></div><div data-l="#    //                                                ----  ----"></div><div data-l="#    //                                        Using different lifetimes here means that"></div><div data-l="#    //                                        the innermost arena *may* be distinct"></div><div data-l="#    //                                        from the global arena (but doesn't have to be)."></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">---- ---- Using different lifetimes here means that the innermost arena <i>may</i> be distinct from the global arena (but doesn&#39;t have to be).</span>ここで異なる生涯を使用するということは、最も内側のアリーナ<i>が</i>グローバルアリーナとは異なる<i>かもしれない</i>ことを意味する（しかし、そうである必要はない）。</span> </div><div data-l=}></div></div><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Allocating and working with types</span>型の割り当てと操作</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust types are represented using the <code>Ty&lt;&#39;tcx&gt;</code> defined in the <code>ty</code> module (not to be confused with the <code>Ty</code> struct from <a class=notranslate href="#4the HIR">the HIR</a> ).</span>錆のタイプは、 <code>ty</code>モジュールで定義された<code>Ty&lt;&#39;tcx&gt;</code>を使って表されます（ <a class=notranslate href="#4the HIR">the HIR</a>から<a class=notranslate href="#4the HIR">the HIR</a> <code>Ty</code>構造体と混同しないでください）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is in fact a simple type alias for a reference with <code>&#39;tcx</code> lifetime:</span>これは実際に<code>&#39;tcx</code> lifetime： <code>&#39;tcx</code>という参照のシンプルな型別名です。</span> </p><br><div data-lang=rust,ignore><div data-l="pub type Ty&lt;'tcx&gt; = &amp;'tcx TyS&lt;'tcx&gt;;"></div></div><br> <a class=notranslate href=#1./hir.html>the HIR</a> <br> <p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can basically ignore the <code>TyS</code> struct – you will basically never access it explicitly.</span>あなたは基本的に<code>TyS</code>構造体を無視することができます - 基本的には明示的にそれにアクセスすることはありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We always pass it by reference using the <code>Ty&lt;&#39;tcx&gt;</code> alias – the only exception I think is to define inherent methods on types.</span>私たちは<code>Ty&lt;&#39;tcx&gt;</code>エイリアスを使って参照することで常に渡します。タイプに固有のメソッドを定義することが唯一の例外です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Instances of <code>TyS</code> are only ever allocated in one of the rustc arenas (never eg on the stack).</span> <code>TyS</code>インスタンスは、錆びたアリーナの1つにしか割り当てられません（スタック上には決して配置されません）。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">One common operation on types is to <b>match</b> and see what kinds of types they are.</span>タイプの一般的な操作の1つは、どのタイプのタイプであるかを<b>照合</b>して確認することです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is done by doing <code>match ty.sty</code> , sort of like this:</span>これは<code>match ty.sty</code>行うことによって行われます。</span> </p><br><div data-lang=rust,ignore><div data-l="fn test_type&lt;'tcx&gt;(ty: Ty&lt;'tcx&gt;) {"></div><div data-l="    match ty.sty {"></div><div data-l="        ty::TyArray(elem_ty, len) =&gt; { ... }"></div><div data-l="        ..."></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>sty</code> field (the origin of this name is unclear to me; perhaps structural type?) is of type <code>TypeVariants&lt;&#39;tcx&gt;</code> , which is an enum defining all of the different kinds of types in the compiler.</span> <code>sty</code>フィールド（この名前の由来は私には分かりませんが、おそらく構造型ですか？）は<code>TypeVariants&lt;&#39;tcx&gt;</code>型です。これはコンパイラのさまざまな種類のすべてを定義する列挙型です。</span> </p><br><blockquote><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">NB inspecting the <code>sty</code> field on types during type inference can be risky, as there may be inference variables and other things to consider, or sometimes types are not yet known that will become known later.).</span>タイプ推論の際にタイプの<code>sty</code>フィールドを検査するNBは、推論変数や考慮すべき他のものが存在する可能性があるため、危険である可能性があります。</span> </p></blockquote><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To allocate a new type, you can use the various <code>mk_</code> methods defined on the <code>tcx</code> .</span>新しい型を割り当てるために、 <code>tcx</code>定義されたさまざまな<code>mk_</code>メソッドを使用できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These have names that correpond mostly to the various kinds of type variants.</span>これらは、主に様々な種類の型変種に対応する名前を持っています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example:</span>例えば：</span> </p><br><div data-lang=rust,ignore><div data-l="let array_ty = tcx.mk_array(elem_ty, len * 2);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These methods all return a <code>Ty&lt;&#39;tcx&gt;</code> – note that the lifetime you get back is the lifetime of the innermost arena that this <code>tcx</code> has access to.</span>これらのメソッドはすべて<code>Ty&lt;&#39;tcx&gt;</code>返します。あなたが戻ってきたライフタイムは、この<code>tcx</code>がアクセスできる最も内側のアリーナのライフタイムです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In fact, types are always canonicalized and interned (so we never allocate exactly the same type twice) and are always allocated in the outermost arena where they can be (so, if they do not contain any inference variables or other &quot;temporary&quot; types, they will be allocated in the global arena).</span>実際には、型は常に正規化され、インターンされています（したがって、同じ型を2回も絶対に割り当てません）。そして、できる限り最も外側の領域に割り当てられます（推論変数やその他の &quot;一時的な&quot;彼らはグローバルアリーナに配分される）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, the lifetime <code>&#39;tcx</code> is always a safe approximation, so that is what you get back.</span>しかし、生涯<code>&#39;tcx</code>は常に安全な近似であるため、これが返されます。</span> </p><br><blockquote><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">NB.</span> NB。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because types are interned, it is possible to compare them for equality efficiently using <code>==</code> – however, this is almost never what you want to do unless you happen to be hashing and looking for duplicates.</span>型はインターンされているので、 <code>==</code>を使用して等価性を効率的に比較することは可能ですが、ハッシュや重複を見つけない限り、これはほとんどあなたがしたいことではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is because often in Rust there are multiple ways to represent the same type, particularly once inference is involved.</span>これは、多くの場合、Rustには同じタイプを表現するための複数の方法があり、特に推論が関与しているからです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you are going to be testing for type equality, you probably need to start looking into the inference code to do it right.</span>型の等価性をテストする場合は、おそらくそれを正しく行うために推論コードを調べる必要があります。</span> </p></blockquote><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can also find various common types in the <code>tcx</code> itself by accessing <code>tcx.types.bool</code> , <code>tcx.types.char</code> , etc (see <code>CommonTypes</code> for more).</span>あなたはまた、様々な一般的なタイプを見つけることができます<code>tcx</code>アクセスすることで自分自身を<code>tcx.types.bool</code> 、 <code>tcx.types.char</code> （参照など、 <code>CommonTypes</code>多くのため）。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Beyond types: other kinds of arena-allocated data structures</span>型を超えて：アリーナに割り当てられた他の種類のデータ構造</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In addition to types, there are a number of other arena-allocated data structures that you can allocate, and which are found in this module.</span>タイプに加えて、割り当て可能な他のアリーナ割り当てデータ構造があり、このモジュールにはいくつかのものがあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here are a few examples:</span>いくつかの例があります：</span> </p><br><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>Substs</code> , allocated with <code>mk_substs</code> – this will intern a slice of types, often used to specify the values to be substituted for generics (eg <code>HashMap&lt;i32, u32&gt;</code> would be represented as a slice <code>&amp;&#39;tcx [tcx.types.i32, tcx.types.u32]</code> ).</span> <code>Substs</code>で割り当てられた<code>mk_substs</code> - これは型のスライスをインターンにします。これは一般にジェネリックスの代わりに値を指定するのに使われます（例えば、 <code>HashMap&lt;i32, u32&gt;</code>はスライスとして表されます<code>&amp;&#39;tcx [tcx.types.i32, tcx.types.u32]</code> ）。</span> </div><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>TraitRef</code> , typically passed by value – a <b>trait reference</b> consists of a reference to a trait along with its various type parameters (including <code>Self</code> ), like <code>i32: Display</code> (here, the def-id would reference the <code>Display</code> trait, and the substs would contain <code>i32</code> ).</span> <code>TraitRef</code> 、典型的には値によって渡される - <b>形質参照</b>は、 <code>i32: Display</code> （ここでは、def-idは<code>Display</code>形質を参照するだろう）のような様々な型パラメータ（ <code>Self</code>を含む） <code>i32</code> ）。</span> </div><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>Predicate</code> defines something the trait system has to prove (see <code>traits</code> module).</span> <code>Predicate</code>は、形質システムが証明しなければならないものを定義します（ <code>traits</code>モジュールを参照）。</span> </div><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Import conventions</span>インポート規則</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Although there is no hard and fast rule, the <code>ty</code> module tends to be used like so:</span> <code>ty</code>高速なルールはありませんが、 <code>ty</code>モジュールは次のように使用される傾向があります。</span> </p><br><div data-lang=rust,ignore><div data-l="use ty::{self, Ty, TyCtxt};"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In particular, since they are so common, the <code>Ty</code> and <code>TyCtxt</code> types are imported directly.</span>特に、それらは非常に一般的であるため、 <code>Ty</code>および<code>TyCtxt</code>タイプは直接インポートされます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Other types are often referenced with an explicit <code>ty::</code> prefix (eg <code>ty::TraitRef&lt;&#39;tcx&gt;</code> ).</span>他の型は、しばしば明示的な<code>ty::</code>接頭辞（例えば、 <code>ty::TraitRef&lt;&#39;tcx&gt;</code> ）で参照されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But some modules choose to import a larger or smaller set of names explicitly.</span>しかし、いくつかのモジュールは、より大きなまたはより小さな名前セットを明示的にインポートすることを選択します。</span> </p><script>_addload(function(){_setupIW('com');_csi('en','ja','ty.html');});</script>