<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180723_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=type-inference.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Type inference</span>型推論</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Type inference is the process of automatic detection of the type of an expression.</span>型推論は、式の型の自動検出のプロセスです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It is what allows Rust to work with fewer or no type annotations, making things easier for users:</span>これは、Rustがタイプアノテーションの数を減らしたり、使用しないようにすることで、ユーザにとってより使いやすくなりました。</span> </p><br><div data-lang=rust,ignore><div data-l="fn main() {"></div><div data-l="    let mut things = vec![];"></div><div data-l="    things.push(&quot;thing&quot;)"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here, the type of <code>things</code> is <i>inferenced</i> to be <code>&amp;str</code> because that&#39;s the value we push into <code>things</code> .</span>ここで、 <code>things</code>の型は<code>&amp;str</code>で<code>things</code>と<i>推論さ</i>れ<code>&amp;str</code>なぜなら、それが私たちが<code>things</code>に押し込む価値だからです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The type inference is based on the standard Hindley-Milner (HM) type inference algorithm, but extended in various way to accommodate subtyping, region inference, and higher-ranked types.</span>型推論は、標準的なHindley-Milner（HM）型の推論アルゴリズムに基づいていますが、サブタイプ、領域推論、および上位ランクの型に対応するためにさまざまな方法で拡張されています。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A note on terminology</span>用語に関する注記</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We use the notation <code>?T</code> to refer to inference variables, also called existential variables.</span>我々は推論変数（実在変数とも呼ばれる）を参照するために<code>?T</code>という表記を使用する。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We use the terms &quot;region&quot; and &quot;lifetime&quot; interchangeably.</span>私たちは、「地域」と「生涯」という言葉を同じ意味で使用しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Both refer to the <code>&#39;a</code> in <code>&amp;&#39;a T</code> .</span>両方とも、 <code>&#39;a</code> in <code>&amp;&#39;a T</code> <code>&#39;a</code>指す。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The term &quot;bound region&quot; refers to a region that is bound in a function signature, such as the <code>&#39;a</code> in <code>for&lt;&#39;a&gt; fn(&amp;&#39;a u32)</code> .</span> 「結合領域」という用語は、 <code>&#39;a</code> in <code>for&lt;&#39;a&gt; fn(&amp;&#39;a u32)</code>ような関数シグネチャにバインドされた領域を指します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A region is &quot;free&quot; if it is not bound.</span>領域が束縛されていない場合、領域は「フリー」です。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Creating an inference context</span>推論コンテキストの作成</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You create and &quot;enter&quot; an inference context by doing something like the following:</span>あなたは、次のようなことをして、推論コンテキストを作成して「入力」します。</span> </p><br><div data-lang=rust,ignore><div data-l="tcx.infer_ctxt().enter(|infcx| {"></div><div data-l="#    // Use the inference context `infcx` here."></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Use the inference context <code>infcx</code> here.</span>ここで推論コンテキスト<code>infcx</code>使用してください。</span> </div><div data-l=})></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Each inference context creates a short-lived type arena to store the fresh types and things that it will create, as described in the <a href=#3ty-ch>chapter on the <code>ty</code> module</a> .</span>それぞれの推論コンテキストは<a href=#3ty-ch>、 <code>ty</code>モジュールの章で</a>説明されているように、作成する新しいタイプとものを格納する短命型のアリーナを作成し<a href=#3ty-ch>ます</a> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This arena is created by the <code>enter</code> function and disposed of after it returns.</span>このアリーナは、 <code>enter</code>機能によって作成され、返された後に処分されます。</span> </p><br> <a class=notranslate href=#1ty.html>ty-ch</a> <br> <p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Within the closure, <code>infcx</code> has the type <code>InferCtxt&lt;&#39;cx, &#39;gcx, &#39;tcx&gt;</code> for some fresh <code>&#39;cx</code> and <code>&#39;tcx</code> – the latter corresponds to the lifetime of this temporary arena, and the <code>&#39;cx</code> is the lifetime of the <code>InferCtxt</code> itself.</span>閉鎖内では、いくつかの新鮮な<code>&#39;cx</code>と<code>&#39;tcx</code>に対して、 <code>infcx</code>は<code>InferCtxt&lt;&#39;cx, &#39;gcx, &#39;tcx&gt;</code>型を<code>InferCtxt&lt;&#39;cx, &#39;gcx, &#39;tcx&gt;</code>後者はこの一時的なアリーナの存続期間に対応し、 <code>&#39;cx</code>は<code>InferCtxt</code>自身。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">(Again, see the <a href=#3ty-ch><code>ty</code> chapter</a> for more details on this setup.)</span> （ここでも、参照<a href=#3ty-ch><code>ty</code>章</a>この設定の詳細については、を。）</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>tcx.infer_ctxt</code> method actually returns a builder, which means there are some kinds of configuration you can do before the <code>infcx</code> is created.</span> <code>tcx.infer_ctxt</code>メソッドは実際にビルダーを返します。 <code>infcx</code> 、 <code>infcx</code>を作成する前にいくつかの設定ができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">See <code>InferCtxtBuilder</code> for more information.</span>詳細については、 <code>InferCtxtBuilder</code>を参照してください。</span> </p><br><p><a name=vars></a></p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Inference variables</span>推論変数</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The main purpose of the inference context is to house a bunch of <b>inference variables</b> – these represent types or regions whose precise value is not yet known, but will be uncovered as we perform type-checking.</span>推論コンテキストの主な目的は、推論<b>変数の</b>束を収容すること<b>です。</b>これらは、正確な値が未知である型または領域を表しますが、型チェックを実行すると明らかになります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you&#39;re familiar with the basic ideas of unification from HM type systems, or logic languages like Prolog, this is the same concept.</span> HM型システムやPrologのような論理言語からの統一の基本的な考え方に精通しているなら、これは同じ概念です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you&#39;re not, you might want to read a tutorial on how HM type inference works, or perhaps this blog post on <a class=notranslate href="#4unification in the Chalk project">unification in the Chalk project</a> .</span>そうでない場合は、HM型推論の仕組みや<a class=notranslate href="#4unification in the Chalk project">unification in the Chalk project</a>に関するブログ記事を読むことをお勧めします。</span> </p><br> <a class=notranslate href=#1http://smallcultfollowing.com/babysteps/blog/2017/03/25/unification-in-chalk-part-1/>Unification in the Chalk project</a> <br> <p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">All told, the inference context stores four kinds of inference variables as of this writing:</span>結論として、推論コンテキストは、この執筆時点で、4種類の推論変数を格納しています。</span> </p><br><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Type variables, which come in three varieties:</span>型変数は、3つの種類があります：</span> </div><div data-b="  -"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">General type variables (the most common).</span>一般的な型変数（最も一般的なもの）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These can be unified with any type.</span>これらはどのタイプでも統一できます。</span> </div><div data-b="  -"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Integral type variables, which can only be unified with an integral type, and arise from an integer literal expression like <code>22</code> .</span>整数型でのみ統一でき、 <code>22</code>ような整数のリテラル式から生まれる整数型変数。</span> </div><div data-b="  -"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Float type variables, which can only be unified with a float type, and arise from a float literal expression like <code>22.0</code> .</span>浮動小数点型変数は、浮動小数点型でのみ統合でき、 <code>22.0</code>ような浮動小数点型のリテラル式から生まれます。</span> </div><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Region variables, which represent lifetimes, and arise all over the place.</span>生存期間を表し、その場全体で発生する領域変数。</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">All the type variables work in much the same way: you can create a new type variable, and what you get is <code>Ty&lt;&#39;tcx&gt;</code> representing an unresolved type <code>?T</code> .</span>あなたは新しいタイプの変数を作成することができ、そして何を得ることである：すべてのタイプの変数は、ほとんど同じように動作する<code>Ty&lt;&#39;tcx&gt;</code>未解決のタイプ表す<code>?T</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then later you can apply the various operations that the inferencer supports, such as equality or subtyping, and it will possibly <b>instantiate</b> (or <b>bind</b> ) that <code>?T</code> to a specific value as a result.</span>その後、等号やサブタイプなどの推論機能がサポートするさまざまな操作を適用することができます。結果として、その<code>?T</code>を特定の値に<b>インスタンス化</b> （または<b>バインド</b> ）し<code>?T</code> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The region variables work somewhat differently, and are described below in a separate section.</span>リージョン変数は多少異なる働きをしますが、以下で別のセクションで説明します。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Enforcing equality / subtyping</span>等価/サブタイプの強制</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The most basic operations you can perform in the type inferencer is <b>equality</b> , which forces two types <code>T</code> and <code>U</code> to be the same.</span>型推論で実行できる最も基本的な操作は<b>等価で</b> 、 <code>T</code>と<code>U</code> 2つの型を同じにします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The recommended way to add an equality constraint is to use the <code>at</code> method, roughly like so:</span>等価制約を追加するための推奨される方法は、 <code>at</code>メソッドを使用することです。</span> </p><br><div data-lang=rust,ignore><div data-l="infcx.at(...).eq(t, u);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The first <code>at()</code> call provides a bit of context, ie why you are doing this unification, and in what environment, and the <code>eq</code> method performs the actual equality constraint.</span>最初の<code>at()</code>コールは少しのコンテキストを提供します。つまり、なぜこの統一を行い、どのような環境で、 <code>eq</code>メソッドが実際の等価制約を実行するのかです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When you equate things, you force them to be precisely equal.</span>あなたが物事を同等にするとき、あなたはそれらが正確に等しくなるように強制します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Equating returns an <code>InferResult</code> – if it returns <code>Err(err)</code> , then equating failed, and the enclosing <code>TypeError</code> will tell you what went wrong.</span> <code>InferResult</code>は<code>InferResult</code>返します。それが<code>Err(err)</code>返した場合、 <code>InferResult</code>失敗し、囲む<code>TypeError</code>は何がうまくいかなかったかを示します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The success case is perhaps more interesting.</span>成功事例はおそらくもっと面白いでしょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The &quot;primary&quot; return type of <code>eq</code> is <code>()</code> – that is, when it succeeds, it doesn&#39;t return a value of any particular interest.</span> <code>eq</code>の「主」戻り値の型は<code>()</code>です。つまり、成功すると、特に関心のある値を返しません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rather, it is executed for its side-effects of constraining type variables and so forth.</span>むしろ、型変数などの制約の副作用のために実行されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, the actual return type is not <code>()</code> , but rather <code>InferOk&lt;()&gt;</code> .</span>しかし、実際の戻り値の型は<code>()</code>ではなく、 <code>InferOk&lt;()&gt;</code>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>InferOk</code> type is used to carry extra trait obligations – your job is to ensure that these are fulfilled (typically by enrolling them in a fulfillment context).</span> <code>InferOk</code>タイプは、特別な義務を負うために使用されます。あなたの仕事は、これらの条件が満たされることを保証することです（通常、履行状況に登録することによって）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">See the <a class=notranslate href="#4trait chapter">trait chapter</a> for more background on that.</span>その背景については、 <a class=notranslate href="#4trait chapter">trait chapter</a>を参照してください。</span> </p><br> <a class=notranslate href=#1traits/resolution.html>trait chapter</a> <br> <p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can similarly enforce subtyping through <code>infcx.at(..).sub(..)</code> .</span>同様に、 <code>infcx.at(..).sub(..)</code>を<code>infcx.at(..).sub(..)</code>してサブタイプを強制することができ<code>infcx.at(..).sub(..)</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The same basic concepts as above apply.</span>上記と同じ基本概念が適用されます。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">&quot;Trying&quot; equality</span>平等を「試す」</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Sometimes you would like to know if it is <i>possible</i> to equate two types without error.</span>場合によっては、エラーなしで2つのタイプを同等にすることが<i>可能</i>かどうかを知りたい場合があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can test that with <code>infcx.can_eq</code> (or <code>infcx.can_sub</code> for subtyping).</span>あなたがそれをテストすることができ<code>infcx.can_eq</code> （または<code>infcx.can_sub</code>サブタイピングのため）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If this returns <code>Ok</code> , then equality is possible – but in all cases, any side-effects are reversed.</span>これが<code>Ok</code>返す場合、等価は可能ですが、すべての場合において副作用が逆転します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Be aware, though, that the success or failure of these methods is always <b>modulo regions</b> .</span>ただし、これらのメソッドの成功または失敗は常に<b>モジュロ領域</b>であることに注意してください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That is, two types <code>&amp;&#39;a u32</code> and <code>&amp;&#39;b u32</code> will return <code>Ok</code> for <code>can_eq</code> , even if <code>&#39;a €= &#39;b</code> .</span>つまり、 <code>&#39;a €= &#39;b</code>であっても、 <code>&amp;&#39;b u32</code> <code>&amp;&#39;a u32</code>と<code>&amp;&#39;b u32</code> 2つの型は、 <code>can_eq</code>に対して<code>Ok</code>を<code>can_eq</code>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This falls out from the &quot;two-phase&quot; nature of how we solve region constraints.</span>これは、地域の制約をどのように解決するかという「2段階」の性質から逸脱しています。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Snapshots</span>スナップショット</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As described in the previous section on <code>can_eq</code> , often it is useful to be able to do a series of operations and then roll back their side-effects.</span> <code>can_eq</code>の前のセクションで説明したように、一連の操作を実行して副作用をロールバックできることがしばしば役に立ちます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is done for various reasons: one of them is to be able to backtrack, trying out multiple possibilities before settling on which path to take.</span>これはさまざまな理由で行われます。そのうちの1つは、取り戻すことができ、複数の可能性を試してから、どのパスを取るか決めることです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Another is in order to ensure that a series of smaller changes take place atomically or not at all.</span>もう一つは、一連の小さな変化が原子的に起こるかどうかを確実にするためです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To allow for this, the inference context supports a <code>snapshot</code> method.</span>これを可能にするために、推論コンテキストは<code>snapshot</code>メソッドをサポートします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When you call it, it will start recording changes that occur from the operations you perform.</span>これを呼び出すと、実行した操作から発生した変更の記録が開始されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When you are done, you can either invoke <code>rollback_to</code> , which will undo those changes, or else <code>confirm</code> , which will make the permanent.</span>完了したら、 <code>rollback_to</code>呼び出すことができます。これは、変更を取り消します。そうでない場合は、 <code>confirm</code>て永続化します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Snapshots can be nested as long as you follow a stack-like discipline.</span>スナップショットは、スタック状の規律に従う限りネストできます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rather than use snapshots directly, it is often helpful to use the methods like <code>commit_if_ok</code> or <code>probe</code> that encapsulate higher-level patterns.</span>スナップショットを直接使うのではなく、より高いレベルのパターンをカプセル化する<code>commit_if_ok</code>や<code>probe</code>ようなメソッドを使うと便利です。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Subtyping obligations</span>サブタイプの義務</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">One thing worth discussing is subtyping obligations.</span>議論する価値のあることの1つは、サブタイプの義務です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When you force two types to be a subtype, like <code>?T &lt;: i32</code> , we can often convert those into equality constraints.</span> <code>?T &lt;: i32</code>ように、2つの型を強制的にサブタイプにすると、それらを等価制約に変換することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This follows from Rust&#39;s rather limited notion of subtyping: so, in the above case, <code>?T &lt;: i32</code> is equivalent to <code>?T = i32</code> .</span>これは、Rustの限定されたサブタイプ化の考え方に従います<code>?T &lt;: i32</code>つまり、上記の場合、 <code>?T &lt;: i32</code>は<code>?T = i32</code>相当し<code>?T = i32</code> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, in some cases we have to be more careful.</span>しかし、場合によってはもっと注意する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, when regions are involved.</span>例えば、領域が関与している場合。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So if you have <code>?T &lt;: &amp;&#39;a i32</code> , what we would do is to first &quot;generalize&quot; <code>&amp;&#39;a i32</code> into a type with a region variable: <code>&amp;&#39;?b i32</code> , and then unify <code>?T</code> with that ( <code>?T = &amp;&#39;?b i32</code> ).</span>あなたが持っているのであれば<code>?T &lt;: &amp;&#39;a i32</code> 、私たちはどうなることはまず『一般』にある<code>&amp;&#39;a i32</code> ：型に領域変数と<code>&amp;&#39;?b i32</code>して、統一<code>?T</code>それと（ <code>?T = &amp;&#39;?b i32</code> ）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We then relate this new variable with the original bound:</span>次に、この新しい変数を元の境界と関連付けます。</span> </p><br><div data-lang=text><div data-l="&amp;'?b i32 &lt;: &amp;'a i32"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This will result in a region constraint (see below) of <code>&#39;?b: &#39;a</code> .</span>これにより、 <code>&#39;?b: &#39;a</code>領域制約（下記参照）が発生し<code>&#39;?b: &#39;a</code> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">One final interesting case is relating two unbound type variables, like <code>?T &lt;: ?U</code> .</span> 1つの最後の興味深いケースは、2つの非結合型変数、例えば<code>?T &lt;: ?U</code>関連付けること<code>?T &lt;: ?U</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In that case, we can&#39;t make progress, so we enqueue an obligation <code>Subtype(?T, ?U)</code> and return it via the <code>InferOk</code> mechanism.</span>その場合、我々は進歩を遂げることができないので、義務<code>Subtype(?T, ?U)</code>をエンキューし、 <code>InferOk</code>メカニズムを介してそれを返します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You&#39;ll have to try again when more details about <code>?T</code> or <code>?U</code> are known.</span> <code>?T</code>か<code>?U</code>についての詳細が分かっ<code>?U</code> 、もう一度やり直す必要があります。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Region constraints</span>地域の制約</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Regions are inferenced somewhat differently from types.</span>リージョンはタイプとは多少推論されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rather than eagerly unifying things, we simply collect constraints as we go, but make (almost) no attempt to solve regions.</span>熱心に物事を統一するのではなく、私たちが行くにつれて制約を集めるだけですが、（ほとんど）地域を解決しようとする試みはありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These constraints have the form of an &quot;outlives&quot; constraint:</span>これらの制約は、「outlives」制約の形式をとります。</span> </p><br><div data-lang=text><div data-l="'a: 'b"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Actually the code tends to view them as a subregion relation, but it&#39;s the same idea:</span>実際には、コードはそれらを部分領域の関係として見る傾向がありますが、同じ考えです。</span> </p><br><div data-lang=text><div data-l="'b &lt;= 'a"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">(There are various other kinds of constraints, such as &quot;verifys&quot;; see the <code>region_constraints</code> module for details.)</span> （ &quot;verifys&quot;など、さまざまな種類の制約があります;詳細については、 <code>region_constraints</code>モジュールを参照してください）。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There is one case where we do some amount of eager unification.</span>私たちがある程度の熱心な統一を行うケースが1つあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you have an equality constraint between two regions</span> 2つの地域の間に等しい制約がある場合</span> </p><br><div data-lang=text><div data-l="'a = 'b"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">we will record that fact in a unification table.</span>その事実を統一表に記録する。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can then use <code>opportunistic_resolve_var</code> to convert <code>&#39;b</code> to <code>&#39;a</code> (or vice versa).</span>その後、 <code>opportunistic_resolve_var</code>を使用して<code>&#39;b</code>を<code>&#39;a</code> （またはその逆）に変換することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is sometimes needed to ensure termination of fixed-point algorithms.</span>これは、固定小数点アルゴリズムの終了を確実にするために必要なことがあります。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Extracting region constraints</span>領域の制約を抽出する</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Ultimately, region constraints are only solved at the very end of type-checking, once all other constraints are known.</span>最終的に、領域制約は、タイプ・チェッキングの最後でのみ解かれます。他のすべての制約がわかっているとします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There are two ways to solve region constraints right now: lexical and non-lexical.</span>今すぐリージョンの制約を解決するには、字句と非字句の2つの方法があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Eventually there will only be one.</span>最終的には1つしかありません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To solve <b>lexical</b> region constraints, you invoke <code>resolve_regions_and_report_errors</code> .</span> <b>字句</b>領域の制約を解決するには、 <code>resolve_regions_and_report_errors</code>を呼び出し<code>resolve_regions_and_report_errors</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This &quot;closes&quot; the region constraint process and invoke the <code>lexical_region_resolve</code> code.</span>これは、領域制約プロセスを「クローズ」し、 <code>lexical_region_resolve</code>コードを呼び出します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Once this is done, any further attempt to equate or create a subtyping relationship will yield an ICE.</span>これが完了すると、サブタイピング関係を同一化または作成しようとするさらなる試みは、ICEを生じる。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Non-lexical region constraints are not handled within the inference context.</span>非語彙領域の制約は、推論コンテキスト内では処理されません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Instead, the NLL solver (actually, the MIR type-checker) invokes <code>take_and_reset_region_constraints</code> periodically.</span>代わりに、NLLソルバ（実際には、MIR型チェッカ）は<code>take_and_reset_region_constraints</code>定期的に呼び出します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This extracts all of the outlives constraints from the region solver, but leaves the set of variables intact.</span>これは、領域ソルバからすべてのアウトライブ制約を抽出しますが、変数セットはそのまま残します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is used to get <i>just</i> the region constraints that resulted from some particular point in the program, since the NLL solver needs to know not just <i>what</i> regions were subregions but <i>where</i> .</span> NLLソルバは領域がサブ領域が、 <i>どこ</i>だっただけでなく、 <i>何を</i>知っている必要があるので、これは、プログラム内のいくつかの特定のポイントに起因する<i>だけで</i>地域の制約を取得するために使用されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Finally, the NLL solver invokes <code>take_region_var_origins</code> , which &quot;closes&quot; the region constraint process in the same way as normal solving.</span>最後に、NLLソルバは<code>take_region_var_origins</code>呼び出し、通常の解決と同じ方法で領域制約プロセスを「閉じる」。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Lexical region resolution</span>字句領域の解像度</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Lexical region resolution is done by initially assigning each region variable to an empty value.</span>字句領域の解決は、各領域変数を最初に空の値に割り当てることによって行われます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We then process each outlives constraint repeatedly, growing region variables until a fixed-point is reached.</span>その後、各アウトライブ制約を繰り返し処理し、固定小数点に達するまで領域変数を拡張します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Region variables can be grown using a least-upper-bound relation on the region lattice in a fairly straightforward fashion.</span>領域変数は、かなり単純な方法で領域格子上の最小上界関係を用いて成長させることができる。</span> </p><script>_addload(function(){_setupIW('com');_csi('en','ja','type-inference.html');});</script>