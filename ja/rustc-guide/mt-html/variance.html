<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180723_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=variance.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Variance of type and lifetime parameters</span>タイプと寿命パラメータの差異</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For a more general background on variance, see the <a class=notranslate href=#4background>background</a> appendix.</span>分散に関するより一般的な背景については、 <a class=notranslate href=#4background>background</a>付録を参照してください。</span> </p><br> <a class=notranslate href=#1./appendix/background.html>background</a> <br> <p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">During type checking we must infer the variance of type and lifetime parameters.</span>タイプチェックの際には、タイプと寿命パラメータの分散を推測する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The algorithm is taken from Section 4 of the paper <a href=#3pldi11>&quot;Taming the Wildcards: Combining Definition- and Use-Site Variance&quot;</a> published in PLDI&#39;11 and written by Altidor et al., and hereafter referred to as The Paper.</span>このアルゴリズムは、PLDI&#39;11で出版され、Altidorらによって書かれた、以後「The Paper」と呼ばれる論文<a href=#3pldi11>「ワイルドカードを飼いならすこと：定義と使用の場所の差異を組み合わせる」の</a>第4章から取られている。</span> </p><br> <a class=notranslate href=#1https://people.cs.umass.edu/~yannis/variance-extended2011.pdf>pldi11</a> <br> <p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This inference is explicitly designed <i>not</i> to consider the uses of types within code.</span>この推論は、コード内の型の使用を考慮し<i>ない</i>ように明示的に設計されて<i>い</i>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To determine the variance of type parameters defined on type <code>X</code> , we only consider the definition of the type <code>X</code> and the definitions of any types it references.</span>タイプ<code>X</code>で定義されたタイプパラメータの分散を決定するために、タイプ<code>X</code>の定義とそれが参照するタイプの定義のみを考慮する。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We only infer variance for type parameters found on <i>data types</i> like structs and enums.</span>構造体や列挙<i>型</i>などの<i>データ型で</i>見つかった型パラメータの分散のみを推測します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In these cases, there is a fairly straightforward explanation for what variance means.</span>このような場合には、分散が何を意味するのかについて、かなり簡単な説明があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The variance of the type or lifetime parameters defines whether <code>T&lt;A&gt;</code> is a subtype of <code>T&lt;B&gt;</code> (resp. <code>T&lt;&#39;a&gt;</code> and <code>T&lt;&#39;b&gt;</code> ) based on the relationship of <code>A</code> and <code>B</code> (resp. <code>&#39;a</code> and <code>&#39;b</code> ).</span>タイプまたはライフタイムパラメータの分散は、 <code>A</code>と<code>B</code>関係に基づいて<code>T&lt;A&gt;</code>が<code>T&lt;B&gt;</code> （ <code>T&lt;&#39;a&gt;</code>と<code>T&lt;&#39;b&gt;</code> ）のサブタイプであるかどうかを定義<code>&#39;a</code>と<code>&#39;b</code> ）。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We do not infer variance for type parameters found on traits, functions, or impls.</span>私たちは、形質、関数、またはインプリメンテーション上に見いだされるタイプのパラメータについては、分散を推測しません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Variance on trait parameters can indeed make sense (and we used to compute it) but it is actually rather subtle in meaning and not that useful in practice, so we removed it.</span>特性パラメータの差異は実際には意味をなさない（そして、それを計算するために使用された）が、実際には意味が微妙であり、実用的ではないので、削除した。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">See the <a class=notranslate href=#4addendum>addendum</a> for some details.</span>詳細は<a class=notranslate href=#4addendum>addendum</a>を参照してください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Variances on function/impl parameters, on the other hand, doesn&#39;t make sense because these parameters are instantiated and then forgotten, they don&#39;t persist in types or compiled byproducts.</span>一方、関数/ implパラメータの分散は、これらのパラメータがインスタンス化されてから忘れられるため、型やコンパイルされた副産物に残らないため、意味をなさない。</span> </p><br> <a class=notranslate href=#1#addendum>addendum</a> <br> <blockquote><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><b>Notation</b></span> <b>記法</b></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We use the notation of The Paper throughout this chapter:</span>この章では、The Paperの表記法を使用しています。</span> </p><br><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>+</code> is <s>covariance</s> .</span> <code>+</code>は<s>共分散である</s> 。</span> </div><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>-</code> is <s>contravariance</s> .</span> <code>-</code> <s>反共分散</s>です。</span> </div><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>*</code> is <s>bivariance</s> .</span> <code>*</code>は二<s>変数</s>です。</span> </div><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>o</code> is <s>invariance</s> .</span> <code>o</code>は<s>不変である</s> 。</span> </div></blockquote><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The algorithm</span>アルゴリズム</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The basic idea is quite straightforward.</span>基本的な考え方はとても簡単です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We iterate over the types defined and, for each use of a type parameter <code>X</code> , accumulate a constraint indicating that the variance of <code>X</code> must be valid for the variance of that use site.</span>定義された型を反復し、型パラメータ<code>X</code>使用するたびに、 <code>X</code>の分散がその使用サイトの分散に対して有効でなければならないことを示す制約を累積します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We then iteratively refine the variance of <code>X</code> until all constraints are met.</span>次に、すべての制約が満たされるまで<code>X</code>の分散を繰り返し調整します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There is <i>always</i> a solution, because at the limit we can declare all type parameters to be invariant and all constraints will be satisfied.</span>制限があると、すべての型パラメーターを不変であると宣言でき、すべての制約が満たされるため、 <i>常に</i>解があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As a simple example, consider:</span>簡単な例として、次の点を考慮してください。</span> </p><br><div data-lang=rust,ignore><div data-l="enum Option&lt;A&gt; { Some(A), None }"></div><div data-l="enum OptionalFn&lt;B&gt; { Some(|B|), None }"></div><div data-l="enum OptionalMap&lt;C&gt; { Some(|C| -&gt; C), None }"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here, we will generate the constraints:</span>ここでは、制約を生成します。</span> </p><br><div data-lang=text><div data-l="1. V(A) &lt;= +"></div><div data-l="2. V(B) &lt;= -"></div><div data-l="3. V(C) &lt;= +"></div><div data-l="4. V(C) &lt;= -"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These indicate that (1) the variance of A must be at most covariant;</span>これらは、（1）Aの分散が最大で共変でなければならないこと、</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">(2) the variance of B must be at most contravariant;</span> （2）Bの分散は、ほとんど反則でなければならない。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">and (3, 4) the variance of C must be at most covariant <i>and</i> contravariant.</span> （3、4）Cの分散は、最大で共変<i>で</i>反変でなければならない。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">All of these results are based on a variance lattice defined as follows:</span>これらの結果はすべて、次のように定義された分散格子に基づいています。</span> </p><br><div data-lang=text><div data-l="   *      Top (bivariant)"></div><div data-l="-     +"></div><div data-l="   o      Bottom (invariant)"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Based on this lattice, the solution <code>V(A)=+</code> , <code>V(B)=-</code> , <code>V(C)=o</code> is the optimal solution.</span>この格子に基づいて、解<code>V(A)=+</code> 、 <code>V(B)=-</code> 、 <code>V(C)=o</code>が最適解です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that there is always a naive solution which just declares all variables to be invariant.</span>すべての変数を不変であると宣言するという単純な解法は常に存在することに注意してください。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You may be wondering why fixed-point iteration is required.</span>なぜ固定小数点の反復が必要なのか疑問に思うかもしれません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The reason is that the variance of a use site may itself be a function of the variance of other type parameters.</span>その理由は、使用サイトの分散自体が、他のタイプのパラメータの分散の関数である可能性があるためです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In full generality, our constraints take the form:</span>完全な一般性において、制約は以下の形をとる：</span> </p><br><div data-lang=text><div data-l="V(X) &lt;= Term"></div><div data-l="Term := + | - | * | o | V(X) | Term x Term"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here the notation <code>V(X)</code> indicates the variance of a type/region parameter <code>X</code> with respect to its defining class.</span>ここで、表記<code>V(X)</code>は、型/領域パラメータ<code>X</code>定義クラスに対する分散を示す。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>Term x Term</code> represents the &quot;variance transform&quot; as defined in the paper:</span> <code>Term x Term</code>は、論文で定義されている「分散変換」を表します。</span> </p><br><blockquote><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If the variance of a type variable <code>X</code> in type expression <code>E</code> is <code>V2</code> and the definition-site variance of the <a class=notranslate href=#4corresponding>corresponding</a> type parameter of a class <code>C</code> is <code>V1</code> , then the variance of <code>X</code> in the type expression <code>C&lt;E&gt;</code> is <code>V3 = V1.xform(V2)</code> .</span>タイプ表現<code>E</code>タイプ変数<code>X</code>の分散が<code>V2</code>あり、クラス<code>C</code> <a class=notranslate href=#4corresponding>corresponding</a>タイプパラメータの定義サイト分散が<code>V1</code>である場合、タイプ表現<code>C&lt;E&gt;</code>の<code>X</code>の分散は<code>V3 = V1.xform(V2)</code> 。</span> </p></blockquote><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Constraints</span>制約</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If I have a struct or enum with where clauses:</span>構造体またはenumのwhere句がある場合：</span> </p><br><div data-lang=rust,ignore><div data-l="struct Foo&lt;T: Bar&gt; { ... }"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">you might wonder whether the variance of <code>T</code> with respect to <code>Bar</code> affects the variance <code>T</code> with respect to <code>Foo</code> .</span> <code>Bar</code>に対する<code>T</code>の分散が<code>Foo</code>に対する分散<code>T</code>影響するかどうか疑問に思うかもしれません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">I claim no.</span>私はノーと主張する。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The reason: assume that <code>T</code> is invariant with respect to <code>Bar</code> but covariant with respect to <code>Foo</code> .</span>その理由は、 <code>T</code>は<code>Bar</code>に対して不変であるが、 <code>Foo</code>に関しては共変であると仮定する。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">And then we have a <code>Foo&lt;X&gt;</code> that is upcast to <code>Foo&lt;Y&gt;</code> , where <code>X &lt;: Y</code> .</span>そして、 <code>Foo&lt;X&gt;</code>が<code>Foo&lt;Y&gt;</code>アップキャストされています（ <code>X &lt;: Y</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, while <code>X : Bar</code> , <code>Y : Bar</code> does not hold.</span>ただし、 <code>X : Bar</code> 、 <code>Y : Bar</code>は保持されません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In that case, the upcast will be illegal, but not because of a variance failure, but rather because the target type <code>Foo&lt;Y&gt;</code> is itself just not well-formed.</span>その場合、アップキャストは違法ですが、分散障害のためではなく、むしろ目標タイプ<code>Foo&lt;Y&gt;</code>自体がうまく構成されていないためです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Basically we get to assume well-formedness of all types involved before considering variance.</span>基本的には、分散を考慮する前に、すべてのタイプの整形式を仮定します。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Dependency graph management</span>依存関係グラフ管理</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because variance is a whole-crate inference, its dependency graph can become quite muddled if we are not careful.</span>分散は全クレート推論であるため、従属グラフは注意を払わないとかなり混乱することがあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To resolve this, we refactor into two queries:</span>これを解決するために、2つのクエリにリファクタリングします。</span> </p><br><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>crate_variances</code> computes the variance for all items in the current crate.</span> <code>crate_variances</code>は、現在のクレート内のすべてのアイテムの分散を計算します。</span> </div><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>variances_of</code> accesses the variance for an individual reading;</span> <code>variances_of</code>は個々の読み値の<code>variances_of</code>アクセスします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">it works by requesting <code>crate_variances</code> and extracting the relevant data.</span> <code>crate_variances</code>を要求し、関連するデータを抽出することによって動作します。</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you limit yourself to reading <code>variances_of</code> , your code will only depend then on the inference of that particular item.</span>あなたが読書の<code>variances_of</code>に自分自身を制限するなら、あなたのコードはその特定のアイテムの推論に依存するだけです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Ultimately, this setup relies on the <a href=#3rga>red-green algorithm</a> .</span>最終的に、この設定は<a href=#3rga>赤緑アルゴリズムに</a>依存し<a href=#3rga>ます</a> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In particular, every variance query effectively depends on all type definitions in the entire crate (through <code>crate_variances</code> ), but since most changes will not result in a change to the actual results from variance inference, the <code>variances_of</code> query will wind up being considered green after it is re-evaluated.</span>特に、すべての分散クエリは効果的に（ <code>crate_variances</code>を<code>crate_variances</code> ）クレート全体のすべての型定義に依存しますが、ほとんどの変更は分散推論の実際の結果に変化をもたらさないため、 <code>variances_of</code>後に緑色と見なされます再評価される。</span> </p><br> <a class=notranslate href=#1./incremental-compilation.html>rga</a> <br> <p><a name=addendum></a></p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Addendum: Variance on traits</span>補遺：形質の差異</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As mentioned above, we used to permit variance on traits.</span>上記のように、私たちは形質の差異を許容するために使用しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This was computed based on the appearance of trait type parameters in method signatures and was used to represent the compatibility of vtables in trait objects (and also &quot;virtual&quot; vtables or dictionary in trait bounds).</span>これは、メソッドシグネチャの特性タイプパラメータの出現に基づいて計算され、特性オブジェクト（および「仮想」vtableまたは特性境界内の辞書）におけるvtableの互換性を表すために使用されました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">One complication was that variance for associated types is less obvious, since they can be projected out and put to myriad uses, so it&#39;s not clear when it is safe to allow <code>X&lt;A&gt;::Bar</code> to vary (or indeed just what that means).</span> 1つの複雑な問題は、関連する型の分散があまり明白でないことです。なぜなら、それらを投射して無数の用途に使うことができるからです<code>X&lt;A&gt;::Bar</code>を変えることが安全かどうかは分かりません（あるいは、 ）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Moreover (as covered below) all inputs on any trait with an associated type had to be invariant, limiting the applicability.</span>さらに、関連する型を持つ任意の形質のすべての入力は不変でなければならず、適用性が制限されていました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Finally, the annotations ( <code>MarkerTrait</code> , <code>PhantomFn</code> ) needed to ensure that all trait type parameters had a variance were confusing and annoying for little benefit.</span>最後に、すべての特性タイプパラメータにばらつきがあることを保証するために必要な注釈（ <code>MarkerTrait</code> 、 <code>PhantomFn</code> ）は、ほとんど利益を得ずに混乱し迷惑になりました。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Just for historical reference, I am going to preserve some text indicating how one could interpret variance and trait matching.</span>歴史的な参考のために、私は分散と形質のマッチングをどのように解釈できるかを示すテキストを保存します。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Variance and object types</span>差異およびオブジェクトタイプ</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Just as with structs and enums, we can decide the subtyping relationship between two object types <code>&amp;Trait&lt;A&gt;</code> and <code>&amp;Trait&lt;B&gt;</code> based on the relationship of <code>A</code> and <code>B</code> .</span>構造体と列挙型と同様に、 <code>A</code>と<code>B</code>関係に基づいて、2つのオブジェクト型<code>&amp;Trait&lt;A&gt;</code>と<code>&amp;Trait&lt;B&gt;</code>間のサブタイプの関係を決定できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that for object types we ignore the <code>Self</code> type parameter – it is unknown, and the nature of dynamic dispatch ensures that we will always call a function that is expected the appropriate <code>Self</code> type.</span>オブジェクト型の場合、 <code>Self</code>型パラメータは無視されます。これは不明です。動的ディスパッチの性質上、適切な<code>Self</code>型の関数が常に呼び出されることに注意してください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, we must be careful with the other type parameters, or else we could end up calling a function that is expecting one type but provided another.</span>しかし、他の型のパラメータに注意する必要があります。そうでなければ、ある型を予期しているが別の型を提供している関数を呼び出すことになります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To see what I mean, consider a trait like so:</span>私が何を意味するかを見るには、次のような特性を考えてみましょう：</span> </p><br><div data-lang=rust><div data-l="trait ConvertTo&lt;A&gt; {"></div><div data-l="    fn convertTo(&amp;self) -&gt; A;"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Intuitively, If we had one object <code>O=&amp;ConvertTo&lt;Object&gt;</code> and another <code>S=&amp;ConvertTo&lt;String&gt;</code> , then <code>S &lt;: O</code> because <code>String &lt;: Object</code> (presuming Java-like &quot;string&quot; and &quot;object&quot; types, my go to examples for subtyping).</span>直感的に、もし私たちが1つのオブジェクト<code>O=&amp;ConvertTo&lt;Object&gt;</code> 1つの<code>S=&amp;ConvertTo&lt;String&gt;</code>を持っていれば、 <code>S &lt;: O</code> <code>String &lt;: Object</code> （Javaのような &quot;string&quot;と &quot;object&quot;サブタイピングのため）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The actual algorithm would be to compare the (explicit) type parameters pairwise respecting their variance: here, the type parameter A is covariant (it appears only in a return position), and hence we require that <code>String &lt;: Object</code> .</span>実際のアルゴリズムは、その分散を考慮して（明示的な）型パラメータをペアで比較することです：ここでは、型パラメータAは共変（戻り位置にのみ現れる）なので、 <code>String &lt;: Object</code>必要です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You&#39;ll note though that we did not consider the binding for the (implicit) <code>Self</code> type parameter: in fact, it is unknown, so that&#39;s good.</span>しかし、（暗黙の） <code>Self</code>型パラメータのバインディングは考慮していませんが、実際は不明です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The reason we can ignore that parameter is precisely because we don&#39;t need to know its value until a call occurs, and at that time (as you said) the dynamic nature of virtual dispatch means the code we run will be correct for whatever value <code>Self</code> happens to be bound to for the particular object whose method we called.</span>そのパラメータを無視できる理由は、コールが発生するまでその値を知る必要がないため、その時点で（バーチャルディスパッチの動的な性質は、実行するコードがどんな値であれ正しい私たちが呼び出したメソッドを持つ特定のオブジェクトに対しては、 <code>Self</code>が縛られてしまいます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>Self</code> is thus different from <code>A</code> , because the caller requires that <code>A</code> be known in order to know the return type of the method <code>convertTo()</code> .</span> <code>Self</code>から従って異なる<code>A</code>発信者がいることを必要とするので、メソッドの戻り型を知るために知られている<code>A</code> <code>convertTo()</code></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">(As an aside, we have rules preventing methods where <code>Self</code> appears outside of the receiver position from being called via an object.)</span> （例外として、受信者の位置の外に出現する<code>Self</code>がオブジェクトを介して呼び出されるのを防ぐルールがあります）。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Trait variance and vtable resolution</span>特性の分散とvtableの解像度</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But traits aren&#39;t only used with objects.</span>しかし、形質は対象物とともに使用されるだけではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">They&#39;re also used when deciding whether a given impl satisfies a given trait bound.</span>与えられたimplが与えられた特性境界を満たすかどうかを決めるときにも使われます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To set the scene here, imagine I had a function:</span>ここでシーンを設定するには、私は関数があると想像してください：</span> </p><br><div data-lang=rust,ignore><div data-l="fn convertAll&lt;A,T:ConvertTo&lt;A&gt;&gt;(v: &amp;[T]) { ... }"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now imagine that I have an implementation of <code>ConvertTo</code> for <code>Object</code> :</span>さて、 <code>Object</code>の<code>ConvertTo</code>実装があるとしましょう。</span> </p><br><div data-lang=rust,ignore><div data-l="impl ConvertTo&lt;i32&gt; for Object { ... }"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">And I want to call <code>convertAll</code> on an array of strings.</span>そして、私は文字列の配列に対して<code>convertAll</code>を呼びたいと思います。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Suppose further that for whatever reason I specifically supply the value of <code>String</code> for the type parameter <code>T</code> :</span>さらに何らかの理由で、型パラメータ<code>T</code>に<code>String</code>の値を指定するとします：</span> </p><br><div data-lang=rust,ignore><div data-l="let mut vector = vec![&quot;string&quot;, ...];"></div><div data-l="convertAll::&lt;i32, String&gt;(vector);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Is this legal?</span>これは合法ですか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To put another way, can we apply the <code>impl</code> for <code>Object</code> to the type <code>String</code> ?</span>別の言い方をすれば、 <code>String</code>の型に<code>Object</code>の<code>impl</code>を適用できますか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The answer is yes, but to see why we have to expand out what will happen:</span>答えは「はい」ですが、何が起こるのかを広げなければならない理由を知るためです。</span> </p><br><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>convertAll</code> will create a pointer to one of the entries in the vector, which will have type <code>&amp;String</code></span> <code>convertAll</code>はベクトル内のエントリの1つを指すポインタを作成します。このポインタはタイプ<code>&amp;String</code>を持ちます</span> </div><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It will then call the impl of <code>convertTo()</code> that is intended for use with objects.</span>次に、オブジェクトで使用する<code>convertTo()</code> implを呼び出します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This has the type <code>fn(self: &amp;Object) -&gt; i32</code> .</span>これはタイプ<code>fn(self: &amp;Object) -&gt; i32</code>です。</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It is OK to provide a value for <code>self</code> of type <code>&amp;String</code> because <code>&amp;String &lt;: &amp;Object</code> .</span>のための価値を提供するためにOKである<code>self</code>タイプの<code>&amp;String</code>理由<code>&amp;String &lt;: &amp;Object</code> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">OK, so intuitively we want this to be legal, so let&#39;s bring this back to variance and see whether we are computing the correct result.</span>そう、直感的に私たちはこれが合法であることを望んでいるので、これを分散して、正しい結果を計算しているかどうかを見てみましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We must first figure out how to phrase the question &quot;is an impl for <code>Object,i32</code> usable where an impl for <code>String,i32</code> is expected?&quot;</span>私たちはまず、 &quot; <code>String,i32</code>が期待されるところで<code>Object,i32</code>使える<code>Object,i32</code>ですか？&quot;</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Maybe it&#39;s helpful to think of a dictionary-passing implementation of type classes.</span>おそらく、型クラスのディクショナリを渡す実装を考えてみると便利です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In that case, <code>convertAll()</code> takes an implicit parameter representing the impl.</span>その場合、 <code>convertAll()</code>はimplを表す暗黙のパラメータをとります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In short, we <i>have</i> an impl of type:</span>つまり、次の<i>よう</i>なタイプのインプリメンテーションがあります。</span> </p><br><div data-lang=text><div data-l="V_O = ConvertTo&lt;i32&gt; for Object"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">and the function prototype expects an impl of type:</span>関数プロトタイプは型のimplを期待しています：</span> </p><br><div data-lang=text><div data-l="V_S = ConvertTo&lt;i32&gt; for String"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As with any argument, this is legal if the type of the value given ( <code>V_O</code> ) is a subtype of the type expected ( <code>V_S</code> ).</span>任意の引数と同様に、指定された値の型（ <code>V_O</code> ）が期待される型（ <code>V_S</code> ）のサブタイプである場合、これは正当です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So is <code>V_O &lt;: V_S</code> ?</span> <code>V_O &lt;: V_S</code>ですか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The answer will depend on the variance of the various parameters.</span>答えは、さまざまなパラメータの分散に依存します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this case, because the <code>Self</code> parameter is contravariant and <code>A</code> is covariant, it means that:</span>この場合、 <code>Self</code>パラメータは反変で<code>A</code>は共変であるため、次のことを意味します。</span> </p><br><div data-lang=text><div data-l="V_O &lt;: V_S iff"></div><div data-l="    i32 &lt;: i32"></div><div data-l="    String &lt;: Object"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These conditions are satisfied and so we are happy.</span>これらの条件は満たされており、満足しています。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Variance and associated types</span>差異および関連タイプ</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Traits with associated types – or at minimum projection expressions – must be invariant with respect to all of their inputs.</span>関連する型（または最小限の射影式）を持つ特性は、すべての入力に対して不変でなければなりません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To see why this makes sense, consider what subtyping for a trait reference means:</span>なぜこれが理にかなっているかを知るためには、形質の参照のためにどのようなサブタイプが意味するのかを検討してください：</span> </p><br><div data-lang=text><div data-l="&lt;T as Trait&gt; &lt;: &lt;U as Trait&gt;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">means that if I know that <code>T as Trait</code> , I also know that <code>U as Trait</code> .</span>私が<code>T as Trait</code>知っているなら、私<code>U as Trait</code>も知っていることを意味します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Moreover, if you think of it as dictionary passing style, it means that a dictionary for <code>&lt;T as Trait&gt;</code> is safe to use where a dictionary for <code>&lt;U as Trait&gt;</code> is expected.</span>また、辞書を通り抜けるスタイルと考えると、 <code>&lt;T as Trait&gt;</code>の辞書は、 <code>&lt;U as Trait&gt;</code>辞書が期待される場所での使用が安全であることを意味します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The problem is that when you can project types out from <code>&lt;T as Trait&gt;</code> , the relationship to types projected out of <code>&lt;U as Trait&gt;</code> is completely unknown unless <code>T==U</code> (see #21726 for more details).</span>問題は、 <code>&lt;T as Trait&gt;</code>から投影すると、 <code>T==U</code> （詳細については＃21726を参照）がない限り、 <code>&lt;U as Trait&gt;</code>から投影された型への関係は完全に不明です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Making <code>Trait</code> invariant ensures that this is true.</span> <code>Trait</code>不変にすることは、これが正しいことを保証する。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Another related reason is that if we didn&#39;t make traits with associated types invariant, then projection is no longer a function with a single result.</span>もう一つの関連する理由は、関連する型が不変な特性を作成しなければ、射影はもはや単一の結果を持つ関数ではないということです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Consider:</span>検討してください：</span> </p><br><div data-lang=rust,ignore><div data-l="trait Identity { type Out; fn foo(&amp;self); }"></div><div data-l="impl&lt;T&gt; Identity for T { type Out = T; ... }"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now if I have <code>&lt;&amp;&#39;static () as Identity&gt;::Out</code> , this can be validly derived as <code>&amp;&#39;a ()</code> for any <code>&#39;a</code> :</span>今、私が<code>&lt;&amp;&#39;static () as Identity&gt;::Out</code>を持っていれば、これは有効に<code>&amp;&#39;a ()</code> for <code>&#39;a</code></span> </p><br><div data-lang=text><div data-l="&lt;&amp;'a () as Identity&gt; &lt;: &lt;&amp;'static () as Identity&gt;"></div><div data-l="if &amp;'static () &lt; : &amp;'a ()   -- Identity is contravariant in Self"></div><div data-l="if 'static : 'a             -- Subtyping rules for relations"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This change otoh means that <code>&lt;&#39;static () as Identity&gt;::Out</code> is always <code>&amp;&#39;static ()</code> (which might then be upcast to <code>&#39;a ()</code> , separately).</span>この変更は、 <code>&lt;&#39;static () as Identity&gt;::Out</code> <code>&amp;&#39;static ()</code>が常に<code>&amp;&#39;static ()</code> （別名<code>&#39;a ()</code>にアップキャストされる可能性があること）を意味します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This was helpful in solving #21750.</span>これは＃21750の解決に役立ちました。</span> </p><script>_addload(function(){_setupIW('com');_csi('en','ja','variance.html');});</script>