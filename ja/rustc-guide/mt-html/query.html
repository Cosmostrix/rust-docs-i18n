<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180723_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=query.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Queries: demand-driven compilation</span>クエリ：需要主導のコンパイル</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As described in <a href=#3hl>the high-level overview of the compiler</a> , the Rust compiler is current transitioning from a traditional &quot;pass-based&quot; setup to a &quot;demand-driven&quot; system.</span> <a href=#3hl>コンパイラの概要で</a>説明し<a href=#3hl>た</a>ように<a href=#3hl>、</a> Rustコンパイラは、従来の「パスベース」のセットアップから「デマンド駆動」のシステムに移行しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><b>The Compiler Query System is the key to our new demand-driven organization.</b></span> <b>コンパイラクエリシステムは、新しい需要主導の組織の鍵です。</b></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The idea is pretty simple.</span>アイデアはかなり簡単です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You have various queries that compute things about the input – for example, there is a query called <code>type_of(def_id)</code> that, given the def-id of some item, will compute the type of that item and return it to you.</span>たとえば、ある項目のdef-idを指定すると、 <code>type_of(def_id)</code>というクエリがあり、その項目の型を計算して返すなど、入力に関するものを計算するさまざまなクエリがあります。</span> </p><br> <a class=notranslate href=#1high-level-overview.html>hl</a> <br> <p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Query execution is <b>memoized</b> – so the first time you invoke a query, it will go do the computation, but the next time, the result is returned from a hashtable.</span>クエリの実行は<b>メモされ</b>ます。最初にクエリを呼び出すと計算が実行されますが、次回はハッシュテーブルから結果が返されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Moreover, query execution fits nicely into <b>incremental computation</b> ;</span>さらに、クエリの実行は<b>インクリメンタルな計算に</b>うまく収まり<b>ます</b> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">the idea is roughly that, when you do a query, the result <b>may</b> be returned to you by loading stored data from disk (but that&#39;s a separate topic we won&#39;t discuss further here).</span>その考えはおおまかに言えば、クエリを実行すると、格納されたデータをディスクからロードすることによって結果<b>が</b>返されることがあります（ただし、ここではこれ以上は説明しません）。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The overall vision is that, eventually, the entire compiler control-flow will be query driven.</span>全体的なビジョンは、最終的に、コンパイラの制御フロー全体がクエリ駆動型であることです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There will effectively be one top-level query (&quot;compile&quot;) that will run compilation on a crate;</span>効果的にクレートでコンパイルを実行するトップレベルクエリ（「コンパイル」）が1つあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">this will in turn demand information about that crate, starting from the <i>end</i> .</span>これは、 <i>最終的に</i> 、そのクレートについての情報を要求する。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example:</span>例えば：</span> </p><br><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This &quot;compile&quot; query might demand to get a list of codegen-units (ie modules that need to be compiled by LLVM).</span>この &quot;コンパイル&quot;クエリは、codegen-units（すなわち、LLVMによってコンパイルされる必要があるモジュール）のリストを取得することを要求するかもしれません。</span> </div><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But computing the list of codegen-units would invoke some subquery that returns the list of all modules defined in the Rust source.</span>しかしcodegen-unitsのリストを計算すると、Rustソースに定義されているすべてのモジュールのリストを返すサブクエリが呼び出されます。</span> </div><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That query in turn would invoke something asking for the HIR.</span>その照会は、HIRを求める何かを呼び出すでしょう。</span> </div><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This keeps going further and further back until we wind up doing the actual parsing.</span>これは、実際の解析を行うまで、さらに進んでいきます。</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, that vision is not fully realized.</span>しかし、そのビジョンは完全には実現されていません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Still, big chunks of the compiler (for example, generating MIR) work exactly like this.</span>それでも、コンパイラの大きなチャンク（例えば、MIRを生成する）は、これとまったく同じように動作します。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Invoking queries</span>クエリの呼び出し</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To invoke a query is simple.</span>クエリを呼び出すのは簡単です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The tcx (&quot;type context&quot;) offers a method for each defined query.</span> tcx（ &quot;type context&quot;）は、定義された各クエリのメソッドを提供します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So, for example, to invoke the <code>type_of</code> query, you would just do this:</span>たとえば、 <code>type_of</code>クエリを呼び出すには、次のようにします。</span> </p><br><div data-lang=rust,ignore><div data-l="let ty = tcx.type_of(some_def_id);"></div></div><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Cycles between queries</span>クエリ間のサイクル数</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A cycle is when a query becomes stuck in a loop eg query A generates query B which generates query A again.</span> 1つのサイクルは、クエリがループ内でスタックになった場合などです。たとえば、クエリAはクエリAを再度生成するクエリBを生成します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Currently, cycles during query execution should always result in a compilation error.</span>現在、クエリ実行中のサイクルでは、常にコンパイルエラーが発生します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Typically, they arise because of illegal programs that contain cyclic references they shouldn&#39;t (though sometimes they arise because of compiler bugs, in which case we need to factor our queries in a more fine-grained fashion to avoid them).</span>一般に、コンパイラのバグのために発生することはありますが、コンパイラのバグのために発生することもありますが、コンパイラのバグを避けるためには、より詳細なファクタをファクタ化する必要があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, it is nonetheless often useful to <i>recover</i> from a cycle (after reporting an error, say) and try to soldier on, so as to give a better user experience.</span>しかし、それでも、（エラーを報告した後に）サイクルから<i>回復</i>し、より良いユーザーエクスペリエンスを提供するために兵士に挑戦することはしばしば有益です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In order to recover from a cycle, you don&#39;t get to use the nice method-call-style syntax.</span>サイクルから回復するために、niceメソッド呼び出しスタイルの構文を使用する必要はありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Instead, you invoke using the <code>try_get</code> method, which looks roughly like this:</span>代わりに、 <code>try_get</code>メソッドを使用して呼び出します。これは、おおよそ次のようになります。</span> </p><br><div data-lang=rust,ignore><div data-l="use ty::queries;"></div><div data-l=...></div><div data-l="match queries::type_of::try_get(tcx, DUMMY_SP, self.did) {"></div><div data-l="  Ok(result) =&gt; {"></div><div data-l="#    // no cycle occurred! You can use `result`"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">no cycle occurred!</span>サイクルは起こらなかった！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can use <code>result</code></span> <code>result</code>を使用することができます</span> </div><div data-l="  }"></div><div data-l="  Err(err) =&gt; {"></div><div data-l="#    // A cycle occurred! The error value `err` is a `DiagnosticBuilder`,"></div><div data-l="#    // meaning essentially an &quot;in-progress&quot;, not-yet-reported error message."></div><div data-l="#    // See below for more details on what to do here."></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A cycle occurred!</span>サイクルが発生しました！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The error value <code>err</code> is a <code>DiagnosticBuilder</code> , meaning essentially an &quot;in-progress&quot;, not-yet-reported error message.</span>エラー値<code>err</code>は<code>DiagnosticBuilder</code>であり、基本的には「進行中」で、まだ報告されていないエラーメッセージです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">See below for more details on what to do here.</span>ここで何をするかの詳細については、以下を参照してください。</span> </div><div data-l="  }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So, if you get back an <code>Err</code> from <code>try_get</code> , then a cycle <i>did</i> occur.</span>したがって、 <code>try_get</code>から<code>Err</code>を<code>try_get</code>と、サイクル<i>が</i>発生しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This means that you must ensure that a compiler error message is reported.</span>つまり、コンパイラーのエラーメッセージが確実に報告されるようにする必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can do that in two ways:</span>あなたは2つの方法でそれを行うことができます：</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The simplest is to invoke <code>err.emit()</code> .</span>最も簡単なのは、 <code>err.emit()</code>を呼び出すこと<code>err.emit()</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This will emit the cycle error to the user.</span>これにより、サイクルエラーがユーザに出されます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, often cycles happen because of an illegal program, and you know at that point that an error either already has been reported or will be reported due to this cycle by some other bit of code.</span>しかし、不正なプログラムのためにサイクルが頻繁に発生し、その時点でエラーが既に報告されているか、このサイクルのために他のコードによって報告されることがあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In that case, you can invoke <code>err.cancel()</code> to not emit any error.</span>その場合、 <code>err.cancel()</code>を呼び出してエラーを出さないようにすることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It is traditional to then invoke:</span>次にそれを呼び出すのは伝統的です。</span> </p><br><div data-lang=rust,ignore><div data-l="tcx.sess.delay_span_bug(some_span, &quot;some message&quot;)"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>delay_span_bug()</code> is a helper that says: we expect a compilation error to have happened or to happen in the future;</span> <code>delay_span_bug()</code>は、次のようなヘルパーです：コンパイルエラーが起こったか、将来起こることが予想されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">so, if compilation ultimately succeeds, make an ICE with the message <code>&quot;some message&quot;</code> .</span>したがって、コンパイルが最終的に成功した場合は、メッセージ<code>&quot;some message&quot;</code>を持つICEを作成します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is basically just a precaution in case you are wrong.</span>これは基本的にあなたが間違っている場合の予防措置です。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">How the compiler executes a query</span>コンパイラによるクエリの実行方法</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So you may be wondering what happens when you invoke a query method.</span>したがって、クエリメソッドを呼び出すときに何が起こるのか不思議に思うかもしれません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The answer is that, for each query, the compiler maintains a cache – if your query has already been executed, then, the answer is simple: we clone the return value out of the cache and return it (therefore, you should try to ensure that the return types of queries are cheaply cloneable; insert a <code>Rc</code> if necessary).</span>その答えは、各クエリについて、コンパイラがキャッシュを保持していることです。クエリがすでに実行されていれば、その答えは簡単です。戻り値をキャッシュからクローン化して返します（したがって、戻り値の型は安価に複製可能である;必要に応じて<code>Rc</code>挿入する）。</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Providers</span>プロバイダー</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If, however, the query is <i>not</i> in the cache, then the compiler will try to find a suitable <b>provider</b> .</span>ただし、クエリがキャッシュに<i>ない</i>場合、コンパイラは適切な<b>プロバイダ</b>を検索しようとします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A provider is a function that has been defined and linked into the compiler somewhere that contains the code to compute the result of the query.</span>プロバイダは、クエリの結果を計算するコードを含むコンパイラに定義され、リンクされている関数です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><b>Providers are defined per-crate.</b></span> <b>プロバイダーはクレートごとに定義されています。</b></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The compiler maintains, internally, a table of providers for every crate, at least conceptually.</span>コンパイラは、少なくとも概念的には、すべてのクレートのプロバイダのテーブルを内部的に保持します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Right now, there are really two sets: the providers for queries about the <b>local crate</b> (that is, the one being compiled) and providers for queries about <b>external crates</b> (that is, dependencies of the local crate).</span>現在、実際には2つのセットがあります。 <b>ローカル・クレート</b> （つまり、コンパイルされているもの）に関する照会のプロバイダーと、 <b>外部クレート</b> （つまり、ローカル・クレートの依存関係）に関する照会のプロバイダーです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that what determines the crate that a query is targeting is not the <i>kind</i> of query, but the <i>key</i> .</span>クエリがターゲットとするクレートを決定するのは、クエリの<i>種類</i>ではなく、 <i>キー</i>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, when you invoke <code>tcx.type_of(def_id)</code> , that could be a local query or an external query, depending on what crate the <code>def_id</code> is referring to (see the <code>self::keys::Key</code> trait for more information on how that works).</span>たとえば、 <code>tcx.type_of(def_id)</code>を呼び出すと、 <code>def_id</code>が参照しているクレートに応じてローカルクエリまたは外部クエリになる可能性があります（ <code>self::keys::Key</code>特性を参照してください）作品）。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Providers always have the same signature:</span>プロバイダには常に同じシグネチャがあります。</span> </p><br><div data-lang=rust,ignore><div data-l="fn provider&lt;'cx, 'tcx&gt;(tcx: TyCtxt&lt;'cx, 'tcx, 'tcx&gt;,"></div><div data-l="                       key: QUERY_KEY)"></div><div data-l="                       -&gt; QUERY_RESULT"></div><div data-l={></div><div data-l="    ..."></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Providers take two arguments: the <code>tcx</code> and the query key.</span>プロバイダには、 <code>tcx</code>と<code>tcx</code> 2つの引数があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note also that they take the <i>global</i> tcx (ie they use the <code>&#39;tcx</code> lifetime twice), rather than taking a tcx with some active inference context.</span>また、彼らは<i>グローバルな</i> tcxを取ることに注意してください（つまり、彼らはいくつかのアクティブ推論コンテキストでtcxを取るのではなく、 <code>&#39;tcx</code> lifetimeを2回使用します）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">They return the result of the query.</span>彼らはクエリの結果を返します。</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">How providers are setup</span>プロバイダの設定方法</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When the tcx is created, it is given the providers by its creator using the <code>Providers</code> struct.</span> tcxが作成されると、 <code>Providers</code>構造体を使用してその作成者によってプロバイダーが指定され<code>Providers</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This struct is generated by the macros here, but it is basically a big list of function pointers:</span>この構造体はここではマクロによって生成されますが、基本的には関数ポインタの大きなリストです：</span> </p><br><div data-lang=rust,ignore><div data-l="struct Providers {"></div><div data-l="    type_of: for&lt;'cx, 'tcx&gt; fn(TyCtxt&lt;'cx, 'tcx, 'tcx&gt;, DefId) -&gt; Ty&lt;'tcx&gt;,"></div><div data-l="    ..."></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">At present, we have one copy of the struct for local crates, and one for external crates, though the plan is that we may eventually have one per crate.</span>現時点では、ローカルクレート用の構造体と外部クレート用の構造体のコピーを1つ用意していますが、最終的にはクレートごとに1つずつ作成する予定です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These <code>Provider</code> structs are ultimately created and populated by <code>librustc_driver</code> , but it does this by distributing the work throughout the other <code>rustc_*</code> crates.</span>これらの<code>Provider</code>構造体は、 <code>librustc_driver</code>によって最終的に作成され、 <code>librustc_driver</code>され<code>librustc_driver</code>が、他の<code>rustc_*</code>箱全体に作業を分散することでこれを<code>rustc_*</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is done by invoking various <code>provide</code> functions.</span>これは、さまざまな<code>provide</code>関数を呼び出すことによって行われます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These functions tend to look something like this:</span>これらの関数は次のようになります。</span> </p><br><div data-lang=rust,ignore><div data-l="pub fn provide(providers: &amp;mut Providers) {"></div><div data-l="    *providers = Providers {"></div><div data-l="        type_of,"></div><div data-l="        ..*providers"></div><div data-l="    };"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That is, they take an <code>&amp;mut Providers</code> and mutate it in place.</span>つまり、 <code>&amp;mut Providers</code> 、それを変更します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Usually we use the formulation above just because it looks nice, but you could as well do <code>providers.type_of = type_of</code> , which would be equivalent.</span>通常は上の<code>providers.type_of = type_of</code>を使っていますが、それはうまく見えますが、同様のものを<code>providers.type_of = type_of</code>とすることもできます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">(Here, <code>type_of</code> would be a top-level function, defined as we saw before.) So, if we want to add a provider for some other query, let&#39;s call it <code>fubar</code> , into the crate above, we might modify the <code>provide()</code> function like so:</span> （ここでは、 <code>type_of</code>我々の前に見たように定義されたトップレベルの関数で、となります。）だから、我々はいくつかの他のクエリのためのプロバイダを追加したい場合は、のは、それを呼びましょう<code>fubar</code> 、上記木枠の中に、我々は変更する可能性<code>provide()</code>次のように機能します：</span> </p><br><div data-lang=rust,ignore><div data-l="pub fn provide(providers: &amp;mut Providers) {"></div><div data-l="    *providers = Providers {"></div><div data-l="        type_of,"></div><div data-l="        fubar,"></div><div data-l="        ..*providers"></div><div data-l="    };"></div><div data-l=}></div><div data-l=""></div><div data-l="fn fubar&lt;'cx, 'tcx&gt;(tcx: TyCtxt&lt;'cx, 'tcx&gt;, key: DefId) -&gt; Fubar&lt;'tcx&gt; { ... }"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">NB Most of the <code>rustc_*</code> crates only provide <b>local providers</b> .</span>注意<code>rustc_*</code>箱のほとんどは、 <b>地元の提供者</b>のみを提供して<b>います</b> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Almost all <b>extern providers</b> wind up going through the <a href=#3rustc_metadata><code>rustc_metadata</code> crate</a> , which loads the information from the crate metadata.</span>ほとんどすべての<a href=#3rustc_metadata><code>rustc_metadata</code></a> <b>プロバイダ</b>は<a href=#3rustc_metadata><code>rustc_metadata</code>クレート</a>を通過し、クレートメタデータから情報をロードします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But in some cases there are crates that provide queries for <i>both</i> local and external crates, in which case they define both a <code>provide</code> and a <code>provide_extern</code> function that <code>rustc_driver</code> can invoke.</span>しかし、いくつかのケースではそれらが定義するどちらの場合には、ローカルと外部<i>の両方の</i>箱のためのクエリを提供箱がある<code>provide</code>し、 <code>provide_extern</code>機能<code>rustc_driver</code>呼び出すことができますが。</span> </p><br> <a class=notranslate href=#1https://github.com/rust-lang/rust/tree/master/src/librustc_metadata>rustc_metadata</a> <br> <h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Adding a new kind of query</span>新しい種類のクエリを追加する</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So suppose you want to add a new kind of query, how do you do so?</span>新しい種類のクエリを追加したいとします。どのようにそうしますか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Well, defining a query takes place in two steps:</span>さて、クエリの定義は2つのステップで行われます。</span> </p><br><div data-b=1.> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">first, you have to specify the query name and arguments;</span>まず、クエリ名と引数を指定する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">and then,</span>その後、</span> </div><div data-b=2.> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">you have to supply query providers where needed.</span>必要に応じてクエリプロバイダを提供する必要があります。</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To specify the query name and arguments, you simply add an entry to the big macro invocation in <a class=notranslate href=#3query-mod><code>src/librustc/ty/query/mod.rs</code></a> , which looks something like:</span>クエリ名と引数を指定するには、単純に<a class=notranslate href=#3query-mod><code>src/librustc/ty/query/mod.rs</code></a>の大きなマクロ呼び出しにエントリを追加し<a class=notranslate href=#3query-mod><code>src/librustc/ty/query/mod.rs</code></a> 。</span> </p><br> <a class=notranslate href=#1https://doc.rust-lang.org/nightly/nightly-rustc/rustc/ty/query/index.html>query-mod</a> <br> <div data-lang=rust,ignore><div data-l="define_queries! { &lt;'tcx&gt;"></div><div data-l="#//    /// Records the type of every item."></div><div data-l="    /// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Records the type of every item.</span>各項目の種類を記録します。</span> </div><div data-l="    [] fn type_of: TypeOfItem(DefId) -&gt; Ty&lt;'tcx&gt;,"></div><div data-l=""></div><div data-l="    ..."></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Each line of the macro defines one query.</span>マクロの各行は1つのクエリを定義します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The name is broken up like this:</span>名前は次のように分かれています：</span> </p><br><div data-lang=rust,ignore><div data-l="[] fn type_of: TypeOfItem(DefId) -&gt; Ty&lt;'tcx&gt;,"></div><div data-l="^^    ^^^^^^^  ^^^^^^^^^^ ^^^^^     ^^^^^^^^"></div><div data-l="|     |        |          |         |"></div><div data-l="|     |        |          |         result type of query"></div><div data-l="|     |        |          query key type"></div><div data-l="|     |        dep-node constructor"></div><div data-l="|     name of query"></div><div data-l="query flags"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s go over them one by one:</span>それらを一つずつ上に行きましょう：</span> </p><br><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><b>Query flags:</b> these are largely unused right now, but the intention is that we&#39;ll be able to customize various aspects of how the query is processed.</span> <b>クエリフラグ：</b>これらは現在ほとんど使われていませんが、クエリの処理方法のさまざまな側面をカスタマイズできるということです。</span> </div><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><b>Name of query:</b> the name of the query method ( <code>tcx.type_of(..)</code> ).</span> <b>クエリ</b>の名前<b>：</b>クエリメソッドの名前（ <code>tcx.type_of(..)</code> ）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Also used as the name of a struct ( <code>ty::queries::type_of</code> ) that will be generated to represent this query.</span>また、このクエリを表すために生成されるstruct（ <code>ty::queries::type_of</code> ）の名前としても使用されます。</span> </div><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><b>Dep-node constructor:</b> indicates the constructor function that connects this query to incremental compilation.</span> <b>Dep-node constructor：</b>このクエリを増分コンパイルに接続するコンストラクタ関数を示します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Typically, this is a <code>DepNode</code> variant, which can be added by modifying the <code>define_dep_nodes€</code> macro invocation in <a class=notranslate href=#3dep-node><code>librustc/dep_graph/dep_node.rs</code></a> .</span>典型的には、これは<code>DepNode</code>変更することによって追加することができる変異体、 <code>define_dep_nodes€</code>マクロ呼び出し<a class=notranslate href=#3dep-node><code>librustc/dep_graph/dep_node.rs</code></a> 。</span> </div><div data-b="  -"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, sometimes we use a custom function, in which case the name will be in snake case and the function will be defined at the bottom of the file.</span>ただし、カスタム関数を使用する場合があります。この場合、名前はスネークケースになり、関数はファイルの最後に定義されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is typically used when the query key is not a def-id, or just not the type that the dep-node expects.</span>これは、通常、照会キーがdef-idでない場合、またはdep-nodeが予期しているタイプでない場合に使用されます。</span> </div><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><b>Query key type:</b> the type of the argument to this query.</span> <b>クエリーキータイプ：</b>このクエリーの引数のタイプ。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This type must implement the <code>ty::query::keys::Key</code> trait, which defines (for example) how to map it to a crate, and so forth.</span>この型は<code>ty::query::keys::Key</code>特性を実装しなければなりません。これは（例えば）木箱にマップする方法などを定義します。</span> </div><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><b>Result type of query:</b> the type produced by this query.</span> <b>クエリの結果の型：</b>このクエリによって生成される型。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This type should (a) not use <code>RefCell</code> or other interior mutability and (b) be cheaply cloneable.</span>このタイプは、（a） <code>RefCell</code>または他の内部の<code>RefCell</code>使用<code>RefCell</code>ず、（b）安価に複製可能でなければならない。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Interning or using <code>Rc</code> or <code>Arc</code> is recommended for non-trivial data types.</span>重大ではないデータ型には、インターンまたは<code>Rc</code>または<code>Arc</code>を使用することをお勧めします。</span> </div><div data-b="  -"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The one exception to those rules is the <code>ty::steal::Steal</code> type, which is used to cheaply modify MIR in place.</span>これらのルールの例外の1つは<code>ty::steal::Steal</code>タイプで、MIRを安価に修正するために使用されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">See the definition of <code>Steal</code> for more details.</span>詳細については<code>Steal</code>の定義を参照してください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">New uses of <code>Steal</code> should <b>not</b> be added without alerting <code>@rust-lang/compiler</code> .</span> <code>Steal</code>新しい用途は、 <code>@rust-lang/compiler</code>警告することなく追加するべきで<b>は</b>ありませ<b>ん</b> 。</span> </div><br> <a class=notranslate href=#1https://doc.rust-lang.org/nightly/nightly-rustc/rustc/dep_graph/struct.DepNode.html>dep-node</a> <br> <p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So, to add a query:</span>したがって、クエリを追加するには：</span> </p><br><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Add an entry to <code>define_queries€</code> using the format above.</span>上記の形式を使用して<code>define_queries€</code>エントリを追加します。</span> </div><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Possibly add a corresponding entry to the dep-node macro.</span>可能であれば、dep-nodeマクロに対応するエントリを追加します。</span> </div><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Link the provider by modifying the appropriate <code>provide</code> method;</span>適切な<code>provide</code>方法を変更してプロバイダをリンクします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">or add a new one if needed and ensure that <code>rustc_driver</code> is invoking it.</span>必要に応じて新しいものを追加して、 <code>rustc_driver</code>が呼び出していることを確認して<code>rustc_driver</code> 。</span> </div><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Query structs and descriptions</span>クエリの構造と説明</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For each kind, the <code>define_queries</code> macro will generate a &quot;query struct&quot; named after the query.</span>各種類について、 <code>define_queries</code>マクロはクエリの後に指定された &quot;query struct&quot;を生成します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This struct is a kind of a place-holder describing the query.</span>この構造体は、クエリを記述するプレースホルダの一種です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Each such struct implements the <code>self::config::QueryConfig</code> trait, which has associated types for the key/value of that particular query.</span>このような各structは、 <code>self::config::QueryConfig</code>特性を実装しています。この特性は、その特定のクエリのキー/値に関連する型を持ちます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Basically the code generated looks something like this:</span>基本的に生成されるコードは次のようになります。</span> </p><br><div data-lang=rust,ignore><div data-l="#// Dummy struct representing a particular kind of query:"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Dummy struct representing a particular kind of query:</span>特定の種類のクエリーを表すDummy構造体：</span> </div><div data-l="pub struct type_of&lt;'tcx&gt; { phantom: PhantomData&lt;&amp;'tcx ()&gt; }"></div><div data-l=""></div><div data-l="impl&lt;'tcx&gt; QueryConfig for type_of&lt;'tcx&gt; {"></div><div data-l="  type Key = DefId;"></div><div data-l="  type Value = Ty&lt;'tcx&gt;;"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There is an additional trait that you may wish to implement called <code>self::config::QueryDescription</code> .</span> <code>self::config::QueryDescription</code>と呼ばれる実装したいかもしれない追加の特性があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This trait is used during cycle errors to give a &quot;human readable&quot; name for the query, so that we can summarize what was happening when the cycle occurred.</span>この特性はサイクルエラー時に使用され、クエリーに「人間が判読可能な」名前を付けるので、サイクルが発生したときの状況を要約できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Implementing this trait is optional if the query key is <code>DefId</code> , but if you <i>don&#39;t</i> implement it, you get a pretty generic error (&quot;processing <code>foo</code> ...&quot;).</span>クエリのキーが<code>DefId</code>場合、この特性の実装はオプションですが、実装して<i>いない</i>と、かなり一般的なエラーが発生します（「 <code>foo</code>処理しています...」）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can put new impls into the <code>config</code> module.</span>あなたは<code>config</code>モジュールに新しいimplを置くことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">They look something like this:</span>彼らはこのように見える：</span> </p><br><div data-lang=rust,ignore><div data-l="impl&lt;'tcx&gt; QueryDescription for queries::type_of&lt;'tcx&gt; {"></div><div data-l="    fn describe(tcx: TyCtxt, key: DefId) -&gt; String {"></div><div data-l="        format!(&quot;computing the type of `{}`&quot;, tcx.item_path_str(key))"></div><div data-l="    }"></div><div data-l=}></div></div><br><script>_addload(function(){_setupIW('com');_csi('en','ja','query.html');});</script>