<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180723_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=resolution.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Trait resolution (old-style)</span>特性解像度（旧式）</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This chapter describes the general process of <s>trait resolution</s> and points out some non-obvious things.</span>この章では、 <s>形質の解決の</s>一般的なプロセスについて説明し、いくつかの非明白な事柄を指摘する。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><b>Note:</b> This chapter (and its subchapters) describe how the trait solver <b>currently</b> works.</span> <b>注意：</b>この章（およびそのサブセクション）では、 <b>現在</b> 、形質ソルバーがどのように機能しているかについて説明して<b>い</b>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, we are in the process of designing a new trait solver.</span>しかし、我々は新しい形質ソルバーを設計する過程にある。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you&#39;d prefer to read about <i>that</i> , see <a href=#2./traits/index.html><i>this</i> traits chapter</a> .</span>あなたが<i>それ</i>について読むこと<i>を</i>好むなら、 <a href=#2./traits/index.html><i>この</i>特徴の章を</a>見てください。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Major concepts</span>主なコンセプト</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Trait resolution is the process of pairing up an impl with each reference to a trait.</span>形質の解像度は、特性を参照するたびにインプラントをペアリングするプロセスです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So, for example, if there is a generic function like:</span>たとえば、次のような汎用関数があるとします。</span> </p><br><div data-lang=rust,ignore><div data-l="fn clone_slice&lt;T:Clone&gt;(x: &amp;[T]) -&gt; Vec&lt;T&gt; { ... }"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">and then a call to that function:</span>その関数への呼び出し：</span> </p><br><div data-lang=rust,ignore><div data-l="let v: Vec&lt;isize&gt; = clone_slice(&amp;[1, 2, 3])"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">it is the job of trait resolution to figure out whether there exists an impl of (in this case) <code>isize : Clone</code> .</span> <code>isize : Clone</code>が存在するかどうかを知ることは、特性決定の仕事です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that in some cases, like generic functions, we may not be able to find a specific impl, but we can figure out that the caller must provide an impl.</span>場合によっては、ジェネリック関数のように特定のimplを見つけることができないかもしれないが、呼び出し元がimplを指定しなければならないことがわかる。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, consider the body of <code>clone_slice</code> :</span>たとえば、 <code>clone_slice</code>の本文を考えてみ<code>clone_slice</code> 。</span> </p><br><div data-lang=rust,ignore><div data-l="fn clone_slice&lt;T:Clone&gt;(x: &amp;[T]) -&gt; Vec&lt;T&gt; {"></div><div data-l="    let mut v = Vec::new();"></div><div data-l="    for e in &amp;x {"></div><div data-l="#//        v.push((*e).clone()); // (*)"></div><div data-l="        v.push((*e).clone()); // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">(*)</span> （*）</span> </div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The line marked <code>(*)</code> is only legal if <code>T</code> (the type of <code>*e</code> ) implements the <code>Clone</code> trait.</span> <code>T</code> （ <code>*e</code>の型）が<code>Clone</code>特性を実装している場合、 <code>(*)</code>と書かれた行は合法です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Naturally, since we don&#39;t know what <code>T</code> is, we can&#39;t find the specific impl;</span>当然、 <code>T</code>が何であるかわからないので、特定のインプットを見つけることはできません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">but based on the bound <code>T:Clone</code> , we can say that there exists an impl which the caller must provide.</span>バインドされた<code>T:Clone</code>に基づいて、呼び出し元が提供しなければならないインプリメンテーションが存在すると言うことができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We use the term <i>obligation</i> to refer to a trait reference in need of an impl.</span>我々は、 <i>義務</i>という用語をインプラントが必要な形質の参照と呼ぶことにする。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Basically, the trait resolution system resolves an obligation by proving that an appropriate impl does exist.</span>基本的に、特性決定システムは、適切なインプラントが存在することを証明することによって義務を解決する。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">During type checking, we do not store the results of trait selection.</span>タイプチェックの間、我々は形質選択の結果を保存しない。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We simply wish to verify that trait selection will succeed.</span>我々は単に形質の選択が成功することを確認したい。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then later, at trans time, when we have all concrete types available, we can repeat the trait selection to choose an actual implementation, which will then be generated in the output binary.</span>その後、トランスタイムで、すべての具体的なタイプが利用可能になったら、特性選択を繰り返して実際の実装を選択し、出力バイナリで生成します。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Overview</span>概要</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Trait resolution consists of three major parts:</span>特性の解決は、3つの主要な部分で構成されています。</span> </p><br><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><b>Selection</b> : Deciding how to resolve a specific obligation.</span> <b>選択</b> ：特定の義務を解決する方法を決定する。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, selection might decide that a specific obligation can be resolved by employing an impl which matches the <code>Self</code> type, or by using a parameter bound (eg <code>T: Trait</code> ).</span>例えば、セレクションでは、 <code>Self</code>型と一致するimplを使用するか、パラメータの束縛（たとえば<code>T: Trait</code> ）を使用することによって、特定の義務を解決できるかどうかを判断できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In the case of an impl, selecting one obligation can create <i>nested obligations</i> because of where clauses on the impl itself.</span>インプラントの場合、1つの義務を選択すると、インプレス自体のwhere句のために<i>ネストされた義務</i>が作成<i>される</i>可能性があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It may also require evaluating those nested obligations to resolve ambiguities.</span>また、あいまいさを解決するためにこれらのネストされた義務を評価する必要があります。</span> </div><br><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><b>Fulfillment</b> : The fulfillment code is what tracks that obligations are completely fulfilled.</span> <b>フルフィルメント</b> ： <b>フルフィルメント</b>コードは、その義務が完全に履行されることを追跡するものです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Basically it is a worklist of obligations to be selected: once selection is successful, the obligation is removed from the worklist and any nested obligations are enqueued.</span>基本的には、選択する義務のワークリストです。選択が成功すると、義務はワークリストから削除され、ネストされた義務はすべてエンキューされます。</span> </div><br><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><b>Coherence</b> : The coherence checks are intended to ensure that there are never overlapping impls, where two impls could be used with equal precedence.</span> <b>一貫性</b> ：一貫性検査は、重複するimplがないことを確実にすることを目的としています.2つのimplを同じ優先順位で使用することができます。</span> </div><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Selection</span>選択</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Selection is the process of deciding whether an obligation can be resolved and, if so, how it is to be resolved (via impl, where clause, etc).</span>選択は、義務が解決できるかどうかを決定するプロセスであり、もしそうであれば、それをどのように解決するか（impl、where句など）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The main interface is the <code>select()</code> function, which takes an obligation and returns a <code>SelectionResult</code> .</span>主なインターフェイスは<code>select()</code>関数で、これは義務を引き受け、 <code>SelectionResult</code>を返します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There are three possible outcomes:</span>可能な結果は3つあります。</span> </p><br><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>Ok(Some(selection))</code> – yes, the obligation can be resolved, and <code>selection</code> indicates how.</span> <code>Ok(Some(selection))</code> - はい、義務を解決することができ、 <code>selection</code>方法を示します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If the impl was resolved via an impl, then <code>selection</code> may also indicate nested obligations that are required by the impl.</span> implがimplを介して解決された場合、 <code>selection</code>はimplによって必要とされるネストされた義務を示すかもしれない。</span> </div><br><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>Ok(None)</code> – we are not yet sure whether the obligation can be resolved or not.</span> <code>Ok(None)</code> - 義務が解決できるかどうかはまだわかりません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This happens most commonly when the obligation contains unbound type variables.</span>債務が非連結型変数を含む場合、これが最も一般的です。</span> </div><br><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>Err(err)</code> – the obligation definitely cannot be resolved due to a type error or because there are no impls that could possibly apply.</span> <code>Err(err)</code> - タイプエラーのために義務が確実に解決できないか、あるいは適用可能なインプラントがないためです。</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The basic algorithm for selection is broken into two big phases: candidate assembly and confirmation.</span>選択のための基本的なアルゴリズムは、2つの大きな段階に分かれています：候補組立と確認。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that because of how lifetime inference works, it is not possible to give back immediate feedback as to whether a unification or subtype relationship between lifetimes holds or not.</span>生涯推論がどのように機能するかにより、生存期間の統一または亜種の関係が成立するかどうかについての即時のフィードバックを返すことはできないことに注意してください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Therefore, lifetime matching is <i>not</i> considered during selection.</span>したがって、選択時にライフタイムマッチングは考慮され<i>ません</i> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is reflected in the fact that subregion assignment is infallible.</span>これは、部分領域の割り当てが間違いないことに反映されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This may yield lifetime constraints that will later be found to be in error (in contrast, the non-lifetime-constraints have already been checked during selection and can never cause an error, though naturally they may lead to other errors downstream).</span>これは、後でエラーとなる生涯の制約をもたらす可能性がある（対照的に、非生涯制約は既に選択中にチェックされており、決してエラーを引き起こすことはできない。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Candidate assembly</span>候補組立</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Searches for impls/where-clauses/etc that might possibly be used to satisfy the obligation.</span>義務を満たすために使用されるかもしれないimpls / where-clauses / etcを検索します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Each of those is called a candidate.</span>それらのそれぞれは候補者と呼ばれます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To avoid ambiguity, we want to find exactly one candidate that is definitively applicable.</span>あいまいさを避けるために、我々は明確に適用可能な1つの候補を正確に探したい。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In some cases, we may not know whether an impl/where-clause applies or not – this occurs when the obligation contains unbound inference variables.</span>場合によっては、impl / where句が適用されるかどうかわからない場合があります。これは、義務にバインドされていない推論変数が含まれている場合に発生します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The subroutines that decide whether a particular impl/where-clause/etc applies to a particular obligation are collectively refered to as the process of <s>matching</s> .</span>特定の義務に特定のimpl / where-clause / etcが適用されるかどうかを決定するサブルーチンは、まとめて<s>マッチング</s>のプロセスと呼ばれます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">At the moment, this amounts to unifying the <code>Self</code> types, but in the future we may also recursively consider some of the nested obligations, in the case of an impl.</span>現時点では、これは<code>Self</code>タイプを統一することになりますが、将来、インプラントの場合には、ネストされた義務のいくつかを再帰的に検討することもあります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><b>TODO</b> : what does &quot;unifying the <code>Self</code> types&quot; mean?</span> <b>TODO</b> ：「 <code>Self</code>タイプを統一する」とはどういう意味ですか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Self</code> of the obligation with that of an impl?</span>インプラントの義務の<code>Self</code> ？</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The basic idea for candidate assembly is to do a first pass in which we identify all possible candidates.</span>候補組立の基本的な考え方は、可能性のあるすべての候補を特定する最初のパスを実行することです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">During this pass, all that we do is try and unify the type parameters.</span>このパスでは、タイプパラメータを統一しようとするだけです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">(In particular, we ignore any nested where clauses.) Presuming that this unification succeeds, the impl is added as a candidate.</span> （特に、ネストされたwhere節は無視されます）。この統一が成功したと仮定すると、implが候補として追加されます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Once this first pass is done, we can examine the set of candidates.</span>この最初のパスが完了すると、候補のセットを調べることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If it is a singleton set, then we are done: this is the only impl in scope that could possibly apply.</span>シングルトンセットの場合は、これが完了します。これが適用可能な範囲内の唯一のインプリメンテーションです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Otherwise, we can winnow down the set of candidates by using where clauses and other conditions.</span>さもなければ、私たちはwhere節と他の条件を使って候補の集合を絞り込むことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If this reduced set yields a single, unambiguous entry, we&#39;re good to go, otherwise the result is considered ambiguous.</span>この減少したセットが単一の明白なエントリをもたらすなら、我々は行かなくてはなりません、そうでなければ結果はあいまいであると考えられます。</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The basic process: Inferring based on the impls we see</span>基本的なプロセス：我々が見るインプルメントに基づいて推論する</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This process is easier if we work through some examples.</span>このプロセスは、いくつかの例を試してみると簡単です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Consider the following trait:</span>次のような特性を考えてみましょう。</span> </p><br><div data-lang=rust,ignore><div data-l="trait Convert&lt;Target&gt; {"></div><div data-l="    fn convert(&amp;self) -&gt; Target;"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This trait just has one method.</span>この形質には1つの方法しかありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It&#39;s about as simple as it gets.</span>それはそれが得るほど簡単です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It converts from the (implicit) <code>Self</code> type to the <code>Target</code> type.</span>これは、（暗黙の） <code>Self</code>型から<code>Target</code>型に変換されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we wanted to permit conversion between <code>isize</code> and <code>usize</code> , we might implement <code>Convert</code> like so:</span> <code>isize</code>と<code>usize</code>間の変換を許可したい場合は、 <code>usize</code>ように<code>Convert</code>を実装することができます：</span> </p><br><div data-lang=rust,ignore><div data-l="#//impl Convert&lt;usize&gt; for isize { ... } // isize -&gt; usize"></div><div data-l="impl Convert&lt;usize&gt; for isize { ... } // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">isize -&gt; usize</span> isize  - &gt; usize</span> </div><div data-l="#//impl Convert&lt;isize&gt; for usize { ... } // usize -&gt; isize"></div><div data-l="impl Convert&lt;isize&gt; for usize { ... } // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">usize -&gt; isize</span> usize  - &gt; isize</span> </div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now imagine there is some code like the following:</span>さて、次のようなコードがあるとしましょう：</span> </p><br><div data-lang=rust,ignore><div data-l="let x: isize = ...;"></div><div data-l="let y = x.convert();"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The call to convert will generate a trait reference <code>Convert&lt;$Y&gt; for isize</code> , where <code>$Y</code> is the type variable representing the type of <code>y</code> .</span> convertへの呼び出しは、 <code>Convert&lt;$Y&gt; for isize</code> 。ここで、 <code>$Y</code>は<code>y</code>の型を表す型変数です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Of the two impls we can see, the only one that matches is <code>Convert&lt;usize&gt; for isize</code> .</span>我々が見ることができる2つの意味のうち、一致するものは<code>Convert&lt;usize&gt; for isize</code>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Therefore, we can select this impl, which will cause the type of <code>$Y</code> to be unified to <code>usize</code> .</span>したがって、このimplを選択すると、 <code>$Y</code>のタイプが<code>usize</code>に統一され<code>usize</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">(Note that while assembling candidates, we do the initial unifications in a transaction, so that they don&#39;t affect one another.)</span> （候補を集めている間は、トランザクションで最初の統一を行い、相互に影響しないことに注意してください）。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><b>TODO</b> : The example says we can &quot;select&quot; the impl, but this section is talking specifically about candidate assembly.</span> <b>TODO</b> ：この例では、implを「選択」できるとしていますが、このセクションでは候補アセンブリについて具体的に話しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Does this mean we can sometimes skip confirmation?</span>これは時には確認をスキップできることを意味しますか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Or is this poor wording?</span>それともこの貧弱な表現ですか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><b>TODO</b> : Is the unification of <code>$Y</code> part of trait resolution or type inference?</span> <b>TODO</b> ： <code>$Y</code>統治しているかどうかは、特性の解明や型推論の一部ですか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Or is this not the same type of &quot;inference variable&quot; as in type inference?</span>あるいは、型推論の場合と同じタイプの「推論変数」ではないのですか？</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Winnowing: Resolving ambiguities</span>驚くようなこと：あいまいさを解決する</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But what happens if there are multiple impls where all the types unify?</span>しかし、すべての型が統一されている複数の意味がある場合はどうなりますか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Consider this example:</span>この例を考えてみましょう。</span> </p><br><div data-lang=rust,ignore><div data-l="trait Get {"></div><div data-l="    fn get(&amp;self) -&gt; Self;"></div><div data-l=}></div><div data-l=""></div><div data-l="impl&lt;T:Copy&gt; Get for T {"></div><div data-l="    fn get(&amp;self) -&gt; T { *self }"></div><div data-l=}></div><div data-l=""></div><div data-l="impl&lt;T:Get&gt; Get for Box&lt;T&gt; {"></div><div data-l="    fn get(&amp;self) -&gt; Box&lt;T&gt; { Box::new(get_it(&amp;**self)) }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">What happens when we invoke <code>get_it(&amp;Box::new(1_u16))</code> , for example?</span> <code>get_it(&amp;Box::new(1_u16))</code>を呼び出すとどうなりますか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this case, the <code>Self</code> type is <code>Box&lt;u16&gt;</code> – that unifies with both impls, because the first applies to all types <code>T</code> , and the second to all <code>Box&lt;T&gt;</code> .</span>この場合、 <code>Self</code>型は<code>Box&lt;u16&gt;</code>です。最初の型はすべての型<code>T</code>適用され、2つ目の型はすべての<code>Box&lt;T&gt;</code>適用されるため、両方のimplで統一されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In order for this to be unambiguous, the compiler does a <i>winnowing</i> pass that considers <code>where</code> clauses and attempts to remove candidates.</span>これを明確にするために、コンパイラは<code>where</code>節と候補を削除しようとする考慮するパスを<i>調べ</i>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this case, the first impl only applies if <code>Box&lt;u16&gt; : Copy</code> , which doesn&#39;t hold.</span>この場合、最初のimplは<code>Box&lt;u16&gt; : Copy</code>が保持していない場合にのみ適用されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">After winnowing, then, we are left with just one candidate, so we can proceed.</span>それから、私たちはただ一つの候補者しか残されていないので、進めることができます。</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>where</code> clauses</span> <code>where</code>句</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Besides an impl, the other major way to resolve an obligation is via a where clause.</span> impl以外にも、義務を解決するもう1つの主要な方法は、where句を使用することです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The selection process is always given a <a class=notranslate href=#4parameterenvironment>parameter environment</a> which contains a list of where clauses, which are basically obligations that we can assume are satisfiable.</span>選択プロセスには常に、基本的には納得のいくものであると仮定できる句である句のリストを含む<a class=notranslate href=#4parameterenvironment>parameter environment</a>が与えられ<a class=notranslate href=#4parameterenvironment>parameter environment</a> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We will iterate over that list and check whether our current obligation can be found in that list.</span>私たちはそのリストを繰り返して、現在の義務がそのリストにあるかどうかをチェックします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If so, it is considered satisfied.</span>そうであれば、満足しているとみなされます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">More precisely, we want to check whether there is a where-clause obligation that is for the same trait (or some subtrait) and which can match against the obligation.</span>より正確には、同一の形質（または一部の亜種）に対する義務の義務があるかどうかを確認したいと思います。</span> </p><br> <a class=notranslate href=#1./param_env.html>parameter environment</a> <br> <p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Consider this simple example:</span>以下の簡単な例を考えてみましょう。</span> </p><br><div data-lang=rust,ignore><div data-l="trait A1 {"></div><div data-l="    fn do_a1(&amp;self);"></div><div data-l=}></div><div data-l="trait A2 : A1 { ... }"></div><div data-l=""></div><div data-l="trait B {"></div><div data-l="    fn do_b(&amp;self);"></div><div data-l=}></div><div data-l=""></div><div data-l="fn foo&lt;X:A2+B&gt;(x: X) {"></div><div data-l="#//    x.do_a1(); // (*)"></div><div data-l="    x.do_a1(); // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">(*)</span> （*）</span> </div><div data-l="#//    x.do_b();  // (#)"></div><div data-l="    x.do_b();  // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">(#)</span> （＃）</span> </div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In the body of <code>foo</code> , clearly we can use methods of <code>A1</code> , <code>A2</code> , or <code>B</code> on variable <code>x</code> .</span> <code>foo</code>の本体では、明らかに変数<code>x</code> <code>A1</code> 、 <code>A2</code> 、または<code>B</code>メソッドを使用できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The line marked <code>(*)</code> will incur an obligation <code>X: A1</code> , while the line marked <code>(#)</code> will incur an obligation <code>X: B</code> .</span> <code>(*)</code>と書かれた行は<code>X: A1</code>義務を負うが、 <code>(#)</code>行は<code>X: B</code>義務を負う。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Meanwhile, the parameter environment will contain two where-clauses: <code>X : A2</code> and <code>X : B</code> .</span>一方、パラメータ環境には、 <code>X : A2</code>と<code>X : B</code> 2つのwhere節が含まれます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For each obligation, then, we search this list of where-clauses.</span>各義務について、where-clauseのこのリストを検索します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The obligation <code>X: B</code> trivially matches against the where-clause <code>X: B</code> .</span>義務<code>X: B</code>はwhere節<code>X: B</code>に対して一意に一致します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To resolve an obligation <code>X:A1</code> , we would note that <code>X:A2</code> implies that <code>X:A1</code> .</span>義務<code>X:A1</code>を解決するには、 <code>X:A2</code>は<code>X:A1</code>意味することに注意してください。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Confirmation</span>確認</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><s>Confirmation</s> unifies the output type parameters of the trait with the values found in the obligation, possibly yielding a type error.</span> <s>確認</s>は、特性の出力タイプのパラメータを義務で見つかった値と統一し、場合によってはタイプエラーが発生する可能性があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Suppose we have the following variation of the <code>Convert</code> example in the previous section:</span>前のセクションで<code>Convert</code>例を次のように変更したとします。</span> </p><br><div data-lang=rust,ignore><div data-l="trait Convert&lt;Target&gt; {"></div><div data-l="    fn convert(&amp;self) -&gt; Target;"></div><div data-l=}></div><div data-l=""></div><div data-l="#//impl Convert&lt;usize&gt; for isize { ... } // isize -&gt; usize"></div><div data-l="impl Convert&lt;usize&gt; for isize { ... } // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">isize -&gt; usize</span> isize  - &gt; usize</span> </div><div data-l="#//impl Convert&lt;isize&gt; for usize { ... } // usize -&gt; isize"></div><div data-l="impl Convert&lt;isize&gt; for usize { ... } // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">usize -&gt; isize</span> usize  - &gt; isize</span> </div><div data-l=""></div><div data-l="let x: isize = ...;"></div><div data-l="#//let y: char = x.convert(); // NOTE: `y: char` now!"></div><div data-l="let y: char = x.convert(); // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">NOTE: <code>y: char</code> now!</span>注： <code>y: char</code> now！</span> </div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Confirmation is where an error would be reported because the impl specified that <code>Target</code> would be <code>usize</code> , but the obligation reported <code>char</code> .</span>確認は、 <code>Target</code>が<code>usize</code>と指定されたimplが、義務は<code>char</code>報告したので、エラーが報告される<code>usize</code>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Hence the result of selection would be an error.</span>したがって、選択の結果はエラーになります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that the candidate impl is chosen based on the <code>Self</code> type, but confirmation is done based on (in this case) the <code>Target</code> type parameter.</span>候補のimplは<code>Self</code>型に基づいて選択されますが、確認は（この場合は） <code>Target</code>型のパラメータに基づいて行われます。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Selection during translation</span>翻訳中の選択</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As mentioned above, during type checking, we do not store the results of trait selection.</span>前述のように、型チェックの際には、特性選択の結果を保存しません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">At trans time, we repeat the trait selection to choose a particular impl for each method call.</span> trans時には、特性選択を繰り返して、各メソッド呼び出しに特定のimplを選択します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this second selection, we do not consider any where-clauses to be in scope because we know that each resolution will resolve to a particular impl.</span>この2番目の選択では、各解決が特定のimplに解決されることを知っているため、where節をスコープとみなしません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">One interesting twist has to do with nested obligations.</span> 1つの興味深いひねりは、ネストされた義務と関連しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In general, in trans, we only need to do a &quot;shallow&quot; selection for an obligation.</span>一般的に、トランスでは、義務のために「浅い」選択を行うだけです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That is, we wish to identify which impl applies, but we do not (yet) need to decide how to select any nested obligations.</span>つまり、どのインプラントが当てはまるのかを確認したいが、ネストされた義務の選択方法を決める必要はない（まだ）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Nonetheless, we <i>do</i> currently do a complete resolution, and that is because it can sometimes inform the results of type inference.</span>それにもかかわらず、私たち<i>は</i>現在、完全な解決を<i>し</i>ています。なぜなら、時には型推論の結果を知らせることができるからです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That is, we do not have the full substitutions in terms of the type variables of the impl available to us, so we must run trait selection to figure everything out.</span>つまり、私たちが利用できるインプットの型変数の点で完全な置換を持っていないので、すべてを把握するために特性選択を実行する必要があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><b>TODO</b> : is this still talking about trans?</span> <b>TODO</b> ：これはまだトランスについて話していますか？</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here is an example:</span>次に例を示します。</span> </p><br><div data-lang=rust,ignore><div data-l="trait Foo { ... }"></div><div data-l="impl&lt;U, T:Bar&lt;U&gt;&gt; Foo for Vec&lt;T&gt; { ... }"></div><div data-l=""></div><div data-l="impl Bar&lt;usize&gt; for isize { ... }"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">After one shallow round of selection for an obligation like <code>Vec&lt;isize&gt; : Foo</code> , we would know which impl we want, and we would know that <code>T=isize</code> , but we do not know the type of <code>U</code> .</span> <code>Vec&lt;isize&gt; : Foo</code>ような義務の選択の浅い1ラウンドの後、私たちが望む<code>T=isize</code>を知ることができ、 <code>T=isize</code>であることが分かるだろうが、 <code>U</code>のタイプは分からない。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We must select the nested obligation <code>isize : Bar&lt;U&gt;</code> to find out that <code>U=usize</code> .</span> <code>U=usize</code>ことを知るために、ネストされた義務<code>isize : Bar&lt;U&gt;</code>を選択する必要があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It would be good to only do <i>just as much</i> nested resolution as necessary.</span>必要な<i>だけ多くの</i>ネストされた解像度を行う<i>だけ</i>でよいでしょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Currently, though, we just do a full resolution.</span>現在のところ、我々は完全な解決策をとるだけです。</span> </p><script>_addload(function(){_setupIW('com');_csi('en','ja','resolution.html');});</script>