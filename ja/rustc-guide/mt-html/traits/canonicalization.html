<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180723_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=canonicalization.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Canonicalization</span>正規化</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Canonicalization is the process of <b>isolating</b> an inference value from its context.</span>正規化は、推論値をそのコンテキストから<b>分離</b>するプロセスです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It is a key part of implementing <a href=#3cq>canonical queries</a> , and you may wish to read the parent chapter to get more context.</span>これは<a href=#3cq>標準的なクエリ</a>を実装するための重要な部分であり、より多くの文脈を得るために親の章を読むことをお勧めします。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Canonicalization is really based on a very simple concept: every <a href=#2./type-inference.html#vars>inference variable</a> is always in one of two states: either it is <b>unbound</b> , in which case we don&#39;t know yet what type it is, or it is <b>bound</b> , in which case we do.</span>正則化は実際には非常に単純な概念に基づいてい<a href=#2./type-inference.html#vars>ます</a> 。すべての<a href=#2./type-inference.html#vars>推論変数</a>は常に2つの状態のいずれかにあります。それは<b>束縛さ</b>れていないか、どちらの型かそれとも<b>束縛され</b>ているかはわかりません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So to isolate some data-structure T that contains types/regions from its environment, we just walk down and find the unbound variables that appear in T;</span>したがって、その環境から型/領域を含むデータ構造体Tを分離するために、Tに現れる非束縛変数を探して見つけます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">those variables get replaced with &quot;canonical variables&quot;, starting from zero and numbered in a fixed order (left to right, for the most part, but really it doesn&#39;t matter as long as it is consistent).</span>これらの変数は、ゼロから始まり、固定された順序で番号が付けられた（「大部分は左から右へ」という番号の）「標準変数」に置き換えられますが、実際は一貫していれば問題ありません。</span> </p><br> <a class=notranslate href=#1./traits/canonical-queries.html>cq</a> <br> <p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So, for example, if we have the type <code>X = (?T, ?U)</code> , where <code>?T</code> and <code>?U</code> are distinct, unbound inference variables, then the canonical form of <code>X</code> would be <code>(?0, ?1)</code> , where <code>?0</code> and <code>?1</code> represent these <b>canonical placeholders</b> .</span>我々がタイプしている場合ので、例えば、 <code>X = (?T, ?U)</code> <code>?T</code>し、 <code>?U</code>その後の正規形、別個の、未結合の推論変数で<code>X</code>だろう<code>(?0, ?1)</code>ここで<code>?0</code>と<code>?1</code>はこれらの<b>カノニカルプレースホルダを</b>表す。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that the type <code>Y = (?U, ?T)</code> also canonicalizes to <code>(?0, ?1)</code> .</span>タイプことに注意してください<code>Y = (?U, ?T)</code>も正規化する<code>(?0, ?1)</code></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But the type <code>Z = (?T, ?T)</code> would canonicalize to <code>(?0, ?0)</code> (as would <code>(?U, ?U)</code> ).</span>しかしタイプ<code>Z = (?T, ?T)</code>に正規化であろう<code>(?0, ?0)</code>同じように<code>(?U, ?U)</code></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In other words, the exact identity of the inference variables is not important – unless they are repeated.</span>言い換えれば、推論変数の正確なアイデンティティーは重要ではありません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We use this to improve caching as well as to detect cycles and other things during trait resolution.</span>これを使用して、キャッシュを改善するとともに、特性の決定時にサイクルやその他のものを検出します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Roughly speaking, the idea is that if two trait queries have the same canonicalize form, then they will get the same answer.</span>おおまかに言えば、2つの特性クエリーが同じ正規化フォームを持つ場合、同じ回答が得られるという考え方です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That answer will be expressed in terms of the canonical variables ( <code>?0</code> , <code>?1</code> ), which we can then map back to the original variables ( <code>?T</code> , <code>?U</code> ).</span>その答えは正準変数（ <code>?0</code> 、 <code>?1</code> ）の形で表現され、元の変数（ <code>?T</code> 、 <code>?U</code> ）に戻すことができます。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Canonicalizing the query</span>クエリの正規化</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To see how it works, imagine that we are asking to solve the following trait query: <code>?A: Foo&lt;&#39;static, ?B&gt;</code> , where <code>?A</code> and <code>?B</code> are unbound.</span>どのように動作するかを見るために、以下の特性クエリを解くように求めていると想像してください： <code>?A: Foo&lt;&#39;static, ?B&gt;</code> <code>?A</code>と<code>?B</code>は非結合です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This query contains two unbound variables, but it also contains the lifetime <code>&#39;static</code> .</span>このクエリには2つのバインドされていない変数が含まれていますが、ライフタイム<code>&#39;static</code>変数も含まれてい<code>&#39;static</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The trait system generally ignores all lifetimes and treats them equally, so when canonicalizing, we will <i>also</i> replace any <a href=#2./appendix/background.html#free-vs-bound>free lifetime</a> with a canonical variable.</span>トレイトシステムは、一般的に、すべての寿命を無視し、平等に扱いますので、canonicalizingとき、我々は<i>また</i> 、任意の置き換えます<a href=#2./appendix/background.html#free-vs-bound>自由寿命を</a>正準変数で。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Therefore, we get the following result:</span>したがって、次の結果が得られます。</span> </p><br><div data-lang=text><div data-l="?0: Foo&lt;'?1, ?2&gt;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Sometimes we write this differently, like so:</span>時にはこれを次のように書きます：</span> </p><br><div data-lang=text><div data-l="for&lt;T,L,T&gt; { ?0: Foo&lt;'?1, ?2&gt; }"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This <code>for&lt;&gt;</code> gives some information about each of the canonical variables within.</span>これ<code>for&lt;&gt;</code>に対して、それぞれの正準変数についての情報を提供します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this case, each <code>T</code> indicates a type variable, so <code>?0</code> and <code>?2</code> are types;</span>この場合、各<code>T</code>は型変数を示すので、 <code>?0</code>と<code>?2</code>は型です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">the <code>L</code> indicates a lifetime varibale, so <code>?1</code> is a lifetime.</span> <code>L</code>生涯varibaleを示し、そう<code>?1</code>寿命です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>canonicalize</code> method <i>also</i> gives back a <code>CanonicalVarValues</code> array OV with the &quot;original values&quot; for each canonicalized variable:</span> <code>canonicalize</code>方法は<i>また</i> 、バック与える<code>CanonicalVarValues</code>各正規化変数の「元の値」と配列OVました：</span> </p><br><div data-lang=text><div data-l="[?A, 'static, ?B]"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll need this vector OV later, when we process the query response.</span>クエリ応答を処理するときに、このベクトルOVが後で必要になります。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Executing the query</span>クエリの実行</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Once we&#39;ve constructed the canonical query, we can try to solve it.</span>標準クエリを作成したら、それを解決しようとすることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To do so, we will wind up creating a fresh inference context and <b>instantiating</b> the canonical query in that context.</span>そのためには、新しい推論コンテキストを作成し、そのコンテキストで標準クエリを<b>インスタンス化</b>することになります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The idea is that we create a substitution S from the canonical form containing a fresh inference variable (of suitable kind) for each canonical variable.</span>考え方は、それぞれの正準変数に対して（適切な種類の）新鮮な推論変数を含むカノニカルフォームから置換Sを作成することです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So, for our example query:</span>したがって、サンプルクエリでは、次のようになります。</span> </p><br><div data-lang=text><div data-l="for&lt;T,L,T&gt; { ?0: Foo&lt;'?1, ?2&gt; }"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">the substitution S might be:</span>置換Sは次のようになります。</span> </p><br><div data-lang=text><div data-l="S = [?A, '?B, ?C]"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can then replace the bound canonical variables ( <code>?0</code> , etc) with these inference variables, yielding the following fully instantiated query:</span>次に、結合された標準変数（ <code>?0</code>など）をこれらの推論変数に置き換えて、完全にインスタンス化された次のクエリを生成することができます。</span> </p><br><div data-lang=text><div data-l="?A: Foo&lt;'?B, ?C&gt;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Remember that substitution S though!</span>代用Sを忘れないで！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;re going to need it later.</span>私たちは後でそれを必要とします。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">OK, now that we have a fresh inference context and an instantiated query, we can go ahead and try to solve it.</span>これで新しい推論コンテキストとインスタンス化されたクエリができたので、これを解決しようとします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The trait solver itself is explained in more detail in <a href=#2./traits/slg.html>another section</a> , but suffice to say that it will compute a <a href=#3cqqr>certainty value</a> ( <code>Proven</code> or <code>Ambiguous</code> ) and have side-effects on the inference variables we&#39;ve created.</span>特性ソルバー自体については、 <a href=#2./traits/slg.html>別のセクション</a>で詳しく説明しますが、 <a href=#3cqqr>確実性値</a> （ <code>Proven</code>または<code>Ambiguous</code> ）を計算し、作成した推論変数に副作用があるといっても過言ではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, if there were only one impl of <code>Foo</code> , like so:</span>たとえば、 <code>Foo</code>インプリメントが1つだけだった場合、次のようになります。</span> </p><br> <a class=notranslate href=#1./traits/canonical-queries.html#query-response>cqqr</a> <br> <div data-lang=rust,ignore><div data-l="impl&lt;'a, X&gt; Foo&lt;'a, X&gt; for Vec&lt;X&gt;"></div><div data-l="where X: 'a"></div><div data-l="{ ... }"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">then we might wind up with a certainty value of <code>Proven</code> , as well as creating fresh inference variables <code>&#39;?D</code> and <code>?E</code> (to represent the parameters on the impl) and unifying as follows:</span> <code>Proven</code>確からしさを念頭に置いて、新たな推論変数<code>&#39;?D</code>と<code>?E</code> （implのパラメータを表現するために） <code>&#39;?D</code>を作り、次のように統一するかもしれない：</span> </p><br><div data-b=-> <code>&#39;?B = &#39;?D</code> </div> <div data-b=-> <code>?A = Vec&lt;?E&gt;</code> </div> <div data-b=-> <code>?C = ?E</code> </div> <br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We would also accumulate the region constraint <code>?E: &#39;?D</code> , due to the where clause.</span>また、where句のために、領域制約<code>?E: &#39;?D</code>累積します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In order to create our final query result, we have to &quot;lift&quot; these values out of the query&#39;s inference context and into something that can be reapplied in our original inference context.</span>最終的なクエリ結果を作成するためには、これらの値をクエリの推論コンテキストから元の推論コンテキストに再適用できるものに「持ち上げる」必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We do that by <b>re-applying canonicalization</b> , but to the <b>query result</b> .</span>これは、 <b>正規化を再適用することで</b>行い<b>ます</b>が、 <b>クエリ結果に</b> <b>適用</b>し<b>ます</b> 。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Canonicalizing the query result</span>クエリ結果の正規化</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As discussed in <a href=#3cqqr>the parent section</a> , most trait queries wind up with a result that brings together a &quot;certainty value&quot; <code>certainty</code> , a result substitution <code>var_values</code> , and some region constraints.</span> <a href=#3cqqr>親セクション</a>で説明し<a href=#3cqqr>た</a>ように、ほとんどの特性クエリは、「確実性値」 <code>certainty</code> 、結果置換<code>var_values</code> 、および一部の領域制約を<code>var_values</code>た結果を<code>var_values</code>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To create this, we wind up re-using the substitution S that we created when first instantiating our query.</span>これを作成するために、最初にクエリをインスタンス化するときに作成した置換Sを再利用します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To refresh your memory, we had a query</span>あなたの記憶をリフレッシュするために、</span> </p><br><div data-lang=text><div data-l="for&lt;T,L,T&gt; { ?0: Foo&lt;'?1, ?2&gt; }"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">for which we made a substutition S:</span>それに対して私たちは副義を作ったS：</span> </p><br><div data-lang=text><div data-l="S = [?A, '?B, ?C]"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We then did some work which unified some of those variables with other things.</span>その後、これらの変数のいくつかを他のものと統合した作業を行いました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we &quot;refresh&quot; S with the latest results, we get:</span>最新の結果をSに反映させると、次のようになります。</span> </p><br><div data-lang=text><div data-l="S = [Vec&lt;?E&gt;, '?D, ?E]"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These are precisely the new values for the three input variables from our original query.</span>これらは、元のクエリの3つの入力変数の新しい値です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note though that they include some new variables (like <code>?E</code> ).</span>ただし、それらにはいくつかの新しい変数（「 <code>?E</code> ）が含まれています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can make those go away by canonicalizing again!</span>私たちはもう一度canonicalizingすることによってそれらを去らせることができます！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We don&#39;t just canonicalize S, though, we canonicalize the whole query response QR:</span> Sを正規化するだけではありませんが、クエリ応答QR全体を正規化します。</span> </p><br><div data-lang=text><div data-l="QR = {"></div><div data-l="#//    certainty: Proven,             // or whatever"></div><div data-l="    certainty: Proven,             // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">or whatever</span>または何でも</span> </div><div data-l="#//    var_values: [Vec&lt;?E&gt;, '?D, ?E] // this is S"></div><div data-l="    var_values: [Vec&lt;?E&gt;, '?D, ?E] // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">this is S</span>これはSです</span> </div><div data-l="#//    region_constraints: [?E: '?D], // from the impl"></div><div data-l="    region_constraints: [?E: '?D], // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">from the impl</span>インプラントから</span> </div><div data-l="#//    value: (),                     // for our purposes, just (), but"></div><div data-l="#                                   // in some cases this might have"></div><div data-l="#                                   // a type or other info"></div><div data-l="    value: (),                     // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">for our purposes, just (), but in some cases this might have a type or other info</span>私たちの目的のためには、just（）ですが、場合によっては型やその他の情報</span> </div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The result would be as follows:</span>結果は次のようになります。</span> </p><br><div data-lang=text><div data-l="Canonical(QR) = for&lt;T, L&gt; {"></div><div data-l="    certainty: Proven,"></div><div data-l="    var_values: [Vec&lt;?0&gt;, '?1, ?2]"></div><div data-l="    region_constraints: [?2: '?1],"></div><div data-l="    value: (),"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">(One subtle point: when we canonicalize the query <b>result</b> , we do not use any special treatment for free lifetimes. Note that both references to <code>&#39;?D</code> , for example, were converted into the same canonical variable ( <code>?1</code> ). This is in contrast to the original query, where we canonicalized every free lifetime into a fresh canonical variable.)</span> （1つの微妙な点：クエリの<b>結果</b>を正規化するとき、フリーライフタイムには特別な扱いはしません。たとえば、 <code>&#39;?D</code>両方の参照は同じ標準変数（ <code>?1</code> ）に変換されています。すべてのフリーライフを正規の新しい変数に正規化した元のクエリとは対照的です）。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now, this result must be reapplied in each context where needed.</span>さて、この結果は、必要に応じてそれぞれの文脈で再適用しなければなりません。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Processing the canonicalized query result</span>正規化されたクエリ結果の処理</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In the previous section we produced a canonical query result.</span>前のセクションでは、標準クエリ結果を作成しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We now have to apply that result in our original context.</span>その結果を元の文脈で適用する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you recall, way back in the beginning, we were trying to prove this query:</span>あなたが思い出すと、始めに戻って、私たちはこのクエリを証明しようとしていました：</span> </p><br><div data-lang=text><div data-l="?A: Foo&lt;'static, ?B&gt;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We canonicalized that into this:</span>これを標準化しました：</span> </p><br><div data-lang=text><div data-l="for&lt;T,L,T&gt; { ?0: Foo&lt;'?1, ?2&gt; }"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">and now we got back a canonical response:</span>今、標準的な応答を得ました：</span> </p><br><div data-lang=text><div data-l="for&lt;T, L&gt; {"></div><div data-l="    certainty: Proven,"></div><div data-l="    var_values: [Vec&lt;?0&gt;, '?1, ?2]"></div><div data-l="    region_constraints: [?2: '?1],"></div><div data-l="    value: (),"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We now want to apply that response to our context.</span>私たちは現在、その応答を私たちの状況に適用したいと考えています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Conceptually, how we do that is to (a) instantiate each of the canonical variables in the result with a fresh inference variable, (b) unify the values in the result with the original values, and then (c) record the region constraints for later.</span>概念的には、（a）結果の中の正準変数をそれぞれ新しい推論変数でインスタンス化し、（b）結果の値を元の値に統一し、（c）後で。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Doing step (a) would yield a result of</span>ステップ（a）を実行すると、</span> </p><br><div data-lang=text><div data-l={></div><div data-l="      certainty: Proven,"></div><div data-l="      var_values: [Vec&lt;?C&gt;, '?D, ?C]"></div><div data-l="                       ^^   ^^^ fresh inference variables"></div><div data-l="      region_constraints: [?C: '?D],"></div><div data-l="      value: (),"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Step (b) would then unify:</span>ステップ（b）は、</span> </p><br><div data-lang=text><div data-l="?A with Vec&lt;?C&gt;"></div><div data-l="'static with '?D"></div><div data-l="?B with ?C"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">And finally the region constraint of <code>?C: &#39;static</code> would be recorded for later verification.</span>最後に、 <code>?C: &#39;static</code>の領域制約は、後で検証するために記録されます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">(What we <i>actually</i> do is a mildly optimized variant of that: Rather than eagerly instantiating all of the canonical values in the result with variables, we instead walk the vector of values, looking for cases where the value is just a canonical variable. In our example, <code>values[2]</code> is <code>?C</code> , so that means we can deduce that <code>?C := ?B and</code> &#39;?D := &#39;static`. This gives us a partial set of values. Anything for which we do not find a value, we create an inference variable.)</span> （私たちが<i>実際に</i>やっているのは、やや最適化された変数です。結果の標準的な値すべてを変数で瞬時にインスタンス化するのではなく、値のベクトルを歩き、値が標準的な変数である場合を探します。例えば、 <code>values[2]</code>は<code>?C</code>なので、 <code>?C := ?B and</code> &#39;？D：=&#39; static`を推論することができます。値、推論変数を作成します。）</span> </p><br><script>_addload(function(){_setupIW('com');_csi('en','ja','canonicalization.html');});</script>