<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180723_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=goals-and-clauses.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Goals and clauses</span>目標と句</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In logic programming terms, a <b>goal</b> is something that you must prove and a <b>clause</b> is something that you know is true.</span>論理プログラミングの用語では、 <b>目標</b>はあなたが証明しなければならないものであり、 <b>句</b>はあなたが知っているものが真であるものです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As described in the <a href=#2./traits/lowering-to-logic.html>lowering to logic</a> chapter, Rust&#39;s trait solver is based on an extension of hereditary harrop (HH) clauses, which extend traditional Prolog Horn clauses with a few new superpowers.</span> <a href=#2./traits/lowering-to-logic.html>ロジックの</a>章に記載されているように、Rustの特性ソルバーは、いくつかの新しいスーパーパワーを持つ伝統的なPrologホーン節を拡張する遺伝的ハーロープ（HH）節の拡張に基づいています。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Goals and clauses meta structure</span>目標と句メタ構造</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In Rust&#39;s solver, <b>goals</b> and <b>clauses</b> have the following forms (note that the two definitions reference one another):</span> Rustのソルバーでは、 <b>目標</b>と<b>節</b>は次のような形をしています（2つの定義がお互いを参照しています）。</span> </p><br><div data-lang=text><div data-l="#//Goal = DomainGoal           // defined in the section below"></div><div data-l="Goal = DomainGoal           // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">defined in the section below</span>下のセクションで定義されています</span> </div><div data-l="        | Goal &amp;&amp; Goal"></div><div data-l="        | Goal || Goal"></div><div data-l="#//        | exists&lt;K&gt; { Goal }   // existential quantification"></div><div data-l="        | exists&lt;K&gt; { Goal }   // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">existential quantification</span>存在量の定量化</span> </div><div data-l="#//        | forall&lt;K&gt; { Goal }   // universal quantification"></div><div data-l="        | forall&lt;K&gt; { Goal }   // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">universal quantification</span>普遍的な定量</span> </div><div data-l="#//        | if (Clause) { Goal } // implication"></div><div data-l="        | if (Clause) { Goal } // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">implication</span>含意</span> </div><div data-l="#//        | true                 // something that's trivially true"></div><div data-l="        | true                 // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">something that&#39;s trivially true</span>自明のことだ</span> </div><div data-l="#//        | ambiguous            // something that's never provable"></div><div data-l="        | ambiguous            // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">something that&#39;s never provable</span>証明できないもの</span> </div><div data-l=""></div><div data-l="Clause = DomainGoal"></div><div data-l="#//        | Clause :- Goal     // if can prove Goal, then Clause is true"></div><div data-l="        | Clause :- Goal     // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">if can prove Goal, then Clause is true</span> Goalを証明できれば、句は真です</span> </div><div data-l="        | Clause &amp;&amp; Clause"></div><div data-l="        | forall&lt;K&gt; { Clause }"></div><div data-l=""></div><div data-l="#//K = &lt;type&gt;     // a &quot;kind&quot;"></div><div data-l="K = &lt;type&gt;     // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">a &quot;kind&quot;</span> &quot;種類&quot;</span> </div><div data-l="    | &lt;lifetime&gt;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The proof procedure for these sorts of goals is actually quite straightforward.</span>これらの種類の目標に対する証明手続きは、実際には非常に簡単です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Essentially, it&#39;s a form of depth-first search.</span>基本的に、これは深さ優先検索の一種です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The paper <a href=#3pphhf>&quot;A Proof Procedure for the Logic of Hereditary Harrop Formulas&quot;</a> gives the details.</span> <a href=#3pphhf>「遺伝的なハロップロ式の論理のための証明手続き」</a>という論文が詳細を述べている。</span> </p><br> <a class=notranslate href=#1./traits/bibliography.html#pphhf>pphhf</a> <br> <p><a name=domain-goals></a></p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Domain goals</span>ドメインの目標</span> </h2><br><p><a name=trait-ref></a></p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To define the set of <i>domain goals</i> in our system, we need to first introduce a few simple formulations.</span>私たちのシステムで一連の<i>ドメイン目標</i>を定義するには、最初にいくつかの簡単な形式を導入する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A <b>trait reference</b> consists of the name of a trait along with a suitable set of inputs P0..Pn:</span> <b>形質の参照</b>は、形質の名前と適切な入力の集合P0..Pnから成ります。</span> </p><br><div data-lang=text><div data-l="TraitRef = P0: TraitName&lt;P1..Pn&gt;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So, for example, <code>u32: Display</code> is a trait reference, as is <code>Vec&lt;T&gt;: IntoIterator</code> .</span>したがって、たとえば、 <code>u32: Display</code>は<code>Vec&lt;T&gt;: IntoIterator</code>ように、特性参照<code>Vec&lt;T&gt;: IntoIterator</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that Rust surface syntax also permits some extra things, like associated type bindings ( <code>Vec&lt;T&gt;: IntoIterator&lt;Item = T&gt;</code> ), that are not part of a trait reference.</span> Rustサーフェスシンタックスでは、関連する型のバインディング（ <code>Vec&lt;T&gt;: IntoIterator&lt;Item = T&gt;</code> ）のようないくつかの余分なものが、特性参照の一部ではないことにも注意してください。</span> </p><br><p><a name=projection></a></p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A <b>projection</b> consists of an associated item reference along with its inputs P0..Pm:</span> <b>投影</b>は、入力P0..Pmと共に関連するアイテム参照から成ります。</span> </p><br><div data-lang=text><div data-l="Projection = &lt;P0 as TraitName&lt;P1..Pn&gt;&gt;::AssocItem&lt;Pn+1..Pm&gt;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Given these, we can define a <code>DomainGoal</code> as follows:</span>これらを考えると、次のように<code>DomainGoal</code>を定義できます。</span> </p><br><div data-lang=text><div data-l="DomainGoal = Implemented(TraitRef)"></div><div data-l="            | ProjectionEq(Projection = Type)"></div><div data-l="            | Normalize(Projection -&gt; Type)"></div><div data-l="            | FromEnv(TraitRef)"></div><div data-l="            | FromEnv(Projection = Type)"></div><div data-l="            | WellFormed(Type)"></div><div data-l="            | WellFormed(TraitRef)"></div><div data-l="            | WellFormed(Projection = Type)"></div><div data-l="            | Outlives(Type: Region)"></div><div data-l="            | Outlives(Region: Region)"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s break down each one of these, one-by-one.</span>これらのそれぞれを1つ1つずつ分解しましょう。</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Implemented(TraitRef)</span>実装済み（TraitRef）</span> </h4><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">eg <code>Implemented(i32: Copy)</code></span>例： <code>Implemented(i32: Copy)</code></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">True if the given trait is implemented for the given input types and lifetimes.</span>指定された入力タイプおよび有効期間に対して、指定された特性が実装されている場合はtrueです。</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">ProjectionEq(Projection = Type)</span>プロジェクションイク（プロジェクション=タイプ）</span> </h4><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">eg <code>ProjectionEq&lt;T as Iterator&gt;::Item = u8</code></span>例えば<code>ProjectionEq&lt;T as Iterator&gt;::Item = u8</code></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The given associated type <code>Projection</code> is equal to <code>Type</code> ;</span>指定された関連型<code>Projection</code>は<code>Type</code>等しい。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">this can be proved with either normalization or using skolemized types.</span>これは、正規化またはスカラー化された型を使用して証明することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">See <a href=#2./traits/associated-types.html>the section on associated types</a> .</span> <a href=#2./traits/associated-types.html>関連するタイプのセクションを</a>参照してください。</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Normalize(Projection -&gt; Type)</span>正規化（投影→タイプ）</span> </h4><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">eg <code>ProjectionEq&lt;T as Iterator&gt;::Item -&gt; u8</code></span>例えば<code>ProjectionEq&lt;T as Iterator&gt;::Item -&gt; u8</code></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The given associated type <code>Projection</code> can be <a class=notranslate href=#3n>normalized</a> to <code>Type</code> .</span>与えられた関連型<code>Projection</code>は<code>Type</code>に<a class=notranslate href=#3n>normalized</a>できます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As discussed in <a href=#2./traits/associated-types.html>the section on associated types</a> , <code>Normalize</code> implies <code>ProjectionEq</code> , but not vice versa.</span> <a href=#2./traits/associated-types.html>関連するタイプのセクションで</a>説明し<a href=#2./traits/associated-types.html>た</a>ように、 <code>Normalize</code> <code>ProjectionEq</code>意味し<a href=#2./traits/associated-types.html>ますが</a> 、その逆はしません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In general, proving <code>Normalize(&lt;T as Trait&gt;::Item -&gt; U)</code> also requires proving <code>Implemented(T: Trait)</code> .</span>一般的には、 <code>Normalize(&lt;T as Trait&gt;::Item -&gt; U)</code>証明するには、 <code>Implemented(T: Trait)</code>証明が必要です。</span> </p><br> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a class=notranslate href=#1./traits/associated-types.html#normalize>n</a> <a class=notranslate href=#1./traits/associated-types.html>at</a></span> <a class=notranslate href=#1./traits/associated-types.html#normalize>n</a> <a class=notranslate href=#1./traits/associated-types.html>at</a></span> <br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">FromEnv(TraitRef), FromEnv(Projection = Type)</span> FromEnv（TraitRef）、FromEnv（Projection = Type）</span> </h4><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">eg <code>FromEnv(Self: Add&lt;i32&gt;)</code></span>例： <code>FromEnv(Self: Add&lt;i32&gt;)</code></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">eg <code>FromEnv(&lt;Self as StreamingIterator&gt;::Item&lt;&#39;a&gt; = &amp;&#39;a [u8])</code></span>例えば<code>FromEnv(&lt;Self as StreamingIterator&gt;::Item&lt;&#39;a&gt; = &amp;&#39;a [u8])</code></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">True if the inner <code>TraitRef</code> or projection equality is <i>assumed</i> to be true;</span>内側の<code>TraitRef</code>または投影法の同等性が真であると<i>仮定さ</i>れている場合はTrueです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">that is, if it can be derived from the in-scope where clauses.</span>つまり、スコープ内のwhereスコープから派生することができる場合です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, given the following function:</span>たとえば、次の関数を指定します。</span> </p><br><div data-lang=rust><div data-l="fn loud_clone&lt;T: Clone&gt;(stuff: &amp;T) -&gt; T {"></div><div data-l="    println!(&quot;cloning!&quot;);"></div><div data-l="    stuff.clone()"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Inside the body of our function, we would have <code>FromEnv(T: Clone)</code> .</span>私たちの機能の中には、 <code>FromEnv(T: Clone)</code>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In-scope where clauses nest, so a function body inside an impl body inherits the impl body&#39;s where clauses, too.</span>スコープ内でスコープが入れ子になるので、インプラント本体内の関数本体は、インプ本体のwhere句も継承します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This and the next rule are used to implement <a class=notranslate href="#4implied bounds">implied bounds</a> .</span>この規則と次の規則は、 <a class=notranslate href="#4implied bounds">implied bounds</a>を実装するために使用さ<a class=notranslate href="#4implied bounds">implied bounds</a> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As we&#39;ll see in the section on lowering, <code>FromEnv(X)</code> implies <code>Implemented(X)</code> , but not vice versa.</span>下のセクションで見ているように、 <code>FromEnv(X)</code> <code>Implemented(X)</code>意味しますが、その逆はしません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This distinction is crucial to implied bounds.</span>この区別は、暗黙の境界にとって重要です。</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">WellFormed(Item)</span> WellFormed（アイテム）</span> </h4><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These goals imply that the given item is <i>well-formed</i> .</span>これらの目標は、所定の項目が<i>整形式である</i>ことを意味する。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can talk about different types of items being well-formed:</span>整形式のアイテムの種類について話すことができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><b>Types</b> , like <code>WellFormed(Vec&lt;i32&gt;)</code> , which is true in Rust, or <code>WellFormed(Vec&lt;str&gt;)</code> , which is not (because <code>str</code> is not <code>Sized</code> .)</span> Rustや<code>WellFormed(Vec&lt;str&gt;)</code>に<code>WellFormed(Vec&lt;i32&gt;)</code>ような<b>型</b>はありません（ <code>str</code>は<code>Sized</code>はないためです）。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><b>TraitRefs</b> , like <code>WellFormed(Vec&lt;i32&gt;: Clone)</code> .</span> <b>WellFormed</b> <code>WellFormed(Vec&lt;i32&gt;: Clone)</code>ような<code>WellFormed(Vec&lt;i32&gt;: Clone)</code> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><b>Projections</b> , like <code>WellFormed(T: Iterator&lt;Item = u32&gt;)</code> .</span> <code>WellFormed(T: Iterator&lt;Item = u32&gt;)</code>ような<b>投影</b> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Well-formedness is important to <a class=notranslate href="#4implied bounds">implied bounds</a> .</span>うまく形成さ<a class=notranslate href="#4implied bounds">implied bounds</a> 、 <a class=notranslate href="#4implied bounds">implied bounds</a>にとって重要です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In particular, the reason it is okay to assume <code>FromEnv(T: Clone)</code> in the example above is that we <s>also</s> verify <code>WellFormed(T: Clone)</code> for each call site of <code>loud_clone</code> .</span>特に、上記の例で<code>FromEnv(T: Clone)</code>を使用するといい理由は、 <code>loud_clone</code>各呼び出しサイトに対して<code>WellFormed(T: Clone)</code> <s>も</s>検証すること<code>loud_clone</code> 。</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Outlives(Type: Region), Outlives(Region: Region)</span>アウトライフ（種類：地域）、アウトライフ（地域：地域）</span> </h4><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">eg <code>Outlives(&amp;&#39;a str: &#39;b)</code> , <code>Outlives(&#39;a: &#39;static)</code></span>例えば<code>Outlives(&amp;&#39;a str: &#39;b)</code> 、 <code>Outlives(&#39;a: &#39;static)</code></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">True if the given type or region on the left outlives the right-hand region.</span>指定された型または領域が右側の領域よりも長い場合はtrue。</span> </p><br><p><a name=coinductive></a></p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Coinductive goals</span>共創の目標</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Most goals in our system are &quot;inductive&quot;.</span>私たちのシステムのほとんどの目標は「誘導的」です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In an inductive goal, circular reasoning is disallowed.</span>帰納的目標では、循環推論は禁止されています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Consider this example clause:</span>この例の節を考えてみましょう。</span> </p><br><div data-lang=text><div data-l="    Implemented(Foo: Bar) :-"></div><div data-l="        Implemented(Foo: Bar)."></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Considered inductively, this clause is useless: if we are trying to prove <code>Implemented(Foo: Bar)</code> , we would then recursively have to prove <code>Implemented(Foo: Bar)</code> , and that cycle would continue ad infinitum (the trait solver will terminate here, it would just consider that <code>Implemented(Foo: Bar)</code> is not known to be true).</span>誘導考えられ、この句は無意味です：我々は証明しようとしている場合<code>Implemented(Foo: Bar)</code> 、我々は、再帰的に証明しなければならない<code>Implemented(Foo: Bar)</code> 、そしてそのサイクルは無限に継続する（形質ソルバーは、ここで終了します<code>Implemented(Foo: Bar)</code>が真実であるとは知られていないと考えられます）。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, some goals are <i>co-inductive</i> .</span>しかし、いくつかの目標は<i>共誘導的である</i> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Simply put, this means that cycles are OK.</span>簡単に言えば、これはサイクルがOKであることを意味します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So, if <code>Bar</code> were a co-inductive trait, then the rule above would be perfectly valid, and it would indicate that <code>Implemented(Foo: Bar)</code> is true.</span>したがって、 <code>Bar</code>が共誘導特性の場合、上記のルールは完全に有効であり、 <code>Implemented(Foo: Bar)</code>がtrueであることを示します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><i>Auto traits</i> are one example in Rust where co-inductive goals are used.</span> <i>自動特性</i>は、誘導目標が使用されるRustの1つの例です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Consider the <code>Send</code> trait, and imagine that we have this struct:</span> <code>Send</code>特性を考えて、この構造体があると想像してください：</span> </p><br><div data-lang=rust><div data-l="struct Foo {"></div><div data-l="    next: Option&lt;Box&lt;Foo&gt;&gt;"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The default rules for auto traits say that <code>Foo</code> is <code>Send</code> if the types of its fields are <code>Send</code> .</span>自動形質のデフォルトのルールはと言う<code>Foo</code>されて<code>Send</code>そのフィールドのタイプがされている場合は<code>Send</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Therefore, we would have a rule like</span>したがって、私たちは</span> </p><br><div data-lang=text><div data-l="Implemented(Foo: Send) :-"></div><div data-l="    Implemented(Option&lt;Box&lt;Foo&gt;&gt;: Send)."></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As you can probably imagine, proving that <code>Option&lt;Box&lt;Foo&gt;&gt;: Send</code> is going to wind up circularly requiring us to prove that <code>Foo: Send</code> again.</span>おそらくあなたが想像しているように、 <code>Option&lt;Box&lt;Foo&gt;&gt;: Send</code>は循環的に巻き上げられ、 <code>Foo: Send</code>再度証明する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So this would be an example where we wind up in a cycle – but that&#39;s ok, we <i>do</i> consider <code>Foo: Send</code> to hold, even though it references itself.</span>だからこれは、我々がサイクルで巻き上げる例です - しかしそれは大丈夫です、私たち<i>は</i> <code>Foo: Send</code>を考慮し<code>Foo: Send</code>それが自分自身を参照していても、保留にします。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In general, co-inductive traits are used in Rust trait solving when we want to enumerate a fixed set of possibilities.</span>一般的に、固定抵抗の集合を列挙したいときには、共誘導特性がRust特性解法で使用されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In the case of auto traits, we are enumerating the set of reachable types from a given starting point (ie, <code>Foo</code> can reach values of type <code>Option&lt;Box&lt;Foo&gt;&gt;</code> , which implies it can reach values of type <code>Box&lt;Foo&gt;</code> , and then of type <code>Foo</code> , and then the cycle is complete).</span>自動特性の場合、与えられた開始点から到達可能な型のセットを列挙しています（つまり、 <code>Foo</code>は<code>Option&lt;Box&lt;Foo&gt;&gt;</code>型の値に達することができます。これは<code>Box&lt;Foo&gt;</code> <code>Foo</code>タイプの場合、サイクルが完了します）。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In addition to auto traits, <code>WellFormed</code> predicates are co-inductive.</span>オート<code>WellFormed</code>加えて、 <code>WellFormed</code>述語は共誘導的です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These are used to achieve a similar &quot;enumerate all the cases&quot; pattern, as described in the section on <a class=notranslate href="#4implied bounds">implied bounds</a> .</span>これらは、 <a class=notranslate href="#4implied bounds">implied bounds</a>に関するセクションで説明したように、同様の「すべてのケースを列挙する」パターンを達成するために使用さ<a class=notranslate href="#4implied bounds">implied bounds</a> 。</span> </p><br> <a class=notranslate href=#1./traits/lowering-rules.html#implied-bounds>implied bounds</a> <br> <h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Incomplete chapter</span>不完全な章</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Some topics yet to be written:</span>まだ書かれていないいくつかのトピック：</span> </p><br><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Elaborate on the proof procedure</span>証明手続きを詳述する</span> </div><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">SLG solving – introduce negative reasoning</span> SLGの解決 - 否定的な推論を導入する</span> </div><script>_addload(function(){_setupIW('com');_csi('en','ja','goals-and-clauses.html');});</script>