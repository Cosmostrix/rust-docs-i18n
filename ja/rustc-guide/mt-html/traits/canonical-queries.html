<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180723_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=canonical-queries.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Canonical queries</span>標準クエリ</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The &quot;start&quot; of the trait system is the <b>canonical query</b> (these are both queries in the more general sense of the word – something you would like to know the answer to – and in the <a href=#2./query.html>rustc-specific sense</a> ).</span>形質システムの「スタート」は<b>標準的なクエリーです</b> （これは、より一般的な意味でのクエリーです - あなたが答えを知りたいと思っているものと<a href=#2./query.html>錆びた特異的な意味で</a> ）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The idea is that the type checker or other parts of the system, may in the course of doing their thing want to know whether some trait is implemented for some type (eg, is <code>u32: Debug</code> true?).</span>考え方は、型チェッカーやシステムの他の部分は、ある種の特性（例えば、 <code>u32: Debug</code> true？）が実装されているかどうかを知りたいということです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Or they may want to <a href=#2./traits/associated-types.html>normalize some associated type</a> .</span>あるいは、 <a href=#2./traits/associated-types.html>関連するタイプ</a>を<a href=#2./traits/associated-types.html>正規化し</a>たいかもしれません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This section covers queries at a fairly high level of abstraction.</span>このセクションでは、抽象度のかなり高いレベルでのクエリについて説明します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The subsections look a bit more closely at how these ideas are implemented in rustc.</span>サブセクションは、これらのアイデアがどのようにしっかりとして実装されているかを少し詳しく見ています。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The traditional, interactive Prolog query</span>従来のインタラクティブなPrologクエリ</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In a traditional Prolog system, when you start a query, the solver will run off and start supplying you with every possible answer it can find.</span>伝統的なPrologシステムでは、クエリを開始するとソルバが実行され、検索可能なすべての回答がユーザに提供されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So given something like this:</span>だからこのような何かを与えられた：</span> </p><br><div data-lang=text><div data-l="?- Vec&lt;i32&gt;: AsRef&lt;?U&gt;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The solver might answer:</span>ソルバーは答えます：</span> </p><br><div data-lang=text><div data-l="Vec&lt;i32&gt;: AsRef&lt;[i32]&gt;"></div><div data-l="    continue? (y/n)"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This <code>continue</code> bit is interesting.</span>この<code>continue</code>ビットは面白いです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The idea in Prolog is that the solver is finding <b>all possible</b> instantiations of your query that are true.</span> Prologのアイデアは、ソルバーが実際のクエリのインスタンス化を<b>すべて</b>見つけることです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this case, if we instantiate <code>?U = [i32]</code> , then the query is true (note that a traditional Prolog interface does not, directly, tell us a value for <code>?U</code> , but we can infer one by unifying the response with our original query – Rust&#39;s solver gives back a substitution instead).</span>この場合、 <code>?U = [i32]</code>をインスタンス化すると、クエリは真です（伝統的なPrologインタフェースは、 <code>?U</code>値を直接指示しませんが、私たちは元のクエリ -  Rustのソルバーは代わりに代入を返します）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we were to hit <code>y</code> , the solver might then give us another possible answer:</span> <code>y</code>を打つと、ソルバーは別の可能な答えを与えるかもしれません：</span> </p><br><div data-lang=text><div data-l="Vec&lt;i32&gt;: AsRef&lt;Vec&lt;i32&gt;&gt;"></div><div data-l="    continue? (y/n)"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This answer derives from the fact that there is a reflexive impl ( <code>impl&lt;T&gt; AsRef&lt;T&gt; for T</code> ) for <code>AsRef</code> .</span>この回答は（再帰のimplがあるという事実に由来<code>impl&lt;T&gt; AsRef&lt;T&gt; for T</code>のために） <code>AsRef</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If were to hit <code>y</code> again, then we might get back a negative response:</span>もう一度<code>y</code>を押すと、否定応答を返す可能性があります。</span> </p><br><div data-lang=text><div data-l=no></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Naturally, in some cases, there may be no possible answers, and hence the solver will just give me back <code>no</code> right away:</span>当然のことながら、いくつかのケースでは、何の可能な答えがないことが、ひいてはソルバーはちょうど私が戻って与える<code>no</code>すぐに：</span> </p><br><div data-lang=text><div data-l="?- Box&lt;i32&gt;: Copy"></div><div data-l="    no"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In some cases, there might be an infinite number of responses.</span>場合によっては、無限の応答が存在する可能性があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So for example if I gave this query, and I kept hitting <code>y</code> , then the solver would never stop giving me back answers:</span>たとえば、このクエリを与えても、 <code>y</code>を続けていたら、ソルバーは決して私に答えを返すことを止めることはできません：</span> </p><br><div data-lang=text><div data-l="?- Vec&lt;?U&gt;: Clone"></div><div data-l="    Vec&lt;i32&gt;: Clone"></div><div data-l="        continue? (y/n)"></div><div data-l="    Vec&lt;Box&lt;i32&gt;&gt;: Clone"></div><div data-l="        continue? (y/n)"></div><div data-l="    Vec&lt;Box&lt;Box&lt;i32&gt;&gt;&gt;: Clone"></div><div data-l="        continue? (y/n)"></div><div data-l="    Vec&lt;Box&lt;Box&lt;Box&lt;i32&gt;&gt;&gt;&gt;: Clone"></div><div data-l="        continue? (y/n)"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As you can imagine, the solver will gleefully keep adding another layer of <code>Box</code> until we ask it to stop, or it runs out of memory.</span>あなたが想像しているように、ソルバーは、停止するように頼むまで、あるいは記憶がなくなるまで、別の層の<code>Box</code>追加し続けます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Another interesting thing is that queries might still have variables in them.</span>もう1つの興味深い点は、クエリにはまだ変数が含まれている可能性があるということです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example:</span>例えば：</span> </p><br><div data-lang=text><div data-l="?- Rc&lt;?T&gt;: Clone"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">might produce the answer:</span>答えを出すかもしれない：</span> </p><br><div data-lang=text><div data-l="Rc&lt;?T&gt;: Clone"></div><div data-l="    continue? (y/n)"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">After all, <code>Rc&lt;?T&gt;</code> is true <b>no matter what type `?T` is</b> .</span>結局、 <code>Rc&lt;?T&gt;</code>は<b>どんな型の `？T &#39;であって</b>も真<b>です</b> 。</span> </p><br><p><a name=query-response></a></p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A trait query in rustc</span> rustcの形質のクエリ</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The trait queries in rustc work somewhat differently.</span> rustcのtrait queryはやや異なった働きをします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Instead of trying to enumerate <b>all possible</b> answers for you, they are looking for an <b>unambiguous</b> answer.</span> <b>可能なすべての</b>回答を列挙しようとするのではなく、 <b>曖昧さのない</b>回答を探しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In particular, when they tell you the value for a type variable, that means that this is the <b>only possible instantiation</b> that you could use, given the current set of impls and where-clauses, that would be provable.</span>特に、型変数の値を伝えると、これは、現在のimplsとwhere-clauseのセットがあれば、それが証明<b>できる唯一の可能なインスタンス化で</b>あることを意味します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">(Internally within the solver, though, they can potentially enumerate all possible answers. See <a href=#2./traits/slg.html>the description of the SLG solver</a> for details.)</span> （ソルバーの内部では、すべての可能な解を列挙できる可能性があります。詳細<a href=#2./traits/slg.html>については、SLGソルバーの説明を</a>参照<a href=#2./traits/slg.html>し</a>てください）。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The response to a trait query in rustc is typically a <code>Result&lt;QueryResult&lt;T&gt;, NoSolution&gt;</code> (where the <code>T</code> will vary a bit depending on the query itself).</span> rustcでのtraitクエリへの応答は、通常、 <code>Result&lt;QueryResult&lt;T&gt;, NoSolution&gt;</code> （ <code>T</code>はクエリ自体に依存して変化します）です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Err(NoSolution)</code> case indicates that the query was false and had no answers (eg, <code>Box&lt;i32&gt;: Copy</code> ).</span> <code>Err(NoSolution)</code>場合は、クエリが偽であり、回答がないことを示します（ <code>Box&lt;i32&gt;: Copy</code> ）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Otherwise, the <code>QueryResult</code> gives back information about the possible answer(s) we did find.</span>それ以外の場合、 <code>QueryResult</code>は、 <code>QueryResult</code>た可能な回答に関する情報を返します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It consists of four parts:</span>それは4つの部分で構成されています。</span> </p><br><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><b>Certainty:</b> tells you how sure we are of this answer.</span> <b>確かなこと：</b>私たちがこの答えをどのようにしているかを伝えます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It can have two values:</span>それは2つの値を持つことができます：</span> </div><div data-b="  -"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>Proven</code> means that the result is known to be true.</span> <code>Proven</code>とは、結果が真実であることを意味します。</span> </div><div data-b="    -"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This might be the result for trying to prove <code>Vec&lt;i32&gt;: Clone</code> , say, or <code>Rc&lt;?T&gt;: Clone</code> .</span>これは<code>Vec&lt;i32&gt;: Clone</code> 、 <code>Rc&lt;?T&gt;: Clone</code>を証明しようとした結果です。</span> </div><div data-b="  -"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>Ambiguous</code> means that there were things we could not yet prove to be either true <i>or</i> false, typically because more type information was needed.</span> <code>Ambiguous</code>ということは、より多くの型情報が必要だったために、我々がまだ真実<i>か</i>偽であるかを証明できなかったことがあることを意味します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">(We&#39;ll see an example shortly.)</span> （まもなく例が表示されます）</span> </div><div data-b="    -"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This might be the result for trying to prove <code>Vec&lt;?T&gt;: Clone</code> .</span>これは、 <code>Vec&lt;?T&gt;: Clone</code>を証明しようとした場合の結果かもしれません。</span> </div><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><b>Var values:</b> Values for each of the unbound inference variables (like <code>?T</code> ) that appeared in your original query.</span>変数<b>値：</b>元のクエリに現れたアンバウンドの推論変数（ <code>?T</code> ）のそれぞれの値。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">(Remember that in Prolog, we had to infer these.)</span> （Prologではこれらを推測しなければならなかったことを忘れないでください）。</span> </div><div data-b="  -"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As we&#39;ll see in the example below, we can get back var values even for <code>Ambiguous</code> cases.</span>下の例で見るように、 <code>Ambiguous</code>場合でもvar値を戻すことができます。</span> </div><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><b>Region constraints:</b> these are relations that must hold between the lifetimes that you supplied as inputs.</span> <b>地域の制約：</b>これはあなたが入力として提供した生涯の間に保持されなければならない関係です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll ignore these here, but see the <a href=#2./traits/regions.html>section on handling regions in traits</a> for more details.</span>これらはここでは無視しますが、詳細については<a href=#2./traits/regions.html>特性の領域を扱うセクションを</a>参照してください。</span> </div><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><b>Value:</b> The query result also comes with a value of type <code>T</code> .</span> <b>値：</b>クエリ結果には、タイプ<code>T</code>値も含まれます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For some specialized queries – like normalizing associated types – this is used to carry back an extra result, but it&#39;s often just <code>()</code> .</span>関連する型の正規化などの特殊なクエリでは、余分な結果を返すために使用されますが、しばしば単なる<code>()</code>です。</span> </div><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Examples</span>例</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s work through an example query to see what all the parts mean.</span>すべての部品の意味を調べるためのサンプルクエリを試してみましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Consider <a href=#3borrow>the <code>Borrow</code> trait</a> .</span> <a href=#3borrow><code>Borrow</code>特性を</a>考えてみましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This trait has a number of impls;</span>この形質には多くの意味があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">among them, there are these two (for clarify, I&#39;ve written the <code>Sized</code> bounds explicitly):</span>その中には、これらの2つがあります（明確にするために、私は<code>Sized</code>境界を明示的に記述しました）。</span> </p><br> <a class=notranslate href=#1https://doc.rust-lang.org/std/borrow/trait.Borrow.html>borrow</a> <br> <div data-lang=rust,ignore><div data-l="impl&lt;T&gt; Borrow&lt;T&gt; for T where T: ?Sized"></div><div data-l="impl&lt;T&gt; Borrow&lt;[T]&gt; for Vec&lt;T&gt; where T: Sized"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><b>Example 1.</b> Imagine we are type-checking this (rather artificial) bit of code:</span> <b>例1.</b>この（人工的ではなく）コードの型チェックをしているとします。</span> </p><br><div data-lang=rust,ignore><div data-l="fn foo&lt;A, B&gt;(a: A, vec_b: Option&lt;B&gt;) where A: Borrow&lt;B&gt; { }"></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="#//    let mut t: Vec&lt;_&gt; = vec![]; // Type: Vec&lt;?T&gt;"></div><div data-l="    let mut t: Vec&lt;_&gt; = vec![]; // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Type: Vec</span>タイプ：Vec</span> <?T></div><div data-l="#//    let mut u: Option&lt;_&gt; = None; // Type: Option&lt;?U&gt;"></div><div data-l="    let mut u: Option&lt;_&gt; = None; // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Type: Option</span>タイプ：オプション</span> <?U></div><div data-l="#//    foo(t, u); // Example 1: requires `Vec&lt;?T&gt;: Borrow&lt;?U&gt;`"></div><div data-l="    foo(t, u); // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Example 1: requires <code>Vec&lt;?T&gt;: Borrow&lt;?U&gt;</code></span>例1： <code>Vec&lt;?T&gt;: Borrow&lt;?U&gt;</code>が必要<code>Vec&lt;?T&gt;: Borrow&lt;?U&gt;</code></span> </div><div data-l="    ..."></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As the comments indicate, we first create two variables <code>t</code> and <code>u</code> ;</span>コメントが示すように、まず2つの変数<code>t</code>と<code>u</code>作成します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>t</code> is an empty vector and <code>u</code> is a <code>None</code> option.</span> <code>t</code>は空のベクトルで、 <code>u</code>は<code>None</code>オプションです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Both of these variables have unbound inference variables in their type: <code>?T</code> represents the elements in the vector <code>t</code> and <code>?U</code> represents the value stored in the option <code>u</code> .</span>これらの変数の両方とも、その型に束縛されていない推論変数を持ち<code>?T</code>はベクトル<code>t</code>要素を表し、 <code>?U</code>はオプション<code>u</code>格納された値を表します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Next, we invoke <code>foo</code> ;</span>次に、 <code>foo</code>を呼び出します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">comparing the signature of <code>foo</code> to its arguments, we wind up with <code>A = Vec&lt;?T&gt;</code> and <code>B = ?U</code> .Therefore, the where clause on <code>foo</code> requires that <code>Vec&lt;?T&gt;: Borrow&lt;?U&gt;</code> .</span> <code>foo</code>のシグネチャとその引数を比較すると、 <code>A = Vec&lt;?T&gt;</code>と<code>B = ?U</code>となり<code>B = ?U</code>したがって、 <code>foo</code>のwhere句には<code>Vec&lt;?T&gt;: Borrow&lt;?U&gt;</code>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is thus our first example trait query.</span>これが最初のtrait queryの例です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There are many possible solutions to the query <code>Vec&lt;?T&gt;: Borrow&lt;?U&gt;</code> ;</span>クエリ<code>Vec&lt;?T&gt;: Borrow&lt;?U&gt;</code>は、多くの解決策があります<code>Vec&lt;?T&gt;: Borrow&lt;?U&gt;</code> ;</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">for example:</span>例えば：</span> </p><br><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>?U = Vec&lt;?T&gt;</code> ,</span> <code>?U = Vec&lt;?T&gt;</code></span> </div><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>?U = [?T]</code> ,</span> <code>?U = [?T]</code> 、</span> </div><div data-b=-> <code>?T = u32, ?U = [u32]</code> </div> <div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">and so forth.</span>等々。</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Therefore, the result we get back would be as follows (I&#39;m going to ignore region constraints and the &quot;value&quot;):</span>したがって、私たちが返す結果は次のようになります（リージョンの制約と「値」を無視します）。</span> </p><br><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Certainty: <code>Ambiguous</code> – we&#39;re not sure yet if this holds</span>確実性： <code>Ambiguous</code> - これが成立すればまだわからない</span> </div><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Var values: <code>[?T = ?T, ?U = ?U]</code> – we learned nothing about the values of the variables</span>変数値： <code>[?T = ?T, ?U = ?U]</code> - 変数の値については何も学びませんでした</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In short, the query result says that it is too soon to say much about whether this trait is proven.</span>要するに、クエリーの結果は、この形質が証明されているかどうかについてはあまりにも早すぎると言います。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">During type-checking, this is not an immediate error: instead, the type checker would hold on to this requirement ( <code>Vec&lt;?T&gt;: Borrow&lt;?U&gt;</code> ) and wait.</span>タイプチェックの間、これは直接的なエラーではありません。代わりに、タイプチェッカーはこの要件（ <code>Vec&lt;?T&gt;: Borrow&lt;?U&gt;</code> ）を保持して待機します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As we&#39;ll see in the next example, it may happen that <code>?T</code> and <code>?U</code> wind up constrained from other sources, in which case we can try the trait query again.</span>次の例でわかるように、 <code>?T</code>と<code>?U</code>が他のソースから拘束されることがあります。この場合、特性クエリを再度試すことができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><b>Example 2.</b> We can now extend our previous example a bit, and assign a value to <code>u</code> :</span> <b>例2</b>これまでの例を少し拡張して、 <code>u</code>値を代入することができます：</span> </p><br><div data-lang=rust,ignore><div data-l="fn foo&lt;A, B&gt;(a: A, vec_b: Option&lt;B&gt;) where A: Borrow&lt;B&gt; { }"></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="#    // What we saw before:"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">What we saw before:</span>私たちが以前見たもの：</span> </div><div data-l="#//    let mut t: Vec&lt;_&gt; = vec![]; // Type: Vec&lt;?T&gt;"></div><div data-l="    let mut t: Vec&lt;_&gt; = vec![]; // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Type: Vec</span>タイプ：Vec</span> <?T></div><div data-l="#//    let mut u: Option&lt;_&gt; = None; // Type: Option&lt;?U&gt;"></div><div data-l="    let mut u: Option&lt;_&gt; = None; // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Type: Option</span>タイプ：オプション</span> <?U></div><div data-l="#//    foo(t, u); // `Vec&lt;?T&gt;: Borrow&lt;?U&gt;` =&gt; ambiguous"></div><div data-l="    foo(t, u); // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>Vec&lt;?T&gt;: Borrow&lt;?U&gt;</code> =&gt; ambiguous</span> <code>Vec&lt;?T&gt;: Borrow&lt;?U&gt;</code> =&gt;あいまい</span> </div><div data-l=""></div><div data-l="#    // New stuff:"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">New stuff:</span>新しいもの：</span> </div><div data-l="#//    u = Some(vec![]); // ?U = Vec&lt;?V&gt;"></div><div data-l="    u = Some(vec![]); // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">?U = Vec</span> ？U = Vec</span> <?V></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As a result of this assignment, the type of <code>u</code> is forced to be <code>Option&lt;Vec&lt;?V&gt;&gt;</code> , where <code>?V</code> represents the element type of the vector.</span>この代入の結果として、 <code>u</code>の型は強制的に<code>Option&lt;Vec&lt;?V&gt;&gt;</code>になり<code>?V</code>ここで、 <code>?V</code>はベクトルの要素型を表します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This in turn implies that <code>?U</code> is <a class=notranslate href=#4unified>unified</a> to <code>Vec&lt;?V&gt;</code> .</span>これは、 <code>?U</code>が<code>Vec&lt;?V&gt;</code> <a class=notranslate href=#4unified>unified</a>れることを意味する。</span> </p><br> <a class=notranslate href=#1./type-checking.html>unified</a> <br> <p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s suppose that the type checker decides to revisit the &quot;as-yet-unproven&quot; trait obligation we saw before, <code>Vec&lt;?T&gt;: Borrow&lt;?U&gt;</code> .</span>タイプ・チェッカーが、以前に見た「未だに証明されていない」特性義務を再考することを決めたとしよう<code>Vec&lt;?T&gt;: Borrow&lt;?U&gt;</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>?U</code> is no longer an unbound inference variable;</span> <code>?U</code>はもはや束縛されていない推論変数ではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">it now has a value, <code>Vec&lt;?V&gt;</code> .</span> <code>Vec&lt;?V&gt;</code>という値を持つようになりました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So, if we &quot;refresh&quot; the query with that value, we get:</span>したがって、その値でクエリを「リフレッシュ」すると、次のようになります。</span> </p><br><div data-lang=text><div data-l="Vec&lt;?T&gt;: Borrow&lt;Vec&lt;?V&gt;&gt;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This time, there is only one impl that applies, the reflexive impl:</span>今回は、適用されるインプラントは1つしかなく、リフレクティブなインプットがあります。</span> </p><br><div data-lang=text><div data-l="impl&lt;T&gt; Borrow&lt;T&gt; for T where T: ?Sized"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Therefore, the trait checker will answer:</span>したがって、特性チェッカーは答えます：</span> </p><br><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Certainty: <code>Proven</code></span>確かさ： <code>Proven</code></span> </div><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Var values: <code>[?T = ?T, ?V = ?T]</code></span> Var値： <code>[?T = ?T, ?V = ?T]</code></span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here, it is saying that we have indeed proven that the obligation holds, and we also know that <code>?T</code> and <code>?V</code> are the same type (but we don&#39;t know what that type is yet!).</span>ここでは、義務が成立していることが実証されているということ<code>?T</code>と<code>?V</code>は同じタイプです（ただし、そのタイプはまだわかりません）。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">(In fact, as the function ends here, the type checker would give an error at this point, since the element types of <code>t</code> and <code>u</code> are still not yet known, even though they are known to be the same.)</span> （関数がここで終わると、型チェッカーは<code>t</code>と<code>u</code>要素型がまだ分かっていないため、この時点で型チェッカーにエラーが発生します）。</span> </p><br><br><script>_addload(function(){_setupIW('com');_csi('en','ja','canonical-queries.html');});</script>