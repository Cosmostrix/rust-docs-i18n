<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180723_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=lowering-to-logic.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Lowering to logic</span>ロジックに下げる</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The key observation here is that the Rust trait system is basically a kind of logic, and it can be mapped onto standard logical inference rules.</span>ここで重要なのは、Rust形質システムは基本的に一種の論理であり、標準の論理推論ルールにマッピングできるということです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can then look for solutions to those inference rules in a very similar fashion to how eg a <a class=notranslate href=#4Prolog>Prolog</a> solver works.</span>これらの推論規則の解を、 <a class=notranslate href=#4Prolog>Prolog</a>ソルバの動作方法と非常によく似た方法で探すことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It turns out that we can&#39;t <i>quite</i> use Prolog rules (also called Horn clauses) but rather need a somewhat more expressive variant.</span>それは、我々は<i>非常に</i> Prologのルールを使用します（また、ホーン節と呼ばれる）のではなく、ややより表現の変形を必要とすることはできませんことが判明しました。</span> </p><br> <a class=notranslate href=#1https://en.wikipedia.org/wiki/Prolog>Prolog</a> <br> <h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust traits and logic</span>錆の特性とロジック</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">One of the first observations is that the Rust trait system is basically a kind of logic.</span>最初の観察の1つは、Rust形質システムは基本的に一種の論理であるということです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As such, we can map our struct, trait, and impl declarations into logical inference rules.</span>このように、私たちはstruct、trait、impl宣言を論理的な推論規則にマップすることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For the most part, these are basically Horn clauses, though we&#39;ll see that to capture the full richness of Rust – and in particular to support generic programming – we have to go a bit further than standard Horn clauses.</span>ほとんどの場合、これらは基本的にHorn節ですが、Rustの完全な豊富さ、特に汎用プログラミングをサポートすることがわかりますが、標準的なHorn節よりも少し先に進む必要があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To see how this mapping works, let&#39;s start with an example.</span>このマッピングがどのように機能するかを確認するには、まず例を見てみましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Imagine we declare a trait and a few impls, like so:</span>私たちが特質を宣言し、いくつかのことがそうであると想像してみましょう：</span> </p><br><div data-lang=rust><div data-l="trait Clone { }"></div><div data-l="impl Clone for usize { }"></div><div data-l="impl&lt;T&gt; Clone for Vec&lt;T&gt; where T: Clone { }"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We could map these declarations to some Horn clauses, written in a Prolog-like notation, as follows:</span>これらの宣言を、Prologのような表記法で書かれたHorn節にマップすると、次のようになります。</span> </p><br><div data-lang=text><div data-l=Clone(usize).></div><div data-l="Clone(Vec&lt;?T&gt;) :- Clone(?T)."></div><div data-l=""></div><div data-l="#// The notation `A :- B` means &quot;A is true if B is true&quot;."></div><div data-l="#// Or, put another way, B implies A."></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The notation <code>A :- B</code> means &quot;A is true if B is true&quot;.</span>表記<code>A :- B</code>は、 &quot; <code>A :- B</code>が真であればAは真&quot;を意味する。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Or, put another way, B implies A.</span>あるいは、別の言い方をすれば、BはAを意味する。</span> </div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In Prolog terms, we might say that <code>Clone(Foo)</code> – where <code>Foo</code> is some Rust type – is a <i>predicate</i> that represents the idea that the type <code>Foo</code> implements <code>Clone</code> .</span> Prologの項では、我々は言うかもしれない<code>Clone(Foo)</code> - <code>Foo</code> 、いくつかの錆のタイプであるが-タイプという考えを表す<i>述語</i>である<code>Foo</code>実装<code>Clone</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These rules are <b>program clauses</b> ;</span>これらの規則は<b>プログラム条項</b>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">they state the conditions under which that predicate can be proven (ie, considered true).</span>その述語が証明できる（すなわち、真であると考えられる）条件を述べている。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So the first rule just says &quot;Clone is implemented for <code>usize</code> &quot;.</span>したがって、最初のルールでは「クローンは<code>usize</code>ために実装されてい<code>usize</code> 」と<code>usize</code>れています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The next rule says &quot;for any type <code>?T</code> , Clone is implemented for <code>Vec&lt;?T&gt;</code> if clone is implemented for <code>?T</code> &quot;.</span>次のルールでは、「どのタイプの<code>?T</code>でもクローンが<code>?T</code>に実装されていれば、 <code>Vec&lt;?T&gt;</code>ためにクローンが実装されてい<code>?T</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So eg if we wanted to prove that <code>Clone(Vec&lt;Vec&lt;usize&gt;&gt;)</code> , we would do so by applying the rules recursively:</span>たとえば、 <code>Clone(Vec&lt;Vec&lt;usize&gt;&gt;)</code>を証明したい場合、ルールを再帰的に適用することでそうすることができます。</span> </p><br><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>Clone(Vec&lt;Vec&lt;usize&gt;&gt;)</code> is provable if:</span> <code>Clone(Vec&lt;Vec&lt;usize&gt;&gt;)</code>は、次の場合に証明可能です。</span> </div><div data-b="  -"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>Clone(Vec&lt;usize&gt;)</code> is provable if:</span> <code>Clone(Vec&lt;usize&gt;)</code>は、次の場合に証明可能です。</span> </div><div data-b="    -"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>Clone(usize)</code> is provable.</span> <code>Clone(usize)</code>は証明可能です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">(Which is is, so we&#39;re all good.)</span> （それは、だから私たちはすべて良いです。）</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But now suppose we tried to prove that <code>Clone(Vec&lt;Bar&gt;)</code> .</span>しかし今、私たちが<code>Clone(Vec&lt;Bar&gt;)</code>を証明しようとしたとします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This would fail (after all, I didn&#39;t give an impl of <code>Clone</code> for <code>Bar</code> ):</span>これは失敗する（結局、私は<code>Bar</code>の<code>Clone</code>インプリメントを与えなかった）。</span> </p><br><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>Clone(Vec&lt;Bar&gt;)</code> is provable if:</span> <code>Clone(Vec&lt;Bar&gt;)</code>は、次の場合に証明可能です。</span> </div><div data-b="  -"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>Clone(Bar)</code> is provable.</span> <code>Clone(Bar)</code>は証明可能です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">(But it is not, as there are no applicable rules.)</span> （ただし、適用されるルールがないため、そうではありません。）</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can easily extend the example above to cover generic traits with more than one input type.</span>上記の例を、複数の入力タイプを持つ一般的な特性をカバーするように簡単に拡張することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So imagine the <code>Eq&lt;T&gt;</code> trait, which declares that <code>Self</code> is equatable with a value of type <code>T</code> :</span>それで、 <code>Self</code>が<code>T</code>型の値と等価であると宣言する<code>Eq&lt;T&gt;</code>特性を想像してください：</span> </p><br><div data-lang=rust,ignore><div data-l="trait Eq&lt;T&gt; { ... }"></div><div data-l="impl Eq&lt;usize&gt; for usize { }"></div><div data-l="impl&lt;T: Eq&lt;U&gt;&gt; Eq&lt;Vec&lt;U&gt;&gt; for Vec&lt;T&gt; { }"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That could be mapped as follows:</span>それは次のようにマッピングすることができます：</span> </p><br><div data-lang=text><div data-l="Eq(usize, usize)."></div><div data-l="Eq(Vec&lt;?T&gt;, Vec&lt;?U&gt;) :- Eq(?T, ?U)."></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So far so good.</span>ここまでは順調ですね。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Type-checking normal functions</span>型チェック正常関数</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">OK, now that we have defined some logical rules that are able to express when traits are implemented and to handle associated types, let&#39;s turn our focus a bit towards <b>type-checking</b> .</span>さて、形質の実装時に表現できる論理的な規則を定義し、関連する型を扱うようになったので、ここでは<b>型チェックに</b>向けて少し焦点を合わせましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Type-checking is interesting because it is what gives us the goals that we need to prove.</span>タイプ・チェックは面白いです。なぜなら、タイプ・チェッキングは私たちが証明する必要がある目標を提供するからです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That is, everything we&#39;ve seen so far has been about how we derive the rules by which we can prove goals from the traits and impls in the program;</span>つまり、今まで見てきたことは、どのようにして我々がその特性から目標を証明し、プログラムに含めることができるかというルールを導き出すことであった。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">but we are also interested in how to derive the goals that we need to prove, and those come from type-checking.</span>しかし、私たちが証明しなければならない目標を導出する方法と、型チェックから来るものにも興味があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Consider type-checking the function <code>foo()</code> here:</span>次の関数<code>foo()</code>型チェックを検討してください。</span> </p><br><div data-lang=rust,ignore><div data-l="fn foo() { bar::&lt;usize&gt;() }"></div><div data-l="fn bar&lt;U: Eq&lt;U&gt;&gt;() { }"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This function is very simple, of course: all it does is to call <code>bar::&lt;usize&gt;()</code> .</span>この関数は非常に単純<code>bar::&lt;usize&gt;()</code>を呼び出すだけです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now, looking at the definition of <code>bar()</code> , we can see that it has one where-clause <code>U: Eq&lt;U&gt;</code> .</span>さて、 <code>bar()</code>定義を見ると、where節<code>U: Eq&lt;U&gt;</code>があることが分かります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So, that means that <code>foo()</code> will have to prove that <code>usize: Eq&lt;usize&gt;</code> in order to show that it can call <code>bar()</code> with <code>usize</code> as the type argument.</span>だから、 <code>foo()</code>は、 <code>usize</code>をtype引数として<code>bar()</code>を<code>usize</code>ことを示すために、 <code>usize: Eq&lt;usize&gt;</code>を証明する必要があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we wanted, we could write a Prolog predicate that defines the conditions under which <code>bar()</code> can be called.</span>必要ならば、 <code>bar()</code>を呼び出すことができる条件を定義するProlog述語を書くことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll say that those conditions are called being &quot;well-formed&quot;:</span>これらの条件は「整形式」と呼ばれています。</span> </p><br><div data-lang=text><div data-l="barWellFormed(?U) :- Eq(?U, ?U)."></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then we can say that <code>foo()</code> type-checks if the reference to <code>bar::&lt;usize&gt;</code> (that is, <code>bar()</code> applied to the type <code>usize</code> ) is well-formed:</span>次に<code>foo()</code>型は、 <code>bar()</code> <code>bar::&lt;usize&gt;</code>への参照（つまり、 <code>usize</code>型に適用された<code>bar()</code>が<code>bar::&lt;usize&gt;</code>式であるかどうかを<code>usize</code> ）。</span> </p><br><div data-lang=text><div data-l="fooTypeChecks :- barWellFormed(usize)."></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we try to prove the goal <code>fooTypeChecks</code> , it will succeed:</span> <code>fooTypeChecks</code>の目標を証明しようとすると成功します：</span> </p><br><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>fooTypeChecks</code> is provable if:</span> <code>fooTypeChecks</code>場合、 <code>fooTypeChecks</code>は証明可能です。</span> </div><div data-b="  -"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>barWellFormed(usize)</code> , which is provable if:</span> <code>barWellFormed(usize)</code> 。次の場合に証明可能です。</span> </div><div data-b="    -"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>Eq(usize, usize)</code> , which is provable because of an impl.</span> <code>Eq(usize, usize)</code> 。これはimplのために証明可能です。</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Ok, so far so good.</span>さて、これほど良い。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s move on to type-checking a more complex function.</span>もっと複雑な関数の型チェックをしましょう。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Type-checking generic functions: beyond Horn clauses</span>型チェック汎用関数：ホーン節を越えて</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In the last section, we used standard Prolog horn-clauses (augmented with Rust&#39;s notion of type equality) to type-check some simple Rust functions.</span>最後のセクションでは、シンプルなRust関数を型チェックするために、標準的なPrologホーン節（Rustの型平等の概念を補強したもの）を使用しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But that only works when we are type-checking non-generic functions.</span>しかし、これは非ジェネリック関数を型チェックするときにのみ機能します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we want to type-check a generic function, it turns out we need a stronger notion of goal than Prolog can be provide.</span>ジェネリック関数の型チェックをしたいのであれば、Prologが提供できる目標よりも強い目標が必要であることが分かります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To see what I&#39;m talking about, let&#39;s revamp our previous example to make <code>foo</code> generic:</span>私が何を話しているのかを見るには、前の例を改良して<code>foo</code>一般化するようにしましょう：</span> </p><br><div data-lang=rust,ignore><div data-l="fn foo&lt;T: Eq&lt;T&gt;&gt;() { bar::&lt;T&gt;() }"></div><div data-l="fn bar&lt;U: Eq&lt;U&gt;&gt;() { }"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To type-check the body of <code>foo</code> , we need to be able to hold the type <code>T</code> &quot;abstract&quot;.</span> <code>foo</code>の本体を型チェックするには、型<code>T</code> &quot;抽象&quot;にする必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That is, we need to check that the body of <code>foo</code> is type-safe <i>for all types `T`</i> , not just for some specific type.</span>つまり、 <code>foo</code>の本体が、特定の型だけでなく、 <i>すべての型 &#39;T&#39;に対して</i>型安全であることを確認する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We might express this like so:</span>私たちはこれを次のように表現するかもしれません：</span> </p><br><div data-lang=text><div data-l="fooTypeChecks :-"></div><div data-l="#  // for all types T..."></div><div data-l="  // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">for all types T...</span>すべてのタイプのTのために...</span> </div><div data-l="  forall&lt;T&gt; {"></div><div data-l="#    // ...if we assume that Eq(T, T) is provable..."></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">...if we assume that Eq(T, T) is provable...</span> ... Eq（T、T）が証明可能であると仮定すると...</span> </div><div data-l="    if (Eq(T, T)) {"></div><div data-l="#      // ...then we can prove that `barWellFormed(T)` holds."></div><div data-l="      // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">...then we can prove that <code>barWellFormed(T)</code> holds.</span> ... <code>barWellFormed(T)</code>が成り立つことを証明できます。</span> </div><div data-l="      barWellFormed(T)"></div><div data-l="    }"></div><div data-l="  }."></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This notation I&#39;m using here is the notation I&#39;ve been using in my prototype implementation;</span>ここで使用しているこの表記法は、私のプロトタイプ実装で使用している表記法です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">it&#39;s similar to standard mathematical notation but a bit Rustified.</span>それは標準的な数学的表記法に似ていますが、少し錆びました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Anyway, the problem is that standard Horn clauses don&#39;t allow universal quantification ( <code>forall</code> ) or implication ( <code>if</code> ) in goals (though many Prolog engines do support them, as an extension).</span>とにかく、問題は、標準的なホーン節では、普遍的な定量化（ <code>forall</code> ）や含意（ <code>if</code> ）がゴールに許されないことです（多くのPrologエンジンがそれらをサポートしていますが）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For this reason, we need to accept something called &quot;first-order hereditary harrop&quot; (FOHH) clauses – this long name basically means &quot;standard Horn clauses with <code>forall</code> and <code>if</code> in the body&quot;.</span>この長い名前は基本的に「と標準ホーン節意味-このような理由から、私たちは、「一次遺伝性のハロップ」（FOHH）条項と呼ばれるもの受け入れる必要が<code>forall</code>と<code>if</code> 、体内での」。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But it&#39;s nice to know the proper name, because there is a lot of work describing how to efficiently handle FOHH clauses;</span>しかし、FOHH句を効率的に扱う方法を記述する作業がたくさんあるので、適切な名前を知ることはうれしいことです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">see for example Gopalan Nadathur&#39;s excellent <a href=#3pphhf>&quot;A Proof Procedure for the Logic of Hereditary Harrop Formulas&quot;</a> in <a class=notranslate href="#4the bibliography">the bibliography</a> .</span>例ゴパランNadathurの優れたを参照<a href=#3pphhf>「遺伝ハロップ式のロジックのための証明手順」</a>で<a class=notranslate href="#4the bibliography">the bibliography</a> 。</span> </p><br> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a class=notranslate href=#1./traits/bibliography.html>the bibliography</a> <a class=notranslate href=#1./traits/bibliography.html#pphhf>pphhf</a></span> <a class=notranslate href=#1./traits/bibliography.html>the bibliography</a> <a class=notranslate href=#1./traits/bibliography.html#pphhf>pphhf</a></span> <br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It turns out that supporting FOHH is not really all that hard.</span> FOHHのサポートはそれほど難しいことではないことが判明しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">And once we are able to do that, we can easily describe the type-checking rule for generic functions like <code>foo</code> in our logic.</span>そしてそれができたら、 <code>foo</code>ようなジェネリック関数の型チェックルールをロジックに簡単に記述することができます。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Source</span>ソース</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This page is a lightly adapted version of a <a href=#3lrtl>blog post by Nicholas Matsakis</a> .</span>このページは、 <a href=#3lrtl>Nicholas Matsakisのブログ記事の</a>軽いバージョンです。</span> </p><br> <a class=notranslate href=#1http://smallcultfollowing.com/babysteps/blog/2017/01/26/lowering-rust-traits-to-logic/>lrtl</a><script>_addload(function(){_setupIW('com');_csi('en','ja','lowering-to-logic.html');});</script>