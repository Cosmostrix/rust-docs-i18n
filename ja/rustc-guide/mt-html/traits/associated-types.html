<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180723_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=associated-types.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Equality and associated types</span>等価および関連タイプ</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This section covers how the trait system handles equality between associated types.</span>このセクションでは、形質システムが関連するタイプ間の等価性をどのように処理するかについて説明します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The full system consists of several moving parts, which we will introduce one by one:</span>フルシステムはいくつかの可動部品で構成されています.1つずつ紹介します：</span> </p><br><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Projection and the <code>Normalize</code> predicate</span>投影法と<code>Normalize</code>述語</span> </div><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Skolemization</span> Skolemization</span> </div><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>ProjectionEq</code> predicate</span> <code>ProjectionEq</code>述語</span> </div><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Integration with unification</span>統一との統合</span> </div><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Associated type projection and normalization</span>関連型の投影と正規化</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When a trait defines an associated type (eg, <a href=#3intoiter-item>the <code>Item</code> type in the <code>IntoIterator</code> trait</a> ), that type can be referenced by the user using an <b>associated type projection</b> like <code>&lt;Option&lt;u32&gt; as IntoIterator&gt;::Item</code> .</span>形質が関連タイプ（例えば、 <a href=#3intoiter-item><code>IntoIterator</code>特性の<code>Item</code>タイプ</a> ）を定義するとき、そのタイプは、 <code>&lt;Option&lt;u32&gt; as IntoIterator&gt;::Item</code>ような<b>関連するタイプ投影</b>を使用してユーザによって参照され得る。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">(Often, though, people will use the shorthand syntax <code>T::Item</code> – presently, that syntax is expanded during <a href=#2./type-checking.html>&quot;type collection&quot;</a> into the explicit form, though that is something we may want to change in the future.)</span> （しばしば、人々は短縮形の構文<code>T::Item</code>を使用します - 現時点では、その構文は<a href=#2./type-checking.html>&quot;型の収集</a>中に<a href=#2./type-checking.html>&quot;</a>明示的な形式に展開されますが、将来的に変更することができます。</span> </p><br> <a class=notranslate href=#1https://doc.rust-lang.org/nightly/core/iter/trait.IntoIterator.html#associatedtype.Item>intoiter-item</a> <br> <p><a name=normalize></a></p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In some cases, associated type projections can be <b>normalized</b> – that is, simplified – based on the types given in an impl.</span>場合によっては、implで指定された型に基づいて、関連する型の投影を<b>正規化</b>することができます（つまり、単純化されます）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So, to continue with our example, the impl of <code>IntoIterator</code> for <code>Option&lt;T&gt;</code> declares (among other things) that <code>Item = T</code> :</span>したがって、この例を続けると、 <code>IntoIterator</code> for <code>Option&lt;T&gt;</code> <code>IntoIterator</code> 、（特に） <code>Item = T</code> ：を宣言します。</span> </p><br><div data-lang=rust,ignore><div data-l="impl&lt;T&gt; IntoIterator for Option&lt;T&gt; {"></div><div data-l="  type Item = T;"></div><div data-l="  ..."></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This means we can normalize the projection <code>&lt;Option&lt;u32&gt; as IntoIterator&gt;::Item</code> to just <code>u32</code> .</span>これは、我々が投影正規化することができることを意味し<code>&lt;Option&lt;u32&gt; as IntoIterator&gt;::Item</code>だけに<code>u32</code> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this case, the projection was a &quot;monomorphic&quot; one – that is, it did not have any type parameters.</span>この場合、投影は「単相性」であり、つまり型パラメータはありませんでした。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Monomorphic projections are special because they can <b>always</b> be fully normalized – but often we can normalize other associated type projections as well.</span>単相性投影は<b>常に</b>完全に正規化できるので特別ですが、しばしば他の関連する投影も正規化することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, <code>&lt;Option&lt;?T&gt; as IntoIterator&gt;::Item</code> (where <code>?T</code> is an inference variable) can be normalized to just <code>?T</code> .</span>例えば、 <code>&lt;Option&lt;?T&gt; as IntoIterator&gt;::Item</code> （ <code>&lt;Option&lt;?T&gt; as IntoIterator&gt;::Item</code> <code>?T</code>は推論変数） <code>&lt;Option&lt;?T&gt; as IntoIterator&gt;::Item</code>は、単に<code>?T</code>正規化することができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In our logic, normalization is defined by a predicate <code>Normalize</code> .</span>私たちのロジックでは、正規化は述語<code>Normalize</code>によって定義されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Normalize</code> clauses arise only from impls.</span> <code>Normalize</code>句はimplからのみ発生します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, the <code>impl</code> of <code>IntoIterator</code> for <code>Option&lt;T&gt;</code> that we saw above would be lowered to a program clause like so:</span>たとえば、 <code>impl</code>の<code>IntoIterator</code>ための<code>Option&lt;T&gt;</code>上で見たようにのようなプログラム節に低下してしまいます。</span> </p><br><div data-lang=text><div data-l="forall&lt;T&gt; {"></div><div data-l="    Normalize(&lt;Option&lt;T&gt; as IntoIterator&gt;::Item -&gt; T) :-"></div><div data-l="        Implemented(Option&lt;T&gt;: IntoIterator)"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">where in this case, the one <code>Implemented</code> condition is always true.</span>この場合、1つの<code>Implemented</code>条件は常にtrueです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">(An aside: since we do not permit quantification over traits, this is really more like a family of program clauses, one for each associated type.)</span> （脇に：形質を定量化することはできないので、これは実際にはプログラム句のファミリーに似ていて、関連するタイプごとに1つです。）</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We could apply that rule to normalize either of the examples that we&#39;ve seen so far.</span>これまでに見た例のいずれかを正規化するためにそのルールを適用することができます。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Skolemized associated types</span> Skolemized関連タイプ</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Sometimes however we want to work with associated types that cannot be normalized.</span>しかし、時には正規化できない関連する型を扱うことが必要な場合もあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, consider this function:</span>たとえば、次の関数を考えます。</span> </p><br><div data-lang=rust,ignore><div data-l="fn foo&lt;T: IntoIterator&gt;(...) { ... }"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this context, how would we normalize the type <code>T::Item</code> ?</span>このコンテキストでは、 <code>T::Item</code>型を正規化する方法はありますか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Without knowing what <code>T</code> is, we can&#39;t really do so.</span> <code>T</code>が何であるか知らずに、私たちは本当にそうすることはできません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To represent this case, we introduce a type called a <b>skolemized associated type projection</b> .</span>このケースを表現するために、 <b>スカラー化関連型投影</b>と呼ばれるタイプを導入する。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is written like so <code>(IntoIterator::Item)&lt;T&gt;</code> .</span>これは<code>(IntoIterator::Item)&lt;T&gt;</code>ように書かれています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You may note that it looks a lot like a regular type (eg, <code>Option&lt;T&gt;</code> ), except that the &quot;name&quot; of the type is <code>(IntoIterator::Item)</code> .</span>型の &quot;名前&quot;が<code>(IntoIterator::Item)</code>ことを除いて、通常の型（例えば、 <code>Option&lt;T&gt;</code> ）のように見えることに注意してください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is not an accident: skolemized associated type projections work just like ordinary types like <code>Vec&lt;T&gt;</code> when it comes to unification.</span>これは事故ではありません。skolemized関連型投影は、統一に関しては<code>Vec&lt;T&gt;</code>ような通常の型と同じように機能します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That is, they are only considered equal if (a) they are both references to the same associated type, like <code>IntoIterator::Item</code> and (b) their type arguments are equal.</span>つまり、（a） <code>IntoIterator::Item</code>や（b）型引数が等しい場合など、それらが両方とも同じ関連型への参照である場合、それらは等しいとみなされます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Skolemized associated types are never written directly by the user.</span> Skolemized関連型は決してユーザーによって直接書かれません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">They are used internally by the trait system only, as we will see shortly.</span>これらは、形質システムによってのみ内部的に使用されます。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Projection equality</span>投影の平等</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So far we have seen two ways to answer the question of &quot;When can we consider an associated type projection equal to another type?&quot;:</span>これまで、「関連する型投影をいつ別の型に等しいと考えることができるか」という質問に答える2つの方法を見てきました。</span> </p><br><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">the <code>Normalize</code> predicate could be used to transform associated type projections when we knew which impl was applicable;</span>適用可能なimplを知っていれば、 <code>Normalize</code>述部を使用して関連する型予測を変換することができます。</span> </div><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><b>skolemized</b> associated types can be used when we don&#39;t.</span>私たちがしていないときには、 <b>スカラー化された</b>関連型を使うことができます。</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We now introduce the <code>ProjectionEq</code> predicate to bring those two cases together.</span> <code>ProjectionEq</code>述語を導入して、これら2つのケースを統合します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>ProjectionEq</code> predicate looks like so:</span> <code>ProjectionEq</code>述語は次のようになります。</span> </p><br><div data-lang=text><div data-l="ProjectionEq(&lt;T as IntoIterator&gt;::Item = U)"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">and we will see that it can be proven <i>either</i> via normalization or skolemization.</span>私たちはそれが正規化かskolemizationの<i>どちらか</i>によって証明さ<i>れる</i>ことがわかります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As part of lowering an associated type declaration from some trait, we create two program clauses for <code>ProjectionEq</code> :</span>関連する型宣言をある種の特性から引き下げる一環として、 <code>ProjectionEq</code> 2つのプログラム節を作成します。</span> </p><br><div data-lang=text><div data-l="forall&lt;T, U&gt; {"></div><div data-l="    ProjectionEq(&lt;T as IntoIterator&gt;::Item = U) :-"></div><div data-l="        Normalize(&lt;T as IntoIterator&gt;::Item -&gt; U)"></div><div data-l=}></div><div data-l=""></div><div data-l="forall&lt;T&gt; {"></div><div data-l="    ProjectionEq(&lt;T as IntoIterator&gt;::Item = (IntoIterator::Item)&lt;T&gt;)"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These are the only two <code>ProjectionEq</code> program clauses we ever make for any given associated item.</span>これらのアイテムは、関連するアイテムごとに作成された唯一の<code>ProjectionEq</code>プログラム句です。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Integration with unification</span>統一との統合</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now we are ready to discuss how associated type equality integrates with unification.</span>これで、関連する型の平等がどのように統一に統合されるのかを議論する準備ができました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As described in the <a href=#2./type-inference.html>type inference</a> section, unification is basically a procedure with a signature like this:</span> <a href=#2./type-inference.html>型推論の</a>セクションで説明したように、統一は基本的に次のような署名を持つ手続きです。</span> </p><br><div data-lang=text><div data-l="Unify(A, B) = Result&lt;(Subgoals, RegionConstraints), NoSolution&gt;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In other words, we try to unify two things A and B. That procedure might just fail, in which case we get back <code>Err(NoSolution)</code> .</span>言い換えれば、私たちはAとBの2つのものを統一しようとします。その手順は失敗するかもしれません。その場合、 <code>Err(NoSolution)</code>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This would happen, for example, if we tried to unify <code>u32</code> and <code>i32</code> .</span>たとえば、 <code>u32</code>と<code>i32</code>を統合しようとすると、これが起こります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The key point is that, on success, unification can also give back to us a set of subgoals that still remain to be proven (it can also give back region constraints, but those are not relevant here).</span>重要な点は、成功すれば、統一はまだ証明されていないサブゴールのセットを私たちに返すことである（リージョンの制約を戻すこともできるが、ここでは関係ない）。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Whenever unification encounters an (unskolemized!) associated type projection P being equated with some other type T, it always succeeds, but it produces a subgoal <code>ProjectionEq(P = T)</code> that is propagated back up.</span>統一が（非公式化された）関連型投射Pが他のいくつかの型Tと等しいとみなされると、常に成功するが、それはバックアップに伝搬されるサブゴール<code>ProjectionEq(P = T)</code>を生成する。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Thus it falls to the ordinary workings of the trait system to process that constraint.</span>したがって、それはその制約を処理するために形質システムの通常の動作に落ちる。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">(If we unify two projections P1 and P2, then unification produces a variable X and asks us to prove that <code>ProjectionEq(P1 = X)</code> and <code>ProjectionEq(P2 = X)</code> . That used to be needed in an older system to prevent cycles; I rather doubt it still is. -nmatsakis)</span> （2つの投影P1とP2を統一すると、統一によって変数Xが生成され、 <code>ProjectionEq(P1 = X)</code>と<code>ProjectionEq(P2 = X)</code>を証明するように求められます。それはまだそれが疑わしい。 -  nmatsakis）</span> </p><script>_addload(function(){_setupIW('com');_csi('en','ja','associated-types.html');});</script>