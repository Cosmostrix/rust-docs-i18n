<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180723_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=lowering-rules.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Lowering rules</span>規則を下げる</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This section gives the complete lowering rules for Rust traits into <a href=#3pc>program clauses</a> .</span>このセクションでは、Rust特性を<a href=#3pc>プログラム節に</a>完全に下げるための規則を示します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It is a kind of reference.</span>これは一種の参考資料です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These rules reference the <a href=#3dg>domain goals</a> defined in an earlier section.</span>これらのルールは、前のセクションで定義した<a href=#3dg>ドメイン目標を</a>参照し<a href=#3dg>ます</a> 。</span> </p><br> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a class=notranslate href=#1./traits/goals-and-clauses.html>pc</a> <a class=notranslate href=#1./traits/goals-and-clauses.html#domain-goals>dg</a></span> <a class=notranslate href=#1./traits/goals-and-clauses.html>pc</a> <a class=notranslate href=#1./traits/goals-and-clauses.html#domain-goals>dg</a></span> <br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Notation</span>記法</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The nonterminal <code>Pi</code> is used to mean some generic <i>parameter</i> , either a named lifetime like <code>&#39;a</code> or a type paramter like <code>A</code> .</span>非終端<code>Pi</code>どちらか、いくつかの一般的な<i>パラメータを</i>意味するような名前の生涯使用されている<code>&#39;a</code>等のタイプPARAMTER 。 <code>A</code></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The nonterminal <code>Ai</code> is used to mean some generic <i>argument</i> , which might be a lifetime like <code>&#39;a</code> or a type like <code>Vec&lt;A&gt;</code> .</span>非終端記号<code>Ai</code>は、一般的な<i>引数</i>を意味するために使用され<i>ます</i> 。これは、 <code>&#39;a</code>や<code>Vec&lt;A&gt;</code>ような型のような生涯のものです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When defining the lowering rules, we will give goals and clauses in the <a href=#2./traits/goals-and-clauses.html>notation given in this section</a> .</span>下げ規則を定義するときには<a href=#2./traits/goals-and-clauses.html>、この節で与えられ</a>た<a href=#2./traits/goals-and-clauses.html>表記法</a>で目標と節を与える。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We sometimes insert &quot;macros&quot; like <code>LowerWhereClause€</code> into these definitions;</span>これらの定義に<code>LowerWhereClause€</code>ような &quot;マクロ&quot;を挿入することがあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">these macros reference other sections within this chapter.</span>これらのマクロはこの章の他のセクションを参照しています。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rule names and cross-references</span>ルール名と相互参照</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Each of these lowering rules is given a name, documented with a comment like so:</span>これらの下げ規則のそれぞれには、次のようなコメントを記載した名前が付けられています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">// Rule Foo-Bar-Baz</span> //ルールFoo-Bar-Baz</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">you can also search through the <code>librustc_traits</code> crate in rustc to find the corresponding rules from the implementation.</span> <code>librustc_traits</code>枠を検索して、実装から対応するルールを見つけることもできます。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Lowering where clauses</span>節を下げる</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When used in a goal position, where clauses can be mapped directly to <a href=#3dg>domain goals</a> , as follows:</span>ゴール位置で使用する場合、句を<a href=#3dg>ドメイン目標</a>に直接マッピングすることができます。</span> </p><br><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>A0: Foo&lt;A1..An&gt;</code> maps to <code>Implemented(A0: Foo&lt;A1..An&gt;)</code> .</span> <code>A0: Foo&lt;A1..An&gt;</code>は<code>Implemented(A0: Foo&lt;A1..An&gt;)</code>マップされます。</span> </div><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>A0: Foo&lt;A1..An, Item = T&gt;</code> maps to <code>ProjectionEq(&lt;A0 as Foo&lt;A1..An&gt;&gt;::Item = T)</code></span> <code>A0: Foo&lt;A1..An, Item = T&gt;</code>は<code>ProjectionEq(&lt;A0 as Foo&lt;A1..An&gt;&gt;::Item = T)</code>マッピングされます<code>ProjectionEq(&lt;A0 as Foo&lt;A1..An&gt;&gt;::Item = T)</code></span> </div><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>T: &#39;r</code> maps to <code>Outlives(T, &#39;r)</code></span> <code>T: &#39;r</code>は<code>Outlives(T, &#39;r)</code>マップされます。</span> </div><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>&#39;a: &#39;b</code> maps to <code>Outlives(&#39;a, &#39;b)</code></span> <code>&#39;a: &#39;b</code>は<code>Outlives(&#39;a, &#39;b)</code>マップされ<code>Outlives(&#39;a, &#39;b)</code></span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In the rules below, we will use <code>WC</code> to indicate where clauses that appear in Rust syntax;</span>以下のルールでは、 <code>WC</code>を使用してRust構文で表示される句を指定します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">we will then use the same <code>WC</code> to indicate where those where clauses appear as goals in the program clauses that we are producing.</span>同じ<code>WC</code>を使用して、私たちが作成しているプログラム句のどこに句がどこに表示されるのかを示します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In that case, the mapping above is used to convert from the Rust syntax into goals.</span>その場合、上記のマッピングを使用してRust構文をゴールに変換します。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Transforming the lowered where clauses</span>下位のwhere句を変換する</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In addition, in the rules below, we sometimes do some transformations on the lowered where clauses, as defined here:</span>さらに、以下の規則では、ここで定義されているように、where句が低くなったところで変換を行うことがあります。</span> </p><br><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>FromEnv(WC)</code> – this indicates that:</span> <code>FromEnv(WC)</code> - 次のことを示します。</span> </div><div data-b="  -"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>Implemented(TraitRef)</code> becomes <code>FromEnv(TraitRef)</code></span> <code>Implemented(TraitRef)</code>は<code>FromEnv(TraitRef)</code></span> </div><div data-b="  -"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>ProjectionEq(Projection = Ty)</code> becomes <code>FromEnv(Projection = Ty)</code></span> <code>ProjectionEq(Projection = Ty)</code>は<code>FromEnv(Projection = Ty)</code></span> </div><div data-b="  -"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">other where-clauses are left intact</span>他のwhere節はそのまま残す</span> </div><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>WellFormed(WC)</code> – this indicates that:</span> <code>WellFormed(WC)</code> - これは次のことを示します。</span> </div><div data-b="  -"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>Implemented(TraitRef)</code> becomes <code>WellFormed(TraitRef)</code></span> <code>Implemented(TraitRef)</code>が<code>WellFormed(TraitRef)</code></span> </div><div data-b="  -"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>ProjectionEq(Projection = Ty)</code> becomes <code>WellFormed(Projection = Ty)</code></span> <code>ProjectionEq(Projection = Ty)</code>は<code>WellFormed(Projection = Ty)</code></span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><i>TODO</i> : I suspect that we want to alter the outlives relations too, but Chalk isn&#39;t modeling those right now.</span> <i>TODO</i> ：私は遺族の関係も変えたいと思うが、チョークは現時点でモデル化していない。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Lowering traits</span>形質を下げる</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Given a trait definition</span>特性の定義が与えられた</span> </p><br><div data-lang=rust,ignore><div data-l="#//trait Trait&lt;P1..Pn&gt; // P0 == Self"></div><div data-l="trait Trait&lt;P1..Pn&gt; // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">P0 == Self</span> P0 ==自己</span> </div><div data-l="where WC"></div><div data-l={></div><div data-l="#    // trait items"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">trait items</span>特産品</span> </div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">we will produce a number of declarations.</span>私たちはいくつかの宣言を生成します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This section is focused on the program clauses for the trait header (ie, the stuff outside the <code>{}</code> );</span>このセクションは、形質ヘッダのプログラム句（すなわち、 <code>{}</code>外のもの）に焦点を当てています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">the <a href=#2#trait-items>section on trait items</a> covers the stuff inside the <code>{}</code> .</span> <a href=#2#trait-items>特性項目</a>の<a href=#2#trait-items>セクション</a>は<code>{}</code>内のものをカバーします。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Trait header</span>形質ヘッダー</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">From the trait itself we mostly make &quot;meta&quot; rules that setup the relationships between different kinds of domain goals.</span>特性そのものから、私たちは主にさまざまな種類のドメイン目標間の関係を設定する「メタ」ルールを作成します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The first such rule from the trait header creates the mapping between the <code>FromEnv</code> and <code>Implemented</code> predicates:</span> traitヘッダーの最初のルールは、 <code>FromEnv</code>述部と<code>Implemented</code>述部の間のマッピングを作成します。</span> </p><br><div data-lang=text><div data-l="#// Rule Implemented-From-Env"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rule Implemented-From-Env</span> Enrから実装されたルール</span> </div><div data-l="forall&lt;Self, P1..Pn&gt; {"></div><div data-l="  Implemented(Self: Trait&lt;P1..Pn&gt;) :- FromEnv(Self: Trait&lt;P1..Pn&gt;)"></div><div data-l=}></div></div><br><p><a name=implied-bounds></a></p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Implied bounds</span>暗黙の境界</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The next few clauses have to do with implied bounds (see also <a class=notranslate href="#4RFC 2089">RFC 2089</a> ).</span>次のいくつかの句は、暗黙の境界と関係しています（ <a class=notranslate href="#4RFC 2089">RFC 2089</a>も参照）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For each trait, we produce two clauses:</span>各形質について、我々は2つの節を生成する：</span> </p><br> <a class=notranslate href=#1https://rust-lang.github.io/rfcs/2089-implied-bounds.html>RFC 2089</a> <br> <div data-lang=text><div data-l="#// Rule Implied-Bound-From-Trait"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rule Implied-Bound-From-Trait</span>ルールが暗黙のうちに束縛する</span> </div><div data-l=//></div><div data-l="#// For each where clause WC:"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For each where clause WC:</span>各where句のWC：</span> </div><div data-l="forall&lt;Self, P1..Pn&gt; {"></div><div data-l="  FromEnv(WC) :- FromEnv(Self: Trait&lt;P1..Pn)"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This clause says that if we are assuming that the trait holds, then we can also assume that its where-clauses hold.</span>この句は、もしその特性が保持されていると仮定しているなら、そのwhere節が保持されていると仮定することもできます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It&#39;s perhaps useful to see an example:</span>例を見てみると便利でしょう。</span> </p><br><div data-lang=rust,ignore><div data-l="trait Eq: PartialEq { ... }"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this case, the <code>PartialEq</code> supertrait is equivalent to a <code>where Self: PartialEq</code> where clause, in our simplified model.</span>この場合、 <code>PartialEq</code> supertraitは、単純化されたモデルの<code>where Self: PartialEq</code> where句に相当します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The program clause above therefore states that if we can prove <code>FromEnv(T: Eq)</code> – eg, if we are in some function with <code>T: Eq</code> in its where clauses – then we also know that <code>FromEnv(T: PartialEq)</code> .</span>したがって、上記のプログラム節は、 <code>FromEnv(T: Eq)</code>証明<code>FromEnv(T: Eq)</code>ば - たとえばwhere節に<code>T: Eq</code>を持つ関数であれば - <code>FromEnv(T: PartialEq)</code>も知っていると<code>FromEnv(T: PartialEq)</code>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Thus the set of things that follow from the environment are not only the <b>direct where clauses</b> but also things that follow from them.</span>したがって、環境から続く一連の事柄は、 <b>直接のwhere句</b>だけでなく、 <b>そこ</b>から続くものでもあります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The next rule is related;</span>次のルールは関連しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">it defines what it means for a trait reference to be <b>well-formed</b> :</span>それは、形質の参照が<b>整形式</b>であることが何を意味するのかを定義する。</span> </p><br><div data-lang=text><div data-l="#// Rule WellFormed-TraitRef"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rule WellFormed-TraitRef</span>ルールWellFormed-TraitRef</span> </div><div data-l="forall&lt;Self, P1..Pn&gt; {"></div><div data-l="  WellFormed(Self: Trait&lt;P1..Pn&gt;) :- Implemented(Self: Trait&lt;P1..Pn&gt;) &amp;&amp; WellFormed(WC)"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This <code>WellFormed</code> rule states that <code>T: Trait</code> is well-formed if (a) <code>T: Trait</code> is implemented and (b) all the where-clauses declared on <code>Trait</code> are well-formed (and hence they are implemented).</span>これは<code>WellFormed</code>ルールはと述べて<code>T: Trait</code> （a）の場合、十分に形成されている<code>T: Trait</code>実装されており、（B）に宣言されたすべての場所条項<code>Trait</code>よく形成されている（従って、それらが実装されています）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Remember that the <code>WellFormed</code> predicate is <a class=notranslate href=#2./traits/goals-and-clauses.html#coinductive>coinductive</a> ;</span> <code>WellFormed</code>述語は<a class=notranslate href=#2./traits/goals-and-clauses.html#coinductive>coinductive</a>あることを忘れないでください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">in this case, it is serving as a kind of &quot;carrier&quot; that allows us to enumerate all the where clauses that are transitively implied by <code>T: Trait</code> .</span>このケースでは、 <code>T: Trait</code>によって推移的に暗示されているすべてのwhere節を列挙することを可能にする一種の「キャリア」として機能しています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">An example:</span>例：</span> </p><br><div data-lang=rust,ignore><div data-l="trait Foo: A + Bar { }"></div><div data-l="trait Bar: B + Foo { }"></div><div data-l="trait A { }"></div><div data-l="trait B { }"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here, the transitive set of implications for <code>T: Foo</code> are <code>T: A</code> , <code>T: Bar</code> , and <code>T: B</code> .</span>ここで、 <code>T: Foo</code>に対する推移の推移は<code>T: A</code> 、 <code>T: Bar</code> 、 <code>T: B</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">And indeed if we were to try to prove <code>WellFormed(T: Foo)</code> , we would have to prove each one of those:</span> <code>WellFormed(T: Foo)</code>を証明しようとするなら、実際にはそれぞれの証明が必要です。</span> </p><br><div data-b=-> <code>WellFormed(T: Foo)</code> </div> <div data-b="  -"> <code>Implemented(T: Foo)</code> </div> <div data-b="  -"> <code>WellFormed(T: A)</code> </div> <div data-b="    -"> <code>Implemented(T: A)</code> </div> <div data-b="  -"> <code>WellFormed(T: Bar)</code> </div> <div data-b="    -"> <code>Implemented(T: Bar)</code> </div> <div data-b="    -"> <code>WellFormed(T: B)</code> </div> <div data-b="      -"> <code>Implemented(T: Bar)</code> </div> <div data-b="    -"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>WellFormed(T: Foo)</code> -- cycle, true coinductively</span> <code>WellFormed(T: Foo)</code> - サイクル、真の共誘導</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This <code>WellFormed</code> predicate is only used when proving that impls are well-formed – basically, for each impl of some trait ref <code>TraitRef</code> , we must show that <code>WellFormed(TraitRef)</code> .</span>この<code>WellFormed</code>述語は、implsが整形式であることを証明する場合にのみ使用されます。基本的には、 <code>TraitRef</code>の一部の<code>TraitRef</code>各<code>TraitRef</code> 、 <code>WellFormed(TraitRef)</code>表示する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This in turn justifies the implied bounds rules that allow us to extend the set of <code>FromEnv</code> items.</span>これは、 <code>FromEnv</code>アイテムのセットを拡張することを可能にする暗黙的な境界ルールを正当化します。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Lowering type definitions</span>タイプ定義を下げる</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We also want to have some rules which define when a type is well-formed.</span>タイプが整形式であるときを定義するいくつかのルールも必要です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, given this type:</span>たとえば、次のように指定します。</span> </p><br><div data-lang=rust,ignore><div data-l="struct Set&lt;K&gt; where K: Hash { ... }"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">then <code>Set&lt;i32&gt;</code> is well-formed because <code>i32</code> implements <code>Hash</code> , but <code>Set&lt;NotHash&gt;</code> would not be well-formed.</span> <code>i32</code>は<code>Hash</code>実装しているので<code>Set&lt;i32&gt;</code>は整形式ですが、 <code>Set&lt;NotHash&gt;</code>は<code>Set&lt;NotHash&gt;</code>はありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Basically, a type is well-formed if its parameters verify the where clauses written on the type definition.</span>基本的に、型の型定義は、そのパラメータが型定義に記述されたwhere文節を検証する場合に適切です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Hence, for every type definition:</span>したがって、すべての型定義について：</span> </p><br><div data-lang="rust, ignore"><div data-l="struct Type&lt;P1..Pn&gt; where WC { ... }"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">we produce the following rule:</span>我々は以下のルールを生成する。</span> </p><br><div data-lang=text><div data-l="#// Rule WellFormed-Type"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rule WellFormed-Type</span>ルールWellFormed型</span> </div><div data-l="forall&lt;P1..Pn&gt; {"></div><div data-l="  WellFormed(Type&lt;P1..Pn&gt;) :- WC"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that we use <code>struct</code> for defining a type, but this should be understood as a general type definition (it could be eg a generic <code>enum</code> ).</span>型を定義するには<code>struct</code>を使用しますが、これは一般的な型定義（一般的な<code>enum</code>型など）として理解する必要があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Conversely, we define rules which say that if we assume that a type is well-formed, we can also assume that its where clauses hold.</span>逆に、型が整形式であると仮定すると、where節が保持されていると仮定することもできるという規則を定義します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That is, we produce the following family of rules:</span>つまり、次のルールファミリが生成されます。</span> </p><br><div data-lang=text><div data-l="#// Rule FromEnv-Type"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rule FromEnv-Type</span>ルールFromEnv-Type</span> </div><div data-l=//></div><div data-l="#// For each where clause `WC`"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For each where clause <code>WC</code></span>各where句について<code>WC</code></span> </div><div data-l="forall&lt;P1..Pn&gt; {"></div><div data-l="  FromEnv(WC) :- FromEnv(Type&lt;P1..Pn&gt;)"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As for the implied bounds RFC, functions will <i>assume</i> that their arguments are well-formed.</span>暗黙の境界RFCに関しては、関数は引数が正しい形式であると<i>想定</i>します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, suppose we have the following bit of code:</span>たとえば、次のようなコードがあるとします。</span> </p><br><div data-lang=rust,ignore><div data-l="trait Hash: Eq { }"></div><div data-l="struct Set&lt;K: Hash&gt; { ... }"></div><div data-l=""></div><div data-l="fn foo&lt;K&gt;(collection: Set&lt;K&gt;, x: K, y: K) {"></div><div data-l="#    // `x` and `y` can be equalized even if we did not explicitly write"></div><div data-l="#    // `where K: Eq`"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>x</code> and <code>y</code> can be equalized even if we did not explicitly write <code>where K: Eq</code></span> <code>x</code>と<code>y</code>は、明示的<code>where K: Eq</code></span> </div><div data-l="    if x == y {"></div><div data-l="        ..."></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In the <code>foo</code> function, we assume that <code>Set&lt;K&gt;</code> is well-formed, ie we have <code>FromEnv(Set&lt;K&gt;)</code> in our environment.</span> <code>foo</code>関数では、 <code>Set&lt;K&gt;</code>が整形式であると仮定します。つまり、我々の環境では<code>FromEnv(Set&lt;K&gt;)</code>を持ちます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because of the previous rule, we get <code>FromEnv(K: Hash)</code> without needing an explicit where clause.</span>以前のルールのため、明示的なwhere節を必要とせずに<code>FromEnv(K: Hash)</code>を取得します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">And because of the <code>Hash</code> trait definition, there also exists a rule which says:</span>また、 <code>Hash</code>特性定義のために、次のようなルールも存在します。</span> </p><br><div data-lang=text><div data-l="forall&lt;K&gt; {"></div><div data-l="  FromEnv(K: Eq) :- FromEnv(K: Hash)"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">which means that we finally get <code>FromEnv(K: Eq)</code> and then can compare <code>x</code> and <code>y</code> without needing an explicit where clause.</span>つまり、最終的に<code>FromEnv(K: Eq)</code>を取得し、明示的なwhere節を必要とせずに<code>x</code>と<code>y</code>を比較できます。</span> </p><br><p><a name=trait-items></a></p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Lowering trait items</span>特性項目を下げる</span> </h2><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Associated type declarations</span>関連付けられた型宣言</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Given a trait that declares a (possibly generic) associated type:</span> （おそらくジェネリックな）関連タイプを宣言する特性が与えられているとします：</span> </p><br><div data-lang=rust,ignore><div data-l="#//trait Trait&lt;P1..Pn&gt; // P0 == Self"></div><div data-l="trait Trait&lt;P1..Pn&gt; // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">P0 == Self</span> P0 ==自己</span> </div><div data-l="where WC"></div><div data-l={></div><div data-l="    type AssocType&lt;Pn+1..Pm&gt;: Bounds where WC1;"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We will produce a number of program clauses.</span>私たちはいくつかのプログラム条項を作成します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The first two define the rules by which <code>ProjectionEq</code> can succeed;</span>最初の2つは、 <code>ProjectionEq</code>が成功するためのルールを定義しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">these two clauses are discussed in detail in the <a href=#2./traits/associated-types.html>section on associated types</a> , but reproduced here for reference:</span>これらの2つの節は<a href=#2./traits/associated-types.html>、関連する種類</a>の<a href=#2./traits/associated-types.html>セクション</a>で詳しく説明していますが、参照用にここに再現しています。</span> </p><br><div data-lang=text><div data-l="#// Rule ProjectionEq-Normalize"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rule ProjectionEq-Normalize</span>ルール射影Eq-正規化</span> </div><div data-l=//></div><div data-l="#// ProjectionEq can succeed by normalizing:"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">ProjectionEq can succeed by normalizing:</span> ProjectionEqは正規化することで成功することができます：</span> </div><div data-l="forall&lt;Self, P1..Pn, Pn+1..Pm, U&gt; {"></div><div data-l="  ProjectionEq(&lt;Self as Trait&lt;P1..Pn&gt;&gt;::AssocType&lt;Pn+1..Pm&gt; = U) :-"></div><div data-l="      Normalize(&lt;Self as Trait&lt;P1..Pn&gt;&gt;::AssocType&lt;Pn+1..Pm&gt; -&gt; U)"></div><div data-l=}></div></div><br><div data-lang=text><div data-l="#// Rule ProjectionEq-Skolemize"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rule ProjectionEq-Skolemize</span>ルールプロジェクション -  Skolemize</span> </div><div data-l=//></div><div data-l="#// ProjectionEq can succeed by skolemizing, see &quot;associated type&quot;"></div><div data-l="#// chapter for more:"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">ProjectionEq can succeed by skolemizing, see &quot;associated type&quot; chapter for more:</span> ProjectionEqはskolemizingで成功することができます。詳しくは、「関連タイプ」の章を参照してください。</span> </div><div data-l="forall&lt;Self, P1..Pn, Pn+1..Pm&gt; {"></div><div data-l="  ProjectionEq("></div><div data-l="    &lt;Self as Trait&lt;P1..Pn&gt;&gt;::AssocType&lt;Pn+1..Pm&gt; ="></div><div data-l="    (Trait::AssocType)&lt;Self, P1..Pn, Pn+1..Pm&gt;"></div><div data-l="  )"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The next rule covers implied bounds for the projection.</span>次の規則は、投影の暗黙の境界をカバーしています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In particular, the <code>Bounds</code> declared on the associated type must have been proven to hold to show that the impl is well-formed, and hence we can rely on them elsewhere.</span>具体的には、関連タイプで宣言された<code>Bounds</code>は、implがうまく形成されていることを示すために保持されていることが証明されている必要があるため、他の場所に依存することができます。</span> </p><br><div data-lang=text><div data-l="#// Rule Implied-Bound-From-AssocTy"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rule Implied-Bound-From-AssocTy</span>ルールが暗示している</span> </div><div data-l=//></div><div data-l="#// For each `Bound` in `Bounds`:"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For each <code>Bound</code> in <code>Bounds</code> :</span> <code>Bound</code> in <code>Bounds</code>について：</span> </div><div data-l="forall&lt;Self, P1..Pn, Pn+1..Pm&gt; {"></div><div data-l="    FromEnv(&lt;Self as Trait&lt;P1..Pn&gt;&gt;::AssocType&lt;Pn+1..Pm&gt;&gt;: Bound) :-"></div><div data-l="      FromEnv(Self: Trait&lt;P1..Pn&gt;)"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Next, we define the requirements for an instantiation of our associated type to be well-formed...</span>次に、関連する型のインスタンス化の要件を整形式に定義します。</span> </p><br><div data-lang=text><div data-l="#// Rule WellFormed-AssocTy"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rule WellFormed-AssocTy</span>ルールWell-Formed-AssocTy</span> </div><div data-l="forall&lt;Self, P1..Pn, Pn+1..Pm&gt; {"></div><div data-l="    WellFormed((Trait::AssocType)&lt;Self, P1..Pn, Pn+1..Pm&gt;) :-"></div><div data-l="      WC1, Implemented(Self: Trait&lt;P1..Pn&gt;)"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">...along with the reverse implications, when we can assume that it is well-formed.</span> ...逆の意味と一緒に、それがうまく形成されていると仮定することができます。</span> </p><br><div data-lang=text><div data-l="#// Rule Implied-WC-From-AssocTy"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rule Implied-WC-From-AssocTy</span>ルールが暗示する -  WC-AssocTy</span> </div><div data-l=//></div><div data-l="#// For each where clause WC1:"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For each where clause WC1:</span>各where句についてWC1：</span> </div><div data-l="forall&lt;Self, P1..Pn, Pn+1..Pm&gt; {"></div><div data-l="    FromEnv(WC1) :- FromEnv((Trait::AssocType)&lt;Self, P1..Pn, Pn+1..Pm&gt;)"></div><div data-l=}></div></div><br><div data-lang=text><div data-l="#// Rule Implied-Trait-From-AssocTy"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rule Implied-Trait-From-AssocTy</span>ルールが暗示する -  Trait-From-AssocTy</span> </div><div data-l="forall&lt;Self, P1..Pn, Pn+1..Pm&gt; {"></div><div data-l="    FromEnv(Self: Trait&lt;P1..Pn&gt;) :-"></div><div data-l="      FromEnv((Trait::AssocType)&lt;Self, P1..Pn, Pn+1..Pm&gt;)"></div><div data-l=}></div></div><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Lowering function and constant declarations</span>関数と定数の宣言を下げる</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Chalk didn&#39;t model functions and constants, but I would eventually like to treat them exactly like normalization.</span>チョークは関数と定数をモデル化していませんでしたが、最終的に正規化と同じように取り扱いたいと思います。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">See <a href=#2#constant-vals>the section on function/constant values below</a> for more details.</span>詳細について<a href=#2#constant-vals>は、関数/定数の項を参照</a>してください。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Lowering impls</span>下げることは意味する</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Given an impl of a trait:</span>特性のインプラントを与えられた：</span> </p><br><div data-lang=rust,ignore><div data-l="impl&lt;P0..Pn&gt; Trait&lt;A1..An&gt; for A0"></div><div data-l="where WC"></div><div data-l={></div><div data-l="#    // zero or more impl items"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">zero or more impl items</span>ゼロ個以上のインプットアイテム</span> </div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let <code>TraitRef</code> be the trait reference <code>A0: Trait&lt;A1..An&gt;</code> .</span> <code>TraitRef</code>特性参照<code>A0: Trait&lt;A1..An&gt;</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then we will create the following rules:</span>次に、次のルールを作成します。</span> </p><br><div data-lang=text><div data-l="#// Rule Implemented-From-Impl"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rule Implemented-From-Impl</span>実装されたルール</span> </div><div data-l="forall&lt;P0..Pn&gt; {"></div><div data-l="  Implemented(TraitRef) :- WC"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In addition, we will lower all of the <i>impl items</i> .</span>さらに、すべての<i>インプラント項目</i>を下げ<i>ます</i> 。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Lowering impl items</span>インプルアイテムを下げる</span> </h2><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Associated type values</span>関連付けられた型の値</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Given an impl that contains:</span>与えられたimplを含む：</span> </p><br><div data-lang=rust,ignore><div data-l="impl&lt;P0..Pn&gt; Trait&lt;P1..Pn&gt; for P0"></div><div data-l="where WC_impl"></div><div data-l={></div><div data-l="    type AssocType&lt;Pn+1..Pm&gt; = T;"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">and our where clause <code>WC1</code> on the trait associated type from above, we produce the following rule:</span>上記のtrait関連型のwhere節<code>WC1</code>では、次のルールを生成します。</span> </p><br><div data-lang=text><div data-l="#// Rule Normalize-From-Impl"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rule Normalize-From-Impl</span>ルール正規化-Implから</span> </div><div data-l="forall&lt;P0..Pm&gt; {"></div><div data-l="  forall&lt;Pn+1..Pm&gt; {"></div><div data-l="    Normalize(&lt;P0 as Trait&lt;P1..Pn&gt;&gt;::AssocType&lt;Pn+1..Pm&gt; -&gt; T) :-"></div><div data-l="      Implemented(P0 as Trait) &amp;&amp; WC1"></div><div data-l="  }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that <code>WC_impl</code> and <code>WC1</code> both encode where-clauses that the impl can rely on.</span> <code>WC_impl</code>と<code>WC1</code>どちらも、implが依存できるwhere節をエンコードすることに注意してください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">( <code>WC_impl</code> is not used here, because it is implied by <code>Implemented(P0 as Trait)</code> .)</span> （ <code>Implemented(P0 as Trait)</code>によって暗示されているため、 <code>WC_impl</code>はここでは使用されません<code>Implemented(P0 as Trait)</code> 。</span> </p><br><p><a name=constant-vals></a></p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Function and constant values</span>関数と定数</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Chalk didn&#39;t model functions and constants, but I would eventually like to treat them exactly like normalization.</span>チョークは関数と定数をモデル化していませんでしたが、最終的に正規化と同じように取り扱いたいと思います。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This presumably involves adding a new kind of parameter (constant), and then having a <code>NormalizeValue</code> domain goal.</span>これには、新しい種類のパラメータ（定数）を追加し、次に<code>NormalizeValue</code>ドメインの目標を持つことが含まれます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is <i>to be written</i> because the details are a bit up in the air.</span>これは、細部が空中でちょっと上にあるため<i>に書かれています</i> 。</span> </p><script>_addload(function(){_setupIW('com');_csi('en','ja','lowering-rules.html');});</script>