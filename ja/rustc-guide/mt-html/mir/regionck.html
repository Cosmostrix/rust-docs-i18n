<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180723_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=regionck.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">MIR-based region checking (NLL)</span> MIRベースの領域チェック（NLL）</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The MIR-based region checking code is located in <a href=#3nll>the <code>rustc_mir::borrow_check::nll</code> module</a> .</span> MIRベースの領域検査コードは<a href=#3nll>、 <code>rustc_mir::borrow_check::nll</code>モジュールにあります</a> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">(NLL, of course, stands for &quot;non-lexical lifetimes&quot;, a term that will hopefully be deprecated once they become the standard kind of lifetime.)</span> （もちろん、NLLは「非語彙生涯」を意味します。これは、生涯の標準的な種類になったら非難されるでしょう）。</span> </p><br> <a class=notranslate href=#1https://github.com/rust-lang/rust/tree/master/src/librustc_mir/borrow_check/nll>nll</a> <br> <p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The MIR-based region analysis consists of two major functions:</span> MIRベースの領域分析は、2つの主要な機能から成り立っています。</span> </p><br><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>replace_regions_in_mir</code> , invoked first, has two jobs:</span>最初に呼び出された<code>replace_regions_in_mir</code>には2つのジョブがあります。</span> </div><div data-b="  -"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">First, it finds the set of regions that appear within the signature of the function (eg, <code>&#39;a</code> in <code>fn foo&lt;&#39;a&gt;(&amp;&#39;a u32) { ... }</code> ).</span>まず、関数のシグネチャ内に現れる領域のセットを見つけます（例えば、 <code>&#39;a</code> in <code>fn foo&lt;&#39;a&gt;(&amp;&#39;a u32) { ... }</code> ）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These are called the &quot;universal&quot; or &quot;free&quot; regions – in particular, they are the regions that <a href=#3fvb>appear free</a> in the function body.</span>これらは、「ユニバーサル」または「フリー」領域と呼ばれ、特に、機能体内で<a href=#3fvb>自由</a>に<a href=#3fvb>見える</a>領域です。</span> </div><div data-b="  -"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Second, it replaces all the regions from the function body with fresh inference variables.</span>次に、関数本体のすべての領域を新しい推論変数に置き換えます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is because (presently) those regions are the results of lexical region inference and hence are not of much interest.</span>これは、（現在）それらの領域がレキシカル領域推論の結果であり、したがってそれほど関心がないためです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The intention is that – eventually – they will be &quot;erased regions&quot; (ie, no information at all), since we won&#39;t be doing lexical region inference at all.</span>その意図は、最終的に、「消去された領域」（すなわち、全く情報がない）であるということである。なぜなら、我々は語彙領域推論を全く行わないからである。</span> </div><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>compute_regions</code> , invoked second: this is given as argument the results of move analysis.</span> <code>compute_regions</code> 、2番目の呼び出し：これは、移動解析の結果を引数として与えられます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It has the job of computing values for all the inference variabes that <code>replace_regions_in_mir</code> introduced.</span>それは、 <code>replace_regions_in_mir</code>導入したすべての推論変数の値を計算する仕事を持っています。</span> </div><div data-b="  -"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To do that, it first runs the <a href=#2#mirtypeck>MIR type checker</a> .</span>これを行うために、まず<a href=#2#mirtypeck>MIR型チェッカーを</a>実行します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is basically a normal type-checker but specialized to MIR, which is much simpler than full Rust of course.</span>これは基本的には通常のタイプチェッカーですが、MIRに特化しています。これは完全なRustよりはるかに簡単です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Running the MIR type checker will however create <b>outlives constraints</b> between region variables (eg, that one variable must outlive another one) to reflect the subtyping relationships that arise.</span>しかし、MIR型チェッカーを実行すると、発生するサブタイプの関係を反映する<b>ために</b> 、リージョン変数間の<b>アウトライヴ制約</b>が作成<b>さ</b>れます（たとえば、ある変数は別の変数よりも長く<b>存続</b>する必要があります）。</span> </div><div data-b="  -"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It also adds <b>liveness constraints</b> that arise from where variables are used.</span>また、変数が使用されている場所から生じる<b>生存の制約</b>を追加します。</span> </div><div data-b="  -"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">More details to come, though the <a class=notranslate href="#4NLL RFC">NLL RFC</a> also includes fairly thorough (and hopefully readable) coverage.</span> <a class=notranslate href="#4NLL RFC">NLL RFC</a>には、かなり徹底した（そしてうまくいけば判読可能な）カバレッジも含まれていますが、さらに詳細があります。</span> </div><br> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a class=notranslate href=#1appendix/background.html#free-vs-bound>fvb</a> <a class=notranslate href=#1http://rust-lang.github.io/rfcs/2094-nll.html>NLL RFC</a></span> <a class=notranslate href=#1appendix/background.html#free-vs-bound>fvb</a> <a class=notranslate href=#1http://rust-lang.github.io/rfcs/2094-nll.html>NLL RFC</a></span> <br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Universal regions</span>ユニバーサル地域</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><i>to be written</i> – explain the <code>UniversalRegions</code> type</span> <i>書かれる</i> - <code>UniversalRegions</code>タイプを説明する</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Region variables and constraints</span>地域変数と制約</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><i>to be written</i> – describe the <code>RegionInferenceContext</code> and the role of <code>liveness_constraints</code> vs other <code>constraints</code> , plus</span> <i>書かれる</i> - <code>RegionInferenceContext</code>と<code>liveness_constraints</code>の役割と他の<code>constraints</code>とを記述する</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Closures</span>閉鎖</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><i>to be written</i></span> <i>書かれる</i></span> </p><br><p><a name=mirtypeck></a></p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The MIR type-check</span> MIR型チェック</span> </h2><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Representing the &quot;values&quot; of a region variable</span>領域変数の「値」を表す</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The value of a region can be thought of as a <b>set</b> ;</span>領域の値は<b>集合</b>と考えることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">we call the domain of this set a <code>RegionElement</code> .</span>このセットのドメインを<code>RegionElement</code>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In the code, the value for all regions is maintained in <a href=#3ri>the <code>rustc_mir::borrow_check::nll::region_infer</code> module</a> .</span>コードでは、すべての領域の値<a href=#3ri>が<code>rustc_mir::borrow_check::nll::region_infer</code>モジュールで</a>維持され<a href=#3ri>ます</a> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For each region we maintain a set storing what elements are present in its value (to make this efficient, we give each kind of element an index, the <code>RegionElementIndex</code> , and use sparse bitsets).</span>各領域に対して、どの要素がその値に格納されているかを保持するセットを保持します（これを効率的にするために、各要素にインデックス、 <code>RegionElementIndex</code> 、疎ビットセットを使用します）。</span> </p><br> <a class=notranslate href=#1https://github.com/rust-lang/rust/tree/master/src/librustc_mir/borrow_check/nll/region_infer/>ri</a> <br> <p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The kinds of region elements are as follows:</span>領域要素の種類は次のとおりです。</span> </p><br><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Each <b>location</b> in the MIR control-flow graph: a location is just the pair of a basic block and an index.</span> MIR制御フローグラフの各<b>位置</b> ：位置は基本ブロックとインデックスのペアです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This identifies the point</span>これは、</span> </div><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><b>on entry</b> to the statement with that index (or the terminator, if the index is equal to <code>statements.len()</code> ).</span>そのインデックスを持つステートメント（または、インデックスが<code>statements.len()</code>と等しい場合はターミネータ） <b>にエントリ</b>します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">- There is an element <code>end(&#39;a)</code> for each universal region <code>&#39;a</code> , corresponding to some portion of the caller&#39;s (or caller&#39;s caller, etc) control-flow graph.</span> - 呼び出し元（または呼び出し元の呼び出し元など）の制御フローグラフの一部に対応する要素の<code>end(&#39;a)</code>が各汎用領域<code>&#39;a</code>にあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">- Similarly, there is an element denoted <code>end(&#39;static)</code> corresponding to the remainder of program execution after this function returns.</span> - 同様に、この関数が復帰した後の残りのプログラム実行に対応する<code>end(&#39;static)</code>と示される要素があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">- There is an element <code>€1</code> for each skolemized region <code>€1</code> .</span> - 各スカラー化領域<code>€1</code>は要素<code>€1</code>があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This corresponds (intuitively) to some unknown set of other elements – for details on skolemization, see the section <a href=#2#skol>skolemization and universes</a> .</span>これは他の要素のいくつかの未知の集合に（直感的に）対応しています - スカイレングスの詳細については、 <a href=#2#skol>skolemizationとユニバースの</a>セクションを参照してください。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Causal tracking</span>原因トラッキング</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><i>to be written</i> – describe how we can extend the values of a variable with causal tracking etc</span> <i>書かれる</i> - 因果追跡などで変数の値をどのように拡張できるかを記述する</span> </p><br><p><a name=skol></a></p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Skolemization and universes</span>スカラー化と宇宙</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">(This section describes ongoing work that hasn&#39;t landed yet.)</span> （このセクションでは、まだ着陸していない進行中の作業について説明します）。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">From time to time we have to reason about regions that we can&#39;t concretely know.</span>時には、われわれが具体的に知ることができない地域について、時には理由を論ずる必要がある。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, consider this program:</span>たとえば、次のプログラムを考えてみましょう。</span> </p><br><div data-lang=rust,ignore><div data-l="#// A function that needs a static reference"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A function that needs a static reference</span>静的参照が必要な関数</span> </div><div data-l="fn foo(x: &amp;'static u32) { }"></div><div data-l=""></div><div data-l="fn bar(f: for&lt;'a&gt; fn(&amp;'a u32)) {"></div><div data-l="#       // ^^^^^^^^^^^^^^^^^^^ a function that can accept **any** reference"></div><div data-l="       // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">^^^^^^^^^^^^^^^^^^^ a function that can accept <b>any</b> reference</span> <b>任意の</b>参照を受け入れることができる^^^^^^^^^^^^^^^^^^^機能</span> </div><div data-l="    let x = 22;"></div><div data-l="    f(&amp;x);"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    bar(foo);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This program ought not to type-check: <code>foo</code> needs a static reference for its argument, and <code>bar</code> wants to be given a function that that accepts <b>any</b> reference (so it can call it with something on its stack, for example).</span> ：このプログラムは型チェックべきではない<code>foo</code>引数の静的参照を必要とし、 <code>bar</code>それが（それは、例えば、そのスタック上に何かでそれを呼び出すことができます） <b>任意の</b>参照を受け入れることの機能を与えることを望んでいます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But <i>how</i> do we reject it and <i>why</i> ?</span>しかし、 <i>どのように</i>我々はそれを拒否<i>する</i>の<i>か</i> 。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Subtyping and skolemization</span>サブタイプ化およびスカイ化</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When we type-check <code>main</code> , and in particular the call <code>bar(foo)</code> , we are going to wind up with a subtyping relationship like this one:</span>型チェック<code>main</code> 、特に<code>bar(foo)</code>場合、次のようなサブタイプの関係で終了します：</span> </p><br><div data-lang=text><div data-l="fn(&amp;'static u32) &lt;: for&lt;'a&gt; fn(&amp;'a u32)"></div><div data-l="----------------    -------------------"></div><div data-l="the type of `foo`   the type `bar` expects"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We handle this sort of subtyping by taking the variables that are bound in the supertype and <b>skolemizing</b> them: this means that we replace them with <a href=#2appendix/background.html#quantified>universally quantified</a> representatives, written like <code>€1</code> .</span>この種のサブタイプは、スーパータイプにバインドされている変数を取り、それらを<b>スカラー</b>化することによって処理されます。つまり、これは、 <code>€1</code>似ている<a href=#2appendix/background.html#quantified>普遍的な定量化された</a>表現で置き換えられます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We call these regions &quot;skolemized regions&quot; – they represent, basically, &quot;some unknown region&quot;.</span>これらの地域を「スカレミア地域」と呼びます。これらは、基本的に「未知の地域」を表しています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Once we&#39;ve done that replacement, we have the following relation:</span>この交換を済ませたら、次の関係があります。</span> </p><br><div data-lang=text><div data-l="fn(&amp;'static u32) &lt;: fn(&amp;'!1 u32)"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The key idea here is that this unknown region <code>&#39;€1</code> is not related to any other regions.</span>ここでの重要なアイデアは、この未知の領域<code>&#39;€1</code>は他のどの地域にも関連していないということです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So if we can prove that the subtyping relationship is true for <code>&#39;€1</code> , then it ought to be true for any region, which is what we wanted.</span>したがって、サブタイプの関係が<code>&#39;€1</code>当てはまることを証明できれば、それはどの地域にとっても当てはまります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So let&#39;s work through what happens next.</span>それでは、次に起こることを考えてみましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To check if two functions are subtypes, we check if their arguments have the desired relationship (fn arguments are <a class=notranslate href=#2./appendix/background.html#variance>contravariant</a> , so we swap the left and right here):</span> 2つの関数がサブタイプであるかどうかを調べるために、引数が望ましい関係にあるかどうかをチェックします（fn引数は<a class=notranslate href=#2./appendix/background.html#variance>contravariant</a>ので、ここでは左と右を入れ替えます）。</span> </p><br><div data-lang=text><div data-l="&amp;'!1 u32 &lt;: &amp;'static u32"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">According to the basic subtyping rules for a reference, this will be true if <code>&#39;€1: &#39;static</code> .</span>リファレンスの基本的なサブタイプの規則によれば、 <code>&#39;€1: &#39;static</code>場合はtrueになります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That is – if &quot;some unknown region <code>€1</code> &quot; lives outlives <code>&#39;static</code> .</span>つまり、「何らかの未知の地域<code>€1</code> 」が生存<code>&#39;static</code>住んで<code>&#39;static</code>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now, this <i>might</i> be true – after all, <code>&#39;€1</code> could be <code>&#39;static</code> – but we don&#39;t <i>know</i> that it&#39;s true.</span>結局のところ、これ<i>は</i>真実<i>かもしれません。</i>結局のところ、 <code>&#39;€1</code>は<code>&#39;static</code>可能性があります<i>が</i> 、それが本当である<i>か</i>どうかは<i>わかり</i>ません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So this should yield up an error (eventually).</span>だから、これはエラー（最終的に）をもたらすはずです。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">What is a universe</span>宇宙とは何ですか？</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In the previous section, we introduced the idea of a skolemized region, and we denoted it <code>€1</code> .</span>前のセクションでは、skolemized地域のアイデアを紹介し、それを<code>€1</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We call this number <code>1</code> the <b>universe index</b> .</span>私たちは、この番号を呼び出す<code>1</code> <b>宇宙インデックスを</b> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The idea of a &quot;universe&quot; is that it is a set of names that are in scope within some type or at some point.</span> 「宇宙」のアイデアは、それが、あるタイプまたはあるポイントの範囲内にある名前のセットであるということです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Universes are formed into a tree, where each child extends its parents with some new names.</span>ユニバースは樹木に形成され、それぞれの子供は両親にいくつかの新しい名前を付ける。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So the <b>root universe</b> conceptually contains global names, such as the the lifetime <code>&#39;static</code> or the type <code>i32</code> .</span>したがって、 <b>ルート・ユニバースに</b>は、ライフタイム<code>&#39;static</code>タイプやタイプ<code>i32</code>などのグローバル名が概念的に含まれています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In the compiler, we also put generic type parameters into this root universe (in this sense, there is not just one root universe, but one per item).</span>コンパイラでは、ジェネリック型のパラメータをこのルートユニバースに入れます（この意味で、ルートユニバースは1つではなく、1つのアイテムに1つあります）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So consider this function <code>bar</code> :</span>この関数の<code>bar</code>考えてみ<code>bar</code> ：</span> </p><br><div data-lang=rust,ignore><div data-l="struct Foo { }"></div><div data-l=""></div><div data-l="fn bar&lt;'a, T&gt;(t: &amp;'a T) {"></div><div data-l="    ..."></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here, the root universe would consist of the lifetimes <code>&#39;static</code> and <code>&#39;a</code> .</span>ここでは、ルートの宇宙は生命体の<code>&#39;static</code> <code>&#39;a</code>と<code>&#39;a</code>生命体<code>&#39;static</code>からなる。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In fact, although we&#39;re focused on lifetimes here, we can apply the same concept to types, in which case the types <code>Foo</code> and <code>T</code> would be in the root universe (along with other global types, like <code>i32</code> ).</span>実際、ここでは生涯に焦点を当てていますが、同じ概念を型に適用することができます。この場合、型<code>Foo</code>と<code>T</code>はルート宇宙にあります（他のグローバル型、 <code>i32</code> ）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Basically, the root universe contains all the names that <a href=#2./appendix/background.html#free-vs-bound>appear free</a> in the body of <code>bar</code> .</span>基本的に、ルートユニバースには、 <code>bar</code>の本体に<a href=#2./appendix/background.html#free-vs-bound>自由</a>に<a href=#2./appendix/background.html#free-vs-bound>表示される</a>すべての名前が含まれてい<code>bar</code> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now let&#39;s extend <code>bar</code> a bit by adding a variable <code>x</code> :</span>変数<code>x</code>追加して<code>bar</code>を少し拡張しましょう：</span> </p><br><div data-lang=rust,ignore><div data-l="fn bar&lt;'a, T&gt;(t: &amp;'a T) {"></div><div data-l="    let x: for&lt;'b&gt; fn(&amp;'b u32) = ...;"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here, the name <code>&#39;b</code> is not part of the root universe.</span>ここでは、名前<code>&#39;b</code>はルートの宇宙の一部ではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Instead, when we &quot;enter&quot; into this <code>for&lt;&#39;b&gt;</code> (eg, by skolemizing it), we will create a child universe of the root, let&#39;s call it U1:</span>代わりに、 <code>for&lt;&#39;b&gt;</code>にこれに「入る」（例えば、それをスカラー化することによって）、ルートの子ユニバースを作成します。それをU1と呼んでいます：</span> </p><br><div data-lang=text><div data-l="U0 (root universe)"></div><div data-l="│"></div><div data-l="└─ U1 (child universe)"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The idea is that this child universe U1 extends the root universe U0 with a new name, which we are identifying by its universe number: <code>€1</code> .</span> ：アイデアは、この子ユニバースU1は、我々はその宇宙の番号で識別されている新しい名前、とルートユニバースU0を拡張することである<code>€1</code></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now let&#39;s extend <code>bar</code> a bit by adding one more variable, <code>y</code> :</span>今度は拡張できます<code>bar</code>少し、1つのより多くの変数を追加することにより、 <code>y</code> ：</span> </p><br><div data-lang=rust,ignore><div data-l="fn bar&lt;'a, T&gt;(t: &amp;'a T) {"></div><div data-l="    let x: for&lt;'b&gt; fn(&amp;'b u32) = ...;"></div><div data-l="    let y: for&lt;'c&gt; fn(&amp;'b u32) = ...;"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When we enter <i>this</i> type, we will again create a new universe, which we&#39;ll call <code>U2</code> .</span> <i>この</i>タイプに入ると、 <code>U2</code>と呼ばれる新しい宇宙をもう一度作ります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Its parent will be the root universe, and U1 will be its sibling:</span>その親はルートの宇宙になり、U1はその兄弟になります：</span> </p><br><div data-lang=text><div data-l="U0 (root universe)"></div><div data-l="│"></div><div data-l="├─ U1 (child universe)"></div><div data-l="│"></div><div data-l="└─ U2 (child universe)"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This implies that, while in U2, we can name things from U0 or U2, but not U1.</span>これは、U2では、U0ではなくU0またはU2から名前を付けることができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><b>Giving existential variables a universe.</b></span> <b>実在の変数を宇宙に与える。</b></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now that we have this notion of universes, we can use it to extend our type-checker and things to prevent illegal names from leaking out.</span>私たちはこのような宇宙の概念を持っているので、これを使って型検査員や物事を拡張して、違法名が漏出するのを防ぐことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The idea is that we give each inference (existential) variable – whether it be a type or a lifetime – a universe.</span>アイデアは、それが型であろうと一生であろうと、宇宙である各推論（存在）変数を与えることです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That variable&#39;s value can then only reference names visible from that universe.</span>その変数の値は、その宇宙から見える名前だけを参照することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So for example is a lifetime variable is created in U0, then it cannot be assigned a value of <code>€1</code> or <code>€2</code> , because those names are not visible from the universe U0.</span>たとえば、U0に生涯変数が作成された場合、これらの名前はユニバースU0から表示されないため、 <code>€1</code>または<code>€2</code>値を割り当てることはできません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><b>Representing universes with just a counter.</b></span> <b>カウンターだけで宇宙を表現する。</b></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You might be surprised to see that the compiler doesn&#39;t keep track of a full tree of universes.</span>コンパイラがユニバースの完全なツリーを追跡していないことに驚くかもしれません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Instead, it just keeps a counter – and, to determine if one universe can see another one, it just checks if the index is greater.</span>代わりに、カウンタを保持し、ある宇宙が別の宇宙を見ることができるかどうかを判断するために、インデックスが大きいかどうかを確認するだけです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, U2 can see U0 because 2 &gt;= 0. But U0 cannot see U2, because 0 &gt;= 2 is false.</span>例えば、2&gt; = 0なのでU2はU0を見ることができます。しかし、0&gt; = 2は偽であるため、U0はU2を見ることができません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">How can we get away with this?</span>どうすればこの問題を解決できますか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Doesn&#39;t this mean that we would allow U2 to also see U1?</span>これは、U2にもU1を見ることを許可するという意味ではありませんか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The answer is that, yes, we would, <b>if that question ever arose</b> .</span>答えは、 <b>その質問が起きたならば</b> 、はい、私たちはそうするでしょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But because of the structure of our type checker etc, there is no way for that to happen.</span>しかし、私たちのタイプチェッカーなどの構造のために、それが起こる方法はありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In order for something happening in the universe U1 to &quot;communicate&quot; with something happening in U2, they would have to have a shared inference variable X in common.</span>宇宙U1で起こっていることがU2で起こっていることと「コミュニケート」するためには、共通の推論変数Xを共有する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">And because everything in U1 is scoped to just U1 and its children, that inference variable X would have to be in U0.</span>そして、U1のすべてがU1とその子にスコープされているので、その推論変数XはU0になければなりません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">And since X is in U0, it cannot name anything from U1 (or U2).</span> XはU0にあるので、U1（またはU2）の名前を付けることはできません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is perhaps easiest to see by using a kind of generic &quot;logic&quot; example:</span>これは、一種の一般的な「論理」の例を使用することによって、おそらく最も簡単に見えます。</span> </p><br><div data-lang=text><div data-l="exists&lt;X&gt; {"></div><div data-l="   forall&lt;Y&gt; { ... /* Y is in U1 ... */ }"></div><div data-l="   forall&lt;Z&gt; { ... /* Z is in U2 ... */ }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here, the only way for the two foralls to interact would be through X, but neither Y nor Z are in scope when X is declared, so its value cannot reference either of them.</span>ここでは、2つのフォールトが相互作用する唯一の方法はXを介して行われるが、Xが宣言されているときにはYもZもスコープにないので、その値はどちらも参照できない。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Universes and skolemized region elements</span>ユニバースとskolemizedリージョンエレメント</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But where does that error come from?</span>しかし、そのエラーはどこから来ますか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The way it happens is like this.</span>それが起こる方法はこれのようなものです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When we are constructing the region inference context, we can tell from the type inference context how many skolemized variables exist (the <code>InferCtxt</code> has an internal counter).</span>領域推論コンテキストを構築するときに、型推論コンテキストから、いくつかの変数が存在することがわかります（ <code>InferCtxt</code>には内部カウンタがあります）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For each of those, we create a corresponding universal region variable <code>€n</code> and a &quot;region element&quot; <code>skol(n)</code> .</span>それぞれについて、対応するユニバーサル領域変数<code>€n</code>と &quot;region要素&quot; <code>skol(n)</code>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This corresponds to &quot;some unknown set of other elements&quot;.</span>これは、「他の要素の未知の集合」に対応します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The value of <code>€n</code> is <code>{skol(n)}</code> .</span> <code>€n</code>の値は<code>{skol(n)}</code>です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">At the same time, we also give each existential variable a <b>universe</b> (also taken from the <code>InferCtxt</code> ).</span>同時に、我々はまた、各存在変数を<b>宇宙</b> （ <code>InferCtxt</code>からも取った<code>InferCtxt</code> ）に<code>InferCtxt</code>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This universe determines which skolemized elements may appear in its value: For example, a variable in universe U3 may name <code>skol(1)</code> , <code>skol(2)</code> , and <code>skol(3)</code> , but not <code>skol(4)</code> .</span>たとえば、ユニバースU3の変数は、 <code>skol(1)</code> 、 <code>skol(2)</code> 、および<code>skol(3)</code>になり<code>skol(3)</code>が、 <code>skol(4)</code>はありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that the universe of an inference variable controls what region elements <b>can</b> appear in its value;</span>推論変数のユニバースは、その値にどの地域要素<b>が</b>現れるかを制御することに注意してください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">it does not say region elements <b>will</b> appear.</span>地域の要素<b>が</b>表示さ<b>れる</b>ことはありません。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Skolemization and outlives constraints</span> Skolemizationと寿命の制約</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In the region inference engine, outlives constraints have the form:</span>領域推論エンジンでは、寿命の制約は次の形式をとります。</span> </p><br><div data-lang=text><div data-l="V1: V2 @ P"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">where <code>V1</code> and <code>V2</code> are region indices, and hence map to some region variable (which may be universally or existentially quantified).</span>ここで、 <code>V1</code>および<code>V2</code>は領域指数であり、したがって、いくつかの領域変数（普遍的または存在的に定量化され得る）にマッピングされる。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>P</code> here is a &quot;point&quot; in the control-flow graph;</span>ここでの<code>P</code>は、制御フローグラフの「ポイント」です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">it&#39;s not important for this section.</span>このセクションでは重要ではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This variable will have a universe, so let&#39;s call those universes <code>U(V1)</code> and <code>U(V2)</code> respectively.</span>この変数には宇宙があるので、それらの宇宙<code>U(V1)</code>と<code>U(V2)</code>それぞれ呼ぶことにしましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">(Actually, the only one we are going to care about is <code>U(V1)</code> .)</span> （実際、私たちが気にするのは<code>U(V1)</code>です。）</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When we encounter this constraint, the ordinary procedure is to start a DFS from <code>P</code> .</span>この制約に遭遇すると、通常の手順は<code>P</code>からDFSを開始することです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We keep walking so long as the nodes we are walking are present in <code>value(V2)</code> and we add those nodes to <code>value(V1)</code> .</span>歩いているノードが<code>value(V2)</code>存在し、それらのノードを<code>value(V1)</code>追加する限り、歩行を続けます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we reach a return point, we add in any <code>end(X)</code> elements.</span>リターンポイントに達すると、任意の<code>end(X)</code>要素が追加されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That part remains unchanged.</span>その部分は変わりません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But then <i>after that</i> we want to iterate over the skolemized <code>skol(x)</code> elements in V2 (each of those must be visible to <code>U(V2)</code> , but we should be able to just assume that is true, we don&#39;t have to check it).</span>しかし、 <i>その後</i> 、私たちはskolemizedを反復処理したい<code>skol(x)</code> V2の要素（これらのそれぞれは、に見えなければならない<code>U(V2)</code>しかし、我々は確認する必要はありません。私達はちょうどそれが本当であると仮定することができるはずですそれ）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We have to ensure that <code>value(V1)</code> outlives each of those skolemized elements.</span> <code>value(V1)</code>がそれらの価値のある要素のそれぞれよりも長く存続することを保証する必要があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now there are two ways that could happen.</span>今、起こる可能性のある2つの方法があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">First, if <code>U(V1)</code> can see the universe <code>x</code> (ie, <code>x &lt;= U(V1)</code> ), then we can just add <code>skol(x)</code> to <code>value(V1)</code> and be done.</span>まず、 <code>U(V1)</code>が宇宙<code>x</code> （ <code>x &lt;= U(V1)</code> ）を見ることができれば、 <code>skol(x)</code>を<code>value(V1)</code>加えて<code>skol(x)</code>することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But if not, then we have to approximate: we may not know what set of elements <code>skol(x)</code> represents, but we should be able to compute some sort of <b>upper bound</b> B for it – some region B that outlives <code>skol(x)</code> .</span>我々は要素の集合のか分からないかもしれません。しかし、そうでなければ、我々は近似する必要があり<code>skol(x)</code>表すが、我々はそれの<b>上限</b> Bのいくつかの並べ替えを計算することができるはず- outlivesいくつかの領域B <code>skol(x)</code></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For now, we&#39;ll just use <code>&#39;static</code> for that (since it outlives everything) – in the future, we can sometimes be smarter here (and in fact we have code for doing this already in other contexts).</span>現時点では、私たちは単に<code>&#39;static</code>を使用しています（すべてが残って<code>&#39;static</code>ため） - 将来、時にはスマートになることがあります（実際には他のコンテキストでこれを行うためのコードがあります）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Moreover, since <code>&#39;static</code> is in the root universe U0, we know that all variables can see it – so basically if we find that <code>value(V2)</code> contains <code>skol(x)</code> for some universe <code>x</code> that <code>V1</code> can&#39;t see, then we force <code>V1</code> to <code>&#39;static</code> .</span>さらに、 <code>&#39;static</code>は根の宇宙U0にあるので、すべての変数がそれを見ることができることを知っている - 基本的に、 <code>V1</code>が見ることができない宇宙<code>x</code> <code>value(V2)</code>に<code>skol(x)</code> <code>V1</code>から<code>&#39;static</code> 。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Extending the &quot;universal regions&quot; check</span> 「ユニバーサル地域」のチェックを拡大する</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">After all constraints have been propagated, the NLL region inference has one final check, where it goes over the values that wound up being computed for each universal region and checks that they did not get &#39;too large&#39;.</span>すべての制約が伝播された後、NLL領域の推論には最終的なチェックが1つあります。ここでは、それぞれのユニバーサル領域で計算された値を超え、「大きすぎる」ことはありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In our case, we will go through each skolemized region and check that it contains <i>only</i> the <code>skol(u)</code> element it is known to outlive.</span>私たちの場合、各スカイメーションされた領域を通過し、それが<i>残っ</i>ていることが分かっている<code>skol(u)</code>要素<i>だけ</i>が含まれていることを確認します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">(Later, we might be able to know that there are relationships between two skolemized regions and take those into account, as we do for universal regions from the fn signature.)</span> （後で、fnシグネチャからの普遍的なリージョンの場合と同様に、2つのスカラー化されたリージョン間に関係があり、それらを考慮に入れていることがわかるかもしれません。）</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Put another way, the &quot;universal regions&quot; check can be considered to be checking constraints like:</span>別の言い方をすれば、「ユニバーサル領域」チェックは以下のような制約をチェックすると考えることができます：</span> </p><br><div data-lang=text><div data-l="{skol(1)}: V1"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">where <code>{skol(1)}</code> is like a constant set, and V1 is the variable we made to represent the <code>€1</code> region.</span>ここで、 <code>{skol(1)}</code>は定数集合に似ており、V1は<code>€1</code>領域を表すために作成した変数です。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Back to our example</span>私たちの例に戻る</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">OK, so far so good.</span> OK、これまでのところ良い。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now let&#39;s walk through what would happen with our first example:</span>さあ、最初の例で起こることを歩みましょう：</span> </p><br><div data-lang=text><div data-l="#//fn(&amp;'static u32) &lt;: fn(&amp;'!1 u32) @ P  // this point P is not imp't here"></div><div data-l="fn(&amp;'static u32) &lt;: fn(&amp;'!1 u32) @ P  // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">this point P is not imp&#39;t here</span>この点Pはここでは意味を持たない</span> </div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The region inference engine will create a region element domain like this:</span>リージョン推論エンジンは、以下のようなリージョン要素ドメインを作成します。</span> </p><br><div data-lang=text><div data-l="{ CFG; end('static); skol(1) }"></div><div data-l="    ---  ------------  ------- from the universe `!1`"></div><div data-l="    |    'static is always in scope"></div><div data-l="    all points in the CFG; not especially relevant here"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It will always create two universal variables, one representing <code>&#39;static</code> and one representing <code>&#39;€1</code> .</span>常に2つの普遍的な変数を作成します.1つは<code>&#39;static</code>変数<code>&#39;static</code>表し、もう1つは<code>&#39;static</code> 1 <code>&#39;€1</code>表します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s call them Vs and V1.</span>それらをVsとV1としましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">They will have initial values like so:</span>それらは次のような初期値を持ちます：</span> </p><br><div data-lang=text><div data-l="#//Vs = { CFG; end('static) } // it is in U0, so can't name anything else"></div><div data-l="Vs = { CFG; end('static) } // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">it is in U0, so can&#39;t name anything else</span>それはU0にあるので、他の名前を付けることはできません</span> </div><div data-l="V1 = { skol(1) }"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">From the subtyping constraint above, we would have an outlives constraint like</span>上記のサブタイプの制約から、次のような寿命の制約があります。</span> </p><br><div data-lang=text><div data-l="'!1: 'static @ P"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To process this, we would grow the value of V1 to include all of Vs:</span>これを処理するには、Vsのすべてを含むようにV1の値を大きくします。</span> </p><br><div data-lang=text><div data-l="Vs = { CFG; end('static) }"></div><div data-l="V1 = { CFG; end('static), skol(1) }"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">At that point, constraint propagation is complete, because all the outlives relationships are satisfied.</span>その時点で、すべての残存関係が満たされているため、制約の伝播は完了しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then we would go to the &quot;check universal regions&quot; portion of the code, which would test that no universal region grew too large.</span>次に、コードの &quot;普遍的な領域をチェックする&quot;部分に行き、普遍的な領域が大きくなりすぎないことをテストします。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this case, <code>V1</code> <i>did</i> grow too large – it is not known to outlive <code>end(&#39;static)</code> , nor any of the CFG – so we would report an error.</span>この場合、 <code>V1</code> <i>は</i>大きくなりすぎました。つまり、 <code>end(&#39;static)</code>ものもCFGのものも残っていないことが分かっています。そのため、エラーが報告されます。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Another example</span>もう一つの例</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">What about this subtyping relationship?</span>このサブタイプの関係はどうですか？</span> </p><br><div data-lang=text><div data-l="for&lt;'a&gt; fn(&amp;'a u32, &amp;'a u32)"></div><div data-l="    &lt;:"></div><div data-l="for&lt;'b, 'c&gt; fn(&amp;'b u32, &amp;'c u32)"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here we would skolemize the supertype, as before, yielding:</span>ここで、以前と同じように、スーパータイプをskolemizeします。</span> </p><br><div data-lang=text><div data-l="for&lt;'a&gt; fn(&amp;'a u32, &amp;'a u32)"></div><div data-l="    &lt;:"></div><div data-l="fn(&amp;'!1 u32, &amp;'!2 u32)"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">then we instantiate the variable on the left-hand side with an existential in universe U2, yielding the following ( <code>?n</code> is a notation for an existential variable):</span>変数U2の左辺の変数をインスタンスU2にインスタンス化すると、以下のようになります（ <code>?n</code>は実在変数の表記です）。</span> </p><br><div data-lang=text><div data-l="fn(&amp;'?3 u32, &amp;'?3 u32)"></div><div data-l="    &lt;:"></div><div data-l="fn(&amp;'!1 u32, &amp;'!2 u32)"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then we break this down further:</span>次に、これをさらに分解します。</span> </p><br><div data-lang=text><div data-l="&amp;'!1 u32 &lt;: &amp;'?3 u32"></div><div data-l="&amp;'!2 u32 &lt;: &amp;'?3 u32"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">and even further, yield up our region constraints:</span>さらに、地域の制約を生み出します：</span> </p><br><div data-lang=text><div data-l="'!1: '?3"></div><div data-l="'!2: '?3"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that, in this case, both <code>&#39;€1</code> and <code>&#39;€2</code> have to outlive the variable <code>&#39;?3</code> , but the variable <code>&#39;?3</code> is not forced to outlive anything else.</span>なお、この場合には、両方の<code>&#39;€1</code>および<code>&#39;€2</code> 、変数をより長生きする必要が<code>&#39;?3</code>が、変数<code>&#39;?3</code> 、何よりも長生きすることを余儀なくされていません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Therefore, it simply starts and ends as the empty set of elements, and hence the type-check succeeds here.</span>したがって、要素の空集合として単純に開始および終了するため、ここで型チェックが成功します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">(This should surprise you a little. It surprised me when I first realized it. We are saying that if we are a fn that <b>needs both of its arguments to have the same region</b> , we can accept being called with <b>arguments with two distinct regions</b> . That seems intuitively unsound. But in fact, it&#39;s fine, as I tried to explain in <a href=#3ohdeargoditsallbroken>this issue</a> on the Rust issue tracker long ago. The reason is that even if we get called with arguments of two distinct lifetimes, those two lifetimes have some intersection (the call itself), and that intersection can be our value of <code>&#39;a</code> that we use as the common lifetime of our arguments. -nmatsakis)</span>私たちが<b>、同じ領域を持つために引数の両方</b>を<b>必要と</b>するfnなら<b>、2つの異なる領域を</b>持つ<b>引数で</b>呼び出されることを受け入れることができると言ってい<b>ます</b> 。それは直感的には不健全なようですが、実際には、 <a href=#3ohdeargoditsallbroken>この問題</a>については、ずっと前にRust号トラッカーで説明しようとしていたので、うまくいきます。その理由は、2つの異なる生涯の議論で呼び出されても、 （呼び出し自体）、その交差点は、私たちの議論の共通の生涯として使用する<code>&#39;a</code>私たちの価値<code>&#39;a</code>なる可能性があります。</span> </p><br> <a class=notranslate href=#1https://github.com/rust-lang/rust/issues/32330#issuecomment-202536977>ohdeargoditsallbroken</a> <br> <h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Final example</span>最後の例</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s look at one last example.</span>最後の例を見てみましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll extend the previous one to have a return type:</span>前の関数を戻り値の型に拡張します：</span> </p><br><div data-lang=text><div data-l="for&lt;'a&gt; fn(&amp;'a u32, &amp;'a u32) -&gt; &amp;'a u32"></div><div data-l="    &lt;:"></div><div data-l="for&lt;'b, 'c&gt; fn(&amp;'b u32, &amp;'c u32) -&gt; &amp;'b u32"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Despite seeming very similar to the previous example, this case is going to get an error.</span>前の例と非常によく似ているにもかかわらず、この場合はエラーが発生します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That&#39;s good: the problem is that we&#39;ve gone from a fn that promises to return one of its two arguments, to a fn that is promising to return the first one.</span>それは問題です：問題は、最初のものを返すことを約束しているfnに、2つの引数の1つを返すことを約束しているfnから行ったことです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That is unsound.</span>それは不健全です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s see how it plays out.</span>それがどのように再生するか見てみましょう。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">First, we skolemize the supertype:</span>まず、スーパータイプをスカラー化します。</span> </p><br><div data-lang=text><div data-l="for&lt;'a&gt; fn(&amp;'a u32, &amp;'a u32) -&gt; &amp;'a u32"></div><div data-l="    &lt;:"></div><div data-l="fn(&amp;'!1 u32, &amp;'!2 u32) -&gt; &amp;'!1 u32"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then we instantiate the subtype with existentials (in U2):</span>次に、（U2の）existentialsでサブタイプをインスタンス化します。</span> </p><br><div data-lang=text><div data-l="fn(&amp;'?3 u32, &amp;'?3 u32) -&gt; &amp;'?3 u32"></div><div data-l="    &lt;:"></div><div data-l="fn(&amp;'!1 u32, &amp;'!2 u32) -&gt; &amp;'!1 u32"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">And now we create the subtyping relationships:</span>次に、サブタイプの関係を作成します。</span> </p><br><div data-lang=text><div data-l="#//&amp;'!1 u32 &lt;: &amp;'?3 u32 // arg 1"></div><div data-l="&amp;'!1 u32 &lt;: &amp;'?3 u32 // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">arg 1</span> arg 1</span> </div><div data-l="#//&amp;'!2 u32 &lt;: &amp;'?3 u32 // arg 2"></div><div data-l="&amp;'!2 u32 &lt;: &amp;'?3 u32 // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">arg 2</span> arg 2</span> </div><div data-l="#//&amp;'?3 u32 &lt;: &amp;'!1 u32 // return type"></div><div data-l="&amp;'?3 u32 &lt;: &amp;'!1 u32 // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">return type</span>戻り値の型</span> </div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">And finally the outlives relationships.</span>そして最終的には永遠の関係。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here, let V1, V2, and V3 be the variables we assign to <code>€1</code> , <code>€2</code> , and <code>?3</code> respectively:</span>ここで、V1、V2、V3をそれぞれ<code>€1</code> 、 <code>€2</code> 、および<code>?3</code>に割り当てる変数とし<code>?3</code> 。</span> </p><br><div data-lang=text><div data-l="V1: V3"></div><div data-l="V2: V3"></div><div data-l="V3: V1"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Those variables will have these initial values:</span>これらの変数は、次の初期値を持ちます。</span> </p><br><div data-lang=text><div data-l="V1 in U1 = {skol(1)}"></div><div data-l="V2 in U2 = {skol(2)}"></div><div data-l="V3 in U2 = {}"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now because of the <code>V3: V1</code> constraint, we have to add <code>skol(1)</code> into <code>V3</code> (and indeed it is visible from <code>V3</code> ), so we get:</span>さてための<code>V3: V1</code>制約、我々は、追加する必要があります<code>skol(1)</code>に<code>V3</code> （そして実際にそれがから見える<code>V3</code> ）ので、我々が得ます：</span> </p><br><div data-lang=text><div data-l="V3 in U2 = {skol(1)}"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">then we have this constraint <code>V2: V3</code> , so we wind up having to enlarge <code>V2</code> to include <code>skol(1)</code> (which it can also see):</span>この制約<code>V2: V3</code>があるので、 <code>V2</code>を拡大して<code>skol(1)</code>を含める<code>skol(1)</code>があります（これも見ることができます）。</span> </p><br><div data-lang=text><div data-l="V2 in U2 = {skol(1), skol(2)}"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now contraint propagation is done, but when we check the outlives relationships, we find that <code>V2</code> includes this new element <code>skol(1)</code> , so we report an error.</span>今度は<code>skol(1)</code>伝播が行われますが、残存関係を調べると、 <code>V2</code>はこの新しい要素<code>skol(1)</code>含まれていることが<code>skol(1)</code>ます。そのため、エラーを報告します。</span> </p><br><script>_addload(function(){_setupIW('com');_csi('en','ja','regionck.html');});</script>