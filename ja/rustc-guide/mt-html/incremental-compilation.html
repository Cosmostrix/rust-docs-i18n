<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180723_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=incremental-compilation.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Incremental compilation</span>インクリメンタルコンパイル</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The incremental compilation scheme is, in essence, a surprisingly simple extension to the overall query system.</span>インクリメンタルコンパイルスキームは、本質的には、全体的なクエリシステムに対する驚くほど単純な拡張です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll start by describing a slightly simplified variant of the real thing – the &quot;basic algorithm&quot; – and then describe some possible improvements.</span>実際のもののやや簡略化された変形 - 基本的なアルゴリズム - を説明し、いくつかの改善点を説明します。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The basic algorithm</span>基本的なアルゴリズム</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The basic algorithm is called the <b>red-green</b> algorithm <a class=notranslate href=#4^salsa>^salsa</a> .</span>基本的なアルゴリズムは<b>赤緑</b>アルゴリズム<a class=notranslate href=#4^salsa>^salsa</a>と呼ばれます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The high-level idea is that, after each run of the compiler, we will save the results of all the queries that we do, as well as the <b>query DAG</b> .</span>高レベルのアイデアは、コンパイラを実行するたびに、私たちが行うすべてのクエリの結果と<b>クエリDAG</b>を保存するということです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <b>query DAG</b> is a <a class=notranslate href=#4DAG>DAG</a> that indexes which queries executed which other queries.</span> <b>問合せDAG</b>は、どの問合せが他の問合せを実行したかを索引付けする<a class=notranslate href=#4DAG>DAG</a>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So, for example, there would be an edge from a query Q1 to another query Q2 if computing Q1 required computing Q2 (note that because queries cannot depend on themselves, this results in a DAG and not a general graph).</span>たとえば、Q1の計算にQ2の計算が必要な場合（つまり、クエリがそれ自体に依存しないため、これはDAGで一般的なグラフではないことに注意してください）、クエリQ1から別のクエリQ2へのエッジがあります。</span> </p><br> <a class=notranslate href=#1https://en.wikipedia.org/wiki/Directed_acyclic_graph>DAG</a> <br> <p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">On the next run of the compiler, then, we can sometimes reuse these query results to avoid re-executing a query.</span>コンパイラの次回の実行時には、クエリの再実行を避けるために、これらのクエリ結果を再利用することがあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We do this by assigning every query a <b>color</b> :</span>これは、すべてのクエリに<b>色を</b>割り当てることで行います。</span> </p><br><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If a query is colored <b>red</b> , that means that its result during this compilation has <b>changed</b> from the previous compilation.</span>クエリーが<b>赤</b>で表示されている場合は、このコンパイル時の結果が前のコンパイルから<b>変更さ</b>れたことを意味します。</span> </div><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If a query is colored <b>green</b> , that means that its result is the <b>same</b> as the previous compilation.</span>クエリーが<b>緑色</b>で表示されている場合は、その結果が以前のコンパイル<b>と同じ</b>であることを意味します。</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There are two key insights here:</span>ここには2つの重要な洞察があります：</span> </p><br><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">First, if all the inputs to query Q are colored green, then the query Q <b>must</b> result in the same value as last time and hence need not be re-executed (or else the compiler is not deterministic).</span>まず、問合せQのすべての入力が緑色に着色されている場合、問合せQ <b>は</b>前回と同じ値になるため、再実行する必要はありません（そうでなければ、コンパイラは確定的ではありません）。</span> </div><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Second, even if some inputs to a query changes, it may be that it</span>第2に、クエリへの入力の一部が変更されたとしても、それが</span> </div><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><b>still</b> produces the same result as the previous compilation.</span> <b>まだ</b>前のコンパイルと同じ結果を生成します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In particular, the query may only use part of its input.</span>特に、クエリは入力の一部しか使用できません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">- Therefore, after executing a query, we always check whether it produced the same result as the previous time.</span> - したがって、クエリを実行した後、前回と同じ結果が得られたかどうかを常にチェックします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><b>If it did,</b> we can still mark the query as green, and hence avoid re-executing dependent queries.</span> <b>そうした場合</b>でも、依然としてクエリを緑色にマークして、従属クエリの再実行を避けることができます。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The try-mark-green algorithm</span> try-mark-greenアルゴリズム</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">At the core of incremental compilation is an algorithm called &quot;try-mark-green&quot;.</span>インクリメンタルコンパイルの中核には、 &quot;try-mark-green&quot;と呼ばれるアルゴリズムがあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It has the job of determining the color of a given query Q (which must not have yet been executed).</span>与えられたクエリーQ（まだ実行されていてはならない）の色を決定する作業をしています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In cases where Q has red inputs, determining Q&#39;s color may involve re-executing Q so that we can compare its output, but if all of Q&#39;s inputs are green, then we can conclude that Q must be green without re-executing it or inspecting its value at all.</span> Qが赤の入力を持つ場合、Qの色を決定するにはQを再実行してその出力を比較することができますが、Qの入力がすべて緑であれば、Qを再実行せずに緑にする必要があります。その価値はまったくありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In the compiler, this allows us to avoid deserializing the result from disk when we don&#39;t need it, and in fact enables us to sometimes skip <i>serializing</i> the result as well (see the refinements section below).</span>コンパイラでは、これにより、必要のないときにディスクから結果を逆シリアル化することを避けることができます。実際には結果を<i>シリアライズ</i>することもできます（下記の詳細セクションを参照してください）。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Try-mark-green works as follows:</span> Try-mark-greenは次のように動作します。</span> </p><br><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">First check if the query Q was executed during the previous compilation.</span>まず、前回のコンパイル時にクエリQが実行されたかどうかを確認します。</span> </div><div data-b="  -"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If not, we can just re-execute the query as normal, and assign it the color of red.</span>そうでない場合は、通常どおりクエリを再実行し、赤の色を割り当てます。</span> </div><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If yes, then load the &#39;dependent queries&#39; of Q.</span> 「はい」の場合は、「依存クエリ」を読み込みます。</span> </div><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If there is a saved result, then we load the <code>reads(Q)</code> vector from the query DAG.</span>保存された結果がある場合は、クエリDAGから<code>reads(Q)</code>ベクトルを<code>reads(Q)</code>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The &quot;reads&quot; is the set of queries that Q executed during its execution.</span> 「読み込み」は、実行中にQが実行したクエリのセットです。</span> </div><div data-b="  -"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For each query R in <code>reads(Q)</code> , we recursively demand the color of R using try-mark-green.</span> <code>reads(Q)</code>各クエリRについて、私たちはtry-mark-greenを使ってRの色を再帰的に要求します。</span> </div><div data-b="    -"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note: it is important that we visit each node in <code>reads(Q)</code> in same order as they occurred in the original compilation.</span>注：元のコンパイルで発生したのと同じ順序で、各ノードを<code>reads(Q)</code>に移動することが重要です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">See <a href=#2#dag>the section on the query DAG below</a> .</span> <a href=#2#dag>以下のクエリDAGのセクションを</a>参照してください。</span> </div><div data-b="    -"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If <b>any</b> of the nodes in <code>reads(Q)</code> wind up colored <b>red</b> , then Q is dirty.</span> <code>reads(Q)</code>ノードの<b>いずれか</b>が<b>赤色</b>に着色して<b>いる</b>場合、Qは汚れています。</span> </div><div data-b="      -"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We re-execute Q and compare the hash of its result to the hash of the result from the previous compilation.</span> Qを再実行し、その結果のハッシュを前のコンパイル結果のハッシュと比較します。</span> </div><div data-b="      -"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If the hash has not changed, we can mark Q as <b>green</b> and return.</span>ハッシュ値が変更されていない場合は、Qを<b>緑色に</b>マークして戻ることができます。</span> </div><div data-b="    -"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Otherwise, <b>all</b> of the nodes in <code>reads(Q)</code> must be <b>green</b> .</span>それ以外の場合は、 <code>reads(Q)</code>ノードは<b>すべて</b> <b>緑色で</b>なければなりません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In that case, we can color Q as <b>green</b> and return.</span>その場合、私たちはQを<b>緑色に</b>して返します。</span> </div><br><p><a name=dag></a></p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The query DAG</span>クエリDAG</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The query DAG code is stored in <a class=notranslate href=#3dep_graph><code>src/librustc/dep_graph</code></a> .</span>クエリDAGコードは<a class=notranslate href=#3dep_graph><code>src/librustc/dep_graph</code></a>格納されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Construction of the DAG is done by instrumenting the query execution.</span> DAGの構築は、クエリの実行を計測することによって行われます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">One key point is that the query DAG also tracks ordering;</span> 1つの重要な点は、クエリDAGも順序付けを追跡することです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">that is, for each query Q, we not only track the queries that Q reads, we track the <b>order</b> in which they were read.</span>つまり、各クエリQに対して、Qが読み取るクエリを追跡するだけでなく、読み取られた<b>順序</b>を追跡します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This allows try-mark-green to walk those queries back in the same order.</span>これにより、try-mark-greenはそれらのクエリを同じ順序で戻すことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is important because once a subquery comes back as red, we can no longer be sure that Q will continue along the same path as before.</span>サブクエリが赤色に戻ると、以前と同じパスでQが続行されることがなくなるため、これは重要です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That is, imagine a query like this:</span>つまり、次のようなクエリを想像してみてください。</span> </p><br><div data-lang=rust,ignore><div data-l="fn main_query(tcx) {"></div><div data-l="    if tcx.subquery1() {"></div><div data-l="        tcx.subquery2()"></div><div data-l="    } else {"></div><div data-l="        tcx.subquery3()"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now imagine that in the first compilation, <code>main_query</code> starts by executing <code>subquery1</code> , and this returns true.</span>今、最初のコンパイルで、 <code>main_query</code>が<code>subquery1</code>を実行することによって開始し、これがtrueを返すと想像してください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In that case, the next query <code>main_query</code> executes will be <code>subquery2</code> , and <code>subquery3</code> will not be executed at all.</span>その場合、次のクエリ<code>main_query</code>は<code>subquery2</code>になり、 <code>subquery3</code>はまったく実行されません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But now imagine that in the <b>next</b> compilation, the input has changed such that <code>subquery1</code> returns <b>false</b> .</span>しかし、今度は、 <b>次の</b>コンパイルで入力が変更され、 <code>subquery1</code>が<b>falseを</b>返すと想像してください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this case, <code>subquery2</code> would never execute.</span>この場合、 <code>subquery2</code>は決して実行されません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If try-mark-green were to visit <code>reads(main_query)</code> out of order, however, it might visit <code>subquery2</code> before <code>subquery1</code> , and hence execute it.</span> try-mark-greenが<code>reads(main_query)</code>を順不同で訪れた場合、 <code>subquery2</code>前の<code>subquery1</code>にアクセスして実行する可能性があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This can lead to ICEs and other problems in the compiler.</span>これにより、ICEやコンパイラのその他の問題が発生する可能性があります。</span> </p><br> <a class=notranslate href=#1https://github.com/rust-lang/rust/tree/master/src/librustc/dep_graph>dep_graph</a> <br> <h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Improvements to the basic algorithm</span>基本的なアルゴリズムの改善</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In the description of the basic algorithm, we said that at the end of compilation we would save the results of all the queries that were performed.</span>基本的なアルゴリズムの説明では、コンパイルの最後に、実行されたすべてのクエリの結果を保存すると述べました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In practice, this can be quite wasteful – many of those results are very cheap to recompute, and serializing and deserializing them is not a particular win.</span>実際には、これは非常に無駄かもしれません。それらの結果の多くは再計算するのに非常に安価であり、シリアライズとデシリアライズは特別な勝利ではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In practice, what we would do is to save <b>the hashes</b> of all the subqueries that we performed.</span>実際には、実行したすべてのサブクエリの<b>ハッシュ</b>を保存することです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then, in select cases, we <b>also</b> save the results.</span>次に、選択されたケースでは、結果<b>も</b>保存します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is why the incremental algorithm separates computing the <b>color</b> of a node, which often does not require its value, from computing the <b>result</b> of a node.</span>これは、増分アルゴリズムが、ノードの<b>結果</b>を計算する<b>こと</b>から、しばしばその値を必要としないノードの<b>色</b>の計算を分離する理由です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Computing the result is done via a simple algorithm like so:</span>結果を計算するには、次のような簡単なアルゴリズムを使用します。</span> </p><br><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Check if a saved result for Q is available.</span> Qの保存結果が利用可能かどうかを確認してください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If so, compute the color of Q. If Q is green, deserialize and return the saved result.</span>そうであれば、Qの色を計算します.Qが緑の場合は、デシリアライズして保存した結果を返します。</span> </div><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Otherwise, execute Q.</span>そうでなければ、Qを実行します</span> </div><div data-b="  -"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can then compare the hash of the result and color Q as green if it did not change.</span>次に、結果のハッシュと色Qが変更されていない場合は緑色を比較することができます。</span> </div><br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Footnotes</span>脚注</span> </h1><br> <a class=notranslate href="#1I have long wanted to rename it to the Salsa algorithm, but it never caught on. -@nikomatsakis">^salsa</a><script>_addload(function(){_setupIW('com');_csi('en','ja','incremental-compilation.html');});</script>