<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180723_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=miri.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Miri</span>ミリ</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Miri ( <b>MIR</b> <b>I</b> nterpreter) is a virtual machine for executing MIR without compiling to machine code.</span> Miri（ <b>MIR</b> <b>I</b> nterpreter）は、マシンコードにコンパイルせずにMIRを実行するための仮想マシンです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It is usually invoked via <code>tcx.const_eval</code> .</span>これは通常、 <code>tcx.const_eval</code>を介して呼び出されます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you start out with a constant</span>あなたが定数で始めるなら</span> </p><br><div data-lang=rust><div data-l="const FOO: usize = 1 &lt;&lt; 12;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">rustc doesn&#39;t actually invoke anything until the constant is either used or placed into metadata.</span> rustcは、定数が使用されるかメタデータに置かれるまで、実際には何も呼び出されません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Once you have a use-site like</span>のような使用サイトを取得したら</span> </p><br><div data-lang=rust,ignore><div data-l="type Foo = [u8; FOO - 42];"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The compiler needs to figure out the length of the array before being able to create items that use the type (locals, constants, function arguments, ...).</span>コンパイラは、型（地域、定数、関数の引数など）を使用する項目を作成するには、配列の長さを把握する必要があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To obtain the (in this case empty) parameter environment, one can call <code>let param_env = tcx.param_env(length_def_id);</code></span> （この場合は空の）パラメータ環境を取得するには、 <code>let param_env = tcx.param_env(length_def_id);</code>呼び出し<code>let param_env = tcx.param_env(length_def_id);</code></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">.</span> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>GlobalId</code> needed is</span>必要な<code>GlobalId</code>は</span> </p><br><div data-lang=rust,ignore><div data-l="let gid = GlobalId {"></div><div data-l="    promoted: None,"></div><div data-l="    instance: Instance::mono(length_def_id),"></div><div data-l=};></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Invoking <code>tcx.const_eval(param_env.and(gid))</code> will now trigger the creation of the MIR of the array length expression.</span> <code>tcx.const_eval(param_env.and(gid))</code>を呼び出すと、配列の長さ式のMIRが作成されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The MIR will look something like this:</span> MIRは次のようになります。</span> </p><br><div data-lang=mir><div data-l="const Foo::{{initializer}}: usize = {"></div><div data-l="#//    let mut _0: usize;                   // return pointer"></div><div data-l="    let mut _0: usize;                   // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">return pointer</span>戻りポインタ</span> </div><div data-l="    let mut _1: (usize, bool);"></div><div data-l=""></div><div data-l="    bb0: {"></div><div data-l="        _1 = CheckedSub(const Unevaluated(FOO, Slice([])), const 42usize);"></div><div data-l="        assert(!(_1.1: bool), &quot;attempt to subtract with overflow&quot;) -&gt; bb1;"></div><div data-l="    }"></div><div data-l=""></div><div data-l="    bb1: {"></div><div data-l="        _0 = (_1.0: usize);"></div><div data-l="        return;"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Before the evaluation, a virtual memory location (in this case essentially a <code>vec€[u8; 4]</code> or <code>vec€[u8; 8]</code> ) is created for storing the evaluation result.</span>評価の前に、評価結果を格納する仮想メモリの場所（この場合は基本的に<code>vec€[u8; 4]</code>または<code>vec€[u8; 8]</code> ）が作成されます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">At the start of the evaluation, <code>_0</code> and <code>_1</code> are <code>Value::ByVal(PrimVal::Undef)</code> .</span>評価の開始時に、 <code>_0</code>と<code>_1</code>は<code>Value::ByVal(PrimVal::Undef)</code>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When the initialization of <code>_1</code> is invoked, the value of the <code>FOO</code> constant is required, and triggers another call to <code>tcx.const_eval</code> , which will not be shown here.</span> <code>_1</code>の初期化が呼び出されると、 <code>FOO</code>定数の値が必要になり、ここには表示されない<code>tcx.const_eval</code>への別の呼び出しがトリガーされます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If the evaluation of FOO is successful, 42 will be subtracted by its value <code>4096</code> and the result stored in <code>_1</code> as <code>Value::ByValPair(PrimVal::Bytes(4054), PrimVal::Bytes(0))</code> .</span> FOOの評価が成功すると、42はその値<code>4096</code>によって減算され、結果は<code>Value::ByValPair(PrimVal::Bytes(4054), PrimVal::Bytes(0))</code>として<code>_1</code>格納されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The first part of the pair is the computed value, the second part is a bool that&#39;s true if an overflow happened.</span>ペアの最初の部分は計算された値で、2番目の部分はオーバーフローが発生した場合に真となるブールです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The next statement asserts that said boolean is <code>0</code> .</span>次の文は、前記ブール値が<code>0</code>ことを表明する。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In case the assertion fails, its error message is used for reporting a compile-time error.</span>アサーションが失敗した場合、そのエラーメッセージはコンパイル時エラーを報告するために使用されます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Since it does not fail, <code>Value::ByVal(PrimVal::Bytes(4054))</code> is stored in the virtual memory was allocated before the evaluation.</span>それが失敗しないので、 <code>Value::ByVal(PrimVal::Bytes(4054))</code>は、評価の前に割り当てられた仮想メモリに格納されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>_0</code> always refers to that location directly.</span> <code>_0</code>常にその場所を直接参照します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">After the evaluation is done, the virtual memory allocation is interned into the <code>TyCtxt</code> .</span>評価が終了すると、仮想メモリの割り当てが<code>TyCtxt</code>されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Future evaluations of the same constants will not actually invoke miri, but just extract the value from the interned allocation.</span>同じ定数の将来の評価は、実際にはmiriを呼び出すのではなく、インターナショナル割り当てから値を抽出するだけです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>tcx.const_eval</code> function has one additional feature: it will not return a <code>ByRef(interned_allocation_id)</code> , but a <code>ByVal(computed_value)</code> if possible.</span> <code>tcx.const_eval</code>関数には、 <code>ByRef(interned_allocation_id)</code> <code>tcx.const_eval</code> <code>ByRef(interned_allocation_id)</code>が返されるのではなく、可能な場合は<code>ByVal(computed_value)</code>が返されるという追加機能があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This makes using the result much more convenient, as no further queries need to be executed in order to get at something as simple as a <code>usize</code> .</span>これにより、 <code>usize</code>ような単純なものを得るためにクエリを実行する必要がないため、結果をより便利に使用できます。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Datastructures</span>データ構造</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Miri&#39;s core datastructures can be found in <a class=notranslate href=#2https://github.com/rust-lang/rust/blob/master/src/librustc/mir/interpret>librustc/mir/interpret</a> .</span> Miriのコアデータ構造は<a class=notranslate href=#2https://github.com/rust-lang/rust/blob/master/src/librustc/mir/interpret>librustc/mir/interpret</a>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is mainly the error enum and the <code>Value</code> and <code>PrimVal</code> types.</span>これは、主にエラー列挙型と<code>Value</code>および<code>PrimVal</code>型です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A <code>Value</code> can be either <code>ByVal</code> (a single <code>PrimVal</code> ), <code>ByValPair</code> (two <code>PrimVal</code> s, usually fat pointers or two element tuples) or <code>ByRef</code> , which is used for anything else and refers to a virtual allocation.</span> <code>Value</code>は、 <code>ByVal</code> （単一の<code>PrimVal</code> ）、 <code>ByValPair</code> （2つの<code>PrimVal</code> 、通常はファットポインタまたは2つの要素タプル）または<code>ByRef</code>いずれかで、他のものに使用され、仮想割り当てを参照します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These allocations can be accessed via the methods on <code>tcx.interpret_interner</code> .</span>これらの割り当ては、 <code>tcx.interpret_interner</code>のメソッドを介してアクセスできます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you are expecting a numeric result, you can use <code>unwrap_u64</code> (panics on anything that can&#39;t be representad as a <code>u64</code> ) or <code>to_raw_bits</code> which results in an <code>Option&lt;u128&gt;</code> yielding the <code>ByVal</code> if possible.</span>数値結果が必要な場合は、 <code>unwrap_u64</code> （ <code>u64</code>として表現できないものについてはパニック）や<code>to_raw_bits</code>を使用して、できるだけ<code>ByVal</code>を生成する<code>Option&lt;u128&gt;</code>を<code>ByVal</code>することができます。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Allocations</span>割り当て</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A miri allocation is either a byte sequence of the memory or an <code>Instance</code> in the case of function pointers.</span>ミリ割り当ては、メモリのバイトシーケンスか、関数ポインタの場合は<code>Instance</code>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Byte sequences can additionally contain relocations that mark a group of bytes as a pointer to another allocation.</span>バイトシーケンスには、さらに、別の割り当てへのポインタとしてバイトグループをマークする再配置を含めることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The actual bytes at the relocation refer to the offset inside the other allocation.</span>再配置時の実際のバイトは、他の割り当て内のオフセットを参照します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These allocations exist so that references and raw pointers have something to point to.</span>これらの割り当ては、参照と生ポインタが指すものがあるように存在します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There is no global linear heap in which things are allocated, but each allocation (be it for a local variable, a static or a (future) heap allocation) gets its own little memory with exactly the required size.</span>物事が割り当てられるグローバルリニアヒープはありませんが、各割り当て（ローカル変数、静的または将来のヒープ割り当て用）は、必要なサイズのメモリを持っています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So if you have a pointer to an allocation for a local variable <code>a</code> , there is no possible (no matter how unsafe) operation that you can do that would ever change said pointer to a pointer to <code>b</code> .</span>したがって、ローカル変数<code>a</code>割り当てへのポインタがあれば、 <code>b</code>へのポインタへのポインタを変更する可能性のある（安全性に関係なく）可能な操作はありません。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Interpretation</span>解釈</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Although the main entry point to constant evaluation is the <code>tcx.const_eval</code> query, there are additional functions in <a class=notranslate href=#2https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/interpret/const_eval/>librustc_mir/interpret/const_eval.rs</a> that allow accessing the fields of a <code>Value</code> ( <code>ByRef</code> or otherwise).</span>定数評価の主なエントリポイントは<code>tcx.const_eval</code>クエリですが、 <a class=notranslate href=#2https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/interpret/const_eval/>librustc_mir/interpret/const_eval.rs</a>には<code>Value</code> （ <code>ByRef</code>など）のフィールドにアクセスするための追加機能があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You should never have to access an <code>Allocation</code> directly except for translating it to the compilation target (at the moment just LLVM).</span>コンパイル対象に翻訳することを除いて（今のところLLVMのみ）、 <code>Allocation</code>直接アクセスする必要はありません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Miri starts by creating a virtual stack frame for the current constant that is being evaluated.</span> Miriは評価されている現在の定数の仮想スタックフレームを作成することから始めます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There&#39;s essentially no difference between a constant and a function with no arguments, except that constants do not allow local (named) variables at the time of writing this guide.</span>本ガイドの作成時には、定数がローカル（名前付き）変数を許可しないという点を除き、定数と関数の間には基本的に違いはありません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A stack frame is defined by the <code>Frame</code> type in <a class=notranslate href=#2https://github.com/rust-lang/rust/blob/master/src/librustc_mir/interpret/eval_context.rs>librustc_mir/interpret/eval_context.rs</a> and contains all the local variables memory ( <code>None</code> at the start of evaluation).</span>スタックフレームは、 <a class=notranslate href=#2https://github.com/rust-lang/rust/blob/master/src/librustc_mir/interpret/eval_context.rs>librustc_mir/interpret/eval_context.rs</a>の<code>Frame</code>タイプで定義され、すべてのローカル変数メモリ（評価の開始時には<code>None</code>を含みます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Each frame refers to the evaluation of either the root constant or subsequent calls to <code>const fn</code> .</span>各フレームは、ルート定数またはそれ以降の<code>const fn</code>呼び出しの評価を参照します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The evaluation of another constant simply calls <code>tcx.const_eval</code> , which produces an entirely new and independent stack frame.</span>別の定数を評価すると、単純に<code>tcx.const_eval</code>が<code>tcx.const_eval</code> 、全く新しい独立したスタックフレームが生成されます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The frames are just a <code>Vec&lt;Frame&gt;</code> , there&#39;s no way to actually refer to a <code>Frame</code> &#39;s memory even if horrible shenigans are done via unsafe code.</span>フレームはちょうど<code>Vec&lt;Frame&gt;</code>なので、恐ろしい怪物が安全でないコードであっても実際に<code>Frame</code>のメモリを参照する方法はありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The only memory that can be referred to are <code>Allocation</code> s.</span>参照できる唯一のメモリは<code>Allocation</code>です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Miri now calls the <code>step</code> method (in <a class=notranslate href=#2https://github.com/rust-lang/rust/blob/master/src/librustc_mir/interpret/step.rs>librustc_mir/interpret/step.rs</a> ) until it either returns an error or has no further statements to execute.</span> Miriはエラーを返すか、実行する文がなくなるまで<code>step</code>メソッド（ <a class=notranslate href=#2https://github.com/rust-lang/rust/blob/master/src/librustc_mir/interpret/step.rs>librustc_mir/interpret/step.rs</a> ）を呼び出します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Each statement will now initialize or modify the locals or the virtual memory referred to by a local.</span>各ステートメントはローカルまたはローカルで参照される仮想メモリを初期化または変更します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This might require evaluating other constants or statics, which just recursively invokes <code>tcx.const_eval</code> .</span>これは、 <code>tcx.const_eval</code>再帰的に呼び出す他の定数や統計を評価する必要があるかもしれません。</span> </p><script>_addload(function(){_setupIW('com');_csi('en','ja','miri.html');});</script>