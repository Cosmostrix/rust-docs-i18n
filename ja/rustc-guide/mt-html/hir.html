<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180723_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=hir.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The HIR</span> HIR</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The HIR – &quot;High-Level Intermediate Representation&quot; – is the primary IR used in most of rustc.</span> HIR  - 「高レベル中間表現」 - ほとんどの錆びた部分に使用される主なIRです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It is a compiler-friendly representation of the abstract syntax tree (AST) that is generated after parsing, macro expansion, and name resolution (see <a class=notranslate href=#2./lowering.html>Lowering</a> for how the HIR is created).</span>それはパースした後に生成された抽象構文木（AST）、マクロ展開、および名前解決（参照のコンパイラにやさしい表現で<a class=notranslate href=#2./lowering.html>Lowering</a> HIRを作成する方法については）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Many parts of HIR resemble Rust surface syntax quite closely, with the exception that some of Rust&#39;s expression forms have been desugared away.</span> HIRの多くの部分は、Rustの表現形式のいくつかが削除されていることを除いて、Rustサーフェイスのシンタックスに非常によく似ています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, <code>for</code> loops are converted into a <code>loop</code> and do not appear in the HIR.</span>例えば、 <code>for</code>ループに変換され<code>loop</code>とHIRには表示されません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This makes HIR more amenable to analysis than a normal AST.</span>これにより、HIRは通常のASTよりも解析が行いやすくなります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This chapter covers the main concepts of the HIR.</span>この章では、HIRの主な概念について説明します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can view the HIR representation of your code by passing the <code>-Zunpretty=hir-tree</code> flag to rustc:</span> <code>-Zunpretty=hir-tree</code>フラグをrustcに渡すことで、コードのHIR表現を表示できます。</span> </p><br><div data-lang=bash><div data-l="&gt; cargo rustc -- -Zunpretty=hir-tree"></div></div><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Out-of-band storage and the <code>Crate</code> type</span>アウトオブバンドストレージと<code>Crate</code>タイプ</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The top-level data-structure in the HIR is the <code>Crate</code> , which stores the contents of the crate currently being compiled (we only ever construct HIR for the current crate).</span> HIRのトップレベルのデータ構造は、現在コンパイルされているクレートの内容を格納する<code>Crate</code> （現在のクレートのHIRのみを構築しています）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Whereas in the AST the crate data structure basically just contains the root module, the HIR <code>Crate</code> structure contains a number of maps and other things that serve to organize the content of the crate for easier access.</span> ASTでは、クレートデータ構造には基本的にルートモジュールのみが含まれていますが、HIR <code>Crate</code>構造には、 <code>Crate</code>の内容を整理して簡単にアクセスできるようにするためのマップやその他の要素が数多く含まれています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, the contents of individual items (eg modules, functions, traits, impls, etc) in the HIR are not immediately accessible in the parents.</span>例えば、HIR内の個々の項目（モジュール、機能、特性、インプラントなど）の内容は、親からすぐにアクセスできません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So, for example, if there is a module item <code>foo</code> containing a function <code>bar()</code> :</span>したがって、たとえば、関数<code>bar()</code>を含むモジュール項目<code>foo</code>がある場合は、次のようになります。</span> </p><br><div data-lang=rust><div data-l="mod foo {"></div><div data-l="    fn bar() { }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">then in the HIR the representation of module <code>foo</code> (the <code>Mod</code> stuct) would only have the <b>`ItemId`</b> <code>I</code> of <code>bar()</code> .</span> HIRでは、モジュール<code>foo</code> （ <code>Mod</code> stuct）の<b>表現</b>は<code>bar()</code> <b>`ItemId`</b> <code>I</code>しか持たないでしょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To get the details of the function <code>bar()</code> , we would lookup <code>I</code> in the <code>items</code> map.</span>関数<code>bar()</code>の詳細を取得する<code>I</code>は、 <code>items</code>マップで<code>I</code>を検索します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">One nice result from this representation is that one can iterate over all items in the crate by iterating over the key-value pairs in these maps (without the need to trawl through the whole HIR).</span>この表現の良い結果の1つは、これらのマップ内のキーと値のペアを反復することによって、木枠内のすべてのアイテムを繰り返し処理できることです（HIR全体をトラックする必要はありません）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There are similar maps for things like trait items and impl items, as well as &quot;bodies&quot; (explained below).</span>特性項目やインプット項目、「ボディ」（以下で説明します）のようなものについても同様のマップがあります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The other reason to set up the representation this way is for better integration with incremental compilation.</span>このように表現を設定するもう1つの理由は、インクリメンタル・コンパイルとのより良い統合のためです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This way, if you gain access to an <code>&amp;hir::Item</code> (eg for the mod <code>foo</code> ), you do not immediately gain access to the contents of the function <code>bar()</code> .</span>こうすると、 <code>&amp;hir::Item</code> （mod <code>foo</code> ）にアクセスすると、すぐに関数<code>bar()</code>内容にアクセスすることはできません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Instead, you only gain access to the <b>id</b> for <code>bar()</code> , and you must invoke some function to lookup the contents of <code>bar()</code> given its id;</span>代わりに、あなただけの<b>ID</b>へのアクセスを得る<code>bar()</code> 、そしてあなたは、内容ルックアップするために、いくつかの機能を呼び出す必要があります<code>bar()</code>そのID与えられました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">this gives the compiler a chance to observe that you accessed the data for <code>bar()</code> , and then record the dependency.</span>これにより、コンパイラは<code>bar()</code>データにアクセスしたことを観察し、依存関係を記録することができます。</span> </p><br><p><a name=hir-id></a></p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Identifiers in the HIR</span> HIRの識別子</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Most of the code that has to deal with things in HIR tends not to carry around references into the HIR, but rather to carry around <i>identifier numbers</i> (or just &quot;ids&quot;).</span> HIRのものを扱わなければならないコードのほとんどは、HIRへの参照を持ち越すのではなく、むしろ<i>識別子番号</i> （または単に &quot;ids&quot;）を持ち歩く傾向があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Right now, you will find four sorts of identifiers in active use:</span>現在、4種類の識別子がアクティブに使用されています。</span> </p><br><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>DefId</code> , which primarily names &quot;definitions&quot; or top-level items.</span> <code>DefId</code> 。主に「定義」またはトップレベルの項目に名前を付けます。</span> </div><div data-b="  -"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can think of a <code>DefId</code> as being shorthand for a very explicit and complete path, like <code>std::collections::HashMap</code> .</span> <code>DefId</code>は、 <code>std::collections::HashMap</code>ような非常に明示的で完全なパスの省略形であると考えることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, these paths are able to name things that are not nameable in normal Rust (eg impls), and they also include extra information about the crate (such as its version number, as two versions of the same crate can co-exist).</span>しかし、これらのパスは、通常のRust（例えばimpls）では名前を付けられないものに名前を付けることができ、また、クレートに関する追加情報（同じクレートの2つのバージョンが共存できるバージョン番号など）も含みます。</span> </div><div data-b="  -"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A <code>DefId</code> really consists of two parts, a <code>CrateNum</code> (which identifies the crate) and a <code>DefIndex</code> (which indixes into a list of items that is maintained per crate).</span> <code>DefId</code>実際には<code>CrateNum</code> （クレートを識別する）と<code>DefIndex</code> （クレートごとに維持されるアイテムのリストに示される）の2つの部分で構成されます。</span> </div><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>HirId</code> , which combines the index of a particular item with an offset within that item.</span> <code>HirId</code>は、特定のアイテムのインデックスとそのアイテム内のオフセットを結合します。</span> </div><div data-b="  -"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">the key point of a <code>HirId</code> is that it is <i>relative</i> to some item (which is named via a <code>DefId</code> ).</span> <code>HirId</code>は、それが（ <code>DefId</code>を介して命名された）いくつかのアイテムに<i>関連</i>していることです。</span> </div><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>BodyId</code> , this is an absolute identifier that refers to a specific body (definition of a function or constant) in the crate.</span> <code>BodyId</code> 、これは、クレート内の特定のボディ（関数または定数の定義）を参照する絶対的な識別子です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It is currently effectively a &quot;newtype&#39;d&quot; <code>NodeId</code> .</span>これは現在、事実上「newtype&#39;d」 <code>NodeId</code>です。</span> </div><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>NodeId</code> , which is an absolute id that identifies a single node in the HIR tree.</span> <code>NodeId</code> ：HIRツリー内の単一のノードを識別する絶対的なIDです。</span> </div><div data-b="  -"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">While these are still in common use, <b>they are being slowly phased out</b> .</span>これらはまだ一般的に使用<b>されてい</b>ます<b>が、徐々に段階的に廃止されてい</b>ます。</span> </div><div data-b="  -"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Since they are absolute within the crate, adding a new node anywhere in the tree causes the <code>NodeId</code> s of all subsequent code in the crate to change.</span>ツリー内のどこにでも新しいノードを追加すると、クレート内のすべての後続コードの<code>NodeId</code>が変更されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is terrible for incremental compilation, as you can perhaps imagine.</span>あなたが想像することができるように、これは増分コンパイルにとってひどいことです。</span> </div><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The HIR Map</span> HIRマップ</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Most of the time when you are working with the HIR, you will do so via the <b>HIR Map</b> , accessible in the tcx via <code>tcx.hir</code> (and defined in the <code>hir::map</code> module).</span>ほとんどの場合、HIRで作業しているときは、tcx.hir経由で<code>tcx.hir</code>でアクセス可能な<b>HIRマップ</b>を使用します（ <code>hir::map</code>モジュールで定義されています）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The HIR map contains a number of methods to convert between IDs of various kinds and to lookup data associated with an HIR node.</span> HIRマップは、様々な種類のID間で変換し、HIRノードに関連するデータを検索するための多数の方法を含む。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, if you have a <code>DefId</code> , and you would like to convert it to a <code>NodeId</code> , you can use <code>tcx.hir.as_local_node_id(def_id)</code> .</span>たとえば、 <code>DefId</code>を持っていて<code>NodeId</code>に変換したい場合は、 <code>tcx.hir.as_local_node_id(def_id)</code>使用できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This returns an <code>Option&lt;NodeId&gt;</code> – this will be <code>None</code> if the def-id refers to something outside of the current crate (since then it has no HIR node), but otherwise returns <code>Some(n)</code> where <code>n</code> is the node-id of the definition.</span>これは、戻り<code>Option&lt;NodeId&gt;</code> -これはないであろう<code>None</code> DEF-idは（それは全くHIRノードを有していないので）、現在のクレートの外部の何かを指し、それ以外を返した場合<code>Some(n)</code>ここで<code>n</code>のノードIDであります定義。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Similarly, you can use <code>tcx.hir.find(n)</code> to lookup the node for a <code>NodeId</code> .</span>同様に、 <code>tcx.hir.find(n)</code>を使用して<code>NodeId</code>ノードをルックアップできます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This returns a <code>Option&lt;Node&lt;&#39;tcx&gt;&gt;</code> , where <code>Node</code> is an enum defined in the map;</span>これは<code>Option&lt;Node&lt;&#39;tcx&gt;&gt;</code>返します。ここで、 <code>Node</code>はマップで定義されたenumです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">by matching on this you can find out what sort of node the node-id referred to and also get a pointer to the data itself.</span>これを照合することでnode-idが参照しているノードの種類を知ることができ、データ自体へのポインタも取得できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Often, you know what sort of node <code>n</code> is – eg if you know that <code>n</code> must be some HIR expression, you can do <code>tcx.hir.expect_expr(n)</code> , which will extract and return the <code>&amp;hir::Expr</code> , panicking if <code>n</code> is not in fact an expression.</span>多くの場合、あなたはノードの種類を知っている<code>n</code>ある-あなたがいることを知っていれば例えば<code>n</code> 、いくつかのHIR式でなければなりません、あなたが行うことができます<code>tcx.hir.expect_expr(n)</code>抽出して返します、 <code>&amp;hir::Expr</code>た場合パニック、 <code>n</code>あるが実際に表現ではありません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Finally, you can use the HIR map to find the parents of nodes, via calls like <code>tcx.hir.get_parent_node(n)</code> .</span>最後に、HIRマップを使用して、 <code>tcx.hir.get_parent_node(n)</code>ような呼び出しによってノードの親を見つけることができます。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">HIR Bodies</span> HIR機関</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A <b>body</b> represents some kind of executable code, such as the body of a function/closure or the definition of a constant.</span> <b>本体は、</b>そのような機能/クロージャの本体又は定数の定義として、実行可能コードのいくつかの種類を表します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Bodies are associated with an <b>owner</b> , which is typically some kind of item (eg an <code>fn()</code> or <code>const</code> ), but could also be a closure expression (eg <code>|x, y| x + y</code> ).</span>ボディは、通常、ある種のアイテム（例えば<code>fn()</code>や<code>const</code> ）であるが、クロージャ式（例えば、 <code>|x, y| x + y</code> ）であってもよい、 <b>オーナー</b>に関連付けられている。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can use the HIR map to find the body associated with a given def-id ( <code>maybe_body_owned_by()</code> ) or to find the owner of a body ( <code>body_owner_def_id()</code> ).</span>指定したDEF-IDに関連付けられた本体を見つけるために、HIRマップを使用することができる（ <code>maybe_body_owned_by()</code>または身体の所有者を見つけるために（ <code>body_owner_def_id()</code></span> </p><script>_addload(function(){_setupIW('com');_csi('en','ja','hir.html');});</script>