<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180723_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=type-safety.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Type safety</span>タイプセーフティ</span> </h1><br><br><p><a id=c-newtype></a> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">## Newtypes provide static distinctions (C-NEWTYPE)</span> ##新しいタイプは静的な区別を提供します（C-NEWTYPE）</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Newtypes can statically distinguish between different interpretations of an underlying type.</span> Newtypeは、基礎となる型の異なる解釈を静的に区別できます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, a <code>f64</code> value might be used to represent a quantity in miles or in kilometers.</span>たとえば、 <code>f64</code>値を使用して数量をマイルまたはキロメートルで表すことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Using newtypes, we can keep track of the intended interpretation:</span> newtypesを使って、意図した解釈を追跡することができます：</span> </p><br><div data-lang=rust><div data-l="struct Miles(pub f64);"></div><div data-l="struct Kilometers(pub f64);"></div><div data-l=""></div><div data-l="impl Miles {"></div><div data-l="    fn to_kilometers(self) -&gt; Kilometers { /* ... */ }"></div><div data-l=}></div><div data-l="impl Kilometers {"></div><div data-l="    fn to_miles(self) -&gt; Miles { /* ... */ }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Once we have separated these two types, we can statically ensure that we do not confuse them.</span>これらの2つのタイプを分離したら、それらを混同しないように静的に確認できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, the function</span>例えば、関数</span> </p><br><div data-lang=rust><div data-l="fn are_we_there_yet(distance_travelled: Miles) -&gt; bool { /* ... */ }"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">cannot accidentally be called with a <code>Kilometers</code> value.</span>誤って<code>Kilometers</code>値で呼び出すことはできません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The compiler will remind us to perform the conversion, thus averting certain <a class=notranslate href="#4catastrophic bugs">catastrophic bugs</a> .</span>コンパイラは、変換を実行するように私たちに思い出させ、特定の<a class=notranslate href="#4catastrophic bugs">catastrophic bugs</a>を回避します。</span> </p><br> <a class=notranslate href=#1http://en.wikipedia.org/wiki/Mars_Climate_Orbiter>catastrophic bugs</a> <br> <br><p><a id=c-custom-type></a> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">## Arguments convey meaning through types, not <code>bool</code> or <code>Option</code> (C-CUSTOM-TYPE)</span> ##引数は、 <code>bool</code>や<code>Option</code> （C-CUSTOM-TYPE）ではなく、型を通して意味を伝えます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Prefer</span>好む</span> </p><br><div data-lang=rust><div data-l="let w = Widget::new(Small, Round)"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">over</span>以上</span> </p><br><div data-lang=rust><div data-l="let w = Widget::new(true, false)"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Core types like <code>bool</code> , <code>u8</code> and <code>Option</code> have many possible interpretations.</span> <code>bool</code> 、 <code>u8</code> 、 <code>Option</code>などのコアタイプには多くの解釈があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Use a deliberate type (whether enum, struct, or tuple) to convey interpretation and invariants.</span>解釈と不変量を伝えるには、意図的な型（enum、struct、またはtuple）を使用します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In the above example, it is not immediately clear what <code>true</code> and <code>false</code> are conveying without looking up the argument names, but <code>Small</code> and <code>Round</code> are more suggestive.</span>上記の例では、引数の名前を調べずに<code>true</code>と<code>false</code>が何を伝えているかがすぐには分かりませんが、 <code>Small</code>と<code>Round</code>はより示唆的です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Using custom types makes it easier to expand the options later on, for example by adding an <code>ExtraLarge</code> variant.</span>カスタムタイプを使用すると、 <code>ExtraLarge</code>バリアントを追加するなど、後でオプションを簡単に拡張することができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">See the newtype pattern ( <a class=notranslate href=#4C-NEWTYPE>C-NEWTYPE</a> ) for a no-cost way to wrap existing types with a distinguished name.</span>既存の型を識別名でラップする無償の方法については、newtypeパターン（ <a class=notranslate href=#4C-NEWTYPE>C-NEWTYPE</a> ）を参照してください。</span> </p><br> <a class=notranslate href=#1#c-newtype>C-NEWTYPE</a> <br> <br><p><a id=c-bitflag></a> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">## Types for a set of flags are <code>bitflags</code> , not enums (C-BITFLAG)</span> ##フラグセットの型は、 <code>bitflags</code>フラグ、enum（C-BITFLAG）ではなく、</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust supports <code>enum</code> types with explicitly specified discriminants:</span> Rustは明示的に指定された判別式を持つ<code>enum</code>型をサポートしています：</span> </p><br><div data-lang=rust><div data-l="enum Color {"></div><div data-l="    Red = 0xff0000,"></div><div data-l="    Green = 0x00ff00,"></div><div data-l="    Blue = 0x0000ff,"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Custom discriminants are useful when an <code>enum</code> type needs to be serialized to an integer value compatibly with some other system/language.</span>カスタム判別式は、 <code>enum</code>型を他のシステム/言語と互換性のある整数値にシリアル化する必要がある場合に便利です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">They support &quot;typesafe&quot; APIs: by taking a <code>Color</code> , rather than an integer, a function is guaranteed to get well-formed inputs, even if it later views those inputs as integers.</span>彼らは「型保証」APIをサポートしています。整数ではなく<code>Color</code>をとることによって、後で整数として整数を表示しても、関数は正しい形式の入力を得ることが保証されます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">An <code>enum</code> allows an API to request exactly one choice from among many.</span> <code>enum</code>使用すると、APIは多数の中から1つの選択肢だけを要求できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Sometimes an API&#39;s input is instead the presence or absence of a set of flags.</span>時には、APIの入力は、フラグのセットの有無です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In C code, this is often done by having each flag correspond to a particular bit, allowing a single integer to represent, say, 32 or 64 flags.</span> Cコードでは、これは、各フラグを特定のビットに対応させることによって行われることが多く、単一の整数、例えば32または64フラグを表すことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust&#39;s <a class=notranslate href="#4`bitflags`">`bitflags`</a> crate provides a typesafe representation of this pattern.</span> Rustの<a class=notranslate href="#4`bitflags`">`bitflags`</a>はこのパターンの型保証表現を提供します。</span> </p><br> <a class=notranslate href=#1https://github.com/rust-lang-nursery/bitflags>`bitflags`</a> <br> <div data-lang=rust><div data-l=#[macro_use]></div><div data-l="extern crate bitflags;"></div><div data-l=""></div><div data-l="bitflags! {"></div><div data-l="    struct Flags: u32 {"></div><div data-l="        const FLAG_A = 0b00000001;"></div><div data-l="        const FLAG_B = 0b00000010;"></div><div data-l="        const FLAG_C = 0b00000100;"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="fn f(settings: Flags) {"></div><div data-l="    if settings.contains(Flags::FLAG_A) {"></div><div data-l="        println!(&quot;doing thing A&quot;);"></div><div data-l="    }"></div><div data-l="    if settings.contains(Flags::FLAG_B) {"></div><div data-l="        println!(&quot;doing thing B&quot;);"></div><div data-l="    }"></div><div data-l="    if settings.contains(Flags::FLAG_C) {"></div><div data-l="        println!(&quot;doing thing C&quot;);"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    f(Flags::FLAG_A | Flags::FLAG_C);"></div><div data-l=}></div></div><br><br><p><a id=c-builder></a> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">## Builders enable construction of complex values (C-BUILDER)</span> ##ビルダーは複雑な値の構築を可能にする（C-BUILDER）</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Some data structures are complicated to construct, due to their construction needing:</span>いくつかのデータ構造は、構築が必要なため、構築が複雑です。</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">a large number of inputs</span>多数の入力</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">compound data (eg slices)</span>複合データ（例えばスライス）</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">optional configuration data</span>オプションの構成データ</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">choice between several flavors</span>いくつかの味の間の選択</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">which can easily lead to a large number of distinct constructors with many arguments each.</span>それぞれ多数の引数を持つ多数の異なるコンストラクタに簡単につながる可能性があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If <code>T</code> is such a data structure, consider introducing a <code>T</code> <s>builder</s> :</span> <code>T</code>がそのようなデータ構造である場合は、 <code>T</code> <s>ビルダーの</s>導入を検討してください。</span> </p><br><div data-b=1.> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Introduce a separate data type <code>TBuilder</code> for incrementally configuring a <code>T</code> value.</span> <code>T</code>値を段階的に構成するための別個のデータ型<code>TBuilder</code>を導入する。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When possible, choose a better name: eg <a class=notranslate href="#4`Command`">`Command`</a> is the builder for a <a class=notranslate href="#4child process">child process</a> , <a class=notranslate href="#4`Url`">`Url`</a> can be created from a <a class=notranslate href="#4`ParseOptions`">`ParseOptions`</a> .</span>可能な場合は、より良い名前を選択します。例えば<a class=notranslate href="#4`Command`">`Command`</a>のためのビルダーである<a class=notranslate href="#4child process">child process</a> 、 <a class=notranslate href="#4`Url`">`Url`</a>から作成することができます<a class=notranslate href="#4`ParseOptions`">`ParseOptions`</a> 。</span> </div><div data-b=2.> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The builder constructor should take as parameters only the data <s>required</s> to make a <code>T</code> .</span>ビルダコンストラクタは、 <code>T</code>を作るために<s>必要な</s>データだけをパラメータとして取る必要があります。</span> </div><div data-b=3.> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The builder should offer a suite of convenient methods for configuration, including setting up compound inputs (like slices) incrementally.</span>ビルダーは、複雑な入力（スライスなど）を徐々に設定するなど、便利な設定方法を提供する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These methods should return <code>self</code> to allow chaining.</span>これらのメソッドは連鎖を可能にするために<code>self</code>を返すべきです。</span> </div><div data-b=4.> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The builder should provide one or more &quot; <s>terminal</s> &quot; methods for actually building a <code>T</code> .</span>ビルダーは、実際に<code>T</code>構築するための1つ以上の「 <s>端末</s> 」メソッドを提供する必要があります。</span> </div><br> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a class=notranslate href=#1https://doc.rust-lang.org/std/process/struct.Command.html>`Command`</a> <a class=notranslate href=#1https://doc.rust-lang.org/std/process/struct.Child.html>child process</a> <a class=notranslate href=#1https://docs.rs/url/1.4.0/url/struct.Url.html>`Url`</a> <a class=notranslate href=#1https://docs.rs/url/1.4.0/url/struct.ParseOptions.html>`ParseOptions`</a></span> <a class=notranslate href=#1https://doc.rust-lang.org/std/process/struct.Command.html>`Command`</a> <a class=notranslate href=#1https://doc.rust-lang.org/std/process/struct.Child.html>child process</a> <a class=notranslate href=#1https://docs.rs/url/1.4.0/url/struct.Url.html>`Url`</a> <a class=notranslate href=#1https://docs.rs/url/1.4.0/url/struct.ParseOptions.html>`ParseOptions`</a></span> <br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The builder pattern is especially appropriate when building a <code>T</code> involves side effects, such as spawning a task or launching a process.</span>ビルダーパターンは、 <code>T</code>を構築する際に、タスクの生成やプロセスの起動などの副作用がある場合に特に適しています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In Rust, there are two variants of the builder pattern, differing in the treatment of ownership, as described below.</span> Rustには、以下に説明するように、所有者の扱いが異なる建築パターンの2つのバリアントがあります。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Non-consuming builders (preferred)</span>非消費ビルダー（推奨）</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In some cases, constructing the final <code>T</code> does not require the builder itself to be consumed.</span>場合によっては、最終<code>T</code>構築する際に、ビルダー自体を消費する必要はありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The following variant on <a class=notranslate href="#4`std::process::Command`">`std::process::Command`</a> is one example:</span> <a class=notranslate href="#4`std::process::Command`">`std::process::Command`</a>の次の亜種が一例です：</span> </p><br> <a class=notranslate href=#1https://doc.rust-lang.org/std/process/struct.Command.html>`std::process::Command`</a> <br> <div data-lang=rust><div data-l="#// NOTE: the actual Command API does not use owned Strings;"></div><div data-l="#// this is a simplified version."></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">NOTE: the actual Command API does not use owned Strings;</span>注：実際のCommand APIは所有されているStringを使用しません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">this is a simplified version.</span>これは単純化されたバージョンです。</span> </div><div data-l=""></div><div data-l="pub struct Command {"></div><div data-l="    program: String,"></div><div data-l="    args: Vec&lt;String&gt;,"></div><div data-l="    cwd: Option&lt;String&gt;,"></div><div data-l="#    // etc"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">etc</span>等</span> </div><div data-l=}></div><div data-l=""></div><div data-l="impl Command {"></div><div data-l="    pub fn new(program: String) -&gt; Command {"></div><div data-l="        Command {"></div><div data-l="            program: program,"></div><div data-l="            args: Vec::new(),"></div><div data-l="            cwd: None,"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=""></div><div data-l="#//    /// Add an argument to pass to the program."></div><div data-l="    /// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Add an argument to pass to the program.</span>プログラムに渡す引数を追加します。</span> </div><div data-l="    pub fn arg(&amp;mut self, arg: String) -&gt; &amp;mut Command {"></div><div data-l="        self.args.push(arg);"></div><div data-l="        self"></div><div data-l="    }"></div><div data-l=""></div><div data-l="#//    /// Add multiple arguments to pass to the program."></div><div data-l="    /// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Add multiple arguments to pass to the program.</span>複数の引数を追加してプログラムに渡します。</span> </div><div data-l="    pub fn args(&amp;mut self, args: &amp;[String]) -&gt; &amp;mut Command {"></div><div data-l="        self.args.extend_from_slice(args);"></div><div data-l="        self"></div><div data-l="    }"></div><div data-l=""></div><div data-l="#//    /// Set the working directory for the child process."></div><div data-l="    /// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Set the working directory for the child process.</span>子プロセスの作業ディレクトリを設定します。</span> </div><div data-l="    pub fn current_dir(&amp;mut self, dir: String) -&gt; &amp;mut Command {"></div><div data-l="        self.cwd = Some(dir);"></div><div data-l="        self"></div><div data-l="    }"></div><div data-l=""></div><div data-l="#//    /// Executes the command as a child process, which is returned."></div><div data-l="    /// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Executes the command as a child process, which is returned.</span>子プロセスとしてコマンドを実行し、それが返されます。</span> </div><div data-l="    pub fn spawn(&amp;self) -&gt; io::Result&lt;Child&gt; {"></div><div data-l="        /* ... */"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that the <code>spawn</code> method, which actually uses the builder configuration to spawn a process, takes the builder by shared reference.</span>実際にビルダー構成を使用してプロセスを生成する<code>spawn</code>メソッドは、共有参照によってビルダーを取得することに注意してください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is possible because spawning the process does not require ownership of the configuration data.</span>これは、プロセスの起動に構成データの所有権が必要ないため可能です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because the terminal <code>spawn</code> method only needs a reference, the configuration methods take and return a mutable borrow of <code>self</code> .</span>端末の<code>spawn</code>メソッドは参照のみを必要と<code>spawn</code>ため、設定メソッドは<code>self</code>可変的な借用を受け取り返します。</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The benefit</span>利益</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">By using borrows throughout, <code>Command</code> can be used conveniently for both one-liner and more complex constructions:</span>全体を通して借用を使用することにより、 <code>Command</code>は1ライナーとより複雑な構成の両方に便利に使用できます。</span> </p><br><div data-lang=rust><div data-l="#// One-liners"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">One-liners</span>ワンライナー</span> </div><div data-l=Command::new(&quot;/bin/cat&quot;).arg(&quot;file.txt&quot;).spawn();></div><div data-l=""></div><div data-l="#// Complex configuration"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Complex configuration</span>複雑な構成</span> </div><div data-l="let mut cmd = Command::new(&quot;/bin/ls&quot;);"></div><div data-l=cmd.arg(&quot;.&quot;);></div><div data-l="if size_sorted {"></div><div data-l="    cmd.arg(&quot;-S&quot;);"></div><div data-l=}></div><div data-l=cmd.spawn();></div></div><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Consuming builders</span>消費者ビルダー</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Sometimes builders must transfer ownership when constructing the final type <code>T</code> , meaning that the terminal methods must take <code>self</code> rather than <code>&amp;self</code> .</span>ビルダーは最終的な型<code>T</code>構築するときに所有権を移譲する必要があります。つまり、端末のメソッドは<code>&amp;self</code>ではなく<code>self</code>とる必要があります。</span> </p><br><div data-lang=rust><div data-l="impl TaskBuilder {"></div><div data-l="#//    /// Name the task-to-be."></div><div data-l="    /// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Name the task-to-be.</span>タスクの名前を指定します。</span> </div><div data-l="    pub fn named(mut self, name: String) -&gt; TaskBuilder {"></div><div data-l="        self.name = Some(name);"></div><div data-l="        self"></div><div data-l="    }"></div><div data-l=""></div><div data-l="#//    /// Redirect task-local stdout."></div><div data-l="    /// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Redirect task-local stdout.</span>タスクローカルstdoutをリダイレクトします。</span> </div><div data-l="    pub fn stdout(mut self, stdout: Box&lt;io::Write + Send&gt;) -&gt; TaskBuilder {"></div><div data-l="        self.stdout = Some(stdout);"></div><div data-l="        self"></div><div data-l="    }"></div><div data-l=""></div><div data-l="#//    /// Creates and executes a new child task."></div><div data-l="    /// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Creates and executes a new child task.</span>新しい子タスクを作成して実行します。</span> </div><div data-l="    pub fn spawn&lt;F&gt;(self, f: F) where F: FnOnce() + Send {"></div><div data-l="        /* ... */"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here, the <code>stdout</code> configuration involves passing ownership of an <code>io::Write</code> , which must be transferred to the task upon construction (in <code>spawn</code> ).</span>ここでは、 <code>stdout</code>設定には<code>io::Write</code>所有権が渡されますが、これは構築時に（ <code>spawn</code> ）タスクに転送する必要があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When the terminal methods of the builder require ownership, there is a basic tradeoff:</span>ビルダーの端末メソッドに所有権が必要な場合、基本的なトレードオフがあります。</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If the other builder methods take/return a mutable borrow, the complex configuration case will work well, but one-liner configuration becomes impossible.</span>他のビルダーメソッドが変更可能な借用を受け入れる/返す場合、複雑な構成の場合はうまくいくが、1ライナーの構成は不可能になる。</span> </div><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If the other builder methods take/return an owned <code>self</code> , one-liners continue to work well but complex configuration is less convenient.</span>他のビルダーメソッドが所有する<code>self</code>取得/返却する場合、1ライナーは引き続きうまく機能しますが、複雑な設定はあまり便利ではありません。</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Under the rubric of making easy things easy and hard things possible, all builder methods for a consuming builder should take and returned an owned <code>self</code> .</span>簡単なものを簡単に、難しいものにするというルーブリックの下で、消費するビルダーのためのすべてのビルダーメソッドは所有している<code>self</code>返すべきです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then client code works as follows:</span>クライアントコードは次のように動作します。</span> </p><br><div data-lang=rust><div data-l="#// One-liners"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">One-liners</span>ワンライナー</span> </div><div data-l="TaskBuilder::new(&quot;my_task&quot;).spawn(|| { /* ... */ });"></div><div data-l=""></div><div data-l="#// Complex configuration"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Complex configuration</span>複雑な構成</span> </div><div data-l="let mut task = TaskBuilder::new();"></div><div data-l="#//task = task.named(&quot;my_task_2&quot;); // must re-assign to retain ownership"></div><div data-l="task = task.named(&quot;my_task_2&quot;); // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">must re-assign to retain ownership</span>所有権を保持するために再割り当てする必要があります</span> </div><div data-l="if reroute {"></div><div data-l="    task = task.stdout(mywriter);"></div><div data-l=}></div><div data-l="task.spawn(|| { /* ... */ });"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">One-liners work as before, because ownership is threaded through each of the builder methods until being consumed by <code>spawn</code> .</span> 1ライナーは以前と同じように動作し<code>spawn</code> 。なぜなら、所有権は、 <code>spawn</code>によって消費されるまで、各ビルダーメソッドにスレッド化されているからです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Complex configuration, however, is more verbose: it requires re-assigning the builder at each step.</span>ただし、複雑な構成はより冗長です。ビルダーを各ステップで再割り当てする必要があります。</span> </p><script>_addload(function(){_setupIW('com');_csi('en','ja','type-safety.html');});</script>