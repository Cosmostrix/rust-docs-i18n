<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180723_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=macros.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Macros</span>マクロ</span> </h1><br><br><p><a id=c-evocative></a> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">## Input syntax is evocative of the output (C-EVOCATIVE)</span> ##入力構文は出力（C-EVOCATIVE）を喚起します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust macros let you dream up practically whatever input syntax you want.</span>錆のマクロは、あなたが望むどんな入力構文であっても実質的に夢を見ることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Aim to keep input syntax familiar and cohesive with the rest of your users&#39; code by mirroring existing Rust syntax where possible.</span>可能であれば、既存のRust構文をミラーリングすることで、入力構文をユーザーのコードの他の部分とよく似合うようにしてください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Pay attention to the choice and placement of keywords and punctuation.</span>キーワードと句読点の選択と配置に注意してください。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A good guide is to use syntax, especially keywords and punctuation, that is similar to what will be produced in the output of the macro.</span>マクロの出力で生成される構文に似た構文、特にキーワードと句読点を使用することをお勧めします。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example if your macro declares a struct with a particular name given in the input, preface the name with the keyword <code>struct</code> to signal to readers that a struct is being declared with the given name.</span>例えば、マクロが入力に与えられた特定の名前を持つ構造体を宣言している場合は、構造体が指定された名前で宣言されていることを読者に知らせるためにキーワード<code>struct</code>を名前に付けます。</span> </p><br><div data-lang=rust><div data-l="#// Prefer this..."></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Prefer this...</span>これを好む...</span> </div><div data-l="bitflags! {"></div><div data-l="    struct S: u32 { /* ... */ }"></div><div data-l=}></div><div data-l=""></div><div data-l="#// ...over no keyword..."></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">...over no keyword...</span> ...キーワードなし...</span> </div><div data-l="bitflags! {"></div><div data-l="    S: u32 { /* ... */ }"></div><div data-l=}></div><div data-l=""></div><div data-l="#// ...or some ad-hoc word."></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">...or some ad-hoc word.</span> ...またはいくつかの特別な言葉。</span> </div><div data-l="bitflags! {"></div><div data-l="    flags S: u32 { /* ... */ }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Another example is semicolons vs commas.</span>もう1つの例はセミコロンとコンマです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Constants in Rust are followed by semicolons so if your macro declares a chain of constants, they should likely be followed by semicolons even if the syntax is otherwise slightly different from Rust&#39;s.</span> Rustの定数の後ろにセミコロンが続くので、マクロが定数の連鎖を宣言している場合は、構文がRustのものと若干異なる場合でもセミコロンが続かなければなりません。</span> </p><br><div data-lang=rust><div data-l="#// Ordinary constants use semicolons."></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Ordinary constants use semicolons.</span>通常の定数はセミコロンを使用します。</span> </div><div data-l="const A: u32 = 0b000001;"></div><div data-l="const B: u32 = 0b000010;"></div><div data-l=""></div><div data-l="#// So prefer this..."></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So prefer this...</span>だからこれを好む...</span> </div><div data-l="bitflags! {"></div><div data-l="    struct S: u32 {"></div><div data-l="        const C = 0b000100;"></div><div data-l="        const D = 0b001000;"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="#// ...over this."></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">...over this.</span> ...これ以上。</span> </div><div data-l="bitflags! {"></div><div data-l="    struct S: u32 {"></div><div data-l="        const E = 0b010000,"></div><div data-l="        const F = 0b100000,"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Macros are so diverse that these specific examples won&#39;t be relevant, but think about how to apply the same principles to your situation.</span>マクロは非常に多様であり、これらの具体的な例は関連しませんが、あなたの状況に同じ原則を適用する方法を考えてください。</span> </p><br><br><p><a id=c-macro-attr></a> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">## Item macros compose well with attributes (C-MACRO-ATTR)</span> ##アイテムマクロは属性（C-MACRO-ATTR）でうまく構成されます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Macros that produce more than one output item should support adding attributes to any one of those items.</span>複数の出力項目を生成するマクロは、それらの項目のいずれかに属性を追加することをサポートする必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">One common use case would be putting individual items behind a cfg.</span> 1つの一般的な使用例は、個々の項目をcfgの後ろに置くことです。</span> </p><br><div data-lang=rust><div data-l="bitflags! {"></div><div data-l="    struct Flags: u8 {"></div><div data-l="        #[cfg(windows)]"></div><div data-l="        const ControlCenter = 0b001;"></div><div data-l="        #[cfg(unix)]"></div><div data-l="        const Terminal = 0b010;"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Macros that produce a struct or enum as output should support attributes so that the output can be used with derive.</span>出力として構造体または列挙型を生成するマクロは、出力を派生させて使用できるように属性をサポートする必要があります。</span> </p><br><div data-lang=rust><div data-l="bitflags! {"></div><div data-l="    #[derive(Default, Serialize)]"></div><div data-l="    struct Flags: u8 {"></div><div data-l="        const ControlCenter = 0b001;"></div><div data-l="        const Terminal = 0b010;"></div><div data-l="    }"></div><div data-l=}></div></div><br><br><p><a id=c-anywhere></a> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">## Item macros work anywhere that items are allowed (C-ANYWHERE)</span> ##アイテムマクロは、アイテムが許可されている場所であればどこでも動作します（C-ANYWHERE）</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust allows items to be placed at the module level or within a tighter scope like a function.</span>錆は、アイテムをモジュールレベルに配置することも、機能のように狭い範囲に配置することもできます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Item macros should work equally well as ordinary items in all of these places.</span>アイテムマクロは、これらすべての場所の通常のアイテムと同じように機能するはずです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The test suite should include invocations of the macro in at least the module scope and function scope.</span>テストスイートには、少なくともモジュールスコープと関数スコープにマクロの呼び出しを含める必要があります。</span> </p><br><div data-lang=rust><div data-l=#[cfg(test)]></div><div data-l="mod tests {"></div><div data-l="    test_your_macro_in_a!(module);"></div><div data-l=""></div><div data-l="    #[test]"></div><div data-l="    fn anywhere() {"></div><div data-l="        test_your_macro_in_a!(function);"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As a simple example of how things can go wrong, this macro works great in a module scope but fails in a function scope.</span>どのように問題が起こるかの簡単な例として、このマクロはモジュールスコープでは機能しますが、関数スコープでは機能しません。</span> </p><br><div data-lang=rust><div data-l="macro_rules! broken {"></div><div data-l="    ($m:ident :: $t:ident) =&gt; {"></div><div data-l="        pub struct $t;"></div><div data-l="        pub mod $m {"></div><div data-l="            pub use super::$t;"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="#//broken!(m::T); // okay, expands to T and m::T"></div><div data-l="broken!(m::T); // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">okay, expands to T and m::T</span>大丈夫、Tとm :: Tに展開</span> </div><div data-l=""></div><div data-l="fn g() {"></div><div data-l="#//    broken!(m::U); // fails to compile, super::U refers to the containing module not g"></div><div data-l="    broken!(m::U); // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">fails to compile, super::U refers to the containing module not g</span>コンパイルに失敗した場合、super :: Uはgを含まないモジュールを参照します。</span> </div><div data-l=}></div></div><br><br><p><a id=c-macro-vis></a> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">## Item macros support visibility specifiers (C-MACRO-VIS)</span> ##項目マクロは可視性指定子をサポートします（C-MACRO-VIS）</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Follow Rust syntax for visibility of items produced by a macro.</span>マクロによって生成された項目の可視性は、Rust構文に従います。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Private by default, public if <code>pub</code> is specified.</span> <code>pub</code>が指定されている場合は、デフォルトで非公開です。</span> </p><br><div data-lang=rust><div data-l="bitflags! {"></div><div data-l="    struct PrivateFlags: u8 {"></div><div data-l="        const A = 0b0001;"></div><div data-l="        const B = 0b0010;"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="bitflags! {"></div><div data-l="    pub struct PublicFlags: u8 {"></div><div data-l="        const C = 0b0100;"></div><div data-l="        const D = 0b1000;"></div><div data-l="    }"></div><div data-l=}></div></div><br><br><p><a id=c-macro-ty></a> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">## Type fragments are flexible (C-MACRO-TY)</span> ##タイプフラグメントは柔軟性があります（C-MACRO-TY）</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If your macro accepts a type fragment like <code>$t:ty</code> in the input, it should be usable with all of the following:</span>あなたのマクロが<code>$t:ty</code>ような型の断片を入力に受け入れるならば、それは以下のすべてで使えるはずです：</span> </p><br><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Primitives: <code>u8</code> , <code>&amp;str</code></span>プリミティブ： <code>u8</code> 、 <code>&amp;str</code></span> </div><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Relative paths: <code>m::Data</code></span>相対パス： <code>m::Data</code></span> </div><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Absolute paths: <code>::base::Data</code></span>絶対パス<code>::base::Data</code></span> </div><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Upward relative paths: <code>super::Data</code></span>上向きの相対パス： <code>super::Data</code></span> </div><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Generics: <code>Vec&lt;String&gt;</code></span>ジェネリックス： <code>Vec&lt;String&gt;</code></span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As a simple example of how things can go wrong, this macro works great with primitives and absolute paths but fails with relative paths.</span>どのように問題が起こる可能性があるかの簡単な例として、このマクロはプリミティブと絶対パスではうまく動作しますが、相対パスでは失敗します。</span> </p><br><div data-lang=rust><div data-l="macro_rules! broken {"></div><div data-l="    ($m:ident =&gt; $t:ty) =&gt; {"></div><div data-l="        pub mod $m {"></div><div data-l="            pub struct Wrapper($t);"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="#//broken!(a =&gt; u8); // okay"></div><div data-l="broken!(a =&gt; u8); // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">okay</span>はい</span> </div><div data-l=""></div><div data-l="#//broken!(b =&gt; ::std::marker::PhantomData&lt;()&gt;); // okay"></div><div data-l="broken!(b =&gt; ::std::marker::PhantomData&lt;()&gt;); // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">okay</span>はい</span> </div><div data-l=""></div><div data-l="struct S;"></div><div data-l="#//broken!(c =&gt; S); // fails to compile"></div><div data-l="broken!(c =&gt; S); // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">fails to compile</span>コンパイルに失敗する</span> </div></div><script>_addload(function(){_setupIW('com');_csi('en','ja','macros.html');});</script>