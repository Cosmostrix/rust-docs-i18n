<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180723_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=predictability.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Predictability</span>予測可能性</span> </h1><br><br><p><a id=c-smart-ptr></a> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">## Smart pointers do not add inherent methods (C-SMART-PTR)</span> ##スマートポインタは、固有のメソッド（C-SMART-PTR）を追加しません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, this is why the <a class=notranslate href="#4`Box::into_raw`">`Box::into_raw`</a> function is defined the way it is.</span>例えば、これは<a class=notranslate href="#4`Box::into_raw`">`Box::into_raw`</a>関数が定義されている理由です。</span> </p><br> <a class=notranslate href=#1https://doc.rust-lang.org/std/boxed/struct.Box.html#method.into_raw>`Box::into_raw`</a> <br> <div data-lang=rust><div data-l="impl&lt;T&gt; Box&lt;T&gt; where T: ?Sized {"></div><div data-l="    fn into_raw(b: Box&lt;T&gt;) -&gt; *mut T { /* ... */ }"></div><div data-l=}></div><div data-l=""></div><div data-l="let boxed_str: Box&lt;str&gt; = /* ... */;"></div><div data-l="let ptr = Box::into_raw(boxed_str);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If this were defined as an inherent method instead, it would be confusing at the call site whether the method being called is a method on <code>Box&lt;T&gt;</code> or a method on <code>T</code> .</span>これは代わりに固有のメソッドとして定義されている場合、それが呼び出されるメソッドが上のメソッドであるかどうかを呼び出しサイトで混乱するでしょう<code>Box&lt;T&gt;</code>または上のメソッド<code>T</code> 。</span> </p><br><div data-lang=rust><div data-l="impl&lt;T&gt; Box&lt;T&gt; where T: ?Sized {"></div><div data-l="#    // Do not do this."></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Do not do this.</span>こんなことしないで。</span> </div><div data-l="    fn into_raw(self) -&gt; *mut T { /* ... */ }"></div><div data-l=}></div><div data-l=""></div><div data-l="let boxed_str: Box&lt;str&gt; = /* ... */;"></div><div data-l=""></div><div data-l="#// This is a method on str accessed through the smart pointer Deref impl."></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is a method on str accessed through the smart pointer Deref impl.</span>これはスマートポインタDeref implを通してアクセスされるstrのメソッドです。</span> </div><div data-l=boxed_str.chars()></div><div data-l=""></div><div data-l="#// This is a method on Box&lt;str&gt;...?"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is a method on Box</span>これはBoxのメソッドです</span> <str> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">...?</span> ...？</span> </div><div data-l=boxed_str.into_raw()></div></div><br><br><p><a id=c-conv-specific></a> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">## Conversions live on the most specific type involved (C-CONV-SPECIFIC)</span> ##コンバージョンは、関与する最も特定のタイプに存在します（C-CONV-SPECIFIC）</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When in doubt, prefer <code>to_</code> / <code>as_</code> / <code>into_</code> to <code>from_</code> , because they are more ergonomic to use (and can be chained with other methods).</span> <code>to_</code>場合は、使用する人間工学的であり（他の方法と連鎖することもできる）、 <code>to_</code> / <code>as_</code> / <code>into_</code>から<code>into_</code>を<code>from_</code> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For many conversions between two types, one of the types is clearly more &quot;specific&quot;: it provides some additional invariant or interpretation that is not present in the other type.</span> 2つのタイプ間の多くの変換では、タイプの1つが明らかに「特定」であり、他のタイプには存在しないいくつかの追加の不変または解釈を提供します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, <a class=notranslate href="#4`str`">`str`</a> is more specific than <code>&amp;[u8]</code> , since it is a UTF-8 encoded sequence of bytes.</span>たとえば、 <a class=notranslate href="#4`str`">`str`</a>はUTF-8でエンコードされた一連のバイトであるため、 <code>&amp;[u8]</code>よりも具体的です。</span> </p><br> <a class=notranslate href=#1https://doc.rust-lang.org/std/primitive.str.html>`str`</a> <br> <p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Conversions should live with the more specific of the involved types.</span>コンバージョンは関連するタイプのより具体的なもので生きていなければなりません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Thus, <code>str</code> provides both the <a class=notranslate href="#4`as_bytes`">`as_bytes`</a> method and the <a class=notranslate href="#4`from_utf8`">`from_utf8`</a> constructor for converting to and from <code>&amp;[u8]</code> values.</span>したがって、 <code>str</code>は、 <code>&amp;[u8]</code>値との変換のための<a class=notranslate href="#4`as_bytes`">`as_bytes`</a>メソッドと<a class=notranslate href="#4`from_utf8`">`from_utf8`</a>コンストラクタの両方を提供します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Besides being intuitive, this convention avoids polluting concrete types like <code>&amp;[u8]</code> with endless conversion methods.</span>直観的であるだけでなく、このコンベンションでは、無限の変換方法で<code>&amp;[u8]</code>ような具体的な型を汚染するのを<code>&amp;[u8]</code>ます。</span> </p><br> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a class=notranslate href=#1https://doc.rust-lang.org/std/primitive.str.html#method.as_bytes>`as_bytes`</a> <a class=notranslate href=#1https://doc.rust-lang.org/std/str/fn.from_utf8.html>`from_utf8`</a></span> <a class=notranslate href=#1https://doc.rust-lang.org/std/primitive.str.html#method.as_bytes>`as_bytes`</a> <a class=notranslate href=#1https://doc.rust-lang.org/std/str/fn.from_utf8.html>`from_utf8`</a></span> <br><br><p><a id=c-method></a> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">## Functions with a clear receiver are methods (C-METHOD)</span> ##明確なレシーバを持つ関数はメソッド（C-METHOD）です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Prefer</span>好む</span> </p><br><div data-lang=rust><div data-l="impl Foo {"></div><div data-l="    pub fn frob(&amp;self, w: widget) { /* ... */ }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">over</span>以上</span> </p><br><div data-lang=rust><div data-l="pub fn frob(foo: &amp;Foo, w: widget) { /* ... */ }"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">for any operation that is clearly associated with a particular type.</span>特定のタイプに明確に関連付けられている操作については、</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Methods have numerous advantages over functions:</span>メソッドには、関数に比べて多くの利点があります。</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">They do not need to be imported or qualified to be used: all you need is a value of the appropriate type.</span>インポートする必要はなく、使用する資格があります。必要なのは適切なタイプの値だけです。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Their invocation performs autoborrowing (including mutable borrows).</span>彼らの呼び出しは自動練習（変更可能な借用を含む）を実行します。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">They make it easy to answer the question &quot;what can I do with a value of type <code>T</code> &quot; (especially when using rustdoc).</span>彼らは &quot; <code>T</code>型の値で何ができるか&quot;という質問に簡単に答えることができます（特にrustdocを使用する場合）。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">They provide <code>self</code> notation, which is more concise and often more clearly conveys ownership distinctions.</span>彼らは<code>self</code>表記法を提供しており、これはより簡潔であり、所有権の区別をより明確に伝えることが多い。</span> </div><br><br><p><a id=c-no-out></a> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">## Functions do not take out-parameters (C-NO-OUT)</span> ##機能はパラメータを取り出さない（C-NO-OUT）</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Prefer</span>好む</span> </p><br><div data-lang=rust><div data-l="fn foo() -&gt; (Bar, Bar)"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">over</span>以上</span> </p><br><div data-lang=rust><div data-l="fn foo(output: &amp;mut Bar) -&gt; Bar"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">for returning multiple <code>Bar</code> values.</span>複数の<code>Bar</code>値を返す</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Compound return types like tuples and structs are efficiently compiled and do not require heap allocation.</span>タプルや構造体などの複合戻り値の型は効率的にコンパイルされ、ヒープ割り当ては不要です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If a function needs to return multiple values, it should do so via one of these types.</span>関数が複数の値を返す必要がある場合は、これらの型のいずれかを使用して値を返す必要があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The primary exception: sometimes a function is meant to modify data that the caller already owns, for example to re-use a buffer:</span>主な例外：関数は、バッファを再利用するなど、呼び出し元がすでに所有しているデータを変更することがあります。</span> </p><br><div data-lang=rust><div data-l="fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; io::Result&lt;usize&gt;"></div></div><br><br><p><a id=c-overload></a> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">## Operator overloads are unsurprising (C-OVERLOAD)</span> ##演算子のオーバーロードは驚くべきものではありません（C-OVERLOAD）</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Operators with built in syntax ( <code>*</code> , <code>|</code> , and so on) can be provided for a type by implementing the traits in <a class=notranslate href="#4`std::ops`">`std::ops`</a> .</span> <a class=notranslate href="#4`std::ops`">`std::ops`</a>特性を実装することで、構文に組み込みの演算子（ <code>*</code> 、 <code>|</code>など）を型に対して提供することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These operators come with strong expectations: implement <code>Mul</code> only for an operation that bears some resemblance to multiplication (and shares the expected properties, eg associativity), and so on for the other traits.</span>これらの演算子は、強い期待が付属しています：実装<code>Mul</code>乗算のみ（および株式期待される特性、例えば結合性）にいくつか似ている操作のために、というように、他の形質について。</span> </p><br> <a class=notranslate href=#1https://doc.rust-lang.org/std/ops/index.html#traits>`std::ops`</a> <br> <br><p><a id=c-deref></a> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">## Only smart pointers implement <code>Deref</code> and <code>DerefMut</code> (C-DEREF)</span> ##だけがスマートポインタ実装<code>Deref</code>と<code>DerefMut</code> （C-DEREF）</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Deref</code> traits are used implicitly by the compiler in many circumstances, and interact with method resolution.</span> <code>Deref</code>特性は、多くの状況でコンパイラによって暗黙的に使用され、メソッド解決と相互作用します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The relevant rules are designed specifically to accommodate smart pointers, and so the traits should be used only for that purpose.</span>関連するルールは、スマートポインタに対応するように特別に設計されているため、その目的のためにのみ特性を使用する必要があります。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Examples from the standard library</span>標準ライブラリの例</span> </h3><br><div data-b=-> <a class=notranslate href=#2https://doc.rust-lang.org/std/boxed/struct.Box.html><code>Box&lt;T&gt;</code></a> </div> <div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a class=notranslate href=#2https://doc.rust-lang.org/std/string/struct.String.html><code>String</code></a> is a smart pointer to <a class=notranslate href=#2https://doc.rust-lang.org/std/primitive.str.html><code>str</code></a></span> <a class=notranslate href=#2https://doc.rust-lang.org/std/string/struct.String.html><code>String</code></a>は<a class=notranslate href=#2https://doc.rust-lang.org/std/primitive.str.html><code>str</code></a>へのスマートポインタです</span> </div><div data-b=-> <a class=notranslate href=#2https://doc.rust-lang.org/std/rc/struct.Rc.html><code>Rc&lt;T&gt;</code></a> </div> <div data-b=-> <a class=notranslate href=#2https://doc.rust-lang.org/std/sync/struct.Arc.html><code>Arc&lt;T&gt;</code></a> </div> <div data-b=-> <a href=#2https://doc.rust-lang.org/std/borrow/enum.Cow.html><code>Cow&lt;&#39;a, T&gt;</code></a> </div> <br><br><p><a id=c-ctor></a> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">## Constructors are static, inherent methods (C-CTOR)</span> ##コンストラクタはスタティックで固有のメソッド（C-CTOR）です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In Rust, &quot;constructors&quot; are just a convention.</span> Rustでは、 &quot;コンストラクタ&quot;は単なるコンベンションです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There are a variety of conventions around constructor naming, and the distinctions are often subtle.</span>コンストラクターの名前にはさまざまな慣習があり、その区別はしばしば微妙です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A constructor in its most basic form is a <code>new</code> method with no arguments.</span>最も基本的な形式のコンストラクタは、引数のない<code>new</code>メソッドです。</span> </p><br><div data-lang=rust><div data-l="impl&lt;T&gt; Example&lt;T&gt; {"></div><div data-l="    pub fn new() -&gt; Example&lt;T&gt; { /* ... */ }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Constructors are static (no <code>self</code> ) inherent methods for the type that they construct.</span>コンストラクターは、構成する型の静的な（ <code>self</code>はない）固有のメソッドです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Combined with the practice of fully importing type names, this convention leads to informative but concise construction:</span>型名を完全にインポートするという習慣と組み合わせることで、このコンベンションは有益ではあるが簡潔な構成につながります。</span> </p><br><div data-lang=rust><div data-l="use example::Example;"></div><div data-l=""></div><div data-l="#// Construct a new Example."></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Construct a new Example.</span>新しい例を作成します。</span> </div><div data-l="let ex = Example::new();"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The name <code>new</code> should generally be used for the primary method of instantiating a type.</span> <code>new</code>という名前は、通常、型をインスタンス化する主なメソッドに使用されるべきです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Sometimes it takes no arguments, as in the examples above.</span>上記の例のように、引数を取らないこともあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Sometimes it does take arguments, like <a class=notranslate href="#4`Box::new`">`Box::new`</a> which is passed the value to place in the <code>Box</code> .</span>時にはそれは次のように、引数を取らない<a class=notranslate href="#4`Box::new`">`Box::new`</a>に配置する値渡された<code>Box</code> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Some types&#39; constructors, most notably I/O resource types, use distinct naming conventions for their constructors, as in <a class=notranslate href="#4`File::open`">`File::open`</a> , <a class=notranslate href="#4`Mmap::open`">`Mmap::open`</a> , <a class=notranslate href="#4`TcpStream::connect`">`TcpStream::connect`</a> , and <a class=notranslate href="#4`UpdSocket::bind`">`UpdSocket::bind`</a> .</span> <a class=notranslate href="#4`File::open`">`File::open`</a> 、 <a class=notranslate href="#4`Mmap::open`">`Mmap::open`</a> 、 <a class=notranslate href="#4`TcpStream::connect`">`TcpStream::connect`</a> 、 <a class=notranslate href="#4`UpdSocket::bind`">`UpdSocket::bind`</a>ように、いくつかの型のコンストラクタ、特にI / Oリソース型は、それらのコンストラクタに異なる命名規則を使用します<a class=notranslate href="#4`UpdSocket::bind`">`UpdSocket::bind`</a> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In these cases names are chosen as appropriate for the domain.</span>これらの場合、ドメインに応じて名前が選択されます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Often there are multiple ways to construct a type.</span>多くの場合、型を構築する方法は複数あります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It&#39;s common in these cases for secondary constructors to be suffixed <code>_with_foo</code> , as in <a class=notranslate href="#4`Mmap::open_with_offset`">`Mmap::open_with_offset`</a> .</span> <a class=notranslate href="#4`Mmap::open_with_offset`">`Mmap::open_with_offset`</a>ように、二次コンストラクタに接尾辞<code>_with_foo</code>のが一般的<a class=notranslate href="#4`Mmap::open_with_offset`">`Mmap::open_with_offset`</a> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If your type has a multiplicity of construction options though, consider the builder pattern ( <a class=notranslate href=#4C-BUILDER>C-BUILDER</a> ) instead.</span>あなたのタイプに複数の構築オプションがある場合は、代わりにビルダーパターン（ <a class=notranslate href=#4C-BUILDER>C-BUILDER</a> ）を考慮してください。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Some constructors are &quot;conversion constructors&quot;, methods that create a new type from an existing value of a different type.</span>いくつかのコンストラクタは、 &quot;コンバージョンコンストラクタ&quot;です。これは、別の型の既存の値から新しい型を作成するメソッドです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These typically have names begining with <code>from_</code> as in <a class=notranslate href="#4`std::io::Error::from_raw_os_error`">`std::io::Error::from_raw_os_error`</a> .</span>これらは通常で初めの名前持っている<code>from_</code>のように<a class=notranslate href="#4`std::io::Error::from_raw_os_error`">`std::io::Error::from_raw_os_error`</a> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note also though the <code>From</code> trait ( <a class=notranslate href=#4C-CONV-TRAITS>C-CONV-TRAITS</a> ), which is quite similar.</span> <code>From</code>特性（ <a class=notranslate href=#4C-CONV-TRAITS>C-CONV-TRAITS</a> ）も同様であることに注意してください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There are three distinctions between a <code>from_</code> -prefixed conversion constructor and a <code>From&lt;T&gt;</code> impl.</span>間に3つの区別があります<code>from_</code> -prefixed変換コンストラクタとA <code>From&lt;T&gt;</code>独自の実装が。</span> </p><br><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A <code>from_</code> constructor can be unsafe;</span> <code>from_</code>コンストラクタは安全ではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">a <code>From</code> impl cannot.</span> <code>From</code>のimplはできません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">One example of this is <a class=notranslate href="#4`Box::from_raw`">`Box::from_raw`</a> .</span>これの一例は<a class=notranslate href="#4`Box::from_raw`">`Box::from_raw`</a>です。</span> </div><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A <code>from_</code> constructor can accept additional arguments to disambiguate the meaning of the source data, as in <a class=notranslate href="#4`u64::from_str_radix`">`u64::from_str_radix`</a> .</span> <code>from_</code>コンストラクタは、 <a class=notranslate href="#4`u64::from_str_radix`">`u64::from_str_radix`</a>ように、ソースデータの意味を明確にする追加の引数を受け入れることができます。</span> </div><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A <code>From</code> impl is only appropriate when the source data type is sufficient to determine the encoding of the output data type.</span> <code>From</code>インプットは、ソースデータ型が出力データ型のエンコーディングを決定するのに十分である場合にのみ適切です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When the input is just a bag of bits like in <a class=notranslate href="#4`u64::from_be`">`u64::from_be`</a> or <a class=notranslate href="#4`String::from_utf8`">`String::from_utf8`</a> , the conversion constructor name is able to identify their meaning.</span>入力が<a class=notranslate href="#4`u64::from_be`">`u64::from_be`</a>や<a class=notranslate href="#4`String::from_utf8`">`String::from_utf8`</a>ようなビットの<a class=notranslate href="#4`String::from_utf8`">`String::from_utf8`</a>場合、変換コンストラクタ名はその意味を識別できます。</span> </div><br> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a class=notranslate href=#1https://doc.rust-lang.org/std/boxed/struct.Box.html#method.from_raw>`Box::from_raw`</a> <a class=notranslate href=#1https://doc.rust-lang.org/std/primitive.u64.html#method.from_str_radix>`u64::from_str_radix`</a> <a class=notranslate href=#1https://doc.rust-lang.org/std/primitive.u64.html#method.from_be>`u64::from_be`</a> <a class=notranslate href=#1https://doc.rust-lang.org/std/string/struct.String.html#method.from_utf8>`String::from_utf8`</a></span> <a class=notranslate href=#1https://doc.rust-lang.org/std/boxed/struct.Box.html#method.from_raw>`Box::from_raw`</a> <a class=notranslate href=#1https://doc.rust-lang.org/std/primitive.u64.html#method.from_str_radix>`u64::from_str_radix`</a> <a class=notranslate href=#1https://doc.rust-lang.org/std/primitive.u64.html#method.from_be>`u64::from_be`</a> <a class=notranslate href=#1https://doc.rust-lang.org/std/string/struct.String.html#method.from_utf8>`String::from_utf8`</a></span> <br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that it is common and expected for types to implement both <code>Default</code> and a <code>new</code> constructor.</span>型が<code>Default</code>と<code>new</code>コンストラクタの両方を実装することは一般的であり、期待されていることに注意してください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For types that have both, they should have the same behavior.</span>両方を持つタイプの場合、同じ動作をする必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Either one may be implemented in terms of the other.</span>いずれか一方を他方の観点から実装することができる。</span> </p><br> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a class=notranslate href=#1type-safety.html#c-builder>C-BUILDER</a> <a class=notranslate href=#1interoperability.html#c-conv-traits>C-CONV-TRAITS</a></span> <a class=notranslate href=#1type-safety.html#c-builder>C-BUILDER</a> <a class=notranslate href=#1interoperability.html#c-conv-traits>C-CONV-TRAITS</a></span> <br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Examples from the standard library</span>標準ライブラリの例</span> </h3><br><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a class=notranslate href="#4`std::io::Error::new`">`std::io::Error::new`</a> is the commonly used constructor for an IO error.</span> <a class=notranslate href="#4`std::io::Error::new`">`std::io::Error::new`</a>はIOエラーのためによく使われるコンストラクタです。</span> </div><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a class=notranslate href="#4`std::io::Error::from_raw_os_error`">`std::io::Error::from_raw_os_error`</a> is a conversion constructor based on an error code received from the operating system.</span> <a class=notranslate href="#4`std::io::Error::from_raw_os_error`">`std::io::Error::from_raw_os_error`</a>は、オペレーティングシステムから受け取ったエラーコードに基づく変換コンストラクタです。</span> </div><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a class=notranslate href="#4`Box::new`">`Box::new`</a> creates a new container type, taking a single argument.</span> <a class=notranslate href="#4`Box::new`">`Box::new`</a>は単一の引数を取って新しいコンテナ型を作成します。</span> </div><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a class=notranslate href="#4`File::open`">`File::open`</a> opens a file resource.</span> <a class=notranslate href="#4`File::open`">`File::open`</a>はファイルリソースを開きます。</span> </div><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a class=notranslate href="#4`Mmap::open_with_offset`">`Mmap::open_with_offset`</a> opens a memory-mapped file, with additional options.</span> <a class=notranslate href="#4`Mmap::open_with_offset`">`Mmap::open_with_offset`</a>はメモリマップされたファイルをオープンします。</span> </div><br> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a class=notranslate href=#1https://doc.rust-lang.org/stable/std/fs/struct.File.html#method.open>`File::open`</a> <a class=notranslate href=#1https://docs.rs/memmap/0.5.2/memmap/struct.Mmap.html#method.open>`Mmap::open`</a> <a class=notranslate href=#1https://docs.rs/memmap/0.5.2/memmap/struct.Mmap.html#method.open_with_offset>`Mmap::open_with_offset`</a> <a class=notranslate href=#1https://doc.rust-lang.org/stable/std/net/struct.TcpStream.html#method.connect>`TcpStream::connect`</a> <a class=notranslate href=#1https://doc.rust-lang.org/stable/std/net/struct.UdpSocket.html#method.bind>`UpdSocket::bind`</a> <a class=notranslate href=#1https://doc.rust-lang.org/std/io/struct.Error.html#method.new>`std::io::Error::new`</a> <a class=notranslate href=#1https://doc.rust-lang.org/std/io/struct.Error.html#method.from_raw_os_error>`std::io::Error::from_raw_os_error`</a> <a class=notranslate href=#1https://doc.rust-lang.org/stable/std/boxed/struct.Box.html#method.new>`Box::new`</a></span> <a class=notranslate href=#1https://doc.rust-lang.org/stable/std/fs/struct.File.html#method.open>`File::open`</a> <a class=notranslate href=#1https://docs.rs/memmap/0.5.2/memmap/struct.Mmap.html#method.open>`Mmap::open`</a> <a class=notranslate href=#1https://docs.rs/memmap/0.5.2/memmap/struct.Mmap.html#method.open_with_offset>`Mmap::open_with_offset`</a> <a class=notranslate href=#1https://doc.rust-lang.org/stable/std/net/struct.TcpStream.html#method.connect>`TcpStream::connect`</a> <a class=notranslate href=#1https://doc.rust-lang.org/stable/std/net/struct.UdpSocket.html#method.bind>`UpdSocket::bind`</a> <a class=notranslate href=#1https://doc.rust-lang.org/std/io/struct.Error.html#method.new>`std::io::Error::new`</a> <a class=notranslate href=#1https://doc.rust-lang.org/std/io/struct.Error.html#method.from_raw_os_error>`std::io::Error::from_raw_os_error`</a> <a class=notranslate href=#1https://doc.rust-lang.org/stable/std/boxed/struct.Box.html#method.new>`Box::new`</a></span> <br><script>_addload(function(){_setupIW('com');_csi('en','ja','predictability.html');});</script>