<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180723_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=future-proofing.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Future proofing</span>将来の校正</span> </h1><br><br><p><a id=c-sealed></a> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">## Sealed traits protect against downstream implementations (C-SEALED)</span> ##封鎖された形質は下流の実装から保護します（C-SEALED）</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Some traits are only meant to be implemented within the crate that defines them.</span>いくつかの形質は、それを定義する枠内でのみ実施されることを意図している。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In such cases, we can retain the ability to make changes to the trait in a non-breaking way by using the sealed trait pattern.</span>そのような場合、我々は、密閉された形質パターンを使用することにより、形質を改変する能力を保持することができる。</span> </p><br><div data-lang=rust><div data-l="#///// This trait is sealed and cannot be implemented for types outside this crate."></div><div data-l="/// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This trait is sealed and cannot be implemented for types outside this crate.</span>この形質は封印されており、この枠の外にある型に対しては実装できません。</span> </div><div data-l="pub trait TheTrait: private::Sealed {"></div><div data-l="#    // Zero or more methods that the user is allowed to call."></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Zero or more methods that the user is allowed to call.</span>ユーザーが呼び出すことができる0個以上のメソッド。</span> </div><div data-l="    fn ...();"></div><div data-l=""></div><div data-l="#    // Zero or more private methods, not allowed for user to call."></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Zero or more private methods, not allowed for user to call.</span>ゼロ個以上のプライベートメソッド。ユーザーがコールすることはできません。</span> </div><div data-l="    #[doc(hidden)]"></div><div data-l="    fn ...();"></div><div data-l=}></div><div data-l=""></div><div data-l="#// Implement for some types."></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Implement for some types.</span>いくつかの型のために実装してください。</span> </div><div data-l="impl TheTrait for usize {"></div><div data-l="    /* ... */"></div><div data-l=}></div><div data-l=""></div><div data-l="mod private {"></div><div data-l="    pub trait Sealed {}"></div><div data-l=""></div><div data-l="#    // Implement for those same types, but no others."></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Implement for those same types, but no others.</span>同じ種類のものを実装しますが、他のものは実装しません。</span> </div><div data-l="    impl Sealed for usize {}"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The empty private <code>Sealed</code> supertrait cannot be named by downstream crates, so we are guaranteed that implementations of <code>Sealed</code> (and therefore <code>TheTrait</code> ) only exist in the current crate.</span>空のプライベート<code>Sealed</code> supertraitにはダウンストリームのクレートで名前を付けることができないため、 <code>Sealed</code> （したがって<code>TheTrait</code> ）の実装は現在のクレートにのみ存在することが保証<code>Sealed</code>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We are free to add methods to <code>TheTrait</code> in a non-breaking release even though that would ordinarily be a breaking change for traits that are not sealed.</span> <code>TheTrait</code>は、たとえ封印されていない形質の通常の変更であっても、 <code>TheTrait</code>的な方法でメソッドを追加することは自由です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Also we are free to change the signature of methods that are not publicly documented.</span>また、公開されていない方法の署名も自由に変更できます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that removing a public method or changing the signature of a public method in a sealed trait are still breaking changes.</span>密封された特性でパブリックメソッドを削除するか、パブリックメソッドのシグネチャを変更することは、依然として大きな変化であることに注意してください。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To avoid frustrated users trying to implement the trait, it should be documented in rustdoc that the trait is sealed and not meant to be implemented outside of the current crate.</span>欲求不満のユーザがその形質を実装しようとするのを避けるために、形質は封印されており、現在の木枠の外では実装されないことをrustdocで文書化する必要があります。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Examples</span>例</span> </h3><br><div data-b=-> <a class=notranslate href=#2https://docs.serde.rs/serde_json/value/trait.Index.html><code>serde_json::value::Index</code></a> </div> <div data-b=-> <a class=notranslate href=#2https://docs.rs/byteorder/1.1.0/byteorder/trait.ByteOrder.html><code>byteorder::ByteOrder</code></a> </div> <br><br><p><a id=c-struct-private></a> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">## Structs have private fields (C-STRUCT-PRIVATE)</span> ##構造体にはプライベートフィールドがあります（C-STRUCT-PRIVATE）</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Making a field public is a strong commitment: it pins down a representation choice, <s>and</s> prevents the type from providing any validation or maintaining any invariants on the contents of the field, since clients can mutate it arbitrarily.</span>フィールドをパブリックにすることは、表現の選択肢を限定し、クライアントが任意にバリデーションを行うことができるため、タイプがフィールドの内容に対して任意の検証を提供したり、不変条件を維持するの<s>を</s>妨げます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Public fields are most appropriate for <code>struct</code> types in the C spirit: compound, passive data structures.</span>パブリックフィールドは、Cの精神の中の<code>struct</code>体型に最も適しています：複合パッシブデータ構造。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Otherwise, consider providing getter/setter methods and hiding fields instead.</span>それ以外の場合は、getter / setterメソッドの提供とフィールドの非表示を検討してください。</span> </p><br><br><p><a id=c-newtype-hide></a> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">## Newtypes encapsulate implementation details (C-NEWTYPE-HIDE)</span> ## Newtypesは実装の詳細をカプセル化します（C-NEWTYPE-HIDE）</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A newtype can be used to hide representation details while making precise promises to the client.</span> newtypeを使用すると、クライアントに正確な約束をしながら表現の詳細を隠すことができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, consider a function <code>my_transform</code> that returns a compound iterator type.</span>たとえば、複合イテレータ型を返す関数<code>my_transform</code>を考えてみ<code>my_transform</code>う。</span> </p><br><div data-lang=rust><div data-l="use std::iter::{Enumerate, Skip};"></div><div data-l=""></div><div data-l="pub fn my_transform&lt;I: Iterator&gt;(input: I) -&gt; Enumerate&lt;Skip&lt;I&gt;&gt; {"></div><div data-l="    input.skip(3).enumerate()"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We wish to hide this type from the client, so that the client&#39;s view of the return type is roughly <code>Iterator&lt;Item = (usize, T)&gt;</code> .</span>このタイプをクライアントから隠して、クライアントの戻り値の型が概ね<code>Iterator&lt;Item = (usize, T)&gt;</code>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can do so using the newtype pattern:</span> newtypeパターンを使用してこれを行うことができます：</span> </p><br><div data-lang=rust><div data-l="use std::iter::{Enumerate, Skip};"></div><div data-l=""></div><div data-l="pub struct MyTransformResult&lt;I&gt;(Enumerate&lt;Skip&lt;I&gt;&gt;);"></div><div data-l=""></div><div data-l="impl&lt;I: Iterator&gt; Iterator for MyTransformResult&lt;I&gt; {"></div><div data-l="    type Item = (usize, I::Item);"></div><div data-l=""></div><div data-l="    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {"></div><div data-l="        self.0.next()"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="pub fn my_transform&lt;I: Iterator&gt;(input: I) -&gt; MyTransformResult&lt;I&gt; {"></div><div data-l="    MyTransformResult(input.skip(3).enumerate())"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Aside from simplifying the signature, this use of newtypes allows us to promise less to the client.</span>シグネチャを単純化する以外にも、この新しいタイプの使用により、クライアントにはあまりお約束することができません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The client does not know <s>how</s> the result iterator is constructed or represented, which means the representation can change in the future without breaking client code.</span>クライアントは、結果イテレータが<s>どのよう</s>に構築または表現されている<s>かを</s>知らないため、クライアントコードを破ることなく表現が将来変更される可能性があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In the future the same thing can be accomplished more concisely with the <a class=notranslate href="#4`implTrait`">`impl Trait`</a> feature but this is currently unstable.</span>将来、同じことを<a class=notranslate href="#4`implTrait`">`impl Trait`</a>機能によってより簡潔に達成することができますが、これは現在不安定です。</span> </p><br> <a class=notranslate href=#1https://github.com/rust-lang/rfcs/blob/master/text/1522-conservative-impl-trait.md>`impl Trait`</a> <br> <div data-lang=rust><div data-l=#![feature(conservative_impl_trait)]></div><div data-l=""></div><div data-l="pub fn my_transform&lt;I: Iterator&gt;(input: I) -&gt; impl Iterator&lt;Item = (usize, I::Item)&gt; {"></div><div data-l="    input.skip(3).enumerate()"></div><div data-l=}></div></div><br><br><p><a id=c-struct-bounds></a> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">## Data structures do not duplicate derived trait bounds (C-STRUCT-BOUNDS)</span> ##データ構造は派生した特性境界を複製しません（C-STRUCT-BOUNDS）</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Generic data structures should not use trait bounds that can be derived or do not otherwise add semantic value.</span>一般的なデータ構造は、導出可能な形質境界を使用してはならない、または意味値を追加しないでください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Each trait in the <code>derive</code> attribute will be expanded into a separate <code>impl</code> block that only applies to generic arguments that implement that trait.</span> <code>derive</code>属性の各特性は、その特性を実装する汎用引数にのみ適用される別個の<code>impl</code>ブロックに展開されます。</span> </p><br><div data-lang=rust><div data-l="#// Prefer this:"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Prefer this:</span>これを好む：</span> </div><div data-l="#[derive(Clone, Debug, PartialEq)]"></div><div data-l="struct Good&lt;T&gt; { /* ... */ }"></div><div data-l=""></div><div data-l="#// Over this:"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Over this:</span>これ以上：</span> </div><div data-l="#[derive(Clone, Debug, PartialEq)]"></div><div data-l="struct Bad&lt;T: Clone + Debug + PartialEq&gt; { /* ... */ }"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Duplicating derived traits as bounds on <code>Bad</code> is unnecessary and a backwards-compatibiliity hazard.</span> <code>Bad</code>境界として派生した特性を複製することは不要であり、後方互換性の危険もあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To illustrate this point, consider deriving <code>PartialOrd</code> on the structures in the previous example:</span>この点を説明するには、前の例の構造<code>PartialOrd</code>を導出することを<code>PartialOrd</code>してください。</span> </p><br><div data-lang=rust><div data-l="#// Non-breaking change:"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Non-breaking change:</span>ノン・ブレイク・チェンジ：</span> </div><div data-l="#[derive(Clone, Debug, PartialEq, PartialOrd)]"></div><div data-l="struct Good&lt;T&gt; { /* ... */ }"></div><div data-l=""></div><div data-l="#// Breaking change:"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Breaking change:</span>変更を破る：</span> </div><div data-l="#[derive(Clone, Debug, PartialEq, PartialOrd)]"></div><div data-l="struct Bad&lt;T: Clone + Debug + PartialEq + PartialOrd&gt; { /* ... */ }"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Generally speaking, adding a trait bound to a data structure is a breaking change because every consumer of that structure will need to start satisfying the additional bound.</span>一般に、データ構造にバインドされた特性を追加することは、その構造のすべてのコンシューマが追加バインディングを満たす必要があるため、大きな変更です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Deriving more traits from the standard library using the <code>derive</code> attribute is not a breaking change.</span> derive属性を使用して標準ライブラリからより多くの形質を<code>derive</code>ことは、大きな変化ではありません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The following traits should never be used in bounds on data structures:</span>以下の特性は、データ構造の境界で決して使用しないでください。</span> </p><br><div data-b=-> <code>Clone</code> </div> <div data-b=-> <code>PartialEq</code> </div> <div data-b=-> <code>PartialOrd</code> </div> <div data-b=-> <code>Debug</code> </div> <div data-b=-> <code>Display</code> </div> <div data-b=-> <code>Default</code> </div> <div data-b=-> <code>Serialize</code> </div> <div data-b=-> <code>Deserialize</code> </div> <div data-b=-> <code>DeserializeOwned</code> </div> <br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There is a grey area around other non-derivable trait bounds that are not strictly required by the structure definition, like <code>Read</code> or <code>Write</code> .</span>構造体定義によって厳密には要求されていない、 <code>Read</code>または<code>Write</code>などの他の非導出可能な特性境界の周囲には、灰色の領域があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">They may communicate the intended behavior of the type better in its definition but also limits future extensibility.</span>彼らはそのタイプの意図された振る舞いをその定義においてより良く伝えるかもしれないが、将来の拡張性も制限する。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Including semantically useful trait bounds on data structures is still less problematic than including derivable traits as bounds.</span>意味的に有用な形質境界をデータ構造に含めることは、誘導可能な形質を境界として含めることよりも問題が少ない。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Exceptions</span>例外</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There are three exceptions where trait bounds on structures are required:</span>構造上の特性境界が必要な場合は3つの例外があります。</span> </p><br><div data-b=1.> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The data structure refers to an associated type on the trait.</span>データ構造は、形質上の関連する型を指す。</span> </div><div data-b=1.> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The bound is <code>?Sized</code> .</span>束縛は「 <code>?Sized</code>です。</span> </div><div data-b=1.> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The data structure has a <code>Drop</code> impl that requires trait bounds.</span>データ構造には、特性境界を必要とする<code>Drop</code> implがあります。</span> </div><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust currently requires all trait bounds on the <code>Drop</code> impl are also present on the data structure.</span> Rustは現在、 <code>Drop</code> implのすべての特性境界もデータ構造上に存在する必要があります。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Examples from the standard library</span>標準ライブラリの例</span> </h3><br><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a class=notranslate href="#4`std::borrow::Cow`">`std::borrow::Cow`</a> refers to an associated type on the <code>Borrow</code> trait.</span> <a class=notranslate href="#4`std::borrow::Cow`">`std::borrow::Cow`</a>は、 <code>Borrow</code>特性の関連タイプを指します。</span> </div><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a class=notranslate href="#4`std::boxed::Box`">`std::boxed::Box`</a> opts out of the implicit <code>Sized</code> bound.</span> <a class=notranslate href="#4`std::boxed::Box`">`std::boxed::Box`</a>は、暗黙の<code>Sized</code> boundからオプトアウトします。</span> </div><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a class=notranslate href="#4`std::io::BufWriter`">`std::io::BufWriter`</a> requires a trait bound in its <code>Drop</code> impl.</span> <a class=notranslate href="#4`std::io::BufWriter`">`std::io::BufWriter`</a>は、その<code>Drop</code> <a class=notranslate href="#4`std::io::BufWriter`">`std::io::BufWriter`</a> 、特性バウンドを必要とします。</span> </div><br> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a class=notranslate href=#1https://doc.rust-lang.org/std/borrow/enum.Cow.html>`std::borrow::Cow`</a> <a class=notranslate href=#1https://doc.rust-lang.org/std/boxed/struct.Box.html>`std::boxed::Box`</a> <a class=notranslate href=#1https://doc.rust-lang.org/std/io/struct.BufWriter.html>`std::io::BufWriter`</a></span> <a class=notranslate href=#1https://doc.rust-lang.org/std/borrow/enum.Cow.html>`std::borrow::Cow`</a> <a class=notranslate href=#1https://doc.rust-lang.org/std/boxed/struct.Box.html>`std::boxed::Box`</a> <a class=notranslate href=#1https://doc.rust-lang.org/std/io/struct.BufWriter.html>`std::io::BufWriter`</a></span><script>_addload(function(){_setupIW('com');_csi('en','ja','future-proofing.html');});</script>