<!DOCTYPE html>
<h2>The Manifest Format</h2>
<br>
<p>The <code>Cargo.toml</code> file for each package is called its <i>manifest</i>. Every manifest
file consists of one or more sections.</p>
<br>
<h3>The <code>[package]</code> section</h3>
<br>
<p>The first section in a <code>Cargo.toml</code> is <code>[package]</code>.</p>
<br>
<div data-lang="toml"><div data-l="[package]"></div><div data-l="name = &quot;hello_world&quot; # the name of the package"></div><div data-l="version = &quot;0.1.0&quot;    # the current version, obeying semver"></div><div data-l="authors = [&quot;Alice &lt;a@example.com&gt;&quot;, &quot;Bob &lt;b@example.com&gt;&quot;]"></div></div>
<br>
<p>All three of these fields are mandatory.</p>
<br>
<h4>The <code>version</code> field</h4>
<br>
<p>Cargo bakes in the concept of <a class="notranslate" href="#2http://semver.org/">Semantic
Versioning</a>, so make sure you follow some basic rules:</p>
<br>
<div data-b="*">Before you reach 1.0.0, anything goes, but if you make breaking changes,
increment the minor version. In Rust, breaking changes include adding fields to
structs or variants to enums.</div>
<div data-b="*">After 1.0.0, only make breaking changes when you increment the major version.
Don’t break the build.</div>
<div data-b="*">After 1.0.0, don’t add any new public API (no new <code>pub</code> anything) in tiny
versions. Always increment the minor version if you add any new <code>pub</code> structs,
traits, fields, types, functions, methods or anything else.</div>
<div data-b="*">Use version numbers with three numeric parts such as 1.0.0 rather than 1.0.</div>
<br>
<h4>The <code>build</code> field (optional)</h4>
<br>
<p>This field specifies a file in the project root which is a <a href="#31">build script</a> for
building native code. More information can be found in the build script
<a class="notranslate" href="#31">guide</a>.</p>
<br>
<a class="notranslate" href="#1reference/build-scripts.html">1</a>
<br>
<div data-lang="toml"><div data-l="[package]"></div><div data-l="# ..."></div><div data-l="build = &quot;build.rs&quot;"></div></div>
<br>
<h4>The <code>links</code> field (optional)</h4>
<br>
<p>This fields specifies the name of a native library that is being linked to.
More information can be found in the <a class="notranslate" href="#3links"><code>links</code></a> section of the build
script guide.</p>
<br>
<a class="notranslate" href="#1reference/build-scripts.html#the-links-manifest-key">links</a>
<br>
<div data-lang="toml"><div data-l="[package]"></div><div data-l="# ..."></div><div data-l="links = &quot;foo&quot;"></div><div data-l="build = &quot;build.rs&quot;"></div></div>
<br>
<h4>The <code>documentation</code> field (optional)</h4>
<br>
<p>This field specifies a URL to a website hosting the crate's documentation.
If no URL is specified in the manifest file, <a class="notranslate" href="#3cratesio">crates.io</a> will
automatically link your crate to the corresponding <a class="notranslate" href="#3docsrs">docs.rs</a> page.</p>
<br>
<p>Documentation links from specific hosts are blacklisted. Hosts are added
to the blacklist if they are known to not be hosting documentation and are
possibly of malicious intent e.g. ad tracking networks. URLs from the
following hosts are blacklisted:</p>
<br>
<div data-b="*">rust-ci.org</div>
<br>
<p>Documentation URLs from blacklisted hosts will not appear on crates.io, and
may be replaced by docs.rs links.</p>
<br>
<a class="notranslate" href="#1https://docs.rs/">docsrs</a>
<a class="notranslate" href="#1https://crates.io/">cratesio</a>
<br>
<h4>The <code>exclude</code> and <code>include</code> fields (optional)</h4>
<br>
<p>You can explicitly specify to Cargo that a set of <a class="notranslate" href="#3globs">globs</a> should be
ignored or included for the purposes of packaging and rebuilding a package. The
globs specified in the <code>exclude</code> field identify a set of files that are not
included when a package is published as well as ignored for the purposes of
detecting when to rebuild a package, and the globs in <code>include</code> specify files
that are explicitly included.</p>
<br>
<p>If a VCS is being used for a package, the <code>exclude</code> field will be seeded with
the VCS’ ignore settings (<code>.gitignore</code> for git for example).</p>
<br>
<div data-lang="toml"><div data-l="[package]"></div><div data-l="# ..."></div><div data-l="exclude = [&quot;build/**/*.o&quot;, &quot;doc/**/*.html&quot;]"></div></div>
<br>
<div data-lang="toml"><div data-l="[package]"></div><div data-l="# ..."></div><div data-l="include = [&quot;src/**/*&quot;, &quot;Cargo.toml&quot;]"></div></div>
<br>
<p>The options are mutually exclusive: setting <code>include</code> will override an
<code>exclude</code>. Note that <code>include</code> must be an exhaustive list of files as otherwise
necessary source files may not be included.</p>
<br>
<a class="notranslate" href="#1http://doc.rust-lang.org/glob/glob/struct.Pattern.html">globs</a>
<br>
<h4>Migrating to <code>gitignore</code>-like pattern matching</h4>
<br>
<p>The current interpretation of these configs is based on UNIX Globs, as
implemented in the <a href="#2https://crates.io/crates/glob"><code>glob</code> crate</a>. We want
Cargo's <code>include</code> and <code>exclude</code> configs to work as similar to <code>gitignore</code> as
possible. <a href="#2https://git-scm.com/docs/gitignore">The <code>gitignore</code> specification</a> is
also based on Globs, but has a bunch of additional features that enable easier
pattern writing and more control. Therefore, we are migrating the interpretation
for the rules of these configs to use the <a class="notranslate" href="#2https://crates.io/crates/ignore"><code>ignore</code>
crate</a>, and treat them each rule as a single
line in a <code>gitignore</code> file. See <a href="#2https://github.com/rust-lang/cargo/issues/4268">the tracking
issue</a> for more details on the
migration.</p>
<br>
<h4>The <code>publish</code>  field (optional)</h4>
<br>
<p>The <code>publish</code> field can be used to prevent a package from being published to a
package registry (like <i>crates.io</i>) by mistake.</p>
<br>
<div data-lang="toml"><div data-l="[package]"></div><div data-l="# ..."></div><div data-l="publish = false"></div></div>
<br>
<h4>The <code>workspace</code>  field (optional)</h4>
<br>
<p>The <code>workspace</code> field can be used to configure the workspace that this package
will be a member of. If not specified this will be inferred as the first
Cargo.toml with <code>[workspace]</code> upwards in the filesystem.</p>
<br>
<div data-lang="toml"><div data-l="[package]"></div><div data-l="# ..."></div><div data-l="workspace = &quot;path/to/workspace/root&quot;"></div></div>
<br>
<p>For more information, see the documentation for the workspace table below.</p>
<br>
<h4>Package metadata</h4>
<br>
<p>There are a number of optional metadata fields also accepted under the
<code>[package]</code> section:</p>
<br>
<div data-lang="toml"><div data-l="[package]"></div><div data-l="# ..."></div><div data-l=""></div><div data-l="# A short blurb about the package. This is not rendered in any format when"></div><div data-l="# uploaded to crates.io (aka this is not markdown)."></div><div data-l="description = &quot;...&quot;"></div><div data-l=""></div><div data-l="# These URLs point to more information about the package. These are"></div><div data-l="# intended to be webviews of the relevant data, not necessarily compatible"></div><div data-l="# with VCS tools and the like."></div><div data-l="documentation = &quot;...&quot;"></div><div data-l="homepage = &quot;...&quot;"></div><div data-l="repository = &quot;...&quot;"></div><div data-l=""></div><div data-l="# This points to a file under the package root (relative to this `Cargo.toml`)."></div><div data-l="# The contents of this file are stored and indexed in the registry."></div><div data-l="# crates.io will render this file and place the result on the crate's page."></div><div data-l="readme = &quot;...&quot;"></div><div data-l=""></div><div data-l="# This is a list of up to five keywords that describe this crate. Keywords"></div><div data-l="# are searchable on crates.io, and you may choose any words that would"></div><div data-l="# help someone find this crate."></div><div data-l="keywords = [&quot;...&quot;, &quot;...&quot;]"></div><div data-l=""></div><div data-l="# This is a list of up to five categories where this crate would fit."></div><div data-l="# Categories are a fixed list available at crates.io/category_slugs, and"></div><div data-l="# they must match exactly."></div><div data-l="categories = [&quot;...&quot;, &quot;...&quot;]"></div><div data-l=""></div><div data-l="# This is an SPDX 2.1 license expression for this package.  Currently"></div><div data-l="# crates.io will validate the license provided against a whitelist of"></div><div data-l="# known license and exception identifiers from the SPDX license list"></div><div data-l="# 2.4.  Parentheses are not currently supported."></div><div data-l="#"></div><div data-l="# Multiple licenses can be separated with a `/`, although that usage"></div><div data-l="# is deprecated.  Instead, use a license expression with AND and OR"></div><div data-l="# operators to get more explicit semantics."></div><div data-l="license = &quot;...&quot;"></div><div data-l=""></div><div data-l="# If a project is using a nonstandard license, then this key may be specified in"></div><div data-l="# lieu of the above key and must point to a file relative to this manifest"></div><div data-l="# (similar to the readme key)."></div><div data-l="license-file = &quot;...&quot;"></div><div data-l=""></div><div data-l="# Optional specification of badges to be displayed on crates.io."></div><div data-l="#"></div><div data-l="# - The badges pertaining to build status that are currently available are"></div><div data-l="#   Appveyor, CircleCI, GitLab, and TravisCI."></div><div data-l="# - Available badges pertaining to code test coverage are Codecov and"></div><div data-l="#   Coveralls."></div><div data-l="# - There are also maintenance-related badges based on isitmaintained.com"></div><div data-l="#   which state the issue resolution time, percent of open issues, and future"></div><div data-l="#   maintenance intentions."></div><div data-l="#"></div><div data-l="# If a `repository` key is required, this refers to a repository in"></div><div data-l="# `user/repo` format."></div><div data-l="[badges]"></div><div data-l=""></div><div data-l="# Appveyor: `repository` is required. `branch` is optional; default is `master`"></div><div data-l="# `service` is optional; valid values are `github` (default), `bitbucket`, and"></div><div data-l="# `gitlab`; `id` is optional; you can specify the appveyor project id if you"></div><div data-l="# want to use that instead. `project_name` is optional; use when the repository"></div><div data-l="# name differs from the appveyor project name."></div><div data-l="appveyor = { repository = &quot;...&quot;, branch = &quot;master&quot;, service = &quot;github&quot; }"></div><div data-l=""></div><div data-l="# Circle CI: `repository` is required. `branch` is optional; default is `master`"></div><div data-l="circle-ci = { repository = &quot;...&quot;, branch = &quot;master&quot; }"></div><div data-l=""></div><div data-l="# GitLab: `repository` is required. `branch` is optional; default is `master`"></div><div data-l="gitlab = { repository = &quot;...&quot;, branch = &quot;master&quot; }"></div><div data-l=""></div><div data-l="# Travis CI: `repository` in format &quot;&lt;user&gt;/&lt;project&gt;&quot; is required."></div><div data-l="# `branch` is optional; default is `master`"></div><div data-l="travis-ci = { repository = &quot;...&quot;, branch = &quot;master&quot; }"></div><div data-l=""></div><div data-l="# Codecov: `repository` is required. `branch` is optional; default is `master`"></div><div data-l="# `service` is optional; valid values are `github` (default), `bitbucket`, and"></div><div data-l="# `gitlab`."></div><div data-l="codecov = { repository = &quot;...&quot;, branch = &quot;master&quot;, service = &quot;github&quot; }"></div><div data-l=""></div><div data-l="# Coveralls: `repository` is required. `branch` is optional; default is `master`"></div><div data-l="# `service` is optional; valid values are `github` (default) and `bitbucket`."></div><div data-l="coveralls = { repository = &quot;...&quot;, branch = &quot;master&quot;, service = &quot;github&quot; }"></div><div data-l=""></div><div data-l="# Is it maintained resolution time: `repository` is required."></div><div data-l="is-it-maintained-issue-resolution = { repository = &quot;...&quot; }"></div><div data-l=""></div><div data-l="# Is it maintained percentage of open issues: `repository` is required."></div><div data-l="is-it-maintained-open-issues = { repository = &quot;...&quot; }"></div><div data-l=""></div><div data-l="# Maintenance: `status` is required. Available options are `actively-developed`,"></div><div data-l="# `passively-maintained`, `as-is`, `experimental`, `looking-for-maintainer`,"></div><div data-l="# `deprecated`, and the default `none`, which displays no badge on crates.io."></div><div data-l="maintenance = { status = &quot;...&quot; }"></div></div>
<br>
<p>The <a class="notranslate" href="#2https://crates.io">crates.io</a> registry will render the description, display
the license, link to the three URLs and categorize by the keywords. These keys
provide useful information to users of the registry and also influence the
search ranking of a crate. It is highly discouraged to omit everything in a
published crate.</p>
<br>
<p>SPDX 2.1 license expressions are documented
<a class="notranslate" href="#3spdx-2.1-license-expressions">here</a>.  The current version of the
license list is available <a class="notranslate" href="#3spdx-license-list">here</a>, and version 2.4
is available <a class="notranslate" href="#3spdx-license-list-2.4">here</a>.</p>
<br>
<h4>The <code>metadata</code> table (optional)</h4>
<br>
<p>Cargo by default will warn about unused keys in <code>Cargo.toml</code> to assist in
detecting typos and such. The <code>package.metadata</code> table, however, is completely
ignored by Cargo and will not be warned about. This section can be used for
tools which would like to store project configuration in <code>Cargo.toml</code>. For
example:</p>
<br>
<div data-lang="toml"><div data-l="[package]"></div><div data-l="name = &quot;...&quot;"></div><div data-l="# ..."></div><div data-l=""></div><div data-l="# Metadata used when generating an Android APK, for example."></div><div data-l="[package.metadata.android]"></div><div data-l="package-name = &quot;my-awesome-android-app&quot;"></div><div data-l="assets = &quot;path/to/static&quot;"></div></div>
<br>
<h3>Dependency sections</h3>
<br>
<p>See the <a href="#2reference/specifying-dependencies.html">specifying dependencies page</a> for
information on the <code>[dependencies]</code>, <code>[dev-dependencies]</code>,
<code>[build-dependencies]</code>, and target-specific <code>[target.*.dependencies]</code> sections.</p>
<br>
<h3>The <code>[profile.*]</code> sections</h3>
<br>
<p>Cargo supports custom configuration of how rustc is invoked through profiles at
the top level. Any manifest may declare a profile, but only the top level
project’s profiles are actually read. All dependencies’ profiles will be
overridden. This is done so the top-level project has control over how its
dependencies are compiled.</p>
<br>
<p>There are four currently supported profile names, all of which have the same
configuration available to them. Listed below is the configuration available,
along with the defaults for each profile.</p>
<br>
<div data-lang="toml"><div data-l="# The development profile, used for `cargo build`."></div><div data-l="[profile.dev]"></div><div data-l="opt-level = 0      # controls the `--opt-level` the compiler builds with."></div><div data-l="                   # 0-1 is good for debugging. 2 is well-optimized. Max is 3."></div><div data-l="                   # 's' attempts to reduce size, 'z' reduces size even more."></div><div data-l="debug = true       # (u32 or bool) Include debug information (debug symbols)."></div><div data-l="                   # Equivalent to `-C debuginfo=2` compiler flag."></div><div data-l="rpath = false      # controls whether compiler should set loader paths."></div><div data-l="                   # If true, passes `-C rpath` flag to the compiler."></div><div data-l="lto = false        # Link Time Optimization usually reduces size of binaries"></div><div data-l="                   # and static libraries. Increases compilation time."></div><div data-l="                   # If true, passes `-C lto` flag to the compiler, and if a"></div><div data-l="                   # string is specified like 'thin' then `-C lto=thin` will"></div><div data-l="                   # be passed."></div><div data-l="debug-assertions = true # controls whether debug assertions are enabled"></div><div data-l="                   # (e.g. debug_assert!() and arithmetic overflow checks)"></div><div data-l="codegen-units = 16 # if &gt; 1 enables parallel code generation which improves"></div><div data-l="                   # compile times, but prevents some optimizations."></div><div data-l="                   # Passes `-C codegen-units`."></div><div data-l="panic = 'unwind'   # panic strategy (`-C panic=...`), can also be 'abort'"></div><div data-l="incremental = true # whether or not incremental compilation is enabled"></div><div data-l="overflow-checks = true # use overflow checks for integer arithmetic."></div><div data-l="                   # Passes the `-C overflow-checks=...` flag to the compiler."></div><div data-l=""></div><div data-l="# The release profile, used for `cargo build --release`."></div><div data-l="[profile.release]"></div><div data-l="opt-level = 3"></div><div data-l="debug = false"></div><div data-l="rpath = false"></div><div data-l="lto = false"></div><div data-l="debug-assertions = false"></div><div data-l="codegen-units = 16"></div><div data-l="panic = 'unwind'"></div><div data-l="incremental = false"></div><div data-l="overflow-checks = false"></div><div data-l=""></div><div data-l="# The testing profile, used for `cargo test`."></div><div data-l="[profile.test]"></div><div data-l="opt-level = 0"></div><div data-l="debug = 2"></div><div data-l="rpath = false"></div><div data-l="lto = false"></div><div data-l="debug-assertions = true"></div><div data-l="codegen-units = 16"></div><div data-l="panic = 'unwind'"></div><div data-l="incremental = true"></div><div data-l="overflow-checks = true"></div><div data-l=""></div><div data-l="# The benchmarking profile, used for `cargo bench` and `cargo test --release`."></div><div data-l="[profile.bench]"></div><div data-l="opt-level = 3"></div><div data-l="debug = false"></div><div data-l="rpath = false"></div><div data-l="lto = false"></div><div data-l="debug-assertions = false"></div><div data-l="codegen-units = 16"></div><div data-l="panic = 'unwind'"></div><div data-l="incremental = false"></div><div data-l="overflow-checks = false"></div></div>
<br>
<h3>The <code>[features]</code> section</h3>
<br>
<p>Cargo supports features to allow expression of:</p>
<br>
<div data-b="*">conditional compilation options (usable through <code>cfg</code> attributes);</div>
<div data-b="*">optional dependencies, which enhance a package, but are not required; and</div>
<div data-b="*">clusters of optional dependencies, such as <code>postgres</code>, that would include the
<code>postgres</code> package, the <code>postgres-macros</code> package, and possibly other packages
(such as development-time mocking libraries, debugging tools, etc.).</div>
<br>
<p>A feature of a package is either an optional dependency, or a set of other
features. The format for specifying features is:</p>
<br>
<div data-lang="toml"><div data-l="[package]"></div><div data-l="name = &quot;awesome&quot;"></div><div data-l=""></div><div data-l="[features]"></div><div data-l="# The default set of optional packages. Most people will want to use these"></div><div data-l="# packages, but they are strictly optional. Note that `session` is not a package"></div><div data-l="# but rather another feature listed in this manifest."></div><div data-l="default = [&quot;jquery&quot;, &quot;uglifier&quot;, &quot;session&quot;]"></div><div data-l=""></div><div data-l="# A feature with no dependencies is used mainly for conditional compilation,"></div><div data-l="# like `#[cfg(feature = &quot;go-faster&quot;)]`."></div><div data-l="go-faster = []"></div><div data-l=""></div><div data-l="# The `secure-password` feature depends on the bcrypt package. This aliasing"></div><div data-l="# will allow people to talk about the feature in a higher-level way and allow"></div><div data-l="# this package to add more requirements to the feature in the future."></div><div data-l="secure-password = [&quot;bcrypt&quot;]"></div><div data-l=""></div><div data-l="# Features can be used to reexport features of other packages. The `session`"></div><div data-l="# feature of package `awesome` will ensure that the `session` feature of the"></div><div data-l="# package `cookie` is also enabled."></div><div data-l="session = [&quot;cookie/session&quot;]"></div><div data-l=""></div><div data-l="[dependencies]"></div><div data-l="# These packages are mandatory and form the core of this package’s distribution."></div><div data-l="cookie = &quot;1.2.0&quot;"></div><div data-l="oauth = &quot;1.1.0&quot;"></div><div data-l="route-recognizer = &quot;=2.1.0&quot;"></div><div data-l=""></div><div data-l="# A list of all of the optional dependencies, some of which are included in the"></div><div data-l="# above `features`. They can be opted into by apps."></div><div data-l="jquery = { version = &quot;1.0.2&quot;, optional = true }"></div><div data-l="uglifier = { version = &quot;1.5.3&quot;, optional = true }"></div><div data-l="bcrypt = { version = &quot;*&quot;, optional = true }"></div><div data-l="civet = { version = &quot;*&quot;, optional = true }"></div></div>
<br>
<p>To use the package <code>awesome</code>:</p>
<br>
<div data-lang="toml"><div data-l="[dependencies.awesome]"></div><div data-l="version = &quot;1.3.5&quot;"></div><div data-l="default-features = false # do not include the default features, and optionally"></div><div data-l="                         # cherry-pick individual features"></div><div data-l="features = [&quot;secure-password&quot;, &quot;civet&quot;]"></div></div>
<br>
<h4>Rules</h4>
<br>
<p>The usage of features is subject to a few rules:</p>
<br>
<div data-b="*">Feature names must not conflict with other package names in the manifest. This
is because they are opted into via <code>features = [...]</code>, which only has a single
namespace.</div>
<div data-b="*">With the exception of the <code>default</code> feature, all features are opt-in. To opt
out of the default feature, use <code>default-features = false</code> and cherry-pick
individual features.</div>
<div data-b="*">Feature groups are not allowed to cyclically depend on one another.</div>
<div data-b="*">Dev-dependencies cannot be optional.</div>
<div data-b="*">Features groups can only reference optional dependencies.</div>
<div data-b="*">When a feature is selected, Cargo will call <code>rustc</code> with <code>--cfg
  feature=&quot;${feature_name}&quot;</code>. If a feature group is included, it and all of its
individual features will be included. This can be tested in code via
<code>#[cfg(feature = &quot;foo&quot;)]</code>.</div>
<br>
<p>Note that it is explicitly allowed for features to not actually activate any
optional dependencies. This allows packages to internally enable/disable
features without requiring a new dependency.</p>
<br>
<h4>Usage in end products</h4>
<br>
<p>One major use-case for this feature is specifying optional features in
end-products. For example, the Servo project may want to include optional
features that people can enable or disable when they build it.</p>
<br>
<p>In that case, Servo will describe features in its <code>Cargo.toml</code> and they can be
enabled using command-line flags:</p>
<br>
<div data-lang="console"><div data-l="$ cargo build --release --features &quot;shumway pdf&quot;"></div></div>
<br>
<p>Default features could be excluded using <code>--no-default-features</code>.</p>
<br>
<h4>Usage in packages</h4>
<br>
<p>In most cases, the concept of <i>optional dependency</i> in a library is best
expressed as a separate package that the top-level application depends on.</p>
<br>
<p>However, high-level packages, like Iron or Piston, may want the ability to
curate a number of packages for easy installation. The current Cargo system
allows them to curate a number of mandatory dependencies into a single package
for easy installation.</p>
<br>
<p>In some cases, packages may want to provide additional curation for optional
dependencies:</p>
<br>
<div data-b="*">grouping a number of low-level optional dependencies together into a single
high-level feature;</div>
<div data-b="*">specifying packages that are recommended (or suggested) to be included by
users of the package; and</div>
<div data-b="*">including a feature (like <code>secure-password</code> in the motivating example) that
will only work if an optional dependency is available, and would be difficult
to implement as a separate package (for example, it may be overly difficult to
design an IO package to be completely decoupled from OpenSSL, with opt-in via
the inclusion of a separate package).</div>
<br>
<p>In almost all cases, it is an antipattern to use these features outside of
high-level packages that are designed for curation. If a feature is optional, it
can almost certainly be expressed as a separate package.</p>
<br>
<h3>The <code>[workspace]</code> section</h3>
<br>
<p>Projects can define a workspace which is a set of crates that will all share the
same <code>Cargo.lock</code> and output directory. The <code>[workspace]</code> table can be defined
as:</p>
<br>
<div data-lang="toml"><div data-l="[workspace]"></div><div data-l=""></div><div data-l="# Optional key, inferred from path dependencies if not present."></div><div data-l="# Additional non-path dependencies that should be included must be given here."></div><div data-l="# In particular, for a virtual manifest, all members have to be listed."></div><div data-l="members = [&quot;path/to/member1&quot;, &quot;path/to/member2&quot;, &quot;path/to/member3/*&quot;]"></div><div data-l=""></div><div data-l="# Optional key, empty if not present."></div><div data-l="exclude = [&quot;path1&quot;, &quot;path/to/dir2&quot;]"></div></div>
<br>
<p>Workspaces were added to Cargo as part of <a class="notranslate" href="#4RFC 1525">RFC 1525</a> and have a number of
properties:</p>
<br>
<div data-b="*">A workspace can contain multiple crates where one of them is the <i>root crate</i>.</div>
<div data-b="*">The <i>root crate</i>'s <code>Cargo.toml</code> contains the <code>[workspace]</code> table, but is not
required to have other configuration.</div>
<div data-b="*">Whenever any crate in the workspace is compiled, output is placed in the</div>
<p>  <i>workspace root</i>. i.e. next to the <i>root crate</i>'s <code>Cargo.toml</code>.
* The lock file for all crates in the workspace resides in the <i>workspace root</i>.
* The <code>[patch]</code>, <code>[replace]</code> and <code>[profile.*]</code> sections in <code>Cargo.toml</code>
  are only recognized
  in the <i>root crate</i>'s manifest, and ignored in member crates' manifests.</p>
<br>
<a class="notranslate" href="#1https://github.com/rust-lang/rfcs/blob/master/text/1525-cargo-workspace.md">RFC 1525</a>
<br>
<p>The <i>root crate</i> of a workspace, indicated by the presence of <code>[workspace]</code> in
its manifest, is responsible for defining the entire workspace. All <code>path</code>
dependencies residing in the workspace directory become members. You can add
additional packages to the workspace by listing them in the <code>members</code> key. Note
that members of the workspaces listed explicitly will also have their path
dependencies included in the workspace. Sometimes a project may have a lot of
workspace members and it can be onerous to keep up to date. The path dependency
can also use <a class="notranslate" href="#3globs">globs</a> to match multiple paths. Finally, the <code>exclude</code>
key can be used to blacklist paths from being included in a workspace. This can
be useful if some path dependencies aren't desired to be in the workspace at
all.</p>
<br>
<p>The <code>package.workspace</code> manifest key (described above) is used in member crates
to point at a workspace's root crate. If this key is omitted then it is inferred
to be the first crate whose manifest contains <code>[workspace]</code> upwards in the
filesystem.</p>
<br>
<p>A crate may either specify <code>package.workspace</code> or specify <code>[workspace]</code>. That
is, a crate cannot both be a root crate in a workspace (contain <code>[workspace]</code>)
and also be a member crate of another workspace (contain <code>package.workspace</code>).</p>
<br>
<p>Most of the time workspaces will not need to be dealt with as <code>cargo new</code> and
<code>cargo init</code> will handle workspace configuration automatically.</p>
<br>
<h4>Virtual Manifest</h4>
<br>
<p>In workspace manifests, if the <code>package</code> table is present, the workspace root
crate will be treated as a normal package, as well as a workspace. If the
<code>package</code> table is not present in a workspace manifest, it is called a <i>virtual
manifest</i>.</p>
<br>
<h4>Package selection</h4>
<br>
<p>In a workspace, package-related cargo commands like <code>cargo build</code> apply to
packages selected by <code>-p</code> / <code>--package</code> or <code>--all</code> command-line parameters.
When neither is specified, the optional <code>default-members</code> configuration is used:</p>
<br>
<div data-lang="toml"><div data-l="[workspace]"></div><div data-l="members = [&quot;path/to/member1&quot;, &quot;path/to/member2&quot;, &quot;path/to/member3/*&quot;]"></div><div data-l="default-members = [&quot;path/to/member2&quot;, &quot;path/to/member3/foo&quot;]"></div></div>
<br>
<p>When specified, <code>default-members</code> must expand to a subset of <code>members</code>.</p>
<br>
<p>When <code>default-members</code> is not specified, the default is the root manifest
if it is a package, or every member manifest (as if <code>--all</code> were specified
on the command-line) for virtual workspaces.</p>
<br>
<h3>The project layout</h3>
<br>
<p>If your project is an executable, name the main source file <code>src/main.rs</code>. If it
is a library, name the main source file <code>src/lib.rs</code>.</p>
<br>
<p>Cargo will also treat any files located in <code>src/bin/*.rs</code> as executables. If your
executable consists of more than just one source file, you might also use a directory
inside <code>src/bin</code> containing a <code>main.rs</code> file which will be treated as an executable
with a name of the parent directory.
Do note, however, once you add a <code>[[bin]]</code> section (<a class="notranslate" href="#2#configuring-a-target">see
below</a>), Cargo will no longer automatically build files
located in <code>src/bin/*.rs</code>.  Instead you must create a <code>[[bin]]</code> section for
each file you want to build.</p>
<br>
<p>Your project can optionally contain folders named <code>examples</code>, <code>tests</code>, and
<code>benches</code>, which Cargo will treat as containing examples,
integration tests, and benchmarks respectively. Analogous to <code>bin</code> targets, they
may be composed of single files or directories with a <code>main.rs</code> file.</p>
<br>
<div data-lang=""><div data-l="▾ src/           # directory containing source files"></div><div data-l="  lib.rs         # the main entry point for libraries and packages"></div><div data-l="  main.rs        # the main entry point for projects producing executables"></div><div data-l="  ▾ bin/         # (optional) directory containing additional executables"></div><div data-l="    *.rs"></div><div data-l="  ▾ */           # (optional) directories containing multi-file executables"></div><div data-l="    main.rs"></div><div data-l="▾ examples/      # (optional) examples"></div><div data-l="  *.rs"></div><div data-l="  ▾ */           # (optional) directories containing multi-file examples"></div><div data-l="    main.rs"></div><div data-l="▾ tests/         # (optional) integration tests"></div><div data-l="  *.rs"></div><div data-l="  ▾ */           # (optional) directories containing multi-file tests"></div><div data-l="    main.rs"></div><div data-l="▾ benches/       # (optional) benchmarks"></div><div data-l="  *.rs"></div><div data-l="  ▾ */           # (optional) directories containing multi-file benchmarks"></div><div data-l="    main.rs"></div></div>
<br>
<p>To structure your code after you've created the files and folders for your
project, you should remember to use Rust's module system, which you can read
about in <a href="#2https://doc.rust-lang.org/book/crates-and-modules.html">the book</a>.</p>
<br>
<h3>Examples</h3>
<br>
<p>Files located under <code>examples</code> are example uses of the functionality provided by
the library. When compiled, they are placed in the <code>target/examples</code> directory.</p>
<br>
<p>They can compile either as executables (with a <code>main()</code> function) or libraries
and pull in the library by using <code>extern crate &lt;library-name&gt;</code>. They are
compiled when you run your tests to protect them from bitrotting.</p>
<br>
<p>You can run individual executable examples with the command <code>cargo run --example
&lt;example-name&gt;</code>.</p>
<br>
<p>Specify <code>crate-type</code> to make an example be compiled as a library (additional
information about crate types is available in
<a href="#2https://doc.rust-lang.org/reference/linkage.html">The Rust Reference</a>):</p>
<br>
<div data-lang="toml"><div data-l="[[example]]"></div><div data-l="name = &quot;foo&quot;"></div><div data-l="crate-type = [&quot;staticlib&quot;]"></div></div>
<br>
<p>You can build individual library examples with the command <code>cargo build
--example &lt;example-name&gt;</code>.</p>
<br>
<h3>Tests</h3>
<br>
<p>When you run <code>cargo test</code>, Cargo will:</p>
<br>
<div data-b="*">compile and run your library’s unit tests, which are in the files reachable
from <code>lib.rs</code> (naturally, any sections marked with <code>#[cfg(test)]</code> will be
considered at this stage);</div>
<div data-b="*">compile and run your library’s documentation tests, which are embedded inside
of documentation blocks;</div>
<div data-b="*">compile and run your library’s <a href="#2#integration-tests">integration tests</a>; and</div>
<div data-b="*">compile your library’s examples.</div>
<br>
<h4>Integration tests</h4>
<br>
<p>Each file in <code>tests/*.rs</code> is an integration test. When you run <code>cargo test</code>,
Cargo will compile each of these files as a separate crate. The crate can link
to your library by using <code>extern crate &lt;library-name&gt;</code>, like any other code that
depends on it.</p>
<br>
<p>Cargo will not automatically compile files inside subdirectories of <code>tests</code>, but
an integration test can import modules from these directories as usual. For
example, if you want several integration tests to share some code, you can put
the shared code in <code>tests/common/mod.rs</code> and then put <code>mod common;</code> in each of
the test files.</p>
<br>
<h3>Configuring a target</h3>
<br>
<p>All of the  <code>[[bin]]</code>, <code>[lib]</code>, <code>[[bench]]</code>, <code>[[test]]</code>, and <code>[[example]]</code>
sections support similar configuration for specifying how a target should be
built. The double-bracket sections like <code>[[bin]]</code> are array-of-table of
<a class="notranslate" href="#2https://github.com/toml-lang/toml#array-of-tables">TOML</a>, which means you can
write more than one <code>[[bin]]</code> section to make several executables in your crate.</p>
<br>
<p>The example below uses <code>[lib]</code>, but it also applies to all other sections
as well. All values listed are the defaults for that option unless otherwise
specified.</p>
<br>
<div data-lang="toml"><div data-l="[package]"></div><div data-l="# ..."></div><div data-l=""></div><div data-l="[lib]"></div><div data-l="# The name of a target is the name of the library that will be generated. This"></div><div data-l="# is defaulted to the name of the package or project, with any dashes replaced"></div><div data-l="# with underscores. (Rust `extern crate` declarations reference this name;"></div><div data-l="# therefore the value must be a valid Rust identifier to be usable.)"></div><div data-l="name = &quot;foo&quot;"></div><div data-l=""></div><div data-l="# This field points at where the crate is located, relative to the `Cargo.toml`."></div><div data-l="path = &quot;src/lib.rs&quot;"></div><div data-l=""></div><div data-l="# A flag for enabling unit tests for this target. This is used by `cargo test`."></div><div data-l="test = true"></div><div data-l=""></div><div data-l="# A flag for enabling documentation tests for this target. This is only relevant"></div><div data-l="# for libraries, it has no effect on other sections. This is used by"></div><div data-l="# `cargo test`."></div><div data-l="doctest = true"></div><div data-l=""></div><div data-l="# A flag for enabling benchmarks for this target. This is used by `cargo bench`."></div><div data-l="bench = true"></div><div data-l=""></div><div data-l="# A flag for enabling documentation of this target. This is used by `cargo doc`."></div><div data-l="doc = true"></div><div data-l=""></div><div data-l="# If the target is meant to be a compiler plugin, this field must be set to true"></div><div data-l="# for Cargo to correctly compile it and make it available for all dependencies."></div><div data-l="plugin = false"></div><div data-l=""></div><div data-l="# If the target is meant to be a &quot;macros 1.1&quot; procedural macro, this field must"></div><div data-l="# be set to true."></div><div data-l="proc-macro = false"></div><div data-l=""></div><div data-l="# If set to false, `cargo test` will omit the `--test` flag to rustc, which"></div><div data-l="# stops it from generating a test harness. This is useful when the binary being"></div><div data-l="# built manages the test runner itself."></div><div data-l="harness = true"></div></div>
<br>
<p>The <code>[package]</code> also includes the optional <code>autobins</code>, <code>autoexamples</code>,
<code>autotests</code>, and <code>autobenches</code> keys to explicitly opt-in or opt-out of
auto-discovering specific target kinds.</p>
<br>
<h4>The <code>required-features</code> field (optional)</h4>
<br>
<p>The <code>required-features</code> field specifies which features the target needs in order
to be built. If any of the required features are not selected, the target will
be skipped. This is only relevant for the <code>[[bin]]</code>, <code>[[bench]]</code>, <code>[[test]]</code>,
and <code>[[example]]</code> sections, it has no effect on <code>[lib]</code>.</p>
<br>
<div data-lang="toml"><div data-l="[features]"></div><div data-l="# ..."></div><div data-l="postgres = []"></div><div data-l="sqlite = []"></div><div data-l="tools = []"></div><div data-l=""></div><div data-l="[[bin]]"></div><div data-l="# ..."></div><div data-l="required-features = [&quot;postgres&quot;, &quot;tools&quot;]"></div></div>
<br>
<h4>Building dynamic or static libraries</h4>
<br>
<p>If your project produces a library, you can specify which kind of library to
build by explicitly listing the library in your <code>Cargo.toml</code>:</p>
<br>
<div data-lang="toml"><div data-l="# ..."></div><div data-l=""></div><div data-l="[lib]"></div><div data-l="name = &quot;...&quot;"></div><div data-l="crate-type = [&quot;dylib&quot;] # could be `staticlib` as well"></div></div>
<br>
<p>The available options are <code>dylib</code>, <code>rlib</code>, <code>staticlib</code>, <code>cdylib</code>, and
<code>proc-macro</code>. You should only use this option in a project. Cargo will always
compile packages (dependencies) based on the requirements of the project that
includes them.</p>
<br>
<p>You can read more about the different crate types in the
<a href="#2https://doc.rust-lang.org/reference/linkage.html">Rust Reference Manual</a></p>
<br>
<h3>The <code>[patch]</code> Section</h3>
<br>
<p>This section of Cargo.toml can be used to <a href="#3replace">override dependencies</a> with
other copies. The syntax is similar to the <code>[dependencies]</code> section:</p>
<br>
<div data-lang="toml"><div data-l="[patch.crates-io]"></div><div data-l="foo = { git = 'https://github.com/example/foo' }"></div><div data-l="bar = { path = 'my/local/bar' }"></div><div data-l=""></div><div data-l="[dependencies.baz]"></div><div data-l="git = 'https://github.com/example/baz'"></div><div data-l=""></div><div data-l="[patch.'https://github.com/example/baz']"></div><div data-l="baz = { git = 'https://github.com/example/patched-baz', branch = 'my-branch' }"></div></div>
<br>
<p>The <code>[patch]</code> table is made of dependency-like sub-tables. Each key after
<code>[patch]</code> is a URL of the source that's being patched, or <code>crates-io</code> if
you're modifying the https://crates.io registry. In the example above
<code>crates-io</code> could be replaced with a git URL such as
<code>https://github.com/rust-lang-nursery/log</code>; the second <code>[patch]</code>
section in the example uses this to specify a source called <code>baz</code>.</p>
<br>
<p>Each entry in these tables is a normal dependency specification, the same as
found in the <code>[dependencies]</code> section of the manifest. The dependencies listed
in the <code>[patch]</code> section are resolved and used to patch the source at the
URL specified. The above manifest snippet patches the <code>crates-io</code> source (e.g.
crates.io itself) with the <code>foo</code> crate and <code>bar</code> crate. It also
patches the <code>https://github.com/example/baz</code> source with a <code>my-branch</code> that
comes from elsewhere.</p>
<br>
<p>Sources can be patched with versions of crates that do not exist, and they can
also be patched with versions of crates that already exist. If a source is
patched with a crate version that already exists in the source, then the
source's original crate is replaced.</p>
<br>
<p>More information about overriding dependencies can be found in the <a class="notranslate" href="#3replace">overriding
dependencies</a> section of the documentation and <a class="notranslate" href="#4RFC 1969">RFC 1969</a> for the
technical specification of this feature.</p>
<br>
<a class="notranslate" href="#1https://github.com/rust-lang/rfcs/pull/1969">RFC 1969</a>
<a class="notranslate" href="#1reference/specifying-dependencies.html#overriding-dependencies">replace</a>
<br>
<h3>The <code>[replace]</code> Section</h3>
<br>
<p>This section of Cargo.toml can be used to <a href="#3replace">override dependencies</a> with
other copies. The syntax is similar to the <code>[dependencies]</code> section:</p>
<br>
<div data-lang="toml"><div data-l="[replace]"></div><div data-l="&quot;foo:0.1.0&quot; = { git = 'https://github.com/example/foo' }"></div><div data-l="&quot;bar:1.0.2&quot; = { path = 'my/local/bar' }"></div></div>
<br>
<p>Each key in the <code>[replace]</code> table is a <a href="#2reference/pkgid-spec.html">package id
specification</a> which allows arbitrarily choosing a node in the
dependency graph to override. The value of each key is the same as the
<code>[dependencies]</code> syntax for specifying dependencies, except that you can't
specify features. Note that when a crate is overridden the copy it's overridden
with must have both the same name and version, but it can come from a different
source (e.g. git or a local path).</p>
<br>
<p>More information about overriding dependencies can be found in the <a class="notranslate" href="#3replace">overriding
dependencies</a> section of the documentation.</p>
<br>
<a class="notranslate" href="#1https://spdx.org/spdx-specification-21-web-version#h.jxpfx0ykyb60">spdx-2.1-license-expressions</a>
<a class="notranslate" href="#1https://spdx.org/licenses/">spdx-license-list</a>
<a class="notranslate" href="#1https://github.com/spdx/license-list-data/tree/v2.4">spdx-license-list-2.4</a>