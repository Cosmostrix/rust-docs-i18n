<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180723_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=faq.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhgQ4ezENlkxSVYGeAHMYQ9vf0ngJQ" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Frequently Asked Questions</span>よくある質問</span> </h2><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Is the plan to use GitHub as a package repository?</span> GitHubをパッケージリポジトリとして使用する予定ですか？</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">No. The plan for Cargo is to use <a class=notranslate href=#4crates.io>crates.io</a> , like npm or Rubygems do with npmjs.org and rubygems.org.</span>いいえ。貨物の計画は、npmやnpmjs.orgやrubygems.orgのような<a class=notranslate href=#4crates.io>crates.io</a>ように、 <a class=notranslate href=#4crates.io>crates.io</a>を使用することです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We plan to support git repositories as a source of packages forever, because they can be used for early development and temporary patches, even when people use the registry as the primary source of packages.</span> gitリポジトリは、レジストリをパッケージの主要なソースとして使用する場合でも、初期の開発や一時的なパッチとして使用できるので、パッケージのソースとして永続的にサポートする予定です。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Why build crates.io rather than use GitHub as a registry?</span>なぜレジストリとしてGitHubを使うのではなく、crates.ioをビルドするのですか？</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We think that it&#39;s very important to support multiple ways to download packages, including downloading from GitHub and copying packages into your project itself.</span>パッケージをダウンロードするには、GitHubからダウンロードしたり、パッケージをプロジェクト自体にコピーしたりするなど、複数の方法をサポートすることが非常に重要だと考えています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That said, we think that <a class=notranslate href=#4crates.io>crates.io</a> offers a number of important benefits, and will likely become the primary way that people download packages in Cargo.</span>つまり、 <a class=notranslate href=#4crates.io>crates.io</a>は多くの重要なメリットをもたらし、人々がカーゴでパッケージをダウンロードする主要な方法になると考えています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For precedent, both Node.js&#39;s <a class=notranslate href=#31>npm</a> and Ruby&#39;s <a class=notranslate href=#32>bundler</a> support both a central registry model as well as a Git-based model, and most packages are downloaded through the registry in those ecosystems, with an important minority of packages making use of git-based packages.</span>前例の場合、Node.jsの<a class=notranslate href=#31>npm</a>とRubyの両方の<a class=notranslate href=#32>bundler</a>は、セントラルレジストリモデルとGitベースモデルの両方をサポートしています。ほとんどのパッケージは、これらのエコシステムのレジストリを介してダウンロードされます。重要な少数のパッケージはgitベースパッケージ。</span> </p><br> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a class=notranslate href=#1https://www.npmjs.org>1</a> <a class=notranslate href=#1https://bundler.io>2</a></span> <a class=notranslate href=#1https://www.npmjs.org>1</a> <a class=notranslate href=#1https://bundler.io>2</a></span> <br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Some of the advantages that make a central registry popular in other languages include:</span>中央レジストリを他の言語で人気のあるものにする利点のいくつかは次のとおりです。</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><b>Discoverability</b> .</span> <b>発見可能性</b> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A central registry provides an easy place to look for existing packages.</span>中央レジストリは、既存のパッケージを探すための簡単な場所を提供します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Combined with tagging, this also makes it possible for a registry to provide ecosystem-wide information, such as a list of the most popular or most-depended-on packages.</span>タグ付けと組み合わせることで、レジストリは、最も一般的な、または最も依存しているパッケージのリストなど、エコシステム全体の情報を提供することも可能になります。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><b>Speed</b> .</span> <b>スピード</b> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A central registry makes it possible to easily fetch just the metadata for packages quickly and efficiently, and then to efficiently download just the published package, and not other bloat that happens to exist in the repository.</span>中央レジストリを使用すると、パッケージのメタデータだけを簡単かつ効率的に簡単にフェッチし、リポジトリに存在する膨大なものではなく、公開パッケージだけを効率的にダウンロードすることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This adds up to a significant improvement in the speed of dependency resolution and fetching.</span>これにより、依存関係の解決とフェッチの速度が大幅に向上します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As dependency graphs scale up, downloading all of the git repositories bogs down fast.</span>依存グラフが拡大するにつれて、すべてのgitリポジトリをダウンロードすることは急速に進まない。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Also remember that not everybody has a high-speed, low-latency Internet connection.</span>また、誰も高速で低遅延のインターネット接続を持っているわけではないことに注意してください。</span> </div><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Will Cargo work with C code (or other languages)?</span> Will CargoはCコード（または他の言語）で動作しますか？</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Yes!</span>はい！</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Cargo handles compiling Rust code, but we know that many Rust projects link against C code.</span>カーゴは錆コードを編集しますが、多くの錆プロジェクトはCコードとリンクしています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We also know that there are decades of tooling built up around compiling languages other than Rust.</span>また、Rust以外の言語のコンパイルには、何十年ものツールが蓄積されています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Our solution: Cargo allows a package to <a href=#2reference/build-scripts.html>specify a script</a> (written in Rust) to run before invoking <code>rustc</code> .</span>私たちのソリューション：Cargoでは、パッケージに<code>rustc</code>を呼び出す前に実行<a href=#2reference/build-scripts.html>するスクリプト</a> （Rustで書かれたもの）を<a href=#2reference/build-scripts.html>指定する</a>ことができ<a href=#2reference/build-scripts.html>ます</a> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust is leveraged to implement platform-specific configuration and refactor out common build functionality among packages.</span> Rustは、プラットフォーム固有の構成を実装し、パッケージ間で共通のビルド機能をリファクタリングするために活用されています。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Can Cargo be used inside of <code>make</code> (or <code>ninja</code> , or ...)</span>貨物を<code>make</code> （または<code>ninja</code> 、または...）の内部で使用することができます</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Indeed.</span>確かに。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">While we intend Cargo to be useful as a standalone way to compile Rust projects at the top-level, we know that some people will want to invoke Cargo from other build tools.</span> Cargoは、Rustプロジェクトを最上位レベルでコンパイルするためのスタンドアロンの方法として有用であると考えていますが、他のビルドツールからCargoを呼び出す人もいます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We have designed Cargo to work well in those contexts, paying attention to things like error codes and machine-readable output modes.</span>我々は、エラーコードや機械可読出力モードなどに注意を払って、これらのコンテキストでうまく動作するようにCargoを設計しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We still have some work to do on those fronts, but using Cargo in the context of conventional scripts is something we designed for from the beginning and will continue to prioritize.</span>これらの分野ではまだまだいくつかの作業がありますが、従来のスクリプトの文脈でCargoを使用することは、当初から設計したものであり、引き続き優先順位を決めることになります。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Does Cargo handle multi-platform projects or cross-compilation?</span> Cargoはマルチプラットフォームプロジェクトやクロスコンパイルを処理しますか？</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust itself provides facilities for configuring sections of code based on the platform.</span>錆そのものは、プラットフォームに基づいてコードのセクションを構成するための機能を提供します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Cargo also supports <a class=notranslate href=#3target-deps>platform-specific dependencies</a> , and we plan to support more per-platform configuration in <code>Cargo.toml</code> in the future.</span> Cargoは<a class=notranslate href=#3target-deps>platform-specific dependencies</a>もサポートしています。今後、 <code>Cargo.toml</code>でより多くのプラットフォームごとの設定をサポートする予定です。</span> </p><br> <a class=notranslate href=#1reference/specifying-dependencies.html#platform-specific-dependencies>target-deps</a> <br> <p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In the longer-term, we&#39;re looking at ways to conveniently cross-compile projects using Cargo.</span>長期的には、Cargoを使用してプロジェクトを簡単にクロスコンパイルする方法を検討しています。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Does Cargo support environments, like <code>production</code> or <code>test</code> ?</span> Cargoは、 <code>production</code>や<code>test</code>などの環境をサポートしていますか？</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We support environments through the use of <a class=notranslate href=#3profile>profiles</a> to support:</span>私たちは、 <a class=notranslate href=#3profile>profiles</a>を使用して環境をサポートします。</span> </p><br> <a class=notranslate href=#1reference/manifest.html#the-profile-sections>profile</a> <br> <div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">environment-specific flags (like <code>-g --opt-level=0</code> for development and <code>--opt-level=3</code> for production).</span>環境固有のフラグ（開発の場合は<code>-g --opt-level=0</code> 、プロダクションの場合は<code>--opt-level=3</code>など）。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">environment-specific dependencies (like <code>hamcrest</code> for test assertions).</span>環境特有の依存関係（テストアサーションの<code>hamcrest</code>など）</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">environment-specific <code>#[cfg]</code></span>環境固有の<code>#[cfg]</code></span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">a <code>cargo test</code> command</span> <code>cargo test</code>命令</span> </div><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Does Cargo work on Windows?</span> CargoはWindows上で動作しますか？</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Yes!</span>はい！</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">All commits to Cargo are required to pass the local test suite on Windows.</span> Cargoに対するすべてのコミットは、Windows上のローカルテストスイートに合格する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If, however, you find a Windows issue, we consider it a bug, so <a href=#33>please file an issue</a> .</span>ただし、Windowsの問題が見つかった場合は、バグとみなされ<a href=#33>ます</a>ので<a href=#33>、問題を提出し</a>て<a href=#33>ください</a> 。</span> </p><br> <a class=notranslate href=#1https://github.com/rust-lang/cargo/issues>3</a> <br> <h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Why do binaries have <code>Cargo.lock</code> in version control, but not libraries?</span>なぜバイナリはバージョン管理で<code>Cargo.lock</code>を持っていますが、ライブラリではありませんか？</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The purpose of a <code>Cargo.lock</code> is to describe the state of the world at the time of a successful build.</span> <code>Cargo.lock</code>の目的は、 <code>Cargo.lock</code>が成功したときの世界の状態を記述することです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It is then used to provide deterministic builds across whatever machine is building the project by ensuring that the exact same dependencies are being compiled.</span>まったく同じ依存関係がコンパイルされていることを確認することで、プロジェクトを構築しているマシンにかかわらず、確定的なビルドを提供するために使用されます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This property is most desirable from applications and projects which are at the very end of the dependency chain (binaries).</span>このプロパティは、依存関係チェインの最後にあるアプリケーションやプロジェクト（バイナリ）から最も望ましいものです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As a result, it is recommended that all binaries check in their <code>Cargo.lock</code> .</span>その結果、すべてのバイナリが<code>Cargo.lock</code>チェックインすることをお勧めします。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For libraries the situation is somewhat different.</span>図書館では状況が多少異なります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A library is not only used by the library developers, but also any downstream consumers of the library.</span>ライブラリは、ライブラリ開発者だけでなく、ライブラリのダウンストリームコンシューマによっても使用されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Users dependent on the library will not inspect the library&#39;s <code>Cargo.lock</code> (even if it exists).</span>ライブラリに依存するユーザーは、ライブラリの<code>Cargo.lock</code>検査しません（存在する場合でも）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is precisely because a library should <b>not</b> be deterministically recompiled for all users of the library.</span>これは、ライブラリのすべてのユーザに対して、ライブラリを確定的に再コンパイルしてはなら<b>ない</b>からです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If a library ends up being used transitively by several dependencies, it&#39;s likely that just a single copy of the library is desired (based on semver compatibility).</span>ライブラリがいくつかの依存関係によって過渡的に使用されると、（セーバーとの互換性に基づいて）ライブラリのコピーがほんの1つだけ必要になることがあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If Cargo used all of the dependencies&#39; <code>Cargo.lock</code> files, then multiple copies of the library could be used, and perhaps even a version conflict.</span> Cargoがすべての依存ファイルの<code>Cargo.lock</code>ファイルを使用していた場合、ライブラリの複数のコピーを使用することができ、バージョン間で競合する可能性もあります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In other words, libraries specify semver requirements for their dependencies but cannot see the full picture.</span>言い換えれば、ライブラリはその依存関係のためにセーバ要件を指定しますが、完全な画像を見ることはできません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Only end products like binaries have a full picture to decide what versions of dependencies should be used.</span>バイナリのような最終製品だけが、依存関係のどのバージョンを使用すべきかを決める完全な画像を持っています。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Can libraries use <code>*</code> as a version for their dependencies?</span>ライブラリは依存関係のバージョンとして<code>*</code>を使用できますか？</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><b>As of January 22nd, 2016, [crates.io] rejects all packages (not just libraries) with wildcard dependency constraints.</b></span> <b>2016年1月22日現在、[crates.io]はワイルドカード依存関係の制約を持つすべてのパッケージ（ライブラリだけでなく）を拒否します。</b></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">While libraries <s>can</s> , strictly speaking, they should not.</span>図書館<s>は</s> 、厳密に言えば、そうするべきではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A version requirement of <code>*</code> says “This will work with every version ever,” which is never going to be true.</span> <code>*</code>のバージョン要件は、「これはこれまでのすべてのバージョンで動作します」と言いますが、これは決して真実ではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Libraries should always specify the range that they do work with, even if it&#39;s something as general as “every 1.xy version.”</span>ライブラリは、「every 1.xyバージョン」のような一般的なものであっても、動作する範囲を常に指定する必要があります。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Why <code>Cargo.toml</code> ?</span>なぜ<code>Cargo.toml</code> ？</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As one of the most frequent interactions with Cargo, the question of why the configuration file is named <code>Cargo.toml</code> arises from time to time.</span> Cargoとの最も頻繁なやりとりの1つとして、設定ファイルの名前が<code>Cargo.toml</code>である理由は、 <code>Cargo.toml</code>発生します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The leading capital- <code>C</code> was chosen to ensure that the manifest was grouped with other similar configuration files in directory listings.</span>大文字の<code>C</code>は、マニフェストがディレクトリリスト内の他の同様の構成ファイルと確実にグループ化されるように選択されました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Sorting files often puts capital letters before lowercase letters, ensuring files like <code>Makefile</code> and <code>Cargo.toml</code> are placed together.</span>ファイルを並べ替えると、大文字が小文字の前に置かれ、 <code>Makefile</code>や<code>Cargo.toml</code>などのファイルが確実に配置されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The trailing <code>.toml</code> was chosen to emphasize the fact that the file is in the <a href=#2https://github.com/toml-lang/toml>TOML configuration format</a> .</span>末尾の<code>.toml</code>は、ファイルが<a href=#2https://github.com/toml-lang/toml>TOML構成形式</a>であることを強調するために選択されました。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Cargo does not allow other names such as <code>cargo.toml</code> or <code>Cargofile</code> to emphasize the ease of how a Cargo repository can be identified.</span>貨物では、 <code>cargo.toml</code>や<code>Cargofile</code>などの他の名前では、貨物保管庫の識別方法の容易さを強調することはできません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">An option of many possible names has historically led to confusion where one case was handled but others were accidentally forgotten.</span>考えられる多くの名前のオプションは、歴史的に、1つのケースが処理されたが、他のケースが誤って忘れられてしまった混乱につながっています。</span> </p><br> <a class=notranslate href=#1https://crates.io/>crates.io</a> <br> <h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">How can Cargo work offline?</span> Cargoはどのようにオフラインで動作しますか？</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Cargo is often used in situations with limited or no network access such as airplanes, CI environments, or embedded in large production deployments.</span>貨物は、飛行機、CI環境などのネットワークアクセスが限られているか、またはネットワークにアクセスできない状況、または大規模な運用環境に組み込まれている場合によく使用されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Users are often surprised when Cargo attempts to fetch resources from the network, and hence the request for Cargo to work offline comes up frequently.</span> Cargoがネットワークからリソースを取得しようとすると、ユーザーはしばしば驚いています。そのため、Cargoのオフライン作業の要求が頻繁に発生します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Cargo, at its heart, will not attempt to access the network unless told to do so.</span>カーゴは、そうしない限り、ネットワークにアクセスしようとしません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That is, if no crates comes from crates.io, a git repository, or some other network location, Cargo will never attempt to make a network connection.</span>つまり、crates.io、gitリポジトリ、または他のネットワークロケーションからのクレートがない場合、Cargoは決してネットワーク接続を試みません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As a result, if Cargo attempts to touch the network, then it&#39;s because it needs to fetch a required resource.</span>その結果、Cargoがネットワークにアクセスしようとすると、それは必要なリソースを取得する必要があるからです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Cargo is also quite aggressive about caching information to minimize the amount of network activity.</span>貨物はまた、ネットワーク活動の量を最小限に抑えるために情報をキャッシュすることに関してかなり積極的です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It will guarantee, for example, that if <code>cargo build</code> (or an equivalent) is run to completion then the next <code>cargo build</code> is guaranteed to not touch the network so long as <code>Cargo.toml</code> has not been modified in the meantime.</span>たとえば、 <code>cargo build</code> （またはそれに相当するもの）が完了<code>cargo build</code>と、その間に<code>Cargo.toml</code>が変更されていない限り、次の<code>cargo build</code>がネットワークに触れない<code>cargo build</code>が保証されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This avoidance of the network boils down to a <code>Cargo.lock</code> existing and a populated cache of the crates reflected in the lock file.</span>このネットワークの回避は、既存の<code>Cargo.lock</code>と、ロックファイルに反映されたクレートの読み込まれたキャッシュへと<code>Cargo.lock</code>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If either of these components are missing, then they&#39;re required for the build to succeed and must be fetched remotely.</span>これらのコンポーネントのいずれかが欠落している場合は、ビルドに成功するために必要であり、リモートからフェッチする必要があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As of Rust 1.11.0 Cargo understands a new flag, <code>--frozen</code> , which is an assertion that it shouldn&#39;t touch the network.</span>錆1.11.0のとおり貨物は新しいフラグ、理解<code>--frozen</code>それがネットワークに触れてはならないという主張です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When passed, Cargo will immediately return an error if it would otherwise attempt a network request.</span>通過すると、Cargoはネットワークリクエストを試みるとすぐにエラーを返します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The error should include contextual information about why the network request is being made in the first place to help debug as well.</span>このエラーには、デバッグにも役立つネットワーク要求が最初に行われた理由に関するコンテキスト情報が含まれている必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that this flag <i>does not change the behavior of Cargo</i> , it simply asserts that Cargo shouldn&#39;t touch the network as a previous command has been run to ensure that network activity shouldn&#39;t be necessary.</span>このフラグ<i>はCargoの動作を変更しないことに</i>注意してください。ネットワークアクティビティが不要であることを保証するために、以前のコマンドが実行されたときにCargoがネットワークに触れてはならないと主張します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For more information about vendoring, see documentation on <a class=notranslate href=#3replace>source replacement</a> .</span> vendoringの詳細については、上のドキュメントを参照<a class=notranslate href=#3replace>source replacement</a> 。</span> </p><br> <a class=notranslate href=#1reference/source-replacement.html>replace</a><script>_addload(function(){_setupIW('com');_csi('en','ja','faq.html');});</script>