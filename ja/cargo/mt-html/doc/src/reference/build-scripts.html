<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180723_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=build-scripts.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhgQ4ezENlkxSVYGeAHMYQ9vf0ngJQ" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Build Scripts</span>ビルドスクリプト</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Some packages need to compile third-party non-Rust code, for example C libraries.</span>パッケージによっては、サードパーティの非錆コード（例えば、Cライブラリ）をコンパイルする必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Other packages need to link to C libraries which can either be located on the system or possibly need to be built from source.</span>他のパッケージは、Cライブラリにリンクする必要があります.Cライブラリは、システム上にあるか、ソースからビルドする必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Others still need facilities for functionality such as code generation before building (think parser generators).</span>他にも、ビルド前のコード生成などの機能のための機能がまだ必要です（パーサー生成ツールを考える）。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Cargo does not aim to replace other tools that are well-optimized for these tasks, but it does integrate with them with the <code>build</code> configuration option.</span> Cargoは、これらのタスクに最適化された他のツールを置き換えることを目的としていませんが、 <code>build</code>構成オプション<code>build</code>使用してそれらと統合します。</span> </p><br><div data-lang=toml><div data-l=[package]></div><div data-l="# ..."></div><div data-l="build = &quot;build.rs&quot;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The Rust file designated by the <code>build</code> command (relative to the package root) will be compiled and invoked before anything else is compiled in the package, allowing your Rust code to depend on the built or generated artifacts.</span> <code>build</code>コマンドで指定されたRustファイル（パッケージのルートからの相対パス）はコン​​パイルされ、パッケージ内で他のものがコンパイルされる前に呼び出され、Rustコードはビルドされた成果物に依存します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">By default Cargo looks up for <code>&quot;build.rs&quot;</code> file in a package root (even if you do not specify a value for <code>build</code> ).</span>デフォルトでは、カーゴはパッケージルートの<code>&quot;build.rs&quot;</code>ファイルを<code>&quot;build.rs&quot;</code>ます（ <code>build</code>値を指定しなくても）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Use <code>build = &quot;custom_build_name.rs&quot;</code> to specify a custom build name or <code>build = false</code> to disable automatic detection of the build script.</span>ビルドスクリプトの自動検出を無効にするには、 <code>build = &quot;custom_build_name.rs&quot;</code>を使用<code>build = &quot;custom_build_name.rs&quot;</code>てカスタムビルド名を指定するか、 <code>build = false</code>を使用します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Some example use cases of the build command are:</span> buildコマンドの使用例は、次のとおりです。</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Building a bundled C library.</span>バンドルされたCライブラリの構築。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Finding a C library on the host system.</span>ホストシステム上のCライブラリの検索</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Generating a Rust module from a specification.</span>仕様から錆モジュールを生成する。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Performing any platform-specific configuration needed for the crate.</span>クレートに必要なプラットフォーム固有の設定を実行する。</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Each of these use cases will be detailed in full below to give examples of how the build command works.</span>これらのユースケースのそれぞれについて、ビルドコマンドの動作例を示すために以下に詳しく説明します。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Inputs to the Build Script</span>ビルドスクリプトへの入力</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When the build script is run, there are a number of inputs to the build script, all passed in the form of <a href=#3env>environment variables</a> .</span>ビルドスクリプトが実行されると、ビルドスクリプトへの入力が多数あり、すべてが<a href=#3env>環境変数の</a>形式で渡され<a href=#3env>ます</a> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In addition to environment variables, the build script&#39;s current directory is the source directory of the build script&#39;s package.</span>環境変数に加えて、ビルドスクリプトの現在のディレクトリは、ビルドスクリプトのパッケージのソースディレクトリです。</span> </p><br> <a class=notranslate href=#1reference/environment-variables.html>env</a> <br> <h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Outputs of the Build Script</span>ビルドスクリプトの出力</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">All the lines printed to stdout by a build script are written to a file like <code>target/debug/build/&lt;pkg&gt;/output</code> (the precise location may depend on your configuration).</span>ビルドスクリプトによってstdoutに出力されるすべての行は、 <code>target/debug/build/&lt;pkg&gt;/output</code>ようなファイルに書き込まれ<code>target/debug/build/&lt;pkg&gt;/output</code> （正確な場所は設定によって異なる場合があります）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you would like to see such output directly in your terminal, invoke cargo as &#39;very verbose&#39; with the <code>-vv</code> flag.</span>ターミナルでこのような出力を直接表示したい場合は、 <code>-vv</code>フラグを指定してcargoを &#39;非常に詳細に表示&#39;してください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that if neither the build script nor project source files are modified, subsequent calls to cargo with <code>-vv</code> will <b>not</b> print output to the terminal because a new build is not executed.</span>ビルド・スクリプトもプロジェクト・ソース・ファイルも変更されて<b>いない場合</b> 、新しいビルドが実行されないため、 <code>-vv</code>を使用したcargoへのその後の呼び出しでは、出力がターミナルに出力されません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Run <code>cargo clean</code> before each cargo invocation if you want to ensure that output is always displayed on your terminal.</span>あなたの端末に常に出力が表示されるようにするには、各貨物呼び出しの前に<code>cargo clean</code>にしてください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Any line that starts with <code>cargo:</code> is interpreted directly by Cargo.</span> <code>cargo:</code>で始まる行は、Cargoによって直接解釈されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This line must be of the form <code>cargo:key=value</code> , like the examples below:</span>この行は、以下の例のように、 <code>cargo:key=value</code>形式でなければなりません。</span> </p><br><div data-lang=""><div data-l="# specially recognized by Cargo"></div><div data-l=cargo:rustc-link-lib=static=foo></div><div data-l=cargo:rustc-link-search=native=/path/to/foo></div><div data-l=cargo:rustc-cfg=foo></div><div data-l=cargo:rustc-env=FOO=bar></div><div data-l="# arbitrary user-defined metadata"></div><div data-l=cargo:root=/path/to/foo></div><div data-l=cargo:libdir=/path/to/foo/lib></div><div data-l=cargo:include=/path/to/foo/include></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">On the other hand, lines printed to stderr are written to a file like <code>target/debug/build/&lt;pkg&gt;/stderr</code> but are not interpreted by cargo.</span>一方、stderrに出力された行は、 <code>target/debug/build/&lt;pkg&gt;/stderr</code>ようなファイルに書き込まれますが、貨物では解釈されません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There are a few special keys that Cargo recognizes, some affecting how the crate is built:</span> Cargoが認識するいくつかの特殊キーがあります。いくつかは、クレートの作成方法に影響を与えます。</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>rustc-link-lib=[KIND=]NAME</code> indicates that the specified value is a library name and should be passed to the compiler as a <code>-l</code> flag.</span> <code>rustc-link-lib=[KIND=]NAME</code>は、指定された値がライブラリ名であることを示し、 <code>-l</code>フラグとしてコンパイラに渡される必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The optional <code>KIND</code> can be one of <code>static</code> , <code>dylib</code> (the default), or <code>framework</code> , see <code>rustc --help</code> for more details.</span>オプションの<code>KIND</code>は、 <code>static</code> 、 <code>dylib</code> （デフォルト）、または<code>framework</code>いずれかになります。詳細については、 <code>rustc --help</code>を参照してください。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>rustc-link-search=[KIND=]PATH</code> indicates the specified value is a library search path and should be passed to the compiler as a <code>-L</code> flag.</span> <code>rustc-link-search=[KIND=]PATH</code>は指定された値がライブラリ検索パスであることを示し、 <code>-L</code>フラグとしてコンパイラに渡されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The optional <code>KIND</code> can be one of <code>dependency</code> , <code>crate</code> , <code>native</code> , <code>framework</code> or <code>all</code> (the default), see <code>rustc --help</code> for more details.</span>オプションの<code>KIND</code>は、 <code>dependency</code> 、 <code>crate</code> 、 <code>native</code> 、 <code>framework</code>または<code>all</code> （デフォルト）の<code>all</code>かになります。詳細は<code>rustc --help</code>を参照してください。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>rustc-flags=FLAGS</code> is a set of flags passed to the compiler, only <code>-l</code> and <code>-L</code> flags are supported.</span> <code>rustc-flags=FLAGS</code>は、コンパイラに渡されるフラグのセットです。 <code>rustc-flags=FLAGS</code> <code>-l</code>フラグと<code>-L</code>フラグだけがサポートされています。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>rustc-cfg=FEATURE</code> indicates that the specified feature will be passed as a <code>--cfg</code> flag to the compiler.</span> <code>rustc-cfg=FEATURE</code>は、指定された機能がコンパイラに<code>--cfg</code>フラグとして渡されることを示します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is often useful for performing compile-time detection of various features.</span>これは、さまざまな機能のコンパイル時検出を実行する場合に便利です。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>rustc-env=VAR=VALUE</code> indicates that the specified environment variable will be added to the environment which the compiler is run within.</span> <code>rustc-env=VAR=VALUE</code>は、指定された環境変数がコンパイラが実行される環境に追加されることを示します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The value can be then retrieved by the <code>env€</code> macro in the compiled crate.</span>コンパイルされたクレートの<code>env€</code>マクロによって値を取得できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is useful for embedding additional metadata in crate&#39;s code, such as the hash of Git HEAD or the unique identifier of a continuous integration server.</span>これは、Git HEADのハッシュや継続的インテグレーションサーバのユニークな識別子など、crateのコードに追加のメタデータを埋め込むのに便利です。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>rerun-if-changed=PATH</code> is a path to a file or directory which indicates that the build script should be re-run if it changes (detected by a more-recent last-modified timestamp on the file).</span> <code>rerun-if-changed=PATH</code>は、ビルドスクリプトが変更された場合（ファイルの最新の最後に変更されたタイムスタンプによって検出された場合）、ビルドスクリプトを再実行する必要があることを示すファイルまたはディレクトリへのパスです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Normally build scripts are re-run if any file inside the crate root changes, but this can be used to scope changes to just a small set of files.</span>クレートルート内のファイルが変更された場合、通常はビルドスクリプトが再実行されますが、これを使用して少数のファイルセットに対する変更をスコープできます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">(If this path points to a directory the entire directory will not be traversed for changes -- only changes to the timestamp of the directory itself (which corresponds to some types of changes within the directory, depending on platform) will trigger a rebuild. To request a re-run on any changes within an entire directory, print a line for the directory and another line for everything inside it, recursively.) Note that if the build script itself (or one of its dependencies) changes, then it&#39;s rebuilt and rerun unconditionally, so <code>cargo:rerun-if-changed=build.rs</code> is almost always redundant (unless you want to ignore changes in all other files except for <code>build.rs</code> ).</span> （このパスがディレクトリを指す場合、ディレクトリ全体が変更のためにトラバースされることはありません。ディレクトリ自体のタイムスタンプの変更のみです（プラットフォームによってはディレクトリ内の変更の一部に相当します）。ディレクトリ全体の変更を再実行するように要求し、ディレクトリの行を出力し、その中にあるすべての行を再帰的に出力します。）ビルドスクリプト自体（またはその依存関係の1つ）が変更された場合、無条件に再実行するので、 <code>cargo:rerun-if-changed=build.rs</code>はほとんど常に冗長です（ <code>build.rs</code>以外のすべてのファイルの変更を無視しない限り）。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>rerun-if-env-changed=VAR</code> is the name of an environment variable which indicates that if the environment variable&#39;s value changes the build script should be rerun.</span> <code>rerun-if-env-changed=VAR</code>は、環境変数の値が変更された場合にビルドスクリプトを再実行する必要があることを示す環境変数の名前です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This basically behaves the same as <code>rerun-if-changed</code> except that it works with environment variables instead.</span>これは基本的に、環境変数で代わりに動作する点を除いて、 <code>rerun-if-changed</code>と同じように動作します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that the environment variables here are intended for global environment variables like <code>CC</code> and such, it&#39;s not necessary to use this for env vars like <code>TARGET</code> that Cargo sets.</span>ここでの環境変数は、 <code>CC</code>などのグローバル環境変数を対象としているため、Cargoが設定する<code>TARGET</code>などのenv変数にはこれを使用する必要はありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Also note that if <code>rerun-if-env-changed</code> is printed out then Cargo will</span>また、 <code>rerun-if-env-changed</code>が出力された場合、Cargoは</span> </div><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><i>only</i> rerun the build script if those environment variables change or if files printed out by <code>rerun-if-changed</code> change.</span>それらの環境変数が変更された場合、または<code>rerun-if-changed</code>によって出力されたファイルが変更された場合に<i>のみ</i> 、ビルドスクリプトを再実行してください。</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>warning=MESSAGE</code> is a message that will be printed to the main console after a build script has finished running.</span> <code>warning=MESSAGE</code>は、ビルドスクリプトの実行が終了した後にメインコンソールに出力されるメッセージです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Warnings are only shown for path dependencies (that is, those you&#39;re working on locally), so for example warnings printed out in crates.io crates are not emitted by default.</span>警告はパスの依存関係（つまり、ローカルで作業しているもの）に対してのみ表示されるため、たとえばcrates.ioで出力された警告はデフォルトでは出力されません。</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Any other element is a user-defined metadata that will be passed to dependents.</span>その他の要素は、扶養家族に渡されるユーザー定義のメタデータです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">More information about this can be found in the <a class=notranslate href=#3links><code>links</code></a> section.</span>これに関する詳細は、 <a class=notranslate href=#3links><code>links</code></a>セクションを参照してください。</span> </p><br> <a class=notranslate href=#1#the-links-manifest-key>links</a> <br> <h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Build Dependencies</span>依存関係を構築する</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Build scripts are also allowed to have dependencies on other Cargo-based crates.</span>ビルドスクリプトは、他のCargoベースのクレートに依存することも許可されています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Dependencies are declared through the <code>build-dependencies</code> section of the manifest.</span>依存関係は、マニフェストの<code>build-dependencies</code>セクションを通じて宣言されます。</span> </p><br><div data-lang=toml><div data-l=[build-dependencies]></div><div data-l="foo = { git = &quot;https://github.com/your-packages/foo&quot; }"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The build script <b>does not</b> have access to the dependencies listed in the <code>dependencies</code> or <code>dev-dependencies</code> section (they&#39;re not built yet!).</span>ビルドスクリプト<b>は</b> 、 <code>dependencies</code>や<code>dev-dependencies</code>セクションにある<code>dependencies</code>関係にアクセスすることはできません（まだビルドされていません！）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">All build dependencies will also not be available to the package itself unless explicitly stated as so.</span>明示的に述べられていない限り、ビルドの依存関係もすべてパッケージ自体で使用できません。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>links</code> Manifest Key</span> <code>links</code>マニフェストキー</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In addition to the manifest key <code>build</code> , Cargo also supports a <code>links</code> manifest key to declare the name of a native library that is being linked to:</span>マニフェストキー<code>build</code>加えて、Cargoは<code>links</code>されているネイティブライブラリの名前を宣言するための<code>links</code>マニフェストキーもサポートしてい<code>links</code> 。</span> </p><br><div data-lang=toml><div data-l=[package]></div><div data-l="# ..."></div><div data-l="links = &quot;foo&quot;"></div><div data-l="build = &quot;build.rs&quot;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This manifest states that the package links to the <code>libfoo</code> native library, and it also has a build script for locating and/or building the library.</span>このマニフェストでは、パッケージが<code>libfoo</code>ネイティブライブラリにリンクしており、ライブラリの<code>libfoo</code>やビルドのためのビルドスクリプトも含まれています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Cargo requires that a <code>build</code> command is specified if a <code>links</code> entry is also specified.</span> Cargoでは、 <code>links</code>エントリも指定されている場合は、 <code>build</code>コマンドを指定<code>build</code>必要があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The purpose of this manifest key is to give Cargo an understanding about the set of native dependencies that a package has, as well as providing a principled system of passing metadata between package build scripts.</span>このマニフェストキーの目的は、パッケージが持つ固有の依存関係のセットを理解し、パッケージビルドスクリプト間でメタデータを渡すという原則的なシステムを提供することです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Primarily, Cargo requires that there is at most one package per <code>links</code> value.</span>主に、Cargoでは<code>links</code>ごとに最大で1つのパッケージが必要です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In other words, it&#39;s forbidden to have two packages link to the same native library.</span>つまり、2つのパッケージを同じネイティブライブラリにリンクさせることは禁じられています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note, however, that there are <a href=#3star-sys>conventions in place</a> to alleviate this.</span>ただし、これを軽減するための<a href=#3star-sys>慣習</a>があることに注意してください。</span> </p><br> <a class=notranslate href=#1#a-sys-packages>star-sys</a> <br> <p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As mentioned above in the output format, each build script can generate an arbitrary set of metadata in the form of key-value pairs.</span>出力フォーマットで前述したように、各ビルドスクリプトは、キーと値のペアの形式で任意のメタデータセットを生成できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This metadata is passed to the build scripts of <b>dependent</b> packages.</span>このメタデータは、 <b>依存</b>パッケージのビルドスクリプトに渡されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, if <code>libbar</code> depends on <code>libfoo</code> , then if <code>libfoo</code> generates <code>key=value</code> as part of its metadata, then the build script of <code>libbar</code> will have the environment variables <code>DEP_FOO_KEY=value</code> .</span>たとえば、 <code>libbar</code>依存する<code>libfoo</code>場合、 <code>libfoo</code>発生し<code>key=value</code>そのメタデータの一部として、その後のビルドスクリプト<code>libbar</code> 、環境変数を持つことになります<code>DEP_FOO_KEY=value</code> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that metadata is only passed to immediate dependents, not transitive dependents.</span>メタデータは、過渡的な扶養家族ではなく、直接の扶養家族に渡されることに注意してください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The motivation for this metadata passing is outlined in the linking to system libraries case study below.</span>このメタデータパッシングの動機は、以下の「システムライブラリへのリンク」のケーススタディに概説されています。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Overriding Build Scripts</span>ビルドスクリプトのオーバーライド</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If a manifest contains a <code>links</code> key, then Cargo supports overriding the build script specified with a custom library.</span>マニフェストに<code>links</code>キーが含まれている場合、Cargoはカスタムライブラリで指定されたビルドスクリプトのオーバーライドをサポートしています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The purpose of this functionality is to prevent running the build script in question altogether and instead supply the metadata ahead of time.</span>この機能の目的は、問題のビルドスクリプトの実行を防ぎ、その代わりにメタデータを事前に提供することです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To override a build script, place the following configuration in any acceptable Cargo <a href=#2reference/config.html>configuration location</a> .</span>ビルドスクリプトをオーバーライドするには、受け入れ可能なCargo <a href=#2reference/config.html>構成の場所に</a>次の構成を<a href=#2reference/config.html>配置します</a> 。</span> </p><br><div data-lang=toml><div data-l=[target.x86_64-unknown-linux-gnu.foo]></div><div data-l="rustc-link-search = [&quot;/path/to/foo&quot;]"></div><div data-l="rustc-link-lib = [&quot;foo&quot;]"></div><div data-l="root = &quot;/path/to/foo&quot;"></div><div data-l="key = &quot;value&quot;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This section states that for the target <code>x86_64-unknown-linux-gnu</code> the library named <code>foo</code> has the metadata specified.</span>このセクションでは、ターゲット<code>x86_64-unknown-linux-gnu</code> 、 <code>foo</code>という名前のライブラリにメタデータが指定されていることを示しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This metadata is the same as the metadata generated as if the build script had run, providing a number of key/value pairs where the <code>rustc-flags</code> , <code>rustc-link-search</code> , and <code>rustc-link-lib</code> keys are slightly special.</span>このメタデータは、ビルドスクリプトが実行されたかのように生成されたメタデータと同じで、 <code>rustc-flags</code> 、 <code>rustc-link-search</code> 、および<code>rustc-link-lib</code>キーがわずかに特殊な多数のキーと値のペアを提供します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">With this configuration, if a package declares that it links to <code>foo</code> then the build script will <b>not</b> be compiled or run, and the metadata specified will instead be used.</span>この構成では、パッケージが<code>foo</code>にリンクすると宣言した場合、ビルドスクリプトはコンパイルまたは実行され<b>ず</b> 、指定されたメタデータが代わりに使用されます。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Case study: Code generation</span>ケーススタディ：コード生成</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Some Cargo packages need to have code generated just before they are compiled for various reasons.</span>いくつかの貨物パッケージは、さまざまな理由でコンパイルされる直前にコードを生成する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here we&#39;ll walk through a simple example which generates a library call as part of the build script.</span>ここでは、ビルドスクリプトの一部としてライブラリ呼び出しを生成する簡単な例を説明します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">First, let&#39;s take a look at the directory structure of this package:</span>まず、このパッケージのディレクトリ構造を見てみましょう：</span> </p><br><div data-lang=""><div data-l=.></div><div data-l="├── Cargo.toml"></div><div data-l="├── build.rs"></div><div data-l="└── src"></div><div data-l="    └── main.rs"></div><div data-l=""></div><div data-l="1 directory, 3 files"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here we can see that we have a <code>build.rs</code> build script and our binary in <code>main.rs</code> .</span>ここで、 <code>build.rs</code>ビルドスクリプトとバイナリがあることが<code>main.rs</code>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Next, let&#39;s take a look at the manifest:</span>次に、マニフェストを見てみましょう：</span> </p><br><div data-lang=toml><div data-l="# Cargo.toml"></div><div data-l=""></div><div data-l=[package]></div><div data-l="name = &quot;hello-from-generated-code&quot;"></div><div data-l="version = &quot;0.1.0&quot;"></div><div data-l="authors = [&quot;you@example.com&quot;]"></div><div data-l="build = &quot;build.rs&quot;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here we can see we&#39;ve got a build script specified which we&#39;ll use to generate some code.</span>ここでは、いくつかのコードを生成するために使用するビルドスクリプトが指定されていることがわかります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s see what&#39;s inside the build script:</span>ビルドスクリプトの内容を見てみましょう：</span> </p><br><div data-lang=rust,no_run><div data-l="#// build.rs"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">build.rs</span> build.rs</span> </div><div data-l=""></div><div data-l="use std::env;"></div><div data-l="use std::fs::File;"></div><div data-l="use std::io::Write;"></div><div data-l="use std::path::Path;"></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let out_dir = env::var(&quot;OUT_DIR&quot;).unwrap();"></div><div data-l="    let dest_path = Path::new(&amp;out_dir).join(&quot;hello.rs&quot;);"></div><div data-l="    let mut f = File::create(&amp;dest_path).unwrap();"></div><div data-l=""></div><div data-l="    f.write_all(b&quot;"></div><div data-l="        pub fn message() -&gt; &amp;'static str {"></div><div data-l="            \&quot;Hello, World!\&quot;"></div><div data-l="        }"></div><div data-l="    &quot;).unwrap();"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There&#39;s a couple of points of note here:</span>ここにいくつかの注意点があります：</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The script uses the <code>OUT_DIR</code> environment variable to discover where the output files should be located.</span>このスクリプトは、 <code>OUT_DIR</code>環境変数を使用して、出力ファイルの場所を検出します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It can use the process&#39; current working directory to find where the input files should be located, but in this case we don&#39;t have any input files.</span>プロセスの現在の作業ディレクトリを使用して入力ファイルの場所を見つけることができますが、この場合は入力ファイルがありません。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In general, build scripts should not modify any files outside of <code>OUT_DIR</code> .</span>一般に、ビルドスクリプトは<code>OUT_DIR</code>外部のファイルを変更すべきではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It may seem fine on the first blush, but it does cause problems when you use such crate as a dependency, because there&#39;s an <i>implicit</i> invariant that sources in <code>.cargo/registry</code> should be immutable.</span>最初のブラッシュではうまく見えるかもしれませんが、依存関係としてこのような枠を使用すると問題が発生します。なぜなら、 <code>.cargo/registry</code>ソースは不変でなければならないという<i>暗黙の</i>不変量があるからです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>cargo</code> won&#39;t allow such scripts when packaging.</span> <code>cargo</code>は梱包する際にそのようなスクリプトを許可しません。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This script is relatively simple as it just writes out a small generated file.</span>このスクリプトは、小さな生成ファイルを書き出すだけで比較的簡単です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">One could imagine that other more fanciful operations could take place such as generating a Rust module from a C header file or another language definition, for example.</span>たとえば、Cヘッダファイルや別の言語定義からRustモジュールを生成するなど、他のより奇妙な操作が行われる可能性があると想像できます。</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Next, let&#39;s peek at the library itself:</span>次に、図書館自体を見てみましょう：</span> </p><br><div data-lang=rust,ignore><div data-l="#// src/main.rs"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">src/main.rs</span> src / main.rs</span> </div><div data-l=""></div><div data-l="include!(concat!(env!(&quot;OUT_DIR&quot;), &quot;/hello.rs&quot;));"></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    println!(&quot;{}&quot;, message());"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is where the real magic happens.</span>これが真の魔法が起こる場所です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The library is using the rustc-defined <code>include€</code> macro in combination with the <code>concat€</code> and <code>env€</code> macros to include the generated file ( <code>hello.rs</code> ) into the crate&#39;s compilation.</span>ライブラリは、生成されたファイル（ <code>hello.rs</code> ）をクレートのコンパイルにインクルードするために、 <code>concat€</code>された<code>include€</code>マクロとコンカチュアルマクロおよび<code>env€</code>マクロを組み合わせて使用​​しています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Using the structure shown here, crates can include any number of generated files from the build script itself.</span>ここに示す構造を使用すると、クレートにはビルドスクリプト自体から生成された任意の数のファイルを含めることができます。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Case study: Building some native code</span>ケーススタディ：ネイティブコードの構築</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Sometimes it&#39;s necessary to build some native C or C++ code as part of a package.</span>パッケージの一部としてネイティブのCまたはC ++コードを構築する必要があることがあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is another excellent use case of leveraging the build script to build a native library before the Rust crate itself.</span>これは、ビルドスクリプトを利用してRustクレート自体の前にネイティブライブラリを構築する優れた使用例です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As an example, we&#39;ll create a Rust library which calls into C to print “Hello, World!”.</span>例として、 &quot;Hello、World！&quot;を印刷するためにCを呼び出すRustライブラリを作成します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Like above, let&#39;s first take a look at the project layout:</span>上記のように、まずプロジェクトのレイアウトを見てみましょう：</span> </p><br><div data-lang=""><div data-l=.></div><div data-l="├── Cargo.toml"></div><div data-l="├── build.rs"></div><div data-l="└── src"></div><div data-l="    ├── hello.c"></div><div data-l="    └── main.rs"></div><div data-l=""></div><div data-l="1 directory, 4 files"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Pretty similar to before!</span>以前とかなり似ています！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Next, the manifest:</span>次に、マニフェスト：</span> </p><br><div data-lang=toml><div data-l="# Cargo.toml"></div><div data-l=""></div><div data-l=[package]></div><div data-l="name = &quot;hello-world-from-c&quot;"></div><div data-l="version = &quot;0.1.0&quot;"></div><div data-l="authors = [&quot;you@example.com&quot;]"></div><div data-l="build = &quot;build.rs&quot;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For now we&#39;re not going to use any build dependencies, so let&#39;s take a look at the build script now:</span>現時点では、ビルドの依存関係は使用しないので、ここでビルドスクリプトを見てみましょう：</span> </p><br><div data-lang=rust,no_run><div data-l="#// build.rs"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">build.rs</span> build.rs</span> </div><div data-l=""></div><div data-l="use std::process::Command;"></div><div data-l="use std::env;"></div><div data-l="use std::path::Path;"></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let out_dir = env::var(&quot;OUT_DIR&quot;).unwrap();"></div><div data-l=""></div><div data-l="#    // note that there are a number of downsides to this approach, the comments"></div><div data-l="#    // below detail how to improve the portability of these commands."></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">note that there are a number of downsides to this approach, the comments below detail how to improve the portability of these commands.</span>このアプローチにはいくつかの欠点があることに注意してください。以下のコメントでは、これらのコマンドの移植性を向上させる方法を詳しく説明します。</span> </div><div data-l="    Command::new(&quot;gcc&quot;).args(&amp;[&quot;src/hello.c&quot;, &quot;-c&quot;, &quot;-fPIC&quot;, &quot;-o&quot;])"></div><div data-l="                       .arg(&amp;format!(&quot;{}/hello.o&quot;, out_dir))"></div><div data-l="                       .status().unwrap();"></div><div data-l="    Command::new(&quot;ar&quot;).args(&amp;[&quot;crus&quot;, &quot;libhello.a&quot;, &quot;hello.o&quot;])"></div><div data-l="                      .current_dir(&amp;Path::new(&amp;out_dir))"></div><div data-l="                      .status().unwrap();"></div><div data-l=""></div><div data-l="    println!(&quot;cargo:rustc-link-search=native={}&quot;, out_dir);"></div><div data-l="    println!(&quot;cargo:rustc-link-lib=static=hello&quot;);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This build script starts out by compiling our C file into an object file (by invoking <code>gcc</code> ) and then converting this object file into a static library (by invoking <code>ar</code> ).</span>このビルドスクリプトは、Cファイルをオブジェクトファイルにコンパイルし（ <code>gcc</code>を呼び出して）、このオブジェクトファイルを（ <code>ar</code>を呼び出して）静的ライブラリに変換することから始まります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The final step is feedback to Cargo itself to say that our output was in <code>out_dir</code> and the compiler should link the crate to <code>libhello.a</code> statically via the <code>-l static=hello</code> flag.</span>最後のステップは、Cargo自身へのフィードバックで、私たちの出力は<code>out_dir</code>あり、コンパイラは<code>-l static=hello</code>フラグを介して<code>libhello.a</code>にクレートを静的にリンクする必要があると言います。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that there are a number of drawbacks to this hardcoded approach:</span>このハードコーディングされたアプローチには多くの欠点があることに注意してください。</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>gcc</code> command itself is not portable across platforms.</span> <code>gcc</code>コマンド自体は、プラットフォーム間で移植できません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example it&#39;s unlikely that Windows platforms have <code>gcc</code> , and not even all Unix platforms may have <code>gcc</code> .</span>たとえば、Windowsプラットフォームに<code>gcc</code>があることはまずありませんし、すべてのUnixプラットフォームで<code>gcc</code>使用できるわけではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>ar</code> command is also in a similar situation.</span> <code>ar</code>コマンドも同様の状況にあります。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These commands do not take cross-compilation into account.</span>これらのコマンドはクロスコンパイルを考慮していません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we&#39;re cross compiling for a platform such as Android it&#39;s unlikely that <code>gcc</code> will produce an ARM executable.</span> Androidなどのプラットフォーム用にクロスコンパイルすると、 <code>gcc</code>がARM実行可能ファイルを生成することはありません。</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Not to fear, though, this is where a <code>build-dependencies</code> entry would help!</span>しかし、恐れてはいけませんが、これは<code>build-dependencies</code>エントリが助けになる場所です！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The Cargo ecosystem has a number of packages to make this sort of task much easier, portable, and standardized.</span> Cargoエコシステムには、この種のタスクをはるかに簡単に、ポータブルに、標準化するための多数のパッケージがあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, the build script could be written as:</span>たとえば、ビルドスクリプトは次のように記述できます。</span> </p><br><div data-lang=rust,ignore><div data-l="#// build.rs"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">build.rs</span> build.rs</span> </div><div data-l=""></div><div data-l="#// Bring in a dependency on an externally maintained `cc` package which manages"></div><div data-l="#// invoking the C compiler."></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Bring in a dependency on an externally maintained <code>cc</code> package which manages invoking the C compiler.</span> Cコンパイラの呼び出しを管理する、外部でメンテナンスされている<code>cc</code>パッケージへの依存をもたらします。</span> </div><div data-l="extern crate cc;"></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    cc::Build::new()"></div><div data-l="        .file(&quot;src/hello.c&quot;)"></div><div data-l="        .compile(&quot;hello&quot;);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Add a build time dependency on the <code>cc</code> crate with the following addition to your <code>Cargo.toml</code> :</span>上のビルド時の依存関係を追加し<code>cc</code>あなたに以下を加えてクレート<code>Cargo.toml</code> ：</span> </p><br><div data-lang=toml><div data-l=[build-dependencies]></div><div data-l="cc = &quot;1.0&quot;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <a href=#2https://crates.io/crates/cc><code>cc</code> crate</a> abstracts a range of build script requirements for C code:</span> <a href=#2https://crates.io/crates/cc><code>cc</code>クラットは</a> 、Cコードの一連のビルドスクリプト要件を抽象化しています。</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It invokes the appropriate compiler (MSVC for windows, <code>gcc</code> for MinGW, <code>cc</code> for Unix platforms, etc.).</span>適切なコンパイラ（Windowsの場合はMSVC、MinGWの場合は<code>gcc</code> 、Unixプラットフォームの場合は<code>cc</code>など）を呼び出します。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It takes the <code>TARGET</code> variable into account by passing appropriate flags to the compiler being used.</span>使用されているコンパイラに適切なフラグを渡すことによって、 <code>TARGET</code>変数が考慮されます。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Other environment variables, such as <code>OPT_LEVEL</code> , <code>DEBUG</code> , etc., are all handled automatically.</span> <code>OPT_LEVEL</code> 、 <code>DEBUG</code>などの他の環境変数はすべて自動的に処理されます。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The stdout output and <code>OUT_DIR</code> locations are also handled by the <code>cc</code> library.</span> stdoutの出力と<code>OUT_DIR</code>位置は、 <code>cc</code>ライブラリによっても処理されます。</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here we can start to see some of the major benefits of farming as much functionality as possible out to common build dependencies rather than duplicating logic across all build scripts!</span>ここでは、すべてのビルドスクリプトでロジックを複製するのではなく、一般的なビルドの依存関係になるべく多くの機能を農業の主要な利点の一部として見ていきます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Back to the case study though, let&#39;s take a quick look at the contents of the <code>src</code> directory:</span>ケーススタディに戻ると、 <code>src</code>ディレクトリの内容を簡単に見てみましょう：</span> </p><br><div data-lang=c><div data-l="#// src/hello.c"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">src/hello.c</span> src / hello.c</span> </div><div data-l=""></div><div data-l="#include &lt;stdio.h&gt;"></div><div data-l=""></div><div data-l="void hello() {"></div><div data-l="    printf(&quot;Hello, World!\n&quot;);"></div><div data-l=}></div></div><br><div data-lang=rust,ignore><div data-l="#// src/main.rs"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">src/main.rs</span> src / main.rs</span> </div><div data-l=""></div><div data-l="#// Note the lack of the `#[link]` attribute. We’re delegating the responsibility"></div><div data-l="#// of selecting what to link to over to the build script rather than hardcoding"></div><div data-l="#// it in the source file."></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note the lack of the <code>#[link]</code> attribute.</span> <code>#[link]</code>属性がないことに注意してください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;re delegating the responsibility of selecting what to link to over to the build script rather than hardcoding it in the source file.</span>私たちは、ソースファイルでハードコーディングするのではなく、ビルドスクリプトにリンクするものを選択する責任を委任しています。</span> </div><div data-l="extern { fn hello(); }"></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    unsafe { hello(); }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">And there we go!</span>そしてそこに行く！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This should complete our example of building some C code from a Cargo package using the build script itself.</span>これは、ビルドスクリプトを使用してCargoパッケージからCコードを構築する例を完成させるはずです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This also shows why using a build dependency can be crucial in many situations and even much more concise!</span>これはまた、ビルドの依存関係を使用することが、多くの状況において重要であり、さらにはるかに簡潔になる理由を示しています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ve also seen a brief example of how a build script can use a crate as a dependency purely for the build process and not for the crate itself at runtime.</span>また、ビルドスクリプトが実行時にクレート自体ではなくビルドプロセスの依存関係としてクレートを使用する方法の簡単な例も見てきました。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Case study: Linking to system libraries</span>ケーススタディ：システムライブラリへのリンク</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The final case study here will be investigating how a Cargo library links to a system library and how the build script is leveraged to support this use case.</span>最後のケーススタディは、カーゴライブラリがシステムライブラリにどのようにリンクしているか、ビルドスクリプトがこのユースケースをサポートするためにどのように活用されているかを調べることです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Quite frequently a Rust crate wants to link to a native library often provided on the system to bind its functionality or just use it as part of an implementation detail.</span>非常に頻繁にRustの箱は、その機能をバインドするか、単に実装の詳細の一部として使用するために、しばしばシステム上で提供されるネイティブライブラリにリンクしたいと考えています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is quite a nuanced problem when it comes to performing this in a platform-agnostic fashion, and the purpose of a build script is again to farm out as much of this as possible to make this as easy as possible for consumers.</span>これはプラットフォームにとらわれない方法でこれを実行する場合には非常に微妙な問題です。また、ビルドスクリプトの目的は、これを可能な限り簡単にして消費者にとってできるだけ簡単にすることです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As an example to follow, let&#39;s take a look at one of <a href=#3git2-rs>Cargo&#39;s own dependencies</a> , <a class=notranslate href=#3libgit2>libgit2</a> .</span>例として、 <a href=#3git2-rs>Cargo自身の依存関係の</a> 1つ<a class=notranslate href=#3libgit2>libgit2</a>見てみましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The C library has a number of constraints:</span> Cライブラリにはいくつかの制約があります。</span> </p><br> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a class=notranslate href=#1https://github.com/alexcrichton/git2-rs/tree/master/libgit2-sys>git2-rs</a> <a class=notranslate href=#1https://github.com/libgit2/libgit2>libgit2</a></span> <a class=notranslate href=#1https://github.com/alexcrichton/git2-rs/tree/master/libgit2-sys>git2-rs</a> <a class=notranslate href=#1https://github.com/libgit2/libgit2>libgit2</a></span> <br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It has an optional dependency on OpenSSL on Unix to implement the https transport.</span> https転送を実装するためにUnix上のOpenSSLに依存するオプションがあります。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It has an optional dependency on libssh2 on all platforms to implement the ssh transport.</span> sshトランスポートを実装するために、すべてのプラットフォーム上のlibssh2にオプションで依存します。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It is often not installed on all systems by default.</span>多くの場合、デフォルトではすべてのシステムにインストールされません。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It can be built from source using <code>cmake</code> .</span> <code>cmake</code>を使ってソースから構築することができます。</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To visualize what&#39;s going on here, let&#39;s take a look at the manifest for the relevant Cargo package that links to the native C library.</span>ここで何が起きているのかを視覚化するために、ネイティブCライブラリにリンクする関連するCargoパッケージのマニフェストを見てみましょう。</span> </p><br><div data-lang=toml><div data-l=[package]></div><div data-l="name = &quot;libgit2-sys&quot;"></div><div data-l="version = &quot;0.1.0&quot;"></div><div data-l="authors = [&quot;...&quot;]"></div><div data-l="links = &quot;git2&quot;"></div><div data-l="build = &quot;build.rs&quot;"></div><div data-l=""></div><div data-l=[dependencies]></div><div data-l="libssh2-sys = { git = &quot;https://github.com/alexcrichton/ssh2-rs&quot; }"></div><div data-l=""></div><div data-l="[target.'cfg(unix)'.dependencies]"></div><div data-l="openssl-sys = { git = &quot;https://github.com/alexcrichton/openssl-sys&quot; }"></div><div data-l=""></div><div data-l="# ..."></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As the above manifests show, we&#39;ve got a <code>build</code> script specified, but it&#39;s worth noting that this example has a <code>links</code> entry which indicates that the crate ( <code>libgit2-sys</code> ) links to the <code>git2</code> native library.</span>上記のマニフェストが示しているように、 <code>build</code>スクリプトが指定されてい<code>links</code>が、この例には<code>libgit2-sys</code> （ <code>libgit2-sys</code> ）が<code>git2</code>ネイティブライブラリにリンクしていることを示す<code>links</code>エントリがあります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here we also see that we chose to have the Rust crate have an unconditional dependency on <code>libssh2</code> via the <code>libssh2-sys</code> crate, as well as a platform-specific dependency on <code>openssl-sys</code> for \ <i>nix (other variants elided for now).</i></span>ここで我々はまた、我々は錆のクレートがオンに無条件依存持つことを選択したことがわかり<code>libssh2</code>経由<code>libssh2-sys</code>クレート、などのプラットフォーム固有の依存関係<code>openssl-sys</code> \ <i>nix</i>のために<i>（今のところは省略さ他の変異体）を。</i></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><i>It may seem a little counterintuitive to express</i> C dependencies* in the <i>Cargo manifest</i> , but this is actually using one of Cargo&#39;s conventions in this space.</span> <i>Cargoマニフェスト</i>でC依存関係<i>を表現するのは少し直感的ではないかもしれませんが、</i>実際にはこのスペースでCargoの規則を使用しています。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>*-sys</code> Packages</span> <code>*-sys</code>パッケージ</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To alleviate linking to system libraries, crates.io has a <i>convention</i> of package naming and functionality.</span>システムライブラリにリンク軽減するために、crates.ioは、パッケージの命名と機能の<i>慣習が</i>あります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Any package named <code>foo-sys</code> should provide two major pieces of functionality:</span> <code>foo-sys</code>という名前のパッケージには、次の2つの機能があります。</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The library crate should link to the native library <code>libfoo</code> .</span>ライブラリクレートは、ネイティブライブラリ<code>libfoo</code>リンクする必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This will often probe the current system for <code>libfoo</code> before resorting to building from source.</span>これはソースからビルドする前に<code>libfoo</code>の現在のシステムを調べることがよくあります。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The library crate should provide <b>declarations</b> for functions in <code>libfoo</code> , but <b>not</b> bindings or higher-level abstractions.</span>ライブラリクレートは、 <code>libfoo</code>関数の<b>宣言</b>を提供するが<b>、</b>バインディングや上位レベルの抽象化は提供し<b>ない</b> 。</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The set of <code>*-sys</code> packages provides a common set of dependencies for linking to native libraries.</span> <code>*-sys</code>パッケージのセットは、ネイティブライブラリにリンクするための共通の依存関係を提供します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There are a number of benefits earned from having this convention of native-library-related packages:</span>このネイティブライブラリ関連のパッケージのコンベンションを持つことによって得られる多くの利点があります：</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Common dependencies on <code>foo-sys</code> alleviates the above rule about one package per value of <code>links</code> .</span> <code>foo-sys</code>に対する共通の依存関係は、 <code>links</code>値ごとに1つのパッケージに関する上記のルールを緩和し<code>links</code> 。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A common dependency allows centralizing logic on discovering <code>libfoo</code> itself (or building it from source).</span>共通の依存関係は、 <code>libfoo</code>自体を発見するための集中ロジックを可能にします（またはソースからビルドする）。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These dependencies are easily overridable.</span>これらの依存関係は簡単に無効にすることができます。</span> </div><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Building libgit2</span> libgit2のビルド</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now that we&#39;ve got libgit2&#39;s dependencies sorted out, we need to actually write the build script.</span> libgit2の依存関係が整理されたので、実際にビルドスクリプトを書く必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;re not going to look at specific snippets of code here and instead only take a look at the high-level details of the build script of <code>libgit2-sys</code> .</span> <code>libgit2-sys</code>ビルドスクリプトの詳細な部分だけを見てみましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is not recommending all packages follow this strategy, but rather just outlining one specific strategy.</span>これは、すべてのパッケージがこの戦略に従うことを推奨するのではなく、特定の戦略を概説することです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The first step of the build script should do is to query whether libgit2 is already installed on the host system.</span>ビルドスクリプトの最初のステップは、libgit2がすでにホストシステムにインストールされているかどうかを問い合わせることです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To do this we&#39;ll leverage the preexisting tool <code>pkg-config</code> (when its available).</span>これを行うために、既存のツール<code>pkg-config</code> （利用可能な場合）を活用します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll also use a <code>build-dependencies</code> section to refactor out all the <code>pkg-config</code> related code (or someone&#39;s already done that!).</span>また、 <code>build-dependencies</code>セクションを使用して、 <code>pkg-config</code>関連のコードをすべてリファクタリングします。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If <code>pkg-config</code> failed to find libgit2, or if <code>pkg-config</code> just wasn&#39;t installed, the next step is to build libgit2 from bundled source code (distributed as part of <code>libgit2-sys</code> itself).</span> <code>pkg-config</code>がlibgit2を見つけられなかった場合、または単に<code>pkg-config</code>がインストールされていない場合は、バンドルされたソースコードからlibgit2をビルドします（ <code>libgit2-sys</code>自体の一部として配布されます）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There are a few nuances when doing so that we need to take into account, however:</span>しかし、我々が考慮に入れる必要があるときに、いくつかのニュアンスがあります：</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The build system of libgit2, <code>cmake</code> , needs to be able to find libgit2&#39;s optional dependency of libssh2.</span> libgit2のビルドシステム<code>cmake</code> 、libgit2のlibssh2のオプションの依存関係を見つけることができる必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;re sure we&#39;ve already built it (it&#39;s a Cargo dependency), we just need to communicate this information.</span>私たちはすでにそれを構築していると確信しています（これは貨物依存です）、この情報を伝えるだけです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To do this we leverage the metadata format to communicate information between build scripts.</span>これを行うために、私たちはメタデータ形式を活用してビルドスクリプト間で情報をやりとりします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this example the libssh2 package printed out <code>cargo:root=...</code> to tell us where libssh2 is installed at, and we can then pass this along to cmake with the <code>CMAKE_PREFIX_PATH</code> environment variable.</span>この例では、libssh2パッケージは<code>cargo:root=...</code>を出力して、libssh2がどこにインストールされている<code>CMAKE_PREFIX_PATH</code>を示し、 <code>CMAKE_PREFIX_PATH</code>環境変数でcmakeに<code>CMAKE_PREFIX_PATH</code>ます。</span> </div><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll need to handle some <code>CFLAGS</code> values when compiling C code (and tell <code>cmake</code> about this).</span> Cコードをコンパイルするときに<code>CFLAGS</code>値を扱う必要があります（これについて<code>cmake</code>伝えてください）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Some flags we may want to pass are <code>-m64</code> for 64-bit code, <code>-m32</code> for 32-bit code, or <code>-fPIC</code> for 64-bit code as well.</span>私たちが渡したいかもしれないいくつかのフラグは<code>-m64</code> 64ビットコード、用<code>-m32</code> 32ビットコードのため、または<code>-fPIC</code>だけでなく、64ビットコードの。</span> </div><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Finally, we&#39;ll invoke <code>cmake</code> to place all output into the <code>OUT_DIR</code> environment variable, and then we&#39;ll print the necessary metadata to instruct rustc how to link to libgit2.</span>最後に、 <code>cmake</code>を呼び出してすべての出力を<code>OUT_DIR</code>環境変数に入れ、必要なメタデータを出力して、 <code>OUT_DIR</code>へのリンク方法を指示します。</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Most of the functionality of this build script is easily refactorable into common dependencies, so our build script isn&#39;t quite as intimidating as this descriptions!</span>このビルドスクリプトの機能のほとんどは、共通の依存関係に簡単にリファクタリング可能ですので、ビルドスクリプトはこの説明と同じくらい威圧的なものではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In reality it&#39;s expected that build scripts are quite succinct by farming logic such as above to build dependencies.</span>現実には、上記のようなロジックを構築して依存関係を構築することによって、ビルドスクリプトがかなり簡潔であることが期待されます。</span> </p><script>_addload(function(){_setupIW('com');_csi('en','ja','build-scripts.html');});</script>