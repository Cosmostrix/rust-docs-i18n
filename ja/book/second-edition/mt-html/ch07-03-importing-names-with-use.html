<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180709_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=ch07-03-importing-names-with-use.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Referring to Names in Different Modules</span>異なるモジュールの名前を参照する</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ve covered how to call functions defined within a module using the module name as part of the call, as in the call to the <code>nested_modules</code> function shown here in Listing 7-7.</span>リスト7-7の<code>nested_modules</code>関数の呼び出しのように、モジュール名を呼び出しの一部として使用してモジュール内で定義された関数を呼び出す方法について説明しました。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="pub mod a {"></div><div data-l="    pub mod series {"></div><div data-l="        pub mod of {"></div><div data-l="            pub fn nested_modules() {}"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    a::series::of::nested_modules();"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 7-7: Calling a function by fully specifying its enclosing module&#39;s path</span></span> <span class=caption>リスト7-7：モジュールのパスを完全に指定して関数を呼び出す</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As you can see, referring to the fully qualified name can get quite lengthy.</span>ご覧のとおり、完全修飾名を参照するとかなり長い時間がかかります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Fortunately, Rust has a keyword to make these calls more concise.</span>幸いにも、Rustはこれらの呼び出しをより簡潔にするためのキーワードを持っています。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Bringing Names into Scope with the <code>use</code> Keyword</span> <code>use</code>キーワードでスコープに名前を持たせる</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust&#39;s <code>use</code> keyword shortens lengthy function calls by bringing the modules of the function you want to call into scope.</span> Rustの<code>use</code>キーワードは、呼び出したい関数のモジュールをスコープに持ってくることで長い関数呼び出しを短縮します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here&#39;s an example of bringing the <code>a::series::of</code> module into a binary crate&#39;s root scope:</span> <code>a::series::of</code>モジュールをバイナリクレートのルートスコープに入れる例を示します：</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="pub mod a {"></div><div data-l="    pub mod series {"></div><div data-l="        pub mod of {"></div><div data-l="            pub fn nested_modules() {}"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="use a::series::of;"></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    of::nested_modules();"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The line <code>use a::series::of;</code></span>この行<code>use a::series::of;</code></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">means that rather than using the full <code>a::series::of</code> path wherever we want to refer to the <code>of</code> module, we can use <code>of</code> .</span>むしろフル使用するよりも意味<code>a::series::of</code>私たちはを参照したい場所にパスを<code>of</code>モジュール、我々が使用することができます<code>of</code> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>use</code> keyword brings only what we&#39;ve specified into scope: it does not bring children of modules into scope.</span> <code>use</code>キーワードは、スコープに指定したものだけを返します。モジュールの子をスコープに持ち込まない。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That&#39;s why we still have to use <code>of::nested_modules</code> when we want to call the <code>nested_modules</code> function.</span>そのため、 <code>nested_modules</code>関数を呼び出すときには<code>of::nested_modules</code>まだ<code>of::nested_modules</code>を使用する<code>nested_modules</code>ます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We could have chosen to bring the function into scope by instead specifying the function in the <code>use</code> as follows:</span>私たちは、代わりに関数を指定することにより、スコープに関数を持参することを選択した可能性があり<code>use</code> 、次のように：</span> </p><br><div data-lang=rust><div data-l="pub mod a {"></div><div data-l="    pub mod series {"></div><div data-l="        pub mod of {"></div><div data-l="            pub fn nested_modules() {}"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="use a::series::of::nested_modules;"></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    nested_modules();"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Doing so allows us to exclude all the modules and reference the function directly.</span>そうすることで、すべてのモジュールを除外し、関数を直接参照することができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because enums also form a sort of namespace like modules, we can bring an enum&#39;s variants into scope with <code>use</code> as well.</span>列挙型はモジュールのような一種の名前空間を形成するので、列挙型の変種を<code>use</code>してスコープに持ち込むこともできます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For any kind of <code>use</code> statement, if you&#39;re bringing multiple items from one namespace into scope, you can list them using curly brackets and commas in the last position, like so:</span>どのような種類の<code>use</code>文でも、ある名前空間から複数の項目をスコープに持ってくる場合は、次のように中括弧とカンマを最後の位置に指定できます。</span> </p><br><div data-lang=rust><div data-l="enum TrafficLight {"></div><div data-l="    Red,"></div><div data-l="    Yellow,"></div><div data-l="    Green,"></div><div data-l=}></div><div data-l=""></div><div data-l="use TrafficLight::{Red, Yellow};"></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let red = Red;"></div><div data-l="    let yellow = Yellow;"></div><div data-l="    let green = TrafficLight::Green;"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;re still specifying the <code>TrafficLight</code> namespace for the <code>Green</code> variant because we didn&#39;t include <code>Green</code> in the <code>use</code> statement.</span> <code>use</code>ステートメントに<code>Green</code>を含めなかったので、 <code>Green</code>バリアントの<code>TrafficLight</code>名前空間を指定して<code>TrafficLight</code>ます。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Bringing All Names into Scope with a Glob</span>すべての名前をGlobでスコープに変換</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To bring all the items in a namespace into scope at once, we can use the <code>*</code> syntax, which is called the <i>glob operator</i> .</span>ネームスペース内のすべての項目を一度に有効範囲に入れるには、 <i>glob演算子</i>と呼ばれる<code>*</code>構文を使用できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This example brings all the variants of an enum into scope without having to list each specifically:</span>この例では、列挙型のすべてのバリアントをスコープに入れます。具体的に列挙する必要はありません。</span> </p><br><div data-lang=rust><div data-l="enum TrafficLight {"></div><div data-l="    Red,"></div><div data-l="    Yellow,"></div><div data-l="    Green,"></div><div data-l=}></div><div data-l=""></div><div data-l="use TrafficLight::*;"></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let red = Red;"></div><div data-l="    let yellow = Yellow;"></div><div data-l="    let green = Green;"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>*</code> operator will bring into scope all the visible items in the <code>TrafficLight</code> namespace.</span> <code>*</code>演算子は、 <code>TrafficLight</code>名前空間内に表示されているすべての項目を有効範囲にします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You should use globs sparingly: they are convenient, but a glob might also pull in more items than you expected and cause naming conflicts.</span>グロブは控えめに使用する必要があります。便利ですが、グロブが予想以上に多くの項目を引き込み、命名の競合を引き起こす可能性があります。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Using <code>super</code> to Access a Parent Module</span> <code>super</code>を使用した親モジュールへのアクセス</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As you saw at the beginning of this chapter, when you create a library crate, Cargo makes a <code>tests</code> module for you.</span>この章の冒頭で見たように、ライブラリクレートを作成すると、Cargoが<code>tests</code>モジュールを作成します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s go into more detail about that now.</span>それについてもっと詳しく説明しましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In your <code>communicator</code> project, open <i>src/lib.rs</i> :</span>あなたの<code>communicator</code>プロジェクトで、 <i>src / lib.rsを</i>開きます：</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/lib.rs</span></span> <span class=filename>ファイル名：src / lib.rs</span></span> </p><br><div data-lang=rust,ignore><div data-l="pub mod client;"></div><div data-l=""></div><div data-l="pub mod network;"></div><div data-l=""></div><div data-l=#[cfg(test)]></div><div data-l="mod tests {"></div><div data-l="    #[test]"></div><div data-l="    fn it_works() {"></div><div data-l="        assert_eq!(2 + 2, 4);"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Chapter 11 explains more about testing, but parts of this example should make sense now: we have a module named <code>tests</code> that lives next to our other modules and contains one function named <code>it_works</code> .</span>第11章ではテストの詳細を説明していますが、この例の部分は意味をなさないはず<code>it_works</code> 。私たちは、他のモジュールの隣にあり、 <code>it_works</code>という名前の関数を含む<code>tests</code>という名前のモジュールを持っています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Even though there are special annotations, the <code>tests</code> module is just another module!</span>特別なアノテーションがあるにもかかわらず、 <code>tests</code>モジュールは単なる別のモジュールです！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So our module hierarchy looks like this:</span>したがって、モジュール階層は次のようになります。</span> </p><br><div data-lang=text><div data-l=communicator></div><div data-l=" ├── client"></div><div data-l=" ├── network"></div><div data-l=" |   └── client"></div><div data-l=" └── tests"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Tests are for exercising the code within our library, so let&#39;s try to call our <code>client::connect</code> function from this <code>it_works</code> function, even though we won&#39;t be checking any functionality right now.</span>テストは私たちのライブラリ内でコードを実行するためのものですので、今は機能をチェックしなくても、この<code>it_works</code>関数から<code>client::connect</code>関数を呼び出そうとします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This won&#39;t work yet:</span>これはまだ動作しません：</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/lib.rs</span></span> <span class=filename>ファイル名：src / lib.rs</span></span> </p><br><div data-lang=rust><div data-l=#[cfg(test)]></div><div data-l="mod tests {"></div><div data-l="    #[test]"></div><div data-l="    fn it_works() {"></div><div data-l="        client::connect();"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Run the tests by invoking the <code>cargo test</code> command:</span> <code>cargo test</code>コマンドを呼び出してテストを実行します。</span> </p><br><div data-lang=text><div data-l="$ cargo test"></div><div data-l="   Compiling communicator v0.1.0 (file:///projects/communicator)"></div><div data-l="error[E0433]: failed to resolve. Use of undeclared type or module `client`"></div><div data-l=" --&gt; src/lib.rs:9:9"></div><div data-l="  |"></div><div data-l="9 |         client::connect();"></div><div data-l="  |         ^^^^^^ Use of undeclared type or module `client`"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The compilation failed, but why?</span>コンパイルに失敗しましたが、なぜですか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We don&#39;t need to place <code>communicator::</code> in front of the function, as we did in <i>src/main.rs</i> , because we are definitely within the <code>communicator</code> library crate here.</span> <i>src / main.rsのよう</i>に、 <code>communicator</code>ライブラリの枠内にあるので、関数の前に<code>communicator::</code>を配置する必要はありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The reason is that paths are always relative to the current module, which here is <code>tests</code> .</span>その理由は、パスは常に現在のモジュールとの相対的なものであり、ここでは<code>tests</code>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The only exception is in a <code>use</code> statement, where paths are relative to the crate root by default.</span>唯一の例外は、デフォルトではパスがクレートルートと相対的な<code>use</code>ステートメントです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Our <code>tests</code> module needs the <code>client</code> module in its scope!</span> <code>tests</code>モジュールには<code>client</code>モジュールが必要です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So how do we get back up one module in the module hierarchy to call the <code>client::connect</code> function in the <code>tests</code> module?</span>だから、モジュール階層の中の一つのモジュールをバックアップして、 <code>tests</code>モジュールの<code>client::connect</code>関数を呼び出すにはどうすればいいですか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In the <code>tests</code> module, we can either use leading colons to let Rust know that we want to start from the root and list the whole path, like this:</span> <code>tests</code>モジュールでは、先頭のコロンを使用してルートから開始し、次のようにパス全体をリストしたいとRustに知らせることができます。</span> </p><br><div data-lang=rust,ignore><div data-l=::client::connect();></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Or, we can use <code>super</code> to move up one module in the hierarchy from our current module, like this:</span>または、 <code>super</code>を使用して、現在のモジュールの階層内の1つのモジュールを上に移動できます。</span> </p><br><div data-lang=rust,ignore><div data-l=super::client::connect();></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These two options don&#39;t look that different in this example, but if you&#39;re deeper in a module hierarchy, starting from the root every time would make your code lengthy.</span>これらの2つのオプションは、この例では違いはありませんが、モジュール階層の中で深い場合は、毎回ルートから始めるとコードが長くなります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In those cases, using <code>super</code> to get from the current module to sibling modules is a good shortcut.</span>そのような場合、現在のモジュールから兄弟モジュールに到達するために<code>super</code>を使用するのがよいショートカットです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Plus, if you&#39;ve specified the path from the root in many places in your code and then rearrange your modules by moving a subtree to another place, you&#39;ll end up needing to update the path in several places, which would be tedious.</span>さらに、コードの多くの場所でルートからパスを指定し、サブツリーを別の場所に移動してモジュールを再配置すると、いくつかの場所でパスを更新する必要がありますが、これは面倒です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It would also be annoying to have to type <code>super::</code> in each test, but you&#39;ve already seen the tool for that solution: <code>use</code> !</span>また、入力する必要は迷惑だろう<code>super::</code>各テストでは、しかし、あなたはすでにその解決のためのツールを見てきました： <code>use</code> ！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>super::</code> functionality changes the path you give to <code>use</code> so it is relative to the parent module instead of to the root module.</span> <code>super::</code>機能は、 <code>use</code>パスを変更して、ルートモジュールではなく親モジュールを基準にしています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For these reasons, in the <code>tests</code> module especially, <code>use super::something</code> is usually the best solution.</span>これらの理由から、特に<code>tests</code>モジュールでは、 <code>use super::something</code>が最も良い解決策です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So now our test looks like this:</span>だから私たちのテストは次のようになります：</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/lib.rs</span></span> <span class=filename>ファイル名：src / lib.rs</span></span> </p><br><div data-lang=rust><div data-l=#[cfg(test)]></div><div data-l="mod tests {"></div><div data-l="    use super::client;"></div><div data-l=""></div><div data-l="    #[test]"></div><div data-l="    fn it_works() {"></div><div data-l="        client::connect();"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When we run <code>cargo test</code> again, the test will pass, and the first part of the test result output will be the following:</span> <code>cargo test</code>再度実行すると、テストは終了し、テスト結果の出力の最初の部分は次のようになります。</span> </p><br><div data-lang=text><div data-l="$ cargo test"></div><div data-l="   Compiling communicator v0.1.0 (file:///projects/communicator)"></div><div data-l="     Running target/debug/communicator-92007ddb5330fa5a"></div><div data-l=""></div><div data-l="running 1 test"></div><div data-l="test tests::it_works ... ok"></div><div data-l=""></div><div data-l="test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out"></div></div><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Summary</span>概要</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now you know some new techniques for organizing your code!</span>これで、コードを整理するための新しいテクニックが分かりました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Use these techniques to group related functionality together, keep files from becoming too long, and present a tidy public API to your library users.</span>これらの手法を使用して、関連する機能をグループ化し、ファイルが長くなりすぎないようにし、ライブラリユーザーに整理されたパブリックAPIを提示します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Next, we&#39;ll look at some collection data structures in the standard library that you can use in your nice, neat code.</span>次に、標準ライブラリのコレクションデータ構造を見ていきます。これは、きちんとしたきれいなコードで使用できます。</span> </p><script>_addload(function(){_setupIW('com');_csi('en','ja','ch07-03-importing-names-with-use.html');});</script>