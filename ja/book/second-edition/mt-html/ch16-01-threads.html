<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180709_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=ch16-01-threads.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Using Threads to Run Code Simultaneously</span>スレッドを使用したコードの同時実行</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In most current operating systems, an executed program&#39;s code is run in a <i>process</i> , and the operating system manages multiple processes at once.</span>ほとんどの現在のオペレーティングシステムでは、実行されたプログラムのコードは<i>プロセス</i>内で実行され、オペレーティングシステムは複数のプロセスを一度に管理します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Within your program, you can also have independent parts that run simultaneously.</span>プログラム内では、同時に実行する独立したパーツを使用することもできます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The features that run these independent parts are called <i>threads</i> .</span>これらの独立した部分を実行する機能を<i>スレッド</i>と呼びます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Splitting the computation in your program into multiple threads can improve performance because the program does multiple tasks at the same time, but it also adds complexity.</span>プログラム内の計算を複数のスレッドに分割すると、プログラムが同時に複数のタスクを実行するためパフォーマンスが向上しますが、複雑さも増します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because threads can run simultaneously, there&#39;s no inherent guarantee about the order in which parts of your code on different threads will run.</span>スレッドは同時に実行できるので、異なるスレッド上のコードの部分が実行される順番は本質的に保証されていません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This can lead to problems, such as:</span>これにより、次のような問題が発生する可能性があります。</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Race conditions, where threads are accessing data or resources in an inconsistent order</span>スレッドがデータまたはリソースに一貫性のない順序でアクセスしている競合条件</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Deadlocks, where two threads are waiting for each other to finish using a resource the other thread has, preventing both threads from continuing</span>デッドロック.2つのスレッドが、互いが他のスレッドが持つリソースの使用を終了するのを待っているため、両方のスレッドが継続しない</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Bugs that happen only in certain situations and are hard to reproduce and fix reliably</span>特定の状況でのみ発生し、確実に再現して固定するのが難しいバグ</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust attempts to mitigate the negative effects of using threads, but programming in a multithreaded context still takes careful thought and requires a code structure that is different from that in programs running in a single thread.</span> Rustはスレッドの使用による悪影響を緩和しようとしますが、マルチスレッドコンテキストでのプログラミングは注意深く考えており、単一スレッドで実行されているプログラムとは異なるコード構造を必要とします。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Programming languages implement threads in a few different ways.</span>プログラミング言語は、いくつかの異なる方法でスレッドを実装します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Many operating systems provide an API for creating new threads.</span>多くのオペレーティングシステムでは、新しいスレッドを作成するためのAPIが提供されています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This model where a language calls the operating system APIs to create threads is sometimes called <i>1:1</i> , meaning one operating system thread per one language thread.</span>言語がオペレーティングシステムAPIを呼び出してスレッドを作成するこのモデルは、時には<i>1：1</i>と呼ばれ、1つの言語スレッドあたり1つのオペレーティングシステムスレッドを意味します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Many programming languages provide their own special implementation of threads.</span>多くのプログラミング言語は、独自のスレッドの実装を提供しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Programming language-provided threads are known as <i>green</i> threads, and languages that use these green threads will execute them in the context of a different number of operating system threads.</span>プログラミング言語提供スレッドは<i>緑色</i>スレッドと呼ばれ、これらの緑色スレッドを使用する言語は異なる数のオペレーティングシステムスレッドのコンテキストで実行されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For this reason, the green-threaded model is called the <i>M:N</i> model: there are <code>M</code> green threads per <code>N</code> operating system threads, where <code>M</code> and <code>N</code> are not necessarily the same number.</span>このため、緑色スレッドモデルは<i>M：N</i>モデルと呼ばれ<i>ます。N</i> <code>N</code>オペレーティングシステムスレッドごとに<code>M</code>緑色スレッドがあります<code>M</code>と<code>N</code>は必ずしも同じ数ではありません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Each model has its own advantages and trade-offs, and the trade-off most important to Rust is runtime support.</span>各モデルには独自の利点とトレードオフがあり、Rustにとって最も重要なトレードオフはランタイムサポートです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><i>Runtime</i> is a confusing term and can have different meanings in different contexts.</span> <i>ランタイム</i>は混乱する用語であり、異なるコンテキストで異なる意味を持つことができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this context, by <i>runtime</i> we mean code that is included by the language in every binary.</span>このコンテキストでは、 <i>実行時に</i>は、すべてのバイナリに言語によって含まれるコードを意味します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This code can be large or small depending on the language, but every non-assembly language will have some amount of runtime code.</span>このコードは言語に応じて大きくても小さくても構いませんが、すべての非アセンブリ言語にはある程度のランタイムコードが含まれます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For that reason, colloquially when people say a language has “no runtime,” they often mean “small runtime.” Smaller runtimes have fewer features but have the advantage of resulting in smaller binaries, which make it easier to combine the language with other languages in more contexts.</span>そのため、言語が「ランタイムがない」と言い表せば、「ランタイムが小さい」ことを意味します。ランタイムが小さくなると機能は少なくなりますが、バイナリが小さくなる利点があり、言語を他の言語と組み合わせやすくなりますより多くの文脈で。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Although many languages are okay with increasing the runtime size in exchange for more features, Rust needs to have nearly no runtime and cannot compromise on being able to call into C to maintain performance.</span>多くの言語は、より多くの機能と引き換えにランタイムサイズを増やしても問題ありませんが、Rustはランタイムをほとんど必要とせず、パフォーマンスを維持するためにCを呼び出すことができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The green-threading M:N model requires a larger language runtime to manage threads.</span>グリーンスレッドのM：Nモデルでは、スレッドを管理するための言語ランタイムが必要です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As such, the Rust standard library only provides an implementation of 1:1 threading.</span>そのため、Rust標準ライブラリは1：1スレッドの実装のみを提供します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because Rust is such a low-level language, there are crates that implement M:N threading if you would rather trade overhead for aspects such as more control over which threads run when and lower costs of context switching, for example.</span> Rustはそのような低レベル言語なので、スレッドの実行時間を制御し、コンテキスト切り替えのコストを削減するなどの面でオーバーヘッドを交換する場合は、M：Nスレッドを実装するテンプレートがあります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now that we&#39;ve defined threads in Rust, let&#39;s explore how to use the thread-related API provided by the standard library.</span> Rustでスレッドを定義したので、標準ライブラリで提供されているスレッド関連APIを使用する方法を探そう。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Creating a New Thread with <code>spawn</code></span> <code>spawn</code>新しいスレッドを作成<code>spawn</code></span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To create a new thread, we call the <code>thread::spawn</code> function and pass it a closure (we talked about closures in Chapter 13) containing the code we want to run in the new thread.</span>新しいスレッドを作成するには、 <code>thread::spawn</code>関数を呼び出し、新しいスレッドで実行したいコードを含むクロージャ（第13章のクロージャについて説明しました）を渡します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The example in Listing 16-1 prints some text from a main thread and other text from a new thread:</span>コードリスト16-1の例は、メインスレッドのテキストと新しいスレッドの他のテキストを出力します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="use std::thread;"></div><div data-l="use std::time::Duration;"></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    thread::spawn(|| {"></div><div data-l="        for i in 1..10 {"></div><div data-l="            println!(&quot;hi number {} from the spawned thread!&quot;, i);"></div><div data-l="            thread::sleep(Duration::from_millis(1));"></div><div data-l="        }"></div><div data-l="    });"></div><div data-l=""></div><div data-l="    for i in 1..5 {"></div><div data-l="        println!(&quot;hi number {} from the main thread!&quot;, i);"></div><div data-l="        thread::sleep(Duration::from_millis(1));"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 16-1: Creating a new thread to print one thing while the main thread prints something else</span></span> <span class=caption>リスト16-1：メインスレッドが何か他のものを印刷している間に1つのものを出力する新しいスレッドを作成する</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that with this function, the new thread will be stopped when the main thread ends, whether or not it has finished running.</span>この関数では、実行が終了したかどうかにかかわらず、メインスレッドが終了すると新しいスレッドが停止することに注意してください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The output from this program might be a little different every time, but it will look similar to the following:</span>このプログラムの出力は毎回少しずつ異なるかもしれませんが、次のようになります：</span> </p><br><div data-lang=text><div data-l="hi number 1 from the main thread!"></div><div data-l="hi number 1 from the spawned thread!"></div><div data-l="hi number 2 from the main thread!"></div><div data-l="hi number 2 from the spawned thread!"></div><div data-l="hi number 3 from the main thread!"></div><div data-l="hi number 3 from the spawned thread!"></div><div data-l="hi number 4 from the main thread!"></div><div data-l="hi number 4 from the spawned thread!"></div><div data-l="hi number 5 from the spawned thread!"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The calls to <code>thread::sleep</code> force a thread to stop its execution for a short duration, allowing a different thread to run.</span> <code>thread::sleep</code>への呼び出しは、実行を短期間停止し、別のスレッドが実行できるようにします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The threads will probably take turns, but that isn&#39;t guaranteed: it depends on how your operating system schedules the threads.</span>スレッドはおそらく順番に実行されますが、それは保証されません。オペレーティングシステムがスレッドをスケジュールする方法によって異なります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this run, the main thread printed first, even though the print statement from the spawned thread appears first in the code.</span>この実行では、生成されたスレッドのprintステートメントがコードの最初に表示されていても、メインスレッドが最初に印刷されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">And even though we told the spawned thread to print until <code>i</code> is 9, it only got to 5 before the main thread shut down.</span>そして、 <code>i</code>が9になるまで、生成されたスレッドに印刷するように指示したとしても、メインスレッドがシャットダウンする前に5にしか達しませんでした。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you run this code and only see output from the main thread, or don&#39;t see any overlap, try increasing the numbers in the ranges to create more opportunities for the operating system to switch between the threads.</span>このコードを実行してメインスレッドの出力のみを表示するか、重複が見られない場合は、範囲内の数値を増やして、オペレーティングシステムがスレッド間で切り替える機会を増やしてみてください。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Waiting for All Threads to Finish Using <code>join</code> Handles</span> <code>join</code>ハンドルを使用してすべてのスレッドが終了するのを待つ</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The code in Listing 16-1 not only stops the spawned thread prematurely most of the time due to the main thread ending, but also can&#39;t guarantee that the spawned thread will get to run at all.</span>コードリスト16-1のコードは、主スレッドの終了のために主に生成されたスレッドを早期に停止するだけでなく、生成されたスレッドがまったく実行されることを保証することもできません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The reason is that there is no guarantee on the order in which threads run!</span>その理由は、スレッドが実行される順序には保証がないからです！</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can fix the problem of the spawned thread not getting to run, or not getting to run completely, by saving the return value of <code>thread::spawn</code> in a variable.</span> <code>thread::spawn</code>戻り値を変数に保存することで、 <code>thread::spawn</code>れた<code>thread::spawn</code>が実行されない、または完全に実行されない問題を修正できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The return type of <code>thread::spawn</code> is <code>JoinHandle</code> .</span> <code>thread::spawn</code>の戻り値の型は<code>JoinHandle</code>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A <code>JoinHandle</code> is an owned value that, when we call the <code>join</code> method on it, will wait for its thread to finish.</span> <code>JoinHandle</code>は所有している値で、 <code>join</code>メソッドを呼び出すと、そのスレッドが終了するのを待ちます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 16-2 shows how to use the <code>JoinHandle</code> of the thread we created in Listing 16-1 and call <code>join</code> to make sure the spawned thread finishes before <code>main</code> exits:</span> 16-2をリストの使用方法を示し<code>JoinHandle</code>私たちは、リスト16-1で作成したスレッドのをと呼んで<code>join</code>前に必ず生成されたスレッドが終了を作るために<code>main</code>終了します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="use std::thread;"></div><div data-l="use std::time::Duration;"></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let handle = thread::spawn(|| {"></div><div data-l="        for i in 1..10 {"></div><div data-l="            println!(&quot;hi number {} from the spawned thread!&quot;, i);"></div><div data-l="            thread::sleep(Duration::from_millis(1));"></div><div data-l="        }"></div><div data-l="    });"></div><div data-l=""></div><div data-l="    for i in 1..5 {"></div><div data-l="        println!(&quot;hi number {} from the main thread!&quot;, i);"></div><div data-l="        thread::sleep(Duration::from_millis(1));"></div><div data-l="    }"></div><div data-l=""></div><div data-l="    handle.join().unwrap();"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 16-2: Saving a <code>JoinHandle</code> from <code>thread::spawn</code> to guarantee the thread is run to completion</span></span> <span class=caption>リスト16-2： <code>thread::spawn</code>から<code>JoinHandle</code>を保存して、スレッドが完了したことを保証する</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Calling <code>join</code> on the handle blocks the thread currently running until the thread represented by the handle terminates.</span>ハンドルで<code>join</code>を呼び出すと、ハンドルによって表されるスレッドが終了するまで現在実行中のスレッドがブロックされます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><i>Blocking</i> a thread means that thread is prevented from performing work or exiting.</span>スレッドを<i>ブロック</i>すると、スレッドが作業を実行したり終了したりすることができなくなります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because we&#39;ve put the call to <code>join</code> after the main thread&#39;s <code>for</code> loop, running Listing 16-2 should produce output similar to this:</span>メインスレッドの<code>for</code>ループの後に<code>join</code>呼び出すので、リスト16-2を実行すると次のような出力が生成されます。</span> </p><br><div data-lang=text><div data-l="hi number 1 from the main thread!"></div><div data-l="hi number 2 from the main thread!"></div><div data-l="hi number 1 from the spawned thread!"></div><div data-l="hi number 3 from the main thread!"></div><div data-l="hi number 2 from the spawned thread!"></div><div data-l="hi number 4 from the main thread!"></div><div data-l="hi number 3 from the spawned thread!"></div><div data-l="hi number 4 from the spawned thread!"></div><div data-l="hi number 5 from the spawned thread!"></div><div data-l="hi number 6 from the spawned thread!"></div><div data-l="hi number 7 from the spawned thread!"></div><div data-l="hi number 8 from the spawned thread!"></div><div data-l="hi number 9 from the spawned thread!"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The two threads continue alternating, but the main thread waits because of the call to <code>handle.join()</code> and does not end until the spawned thread is finished.</span> 2つのスレッドは交互に継続しますが、メインスレッドは<code>handle.join()</code>呼び出しのために待機し、生成されたスレッドが終了するまで終了しません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But let&#39;s see what happens when we instead move <code>handle.join()</code> before the <code>for</code> loop in <code>main</code> , like this:</span>しかし、我々は代わりに移動するときに何が起こるか見てみましょう<code>handle.join()</code>する前に<code>for</code>にループ<code>main</code>のように、：</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="use std::thread;"></div><div data-l="use std::time::Duration;"></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let handle = thread::spawn(|| {"></div><div data-l="        for i in 1..10 {"></div><div data-l="            println!(&quot;hi number {} from the spawned thread!&quot;, i);"></div><div data-l="            thread::sleep(Duration::from_millis(1));"></div><div data-l="        }"></div><div data-l="    });"></div><div data-l=""></div><div data-l="    handle.join().unwrap();"></div><div data-l=""></div><div data-l="    for i in 1..5 {"></div><div data-l="        println!(&quot;hi number {} from the main thread!&quot;, i);"></div><div data-l="        thread::sleep(Duration::from_millis(1));"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The main thread will wait for the spawned thread to finish and then run its <code>for</code> loop, so the output won&#39;t be interleaved anymore, as shown here:</span>メインスレッドは、生成されたスレッドが終了してから<code>for</code>ループを実行するのを待つため、ここで示すように、出力はもうインターリーブされません。</span> </p><br><div data-lang=text><div data-l="hi number 1 from the spawned thread!"></div><div data-l="hi number 2 from the spawned thread!"></div><div data-l="hi number 3 from the spawned thread!"></div><div data-l="hi number 4 from the spawned thread!"></div><div data-l="hi number 5 from the spawned thread!"></div><div data-l="hi number 6 from the spawned thread!"></div><div data-l="hi number 7 from the spawned thread!"></div><div data-l="hi number 8 from the spawned thread!"></div><div data-l="hi number 9 from the spawned thread!"></div><div data-l="hi number 1 from the main thread!"></div><div data-l="hi number 2 from the main thread!"></div><div data-l="hi number 3 from the main thread!"></div><div data-l="hi number 4 from the main thread!"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Small details, such as where <code>join</code> is called, can affect whether or not your threads run at the same time.</span> <code>join</code>が呼び出される場所などの細かい詳細は、スレッドが同時に実行されるかどうかに影響を与えます。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Using <code>move</code> Closures with Threads</span>スレッドでの<code>move</code>クロージャの使用</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>move</code> closure is often used alongside <code>thread::spawn</code> because it allows you to use data from one thread in another thread.</span> <code>move</code>クロージャは、 <code>thread::spawn</code>と一緒に使用されることがよくあります。これは、別のスレッドのあるスレッドのデータを使用できるように<code>thread::spawn</code>ためです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In Chapter 13, we mentioned we can use the <code>move</code> keyword before the parameter list of a closure to force the closure to take ownership of the values it uses in the environment.</span>第13章では、クロージャのパラメータリストの前に<code>move</code>キーワードを使用して、クロージャが環境内で使用する値の所有権を持つようにすることを説明しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This technique is especially useful when creating new threads in order to transfer ownership of values from one thread to another.</span>このテクニックは、値の所有権をあるスレッドから別のスレッドに移すために新しいスレッドを作成するときに特に便利です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Notice in Listing 16-1 that the closure we pass to <code>thread::spawn</code> takes no arguments: we&#39;re not using any data from the main thread in the spawned thread&#39;s code.</span>コードリスト16-1で、 <code>thread::spawn</code>渡すクロージャは引数をとりません。生成されたスレッドのコードのメインスレッドからのデータは使用していません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To use data from the main thread in the spawned thread, the spawned thread&#39;s closure must capture the values it needs.</span>生成されたスレッドのメインスレッドのデータを使用するには、生成されたスレッドのクロージャが必要な値を取得する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 16-3 shows an attempt to create a vector in the main thread and use it in the spawned thread.</span>コードリスト16-3は、メインスレッドでベクトルを作成し、それを生成したスレッドで使用する試みを示しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, this won&#39;t yet work, as you&#39;ll see in a moment.</span>しかし、これはすぐには分かりませんが、まだ動作しません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust,ignore><div data-l="use std::thread;"></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let v = vec![1, 2, 3];"></div><div data-l=""></div><div data-l="    let handle = thread::spawn(|| {"></div><div data-l="        println!(&quot;Here's a vector: {:?}&quot;, v);"></div><div data-l="    });"></div><div data-l=""></div><div data-l="    handle.join().unwrap();"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 16-3: Attempting to use a vector created by the main thread in another thread</span></span> <span class=caption>リスト16-3：メインスレッドによって作成されたベクトルを別のスレッドで使用しようとする</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The closure uses <code>v</code> , so it will capture <code>v</code> and make it part of the closure&#39;s environment.</span>閉鎖は使用しています<code>v</code> 、それがキャプチャされます<code>v</code> 、その閉鎖の環境の一部にします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because <code>thread::spawn</code> runs this closure in a new thread, we should be able to access <code>v</code> inside that new thread.</span> <code>thread::spawn</code>は新しいスレッドでこのクロージャを実行<code>thread::spawn</code>ので、その新しいスレッドの中で<code>v</code>にアクセスできるはずです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But when we compile this example, we get the following error:</span>しかし、この例をコンパイルすると、次のエラーが発生します。</span> </p><br><div data-lang=text><div data-l="error[E0373]: closure may outlive the current function, but it borrows `v`,"></div><div data-l="which is owned by the current function"></div><div data-l=" --&gt; src/main.rs:6:32"></div><div data-l="  |"></div><div data-l="6 |     let handle = thread::spawn(|| {"></div><div data-l="  |                                ^^ may outlive borrowed value `v`"></div><div data-l="7 |         println!(&quot;Here's a vector: {:?}&quot;, v);"></div><div data-l="  |                                           - `v` is borrowed here"></div><div data-l="  |"></div><div data-l="help: to force the closure to take ownership of `v` (and any other referenced"></div><div data-l="variables), use the `move` keyword"></div><div data-l="  |"></div><div data-l="6 |     let handle = thread::spawn(move || {"></div><div data-l="  |                                ^^^^^^^"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust <i>infers</i> how to capture <code>v</code> , and because <code>println€</code> only needs a reference to <code>v</code> , the closure tries to borrow <code>v</code> .</span> Rust <i>は</i> <code>v</code>をキャプチャする方法を<i>推測</i>し、 <code>println€</code>は<code>v</code>への参照のみを必要とするため、クロージャは<code>v</code>を借りようとします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, there&#39;s a problem: Rust can&#39;t tell how long the spawned thread will run, so it doesn&#39;t know if the reference to <code>v</code> will always be valid.</span>しかし、問題があります：Rustは生成されたスレッドがどれくらい実行されるかを知ることができないので、 <code>v</code>への参照が常に有効かどうかはわかりません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 16-4 provides a scenario that&#39;s more likely to have a reference to <code>v</code> that won&#39;t be valid:</span>コードリスト16-4は、有効でない<code>v</code>への参照を持つ可能性の高いシナリオを示しています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust,ignore><div data-l="use std::thread;"></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let v = vec![1, 2, 3];"></div><div data-l=""></div><div data-l="    let handle = thread::spawn(|| {"></div><div data-l="        println!(&quot;Here's a vector: {:?}&quot;, v);"></div><div data-l="    });"></div><div data-l=""></div><div data-l="#//    drop(v); // oh no!"></div><div data-l="    drop(v); // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">oh no!</span>あらいやだ！</span> </div><div data-l=""></div><div data-l="    handle.join().unwrap();"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 16-4: A thread with a closure that attempts to capture a reference to <code>v</code> from a main thread that drops <code>v</code></span></span> <span class=caption>リスト16-4：参照キャプチャしようとクロージャとのスレッド<code>v</code>低下メインスレッドから<code>v</code></span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we were allowed to run this code, there&#39;s a possibility the spawned thread would be immediately put in the background without running at all.</span>このコードを実行することが許可された場合、生成されたスレッドは、まったく実行せずにすぐにバックグラウンドに置かれる可能性があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The spawned thread has a reference to <code>v</code> inside, but the main thread immediately drops <code>v</code> , using the <code>drop</code> function we discussed in Chapter 15. Then, when the spawned thread starts to execute, <code>v</code> is no longer valid, so a reference to it is also invalid.</span>生成されたスレッドは<code>v</code>内部参照を持ちますが、第15章で説明した<code>drop</code>関数を使用して、メインスレッドは直ちに<code>v</code>を<code>drop</code>ます。次に、生成されたスレッドが実行を開始すると<code>v</code>は無効になるので、無効です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Oh no!</span>あらいやだ！</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To fix the compiler error in Listing 16-3, we can use the error message&#39;s advice:</span>リスト16-3のコンパイラエラーを修正するために、エラーメッセージのアドバイスを使用できます：</span> </p><br><div data-lang=text><div data-l="help: to force the closure to take ownership of `v` (and any other referenced"></div><div data-l="variables), use the `move` keyword"></div><div data-l="  |"></div><div data-l="6 |     let handle = thread::spawn(move || {"></div><div data-l="  |                                ^^^^^^^"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">By adding the <code>move</code> keyword before the closure, we force the closure to take ownership of the values it&#39;s using rather than allowing Rust to infer that it should borrow the values.</span>クロージャの前に<code>move</code>キーワードを追加する<code>move</code>で、クロストは値を借りるべきであるとRustが推測するのではなく、クロージャが使用している値の所有権を持つように強制します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The modification to Listing 16-3 shown in Listing 16-5 will compile and run as we intend:</span>リスト16-5のリスト16-3の変更は、意図したとおりにコンパイルされ、実行されます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="use std::thread;"></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let v = vec![1, 2, 3];"></div><div data-l=""></div><div data-l="    let handle = thread::spawn(move || {"></div><div data-l="        println!(&quot;Here's a vector: {:?}&quot;, v);"></div><div data-l="    });"></div><div data-l=""></div><div data-l="    handle.join().unwrap();"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 16-5: Using the <code>move</code> keyword to force a closure to take ownership of the values it uses</span></span> <span class=caption>リスト16-5： <code>move</code>キーワードを使ってクロージャが使用する値の所有権を持つようにする</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">What would happen to the code in Listing 16-4 where the main thread called <code>drop</code> if we use a <code>move</code> closure?</span>コードリスト16-4のコードには、 <code>move</code>クロージャを使用した場合にメインスレッドが<code>drop</code>と呼ばれる部分はどう<code>move</code>ますか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Would <code>move</code> fix that case?</span>う<code>move</code>その場合を修正？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Unfortunately, no;</span>残念だけど違う;</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">we would get a different error because what Listing 16-4 is trying to do isn&#39;t allowed for a different reason.</span>リスト16-4で実行しようとしている処理が異なる理由で許可されていないため、別のエラーが発生します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we added <code>move</code> to the closure, we would move <code>v</code> into the closure&#39;s environment, and we could no longer call <code>drop</code> on it in the main thread.</span>クロージャに<code>move</code>を追加<code>move</code>と、 <code>v</code>をクロージャの環境に移動し、メインスレッドでも<code>v</code>を<code>drop</code>することはできません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We would get this compiler error instead:</span>代わりに、このコンパイラエラーが発生します。</span> </p><br><div data-lang=text><div data-l="error[E0382]: use of moved value: `v`"></div><div data-l="  --&gt; src/main.rs:10:10"></div><div data-l="   |"></div><div data-l="6  |     let handle = thread::spawn(move || {"></div><div data-l="   |                                ------- value moved (into closure) here"></div><div data-l=...></div><div data-l="#//10 |     drop(v); // oh no!"></div><div data-l="10 |     drop(v); // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">oh no!</span>あらいやだ！</span> </div><div data-l="   |          ^ value used here after move"></div><div data-l="   |"></div><div data-l="   = note: move occurs because `v` has type `std::vec::Vec&lt;i32&gt;`, which does"></div><div data-l="   not implement the `Copy` trait"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust&#39;s ownership rules have saved us again!</span> Rustのオーナーシップルールは私たちをもう一度救った！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We got an error from the code in Listing 16-3 because Rust was being conservative and only borrowing <code>v</code> for the thread, which meant the main thread could theoretically invalidate the spawned thread&#39;s reference.</span> Rustは控えめで、スレッドに対して<code>v</code>を借用しているだけなので、リスト16-3のコードからエラーが発生しました。これは、主スレッドが理論的に生成されたスレッドの参照を無効にできることを意味します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">By telling Rust to move ownership of <code>v</code> to the spawned thread, we&#39;re guaranteeing Rust that the main thread won&#39;t use <code>v</code> anymore.</span> Rustに<code>v</code>所有権をspawnされたスレッドに移すように指示することで、メインスレッドはもはや<code>v</code>使用しないことをRustに保証します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we change Listing 16-4 in the same way, we&#39;re then violating the ownership rules when we try to use <code>v</code> in the main thread.</span>同じ方法でリスト16-4を変更した場合、主スレッドで<code>v</code>を使用しようとすると所有権の規則に違反します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>move</code> keyword overrides Rust&#39;s conservative default of borrowing;</span> <code>move</code>キーワードは、Rustの控えめなデフォルトの借用を上書きします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">it doesn&#39;t let us violate the ownership rules.</span>所有権のルールに違反することは許されません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">With a basic understanding of threads and the thread API, let&#39;s look at what we can <i>do</i> with threads.</span>スレッドとスレッドAPIの基本を理解して、我々はスレッドで<i>何</i>ができるかを見てみましょう。</span> </p><script>_addload(function(){_setupIW('com');_csi('en','ja','ch16-01-threads.html');});</script>