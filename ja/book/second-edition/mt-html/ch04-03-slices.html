<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180709_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=ch04-03-slices.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The Slice Type</span>スライスタイプ</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Another data type that does not have ownership is the <i>slice</i> .</span>所有権を持たない別のデータ型は<i>スライス</i>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Slices let you reference a contiguous sequence of elements in a collection rather than the whole collection.</span>スライスを使用すると、コレクション全体ではなく、コレクション内の要素の連続したシーケンスを参照できます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here&#39;s a small programming problem: write a function that takes a string and returns the first word it finds in that string.</span>小さなプログラミング上の問題があります：文字列をとり、その文字列で見つかった最初の単語を返す関数を書く。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If the function doesn&#39;t find a space in the string, the whole string must be one word, so the entire string should be returned.</span>関数が文字列内にスペースを見つけられない場合は、文字列全体が1つの単語でなければならないため、文字列全体が返されます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s think about the signature of this function:</span>この関数のシグネチャについて考えてみましょう：</span> </p><br><div data-lang=rust,ignore><div data-l="fn first_word(s: &amp;String) -&gt; ?"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This function, <code>first_word</code> , has a <code>&amp;String</code> as a parameter.</span>このファンクション<code>first_word</code>は、パラメータとして<code>&amp;String</code>を持ちます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We don&#39;t want ownership, so this is fine.</span>私たちは所有権を望まないので、これは問題ありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But what should we return?</span>しかし、何を返すべきですか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We don&#39;t really have a way to talk about <i>part</i> of a string.</span>文字列の<i>一部</i>について話す方法はありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, we could return the index of the end of the word.</span>しかし、単語の終わりのインデックスを返すことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s try that, as shown in Listing 4-7.</span>リスト4-7に示すように、これを試してみましょう。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="fn first_word(s: &amp;String) -&gt; usize {"></div><div data-l="    let bytes = s.as_bytes();"></div><div data-l=""></div><div data-l="    for (i, &amp;item) in bytes.iter().enumerate() {"></div><div data-l="        if item == b' ' {"></div><div data-l="            return i;"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=""></div><div data-l="    s.len()"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 4-7: The <code>first_word</code> function that returns a byte index value into the <code>String</code> parameter</span></span> <span class=caption>リスト4-7： <code>String</code>パラメータにバイトインデックス値を返す<code>first_word</code>関数</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because we need to go through the <code>String</code> element by element and check whether a value is a space, we&#39;ll convert our <code>String</code> to an array of bytes using the <code>as_bytes</code> method:</span> <code>String</code>要素を要素単位で調べ、値が空白かどうかをチェックする必要があるため、 <code>as_bytes</code>メソッドを使用して<code>String</code>をバイト配列に変換します。</span> </p><br><div data-lang=rust,ignore><div data-l="let bytes = s.as_bytes();"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Next, we create an iterator over the array of bytes using the <code>iter</code> method:</span>次に、 <code>iter</code>メソッドを使用して、バイト配列のイテレータを作成します。</span> </p><br><div data-lang=rust,ignore><div data-l="for (i, &amp;item) in bytes.iter().enumerate() {"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll discuss iterators in more detail in Chapter 13. For now, know that <code>iter</code> is a method that returns each element in a collection and that <code>enumerate</code> wraps the result of <code>iter</code> and returns each element as part of a tuple instead.</span>反復子については、第13章で詳しく説明します<code>iter</code>はコレクション内の各要素を返すメソッドであり、 <code>enumerate</code>すると<code>iter</code>の結果をラップし、各要素をタプルの一部として返すメソッドであることがわかります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The first element of the tuple returned from <code>enumerate</code> is the index, and the second element is a reference to the element.</span> <code>enumerate</code>から返されたタプルの最初の要素はインデックスであり、2番目の要素は要素への参照です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is a bit more convenient than calculating the index ourselves.</span>これは、インデックスを自分で計算するよりも少し便利です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because the <code>enumerate</code> method returns a tuple, we can use patterns to destructure that tuple, just like everywhere else in Rust.</span> <code>enumerate</code>メソッドはタプルを返すので、Rustの他の場所と同様に、パターンを使用してそのタプルを破棄することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So in the <code>for</code> loop, we specify a pattern that has <code>i</code> for the index in the tuple and <code>&amp;item</code> for the single byte in the tuple.</span>したがって、 <code>for</code>ループでは、タプル内のインデックスの<code>i</code>とタプル内の1バイトの<code>&amp;item</code>を持つパターンを指定します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because we get a reference to the element from <code>.iter().enumerate()</code> , we use <code>&amp;</code> in the pattern.</span> <code>.iter().enumerate()</code>から要素への参照を取得するため、パターン内で<code>&amp;</code>を使用します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Inside the <code>for</code> loop, we search for the byte that represents the space by using the byte literal syntax.</span> <code>for</code>ループの内部では、バイトリテラル構文を使用してスペースを表すバイトを検索します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we find a space, we return the position.</span>スペースを見つけると、その位置を返します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Otherwise, we return the length of the string by using <code>s.len()</code> :</span>それ以外の場合は、 <code>s.len()</code>を使用して文字列の長さを返します。</span> </p><br><div data-lang=rust,ignore><div data-l="    if item == b' ' {"></div><div data-l="        return i;"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l=s.len()></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We now have a way to find out the index of the end of the first word in the string, but there&#39;s a problem.</span>文字列の最初の単語の終わりのインデックスを見つける方法がありますが、問題があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;re returning a <code>usize</code> on its own, but it&#39;s only a meaningful number in the context of the <code>&amp;String</code> .</span>私たちは独自に<code>usize</code>を返していますが、 <code>&amp;String</code>コンテキストでは意味のある数字です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In other words, because it&#39;s a separate value from the <code>String</code> , there&#39;s no guarantee that it will still be valid in the future.</span>つまり、 <code>String</code>とは別の値なので、将来も有効であるという保証はありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Consider the program in Listing 4-8 that uses the <code>first_word</code> function from Listing 4-7.</span>リスト4-7の<code>first_word</code>関数を使用するリスト4-8のプログラムを考えてみましょう。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="# fn first_word(s: &amp;String) -&gt; usize {"></div><div data-l="#     let bytes = s.as_bytes();"></div><div data-l=#></div><div data-l="#     for (i, &amp;item) in bytes.iter().enumerate() {"></div><div data-l="#         if item == b' ' {"></div><div data-l="#             return i;"></div><div data-l="#         }"></div><div data-l="#     }"></div><div data-l=#></div><div data-l="#     s.len()"></div><div data-l="# }"></div><div data-l=#></div><div data-l="fn main() {"></div><div data-l="    let mut s = String::from(&quot;hello world&quot;);"></div><div data-l=""></div><div data-l="#//    let word = first_word(&amp;s); // word will get the value 5"></div><div data-l="    let word = first_word(&amp;s); // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">word will get the value 5</span>単語は値5を取得します</span> </div><div data-l=""></div><div data-l="#//    s.clear(); // this empties the String, making it equal to &quot;&quot;"></div><div data-l="    s.clear(); // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">this empties the String, making it equal to &quot;&quot;</span>これは文字列を空にして、それを &quot;&quot;と等しくします</span> </div><div data-l=""></div><div data-l="#    // word still has the value 5 here, but there's no more string that"></div><div data-l="#    // we could meaningfully use the value 5 with. word is now totally invalid!"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">word still has the value 5 here, but there&#39;s no more string that we could meaningfully use the value 5 with.</span>単語はここでも値5を持っていますが、意味のある値5を使用できるストリングはありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">word is now totally invalid!</span>言葉が完全に無効になりました！</span> </div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 4-8: Storing the result from calling the <code>first_word</code> function and then changing the <code>String</code> contents</span></span> <span class=caption>リスト4-8：結果を<code>first_word</code>関数を呼び出してから格納してから<code>String</code>内容を変更する</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This program compiles without any errors and would also do so if we used <code>word</code> after calling <code>s.clear()</code> .</span>このプログラムはエラーなしでコンパイルされ、 <code>s.clear()</code>呼び出した後に<code>word</code>を使用した場合も同様です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because <code>word</code> isn&#39;t connected to the state of <code>s</code> at all, <code>word</code> still contains the value <code>5</code> .</span> <code>word</code>は<code>s</code>の状態に全く接続されていないので、 <code>word</code>には値<code>5</code>が含まれています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We could use that value <code>5</code> with the variable <code>s</code> to try to extract the first word out, but this would be a bug because the contents of <code>s</code> have changed since we saved <code>5</code> in <code>word</code> .</span>その値<code>5</code>を変数<code>s</code>と一緒に使用して最初の単語を抽出しようとしましたが、 <code>word</code> <code>5</code>を保存してから<code>s</code>の内容が変更されたため、バグになります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Having to worry about the index in <code>word</code> getting out of sync with the data in <code>s</code> is tedious and error prone!</span> <code>word</code>の索引が<code>s</code>のデータと同期しなくなることを心配することは面倒でエラーが起こりやすい！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Managing these indices is even more brittle if we write a <code>second_word</code> function.</span> <code>second_word</code>関数を書くと、これらのインデックスを管理することはさらに脆弱です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Its signature would have to look like this:</span>その署名は次のようになります。</span> </p><br><div data-lang=rust,ignore><div data-l="fn second_word(s: &amp;String) -&gt; (usize, usize) {"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now we&#39;re tracking a starting <i>and</i> an ending index, and we have even more values that were calculated from data in a particular state but aren&#39;t tied to that state at all.</span>現在、開始インデックス<i>と</i>終了インデックスを追跡しており、特定の状態のデータから計算された値はさらに多くなりますが、その状態にはまったく結び付けられていません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We now have three unrelated variables floating around that need to be kept in sync.</span>私たちは3つの無関係な変数を浮動させて、同期させておく必要があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Luckily, Rust has a solution to this problem: string slices.</span>幸運にも、Rustにはこの問題の解決策があります：文字列スライス。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">String Slices</span>文字列スライス</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A <i>string slice</i> is a reference to part of a <code>String</code> , and it looks like this:</span> <i>文字列スライス</i>は<code>String</code>一部への参照で、次のようになります。</span> </p><br><div data-lang=rust><div data-l="let s = String::from(&quot;hello world&quot;);"></div><div data-l=""></div><div data-l="let hello = &amp;s[0..5];"></div><div data-l="let world = &amp;s[6..11];"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is similar to taking a reference to the whole <code>String</code> but with the extra <code>[0..5]</code> bit.</span>これは、 <code>String</code>全体を参照するのと同様ですが、余分な<code>[0..5]</code>ビットを使用します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rather than a reference to the entire <code>String</code> , it&#39;s a reference to a portion of the <code>String</code> .</span> <code>String</code>全体の参照ではなく、 <code>String</code>一部への参照です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>start..end</code> syntax is a range that begins at <code>start</code> and continues up to, but not including, <code>end</code> .</span> <code>start..end</code>構文は、開始時に<code>start</code>し、 <code>end</code>継続する範囲です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can create slices using a range within brackets by specifying <code>[starting_index..ending_index]</code> , where <code>starting_index</code> is the first position in the slice and <code>ending_index</code> is one more than the last position in the slice.</span> <code>[starting_index..ending_index]</code>指定することで、括弧内の範囲を使用してスライスを作成できます。ここで、 <code>starting_index</code>はスライスの最初の位置で、 <code>ending_index</code>はスライスの最後の位置よりも1つ多くなります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Internally, the slice data structure stores the starting position and the length of the slice, which corresponds to <code>ending_index</code> minus <code>starting_index</code> .</span>内部的には、スライスデータ構造に対応する開始位置とスライスの長さ、格納<code>ending_index</code>マイナス<code>starting_index</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So in the case of <code>let world = &amp;s[6..11];</code></span>したがって、 <code>let world = &amp;s[6..11];</code>場合は<code>let world = &amp;s[6..11];</code></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">, <code>world</code> would be a slice that contains a pointer to the 7th byte of <code>s</code> with a length value of 5.</span> 、 <code>world</code>は、5の長さの値を持つ<code>s</code> 7番目のバイトへのポインタを含むスライスになります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Figure 4-6 shows this in a diagram.</span>図4-6に、これを図で示します。</span> </p><br><p><img alt="Stringの6番目のバイトへのポインタと長さ5" src=img/trpl04-06.svg class=center style="width: 50%;" /></p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Figure 4-6: String slice referring to part of a <code>String</code></span></span> <span class=caption>図4-6：文字列スライスの一部を参照する<code>String</code></span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">With Rust&#39;s <code>..</code> range syntax, if you want to start at the first index (zero), you can drop the value before the two periods.</span>錆のでは<code>..</code>あなたが最初のインデックス（ゼロ）で開始したい場合は、範囲の構文、次の2つの期間の前に値をドロップすることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In other words, these are equal:</span>換言すれば、これらは等しい。</span> </p><br><div data-lang=rust><div data-l="let s = String::from(&quot;hello&quot;);"></div><div data-l=""></div><div data-l="let slice = &amp;s[0..2];"></div><div data-l="let slice = &amp;s[..2];"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">By the same token, if your slice includes the last byte of the <code>String</code> , you can drop the trailing number.</span>同じトークンによって、スライスに<code>String</code>最後のバイトが含まれている場合は、末尾の数値を削除できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That means these are equal:</span>これは、これらが等しいことを意味します。</span> </p><br><div data-lang=rust><div data-l="let s = String::from(&quot;hello&quot;);"></div><div data-l=""></div><div data-l="let len = s.len();"></div><div data-l=""></div><div data-l="let slice = &amp;s[3..len];"></div><div data-l="let slice = &amp;s[3..];"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can also drop both values to take a slice of the entire string.</span>両方の値をドロップして、文字列全体をスライスすることもできます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So these are equal:</span>したがって、これらは等しいです：</span> </p><br><div data-lang=rust><div data-l="let s = String::from(&quot;hello&quot;);"></div><div data-l=""></div><div data-l="let len = s.len();"></div><div data-l=""></div><div data-l="let slice = &amp;s[0..len];"></div><div data-l="let slice = &amp;s[..];"></div></div><br><blockquote><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note: String slice range indices must occur at valid UTF-8 character boundaries.</span>注意：文字列スライス範囲のインデックスは、有効なUTF-8文字境界で指定する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you attempt to create a string slice in the middle of a multibyte character, your program will exit with an error.</span>マルチバイト文字の途中で文字列スライスを作成しようとすると、プログラムはエラーで終了します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For the purposes of introducing string slices, we are assuming ASCII only in this section;</span>文字列スライスを導入する目的で、このセクションでのみASCIIを仮定しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">a more thorough discussion of UTF-8 handling is in the “Storing UTF-8 Encoded Text with Strings” section of Chapter 8.</span> UTF-8処理の詳細については、第8章の「文字列を使用したUTF-8エンコードテキストの保存」を参照してください。</span> </p></blockquote><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">With all this information in mind, let&#39;s rewrite <code>first_word</code> to return a slice.</span>このすべての情報を念頭に置いて、 <code>first_word</code>を書き換えてスライスを返しましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The type that signifies “string slice” is written as <code>&amp;str</code> :</span> &quot;string slice&quot;を表す型は<code>&amp;str</code> ：</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="fn first_word(s: &amp;String) -&gt; &amp;str {"></div><div data-l="    let bytes = s.as_bytes();"></div><div data-l=""></div><div data-l="    for (i, &amp;item) in bytes.iter().enumerate() {"></div><div data-l="        if item == b' ' {"></div><div data-l="            return &amp;s[0..i];"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=""></div><div data-l="    &amp;s[..]"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We get the index for the end of the word in the same way as we did in Listing 4-7, by looking for the first occurrence of a space.</span>リスト4-7と同じ方法で、単語の終わりのインデックスを取得します。スペースの最初のオカレンスを探します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When we find a space, we return a string slice using the start of the string and the index of the space as the starting and ending indices.</span>スペースを見つけると、文字列の始まりとスペースのインデックスを開始と終了のインデックスとして使用して文字列スライスを返します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now when we call <code>first_word</code> , we get back a single value that is tied to the underlying data.</span>今、 <code>first_word</code>を呼び出すと、基礎となるデータに結びついた単一の値が返されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The value is made up of a reference to the starting point of the slice and the number of elements in the slice.</span>値は、スライスの開始点への参照とスライス内の要素の数で構成されます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Returning a slice would also work for a <code>second_word</code> function:</span>スライスを返すことは、 <code>second_word</code>関数でも機能します：</span> </p><br><div data-lang=rust,ignore><div data-l="fn second_word(s: &amp;String) -&gt; &amp;str {"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We now have a straightforward API that&#39;s much harder to mess up, because the compiler will ensure the references into the <code>String</code> remain valid.</span>コンパイラは、 <code>String</code>への参照が有効であることを保証するので、今や簡単なAPIを使いこなすことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Remember the bug in the program in Listing 4-8, when we got the index to the end of the first word but then cleared the string so our index was invalid?</span>リスト4-8のプログラムのバグを覚えておいてください。最初の単語の終わりまでインデックスを取得した後、インデックスを無効にするために文字列をクリアした場合はどうでしょうか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That code was logically incorrect but didn&#39;t show any immediate errors.</span>そのコードは論理的に間違っていましたが、即時のエラーは表示されませんでした。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The problems would show up later if we kept trying to use the first word index with an emptied string.</span> Emptied文字列で最初の単語インデックスを使用しようとした場合、問題が後で表示されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Slices make this bug impossible and let us know we have a problem with our code much sooner.</span>スライスはこのバグを不可能にし、私たちにコードの問題がはるかに早いことを知らせます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Using the slice version of <code>first_word</code> will throw a compile-time error:</span> <code>first_word</code>のスライス版を使用すると、コンパイル時エラーがスローされます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust,ignore><div data-l="fn main() {"></div><div data-l="    let mut s = String::from(&quot;hello world&quot;);"></div><div data-l=""></div><div data-l="    let word = first_word(&amp;s);"></div><div data-l=""></div><div data-l="#//    s.clear(); // error!"></div><div data-l="    s.clear(); // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">error!</span>エラー！</span> </div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here&#39;s the compiler error:</span>コンパイラのエラーは次のとおりです。</span> </p><br><div data-lang=text><div data-l="error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable"></div><div data-l=" --&gt; src/main.rs:6:5"></div><div data-l="  |"></div><div data-l="4 |     let word = first_word(&amp;s);"></div><div data-l="  |                            - immutable borrow occurs here"></div><div data-l="5 |"></div><div data-l="#//6 |     s.clear(); // error!"></div><div data-l="6 |     s.clear(); // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">error!</span>エラー！</span> </div><div data-l="  |     ^ mutable borrow occurs here"></div><div data-l="7 | }"></div><div data-l="  | - immutable borrow ends here"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Recall from the borrowing rules that if we have an immutable reference to something, we cannot also take a mutable reference.</span>借用のルールから、何かへの不変な参照があれば、変更可能な参照を取ることができないことを思い出してください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because <code>clear</code> needs to truncate the <code>String</code> , it tries to take a mutable reference, which fails.</span> <code>clear</code>は<code>String</code>を切り捨てる必要があるため、変更可能な参照を取得しようとしますが、失敗します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Not only has Rust made our API easier to use, but it has also eliminated an entire class of errors at compile time!</span> RustはAPIを使いやすくしただけでなく、コンパイル時にクラス全体のエラーをなくしました！</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">String Literals Are Slices</span>文字列リテラルはスライスです</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Recall that we talked about string literals being stored inside the binary.</span>バイナリの内部に格納されている文字列リテラルについて話したことを思い出してください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now that we know about slices, we can properly understand string literals:</span>スライスについて知ったので、文字列リテラルを正しく理解することができます：</span> </p><br><div data-lang=rust><div data-l="let s = &quot;Hello, world!&quot;;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The type of <code>s</code> here is <code>&amp;str</code> : it&#39;s a slice pointing to that specific point of the binary.</span>タイプ<code>s</code> 、ここでは、 <code>&amp;str</code> ：それはバイナリの特定のポイントを指し示すスライスです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is also why string literals are immutable;</span>これは、文字列リテラルが不変である理由です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>&amp;str</code> is an immutable reference.</span> <code>&amp;str</code>は不変の参照です。</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">String Slices as Parameters</span>パラメータとしての文字列スライス</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Knowing that you can take slices of literals and <code>String</code> values leads us to one more improvement on <code>first_word</code> , and that&#39;s its signature:</span>リテラルと<code>String</code>値を<code>first_word</code>ことができることを知っていると、 <code>first_word</code>改善が<code>first_word</code> 1つあります。それはその署名です。</span> </p><br><div data-lang=rust,ignore><div data-l="fn first_word(s: &amp;String) -&gt; &amp;str {"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A more experienced Rustacean would write the signature shown in Listing 4-9 instead because it allows us to use the same function on both <code>String</code> values and <code>&amp;str</code> values.</span>より経験豊富なRustaceanは、リスト4-9に示すような署名を書くのではなく、 <code>String</code>値と<code>&amp;str</code>値の両方で同じ関数を使うことができるからです。</span> </p><br><div data-lang=rust,ignore><div data-l="fn first_word(s: &amp;str) -&gt; &amp;str {"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 4-9: Improving the <code>first_word</code> function by using a string slice for the type of the <code>s</code> parameter</span></span> <span class=caption>リスト4-9： <code>s</code>パラメータの型に文字列スライスを使用して<code>first_word</code>関数を改善する</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we have a string slice, we can pass that directly.</span>文字列スライスがある場合は、それを直接渡すことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we have a <code>String</code> , we can pass a slice of the entire <code>String</code> .</span>我々が持っている場合は<code>String</code> 、我々は全体のスライス渡すことができます<code>String</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Defining a function to take a string slice instead of a reference to a <code>String</code> makes our API more general and useful without losing any functionality:</span> <code>String</code>への参照の代わりに文字列スライスを取る関数を定義することにより、私たちのAPIは機能を失うことなくより一般的かつ有用になります：</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="# fn first_word(s: &amp;str) -&gt; &amp;str {"></div><div data-l="#     let bytes = s.as_bytes();"></div><div data-l=#></div><div data-l="#     for (i, &amp;item) in bytes.iter().enumerate() {"></div><div data-l="#         if item == b' ' {"></div><div data-l="#             return &amp;s[0..i];"></div><div data-l="#         }"></div><div data-l="#     }"></div><div data-l=#></div><div data-l="#     &amp;s[..]"></div><div data-l="# }"></div><div data-l="fn main() {"></div><div data-l="    let my_string = String::from(&quot;hello world&quot;);"></div><div data-l=""></div><div data-l="#    // first_word works on slices of `String`s"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">first_word works on slices of <code>String</code> s</span> first_wordは<code>String</code>のスライスで機能します</span> </div><div data-l="    let word = first_word(&amp;my_string[..]);"></div><div data-l=""></div><div data-l="    let my_string_literal = &quot;hello world&quot;;"></div><div data-l=""></div><div data-l="#    // first_word works on slices of string literals"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">first_word works on slices of string literals</span> first_wordは文字列リテラルのスライスで機能します</span> </div><div data-l="    let word = first_word(&amp;my_string_literal[..]);"></div><div data-l=""></div><div data-l="#    // Because string literals *are* string slices already,"></div><div data-l="#    // this works too, without the slice syntax!"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because string literals <i>are</i> string slices already, this works too, without the slice syntax!</span>文字列リテラル<i>は</i>すでに文字列スライスなので、これもスライス構文なしで動作します！</span> </div><div data-l="    let word = first_word(my_string_literal);"></div><div data-l=}></div></div><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Other Slices</span>その他のスライス</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">String slices, as you might imagine, are specific to strings.</span>想像の通り、文字列スライスは文字列に固有のものです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But there&#39;s a more general slice type, too.</span>しかし、より一般的なスライスタイプもあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Consider this array:</span>この配列を考えてみましょう：</span> </p><br><div data-lang=rust><div data-l="let a = [1, 2, 3, 4, 5];"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Just as we might want to refer to a part of a string, we might want to refer to part of an array.</span>文字列の一部を参照したいのと同じように、配列の一部を参照することもできます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;d do so like this:</span>私たちはこれを次のようにします：</span> </p><br><div data-lang=rust><div data-l="let a = [1, 2, 3, 4, 5];"></div><div data-l=""></div><div data-l="let slice = &amp;a[1..3];"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This slice has the type <code>&amp;[i32]</code> .</span>このスライスは<code>&amp;[i32]</code>タイプです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It works the same way as string slices do, by storing a reference to the first element and a length.</span>これは、最初の要素と長さへの参照を格納することによって、文字列スライスと同じように動作します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You&#39;ll use this kind of slice for all sorts of other collections.</span>この種のスライスを、あらゆる種類の他のコレクションに使用します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll discuss these collections in detail when we talk about vectors in Chapter 8.</span>これらのコレクションについては、第8章のベクトルについて説明します。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Summary</span>概要</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The concepts of ownership, borrowing, and slices ensure memory safety in Rust programs at compile time.</span>所有権、借用、およびスライスの概念は、コンパイル時にRustプログラムにおけるメモリの安全性を保証します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The Rust language gives you control over your memory usage in the same way as other systems programming languages, but having the owner of data automatically clean up that data when the owner goes out of scope means you don&#39;t have to write and debug extra code to get this control.</span> Rust言語は、他のシステムプログラミング言語と同じ方法でメモリ使用量を制御できますが、所有者が範囲外になったときにデータ所有者がデータを自動的にクリーンアップするということは、追加コードを記述したりデバッグする必要がないこの制御を得る。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Ownership affects how lots of other parts of Rust work, so we&#39;ll talk about these concepts further throughout the rest of the book.</span>所有権は、Rustの他の部分のどれくらいが影響を受けるのかに影響を及ぼします。そのため、これらの概念については、残りの部分でさらに詳しく説明します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s move on to Chapter 5 and look at grouping pieces of data together in a <code>struct</code> .</span>第5章に進み、 <code>struct</code>内のデータをまとめてグループ化しましょう。</span> </p><script>_addload(function(){_setupIW('com');_csi('en','ja','ch04-03-slices.html');});</script>