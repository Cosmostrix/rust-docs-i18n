<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180709_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=ch10-01-syntax.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Generic Data Types</span>汎用データ型</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can use generics to create definitions for items like function signatures or structs, which we can then use with many different concrete data types.</span>関数シグネチャや構造体などの定義を作成するためにジェネリックスを使用できます。これらの定義は、多くの異なる具体的なデータ型で使用できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s first look at how to define functions, structs, enums, and methods using generics.</span>まず、ジェネリックを使って関数、構造体、列挙型、およびメソッドを定義する方法を見ていきましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then we&#39;ll discuss how generics affect code performance.</span>次に、ジェネリックがコードのパフォーマンスにどのように影響するかについて説明します。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In Function Definitions</span>関数定義で</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When defining a function that uses generics, we place the generics in the signature of the function where we would usually specify the data types of the parameters and return value.</span>ジェネリックを使用する関数を定義するとき、ジェネリックを関数のシグネチャに置きます。ここでは、通常、パラメータと戻り値のデータ型を指定します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Doing so makes our code more flexible and provides more functionality to callers of our function while preventing code duplication.</span>そうすることで、コードの柔軟性が高まり、コードの重複を防ぎながら、関数の呼び出し側に多くの機能が提供されます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Continuing with our <code>largest</code> function, Listing 10-4 shows two functions that both find the largest value in a slice.</span>引き続き、 <code>largest</code>関数をリスト10-4に示します。リスト10-4は、スライス内で最大の値を見つける2つの関数を示しています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="fn largest_i32(list: &amp;[i32]) -&gt; i32 {"></div><div data-l="    let mut largest = list[0];"></div><div data-l=""></div><div data-l="    for &amp;item in list.iter() {"></div><div data-l="        if item &gt; largest {"></div><div data-l="            largest = item;"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=""></div><div data-l="    largest"></div><div data-l=}></div><div data-l=""></div><div data-l="fn largest_char(list: &amp;[char]) -&gt; char {"></div><div data-l="    let mut largest = list[0];"></div><div data-l=""></div><div data-l="    for &amp;item in list.iter() {"></div><div data-l="        if item &gt; largest {"></div><div data-l="            largest = item;"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=""></div><div data-l="    largest"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let number_list = vec![34, 50, 25, 100, 65];"></div><div data-l=""></div><div data-l="    let result = largest_i32(&amp;number_list);"></div><div data-l="    println!(&quot;The largest number is {}&quot;, result);"></div><div data-l="#    assert_eq!(result, 100);"></div><div data-l=""></div><div data-l="    let char_list = vec!['y', 'm', 'a', 'q'];"></div><div data-l=""></div><div data-l="    let result = largest_char(&amp;char_list);"></div><div data-l="    println!(&quot;The largest char is {}&quot;, result);"></div><div data-l="#    assert_eq!(result, 'y');"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 10-4: Two functions that differ only in their names and the types in their signatures</span></span> <span class=caption>コードリスト10-4：名前とシグネチャの型だけが異なる2つの関数</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>largest_i32</code> function is the one we extracted in Listing 10-3 that finds the largest <code>i32</code> in a slice.</span> <code>largest_i32</code>機能は、最大見つけた私たちは、リスト10-3で抽出されたものです<code>i32</code>スライスして。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>largest_char</code> function finds the largest <code>char</code> in a slice.</span> <code>largest_char</code>関数は、スライス内で最大の<code>char</code>を検出します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The function bodies have the same code, so let&#39;s eliminate the duplication by introducing a generic type parameter in a single function.</span>関数本体には同じコードがありますので、単一の関数に汎用型パラメータを導入して重複を排除しましょう。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To parameterize the types in the new function we&#39;ll define, we need to name the type parameter, just as we do for the value parameters to a function.</span>定義する新しい関数の型をパラメータ化するには、関数への値パラメータの場合と同様に、型パラメータの名前を付ける必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can use any identifier as a type parameter name.</span>任意の識別子を型パラメータ名として使用できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But we&#39;ll use <code>T</code> because, by convention, parameter names in Rust are short, often just a letter, and Rust&#39;s type-naming convention is CamelCase.</span>しかし、慣習的には、Rustのパラメータ名は短く、しばしば単なる文字であり、Rustのタイプ命名規則はCamelCaseであるため、 <code>T</code>を使用します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Short for “type,” <code>T</code> is the default choice of most Rust programmers.</span> &quot;type&quot;の略で、 <code>T</code>はほとんどのRustプログラマーのデフォルトの選択です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When we use a parameter in the body of the function, we have to declare the parameter name in the signature so the compiler knows what that name means.</span>関数の本体でパラメータを使用するときは、コンパイラがその名前の意味を知るように、シグネチャにパラメータ名を宣言する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Similarly, when we use a type parameter name in a function signature, we have to declare the type parameter name before we use it.</span>同様に、関数シグネチャに型パラメータ名を使用する場合は、型パラメータ名を宣言してから使用する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To define the generic <code>largest</code> function, place type name declarations inside angle brackets, <code>&lt;&gt;</code> , between the name of the function and the parameter list, like this:</span>一般的な<code>largest</code>関数を定義するには、型名宣言を関数の名前とパラメータリストの間に<code>&lt;&gt;</code>ように山括弧で囲みます。</span> </p><br><div data-lang=rust,ignore><div data-l="fn largest&lt;T&gt;(list: &amp;[T]) -&gt; T {"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We read this definition as: the function <code>largest</code> is generic over some type <code>T</code> .</span>この定義は次のように解釈されます。関数の<code>largest</code>は、ある型<code>T</code>に対して一般的です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This function has one parameter named <code>list</code> , which is a slice of values of type <code>T</code> .</span>この関数には、 <code>list</code>という名前の1つのパラメータがあります。このパラメータは、 <code>T</code>型の値のスライスです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>largest</code> function will return a value of the same type <code>T</code> .</span> <code>largest</code>関数は、同じ型<code>T</code>値を返します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 10-5 shows the combined <code>largest</code> function definition using the generic data type in its signature.</span>コードリスト10-5に、署名に汎用データ型を使用した<code>largest</code>関数定義を示します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The listing also shows how we can call the function with either a slice of <code>i32</code> values or <code>char</code> values.</span>リストには、 <code>i32</code>値のスライスまたは<code>char</code>値のいずれかで関数を呼び出す方法も示されています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that this code won&#39;t compile yet, but we&#39;ll fix it later in this chapter.</span>このコードはまだコンパイルされませんが、この章の後半で修正します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust,ignore><div data-l="fn largest&lt;T&gt;(list: &amp;[T]) -&gt; T {"></div><div data-l="    let mut largest = list[0];"></div><div data-l=""></div><div data-l="    for &amp;item in list.iter() {"></div><div data-l="        if item &gt; largest {"></div><div data-l="            largest = item;"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=""></div><div data-l="    largest"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let number_list = vec![34, 50, 25, 100, 65];"></div><div data-l=""></div><div data-l="    let result = largest(&amp;number_list);"></div><div data-l="    println!(&quot;The largest number is {}&quot;, result);"></div><div data-l=""></div><div data-l="    let char_list = vec!['y', 'm', 'a', 'q'];"></div><div data-l=""></div><div data-l="    let result = largest(&amp;char_list);"></div><div data-l="    println!(&quot;The largest char is {}&quot;, result);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 10-5: A definition of the <code>largest</code> function that uses generic type parameters but doesn&#39;t compile yet</span></span> <span class=caption>コードリスト10-5：ジェネリック型のパラメータを使用するが、まだコンパイルしていない<code>largest</code>関数の定義</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we compile this code right now, we&#39;ll get this error:</span>今すぐこのコードをコンパイルすると、このエラーが発生します：</span> </p><br><div data-lang=text><div data-l="error[E0369]: binary operation `&gt;` cannot be applied to type `T`"></div><div data-l=" --&gt; src/main.rs:5:12"></div><div data-l="  |"></div><div data-l="5 |         if item &gt; largest {"></div><div data-l="  |            ^^^^^^^^^^^^^^"></div><div data-l="  |"></div><div data-l="  = note: an implementation of `std::cmp::PartialOrd` might be missing for `T`"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The note mentions <code>std::cmp::PartialOrd</code> , which is a <i>trait</i> .</span>このノートでは、 <i>特性</i>である<code>std::cmp::PartialOrd</code>について説明してい<i>ます</i> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll talk about traits in the next section.</span>次のセクションでは、特性について説明します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For now, this error states that the body of <code>largest</code> won&#39;t work for all possible types that <code>T</code> could be.</span>今のところ、このエラーは、 <code>T</code>可能なすべての型に対して、 <code>largest</code>の本体が機能しないことを示しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because we want to compare values of type <code>T</code> in the body, we can only use types whose values can be ordered.</span>本体の<code>T</code>型の値を比較したいので、値を順序付けできる型しか使用できません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To enable comparisons, the standard library has the <code>std::cmp::PartialOrd</code> trait that you can implement on types (see Appendix C for more on this trait).</span>比較を可能にするために、標準ライブラリには型に対して実装できる<code>std::cmp::PartialOrd</code>特性があります（この特性の詳細については付録Cを参照してください）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You&#39;ll learn how to specify that a generic type has a particular trait in the “Trait Bounds” section, but let&#39;s first explore other ways of using generic type parameters.</span> &quot;Trait Bounds&quot;セクションにジェネリック型が特定の特性を持つように指定する方法を学びますが、まずジェネリック型パラメータを使用する他の方法を調べてみましょう。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In Struct Definitions</span>構造定義で</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can also define structs to use a generic type parameter in one or more fields using the <code>&lt;&gt;</code> syntax.</span>また、 <code>&lt;&gt;</code>構文を使用して、1つまたは複数のフィールドでジェネリック型パラメータを使用するように構造体を定義することもできます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 10-6 shows how to define a <code>Point&lt;T&gt;</code> struct to hold <code>x</code> and <code>y</code> coordinate values of any type.</span>リスト10-6は、任意の型の<code>x</code>と<code>y</code>座標値を保持する<code>Point&lt;T&gt;</code>構造体を定義する方法を示しています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="struct Point&lt;T&gt; {"></div><div data-l="    x: T,"></div><div data-l="    y: T,"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let integer = Point { x: 5, y: 10 };"></div><div data-l="    let float = Point { x: 1.0, y: 4.0 };"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 10-6: A <code>Point&lt;T&gt;</code> struct that holds <code>x</code> and <code>y</code> values of type <code>T</code></span></span> <span class=caption>10-6のリスト： <code>Point&lt;T&gt;</code>保持構造体<code>x</code>と<code>y</code>型の値<code>T</code></span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The syntax for using generics in struct definitions is similar to that used in function definitions.</span>構造体定義でジェネリックを使用する構文は、関数定義で使用される構文に似ています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">First, we declare the name of the type parameter inside angle brackets just after the name of the struct.</span>まず、構造体の名前の直後に山形括弧で囲まれた型パラメータの名前を宣言します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then we can use the generic type in the struct definition where we would otherwise specify concrete data types.</span>次に、具体的なデータ型を指定する場合は、構造体定義のジェネリック型を使用できます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that because we&#39;ve used only one generic type to define <code>Point&lt;T&gt;</code> , this definition says that the <code>Point&lt;T&gt;</code> struct is generic over some type <code>T</code> , and the fields <code>x</code> and <code>y</code> are <i>both</i> that same type, whatever that type may be.</span>我々が定義する唯一のジェネリック型を使用しましたので、ことに注意してください<code>Point&lt;T&gt;</code> 、この定義は、と言っている<code>Point&lt;T&gt;</code>のstructいくつかのタイプを超える一般的なものであり<code>T</code> 、およびフィールド<code>x</code>と<code>y</code> 、同じタイプの<i>両方とも</i> 、何でもそのタイプ多分。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we create an instance of a <code>Point&lt;T&gt;</code> that has values of different types, as in Listing 10-7, our code won&#39;t compile.</span>リスト10-7のように、異なる型の値を持つ<code>Point&lt;T&gt;</code>インスタンスを作成すると、コードはコンパイルされません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust,ignore><div data-l="struct Point&lt;T&gt; {"></div><div data-l="    x: T,"></div><div data-l="    y: T,"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let wont_work = Point { x: 5, y: 4.0 };"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 10-7: The fields <code>x</code> and <code>y</code> must be the same type because both have the same generic data type <code>T</code> .</span></span> <span class=caption>リスト10-7：フィールド<code>x</code>と<code>y</code>は、両方とも同じジェネリックデータ型<code>T</code>持つため、同じ型でなければなりません。</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this example, when we assign the integer value 5 to <code>x</code> , we let the compiler know that the generic type <code>T</code> will be an integer for this instance of <code>Point&lt;T&gt;</code> .</span>この例では、整数値5を<code>x</code>に代入すると、ジェネリック型<code>T</code>が<code>Point&lt;T&gt;</code>このインスタンスの整数になることをコンパイラに知らせます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then when we specify 4.0 for <code>y</code> , which we&#39;ve defined to have the same type as <code>x</code> , we&#39;ll get a type mismatch error like this:</span>次に、 <code>x</code>と同じ型を持つと定義した<code>y</code>を4.0と指定すると、次のような型の不一致エラーが発生します。</span> </p><br><div data-lang=text><div data-l="error[E0308]: mismatched types"></div><div data-l=" --&gt; src/main.rs:7:38"></div><div data-l="  |"></div><div data-l="7 |     let wont_work = Point { x: 5, y: 4.0 };"></div><div data-l="  |                                      ^^^ expected integral variable, found"></div><div data-l="floating-point variable"></div><div data-l="  |"></div><div data-l="  = note: expected type `{integer}`"></div><div data-l="             found type `{float}`"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To define a <code>Point</code> struct where <code>x</code> and <code>y</code> are both generics but could have different types, we can use multiple generic type parameters.</span> <code>x</code>と<code>y</code>がともにジェネリックであるが異なるタイプを持つ<code>Point</code>構造体を定義するには、複数のジェネリック型パラメータを使用できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, in Listing 10-8, we can change the definition of <code>Point</code> to be generic over types <code>T</code> and <code>U</code> where <code>x</code> is of type <code>T</code> and <code>y</code> is of type <code>U</code> .</span>たとえば、リスト10-8では、タイプ<code>T</code>とタイプ<code>U</code>ここで、 <code>x</code>はタイプ<code>T</code> 、 <code>y</code>はタイプ<code>U</code>に対して、 <code>Point</code>の定義を汎用タイプに変更することができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="struct Point&lt;T, U&gt; {"></div><div data-l="    x: T,"></div><div data-l="    y: U,"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let both_integer = Point { x: 5, y: 10 };"></div><div data-l="    let both_float = Point { x: 1.0, y: 4.0 };"></div><div data-l="    let integer_and_float = Point { x: 5, y: 4.0 };"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 10-8: A <code>Point&lt;T, U&gt;</code> generic over two types so that <code>x</code> and <code>y</code> can be values of different types</span></span> <span class=caption>リスト10-8： <code>Point&lt;T, U&gt;</code>は2つの型を総称し、 <code>x</code>と<code>y</code>は異なる型の値となりうる</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now all the instances of <code>Point</code> shown are allowed!</span>表示された<code>Point</code>すべてのインスタンスが許可されました！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can use as many generic type parameters in a definition as you want, but using more than a few makes your code hard to read.</span>定義には、必要な数のジェネリック・タイプ・パラメーターを使用できますが、数を超える数を使用すると、コードを読みにくくすることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When you need lots of generic types in your code, it could indicate that your code needs restructuring into smaller pieces.</span>あなたのコードにたくさんのジェネリック型が必要な場合は、コードがより小さな部分に再構成する必要があることを示している可能性があります。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In Enum Definitions</span>列挙型の定義</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As we did with structs, we can define enums to hold generic data types in their variants.</span>構造体で行ったように、さまざまな種類の汎用データ型を保持する列挙型を定義できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s take another look at the <code>Option&lt;T&gt;</code> enum that the standard library provides, which we used in Chapter 6:</span>第6章で使用した標準ライブラリが提供する<code>Option&lt;T&gt;</code>列をもう一度見てみましょう：</span> </p><br><div data-lang=rust><div data-l="enum Option&lt;T&gt; {"></div><div data-l="    Some(T),"></div><div data-l="    None,"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This definition should now make more sense to you.</span>この定義はあなたにもっと意味をなさされるはずです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As you can see, <code>Option&lt;T&gt;</code> is an enum that is generic over type <code>T</code> and has two variants: <code>Some</code> , which holds one value of type <code>T</code> , and a <code>None</code> variant that doesn&#39;t hold any value.</span>あなたが見ることができるように、 <code>Option&lt;T&gt;</code>型の上に一般的なもので列挙型である<code>T</code> ：と二つの変種がある<code>Some</code> 、1型の値を保持している<code>T</code> 、および<code>None</code>任意の値を保持していないバリアントを。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">By using the <code>Option&lt;T&gt;</code> enum, we can express the abstract concept of having an optional value, and because <code>Option&lt;T&gt;</code> is generic, we can use this abstraction no matter what the type of the optional value is.</span> <code>Option&lt;T&gt;</code>列挙型を使用することによって、オプションの値を持つという抽象的な概念を表現することができます。 <code>Option&lt;T&gt;</code>は汎用的なので、オプション値の型に関係なく抽象化を使用できます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Enums can use multiple generic types as well.</span> Enumは複数のジェネリック型も使用できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The definition of the <code>Result</code> enum that we used in Chapter 9 is one example:</span>第9章で使用した<code>Result</code> enumの定義は、一例です。</span> </p><br><div data-lang=rust><div data-l="enum Result&lt;T, E&gt; {"></div><div data-l="    Ok(T),"></div><div data-l="    Err(E),"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Result</code> enum is generic over two types, <code>T</code> and <code>E</code> , and has two variants: <code>Ok</code> , which holds a value of type <code>T</code> , and <code>Err</code> , which holds a value of type <code>E</code> .</span> <code>Result</code>列挙型の2種類、オーバー総称である<code>T</code>と<code>E</code> 、および2つのバリエーションがあります： <code>Ok</code> 、型の値を保持<code>T</code> 、と<code>Err</code>型の値を保持し、 <code>E</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This definition makes it convenient to use the <code>Result</code> enum anywhere we have an operation that might succeed (return a value of some type <code>T</code> ) or fail (return an error of some type <code>E</code> ).</span>この定義は、それが便利に使用できるようになり<code>Result</code>どこでも、我々は成功（いくつかの型の値を返す可能性がある操作持って列挙型を<code>T</code> （いくつかのタイプのエラーを返す）または失敗を<code>E</code> ）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In fact, this is what we used to open a file in Listing 9-3, where <code>T</code> was filled in with the type <code>std::fs::File</code> when the file was opened successfully and <code>E</code> was filled in with the type <code>std::io::Error</code> when there were problems opening the file.</span>実際には、これはリスト9-3のファイルを開くために使用したものです。ファイルが正常にオープンされたときに<code>T</code>がタイプ<code>std::fs::File</code>で埋められ、 <code>E</code>がタイプ<code>std::io::Error</code>ファイルを開くときに問題が発生したときの<code>std::io::Error</code> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When you recognize situations in your code with multiple struct or enum definitions that differ only in the types of the values they hold, you can avoid duplication by using generic types instead.</span>あなたが保持する値の型だけが異なる複数の構造体または列挙型定義を持つコードの状況を認識すると、代わりに汎用型を使用して重複を避けることができます。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In Method Definitions</span>メソッド定義</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can implement methods on structs and enums (as we did in Chapter 5) and use generic types in their definitions, too.</span>構造体と列挙型のメソッドを実装することができます（第5章で行ったように）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 10-9 shows the <code>Point&lt;T&gt;</code> struct we defined in Listing 10-6 with a method named <code>x</code> implemented on it.</span>リスト10-9は、リスト10-6で定義した<code>Point&lt;T&gt;</code>構造体に、 <code>x</code>という名前のメソッドを実装したものです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="struct Point&lt;T&gt; {"></div><div data-l="    x: T,"></div><div data-l="    y: T,"></div><div data-l=}></div><div data-l=""></div><div data-l="impl&lt;T&gt; Point&lt;T&gt; {"></div><div data-l="    fn x(&amp;self) -&gt; &amp;T {"></div><div data-l="        &amp;self.x"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let p = Point { x: 5, y: 10 };"></div><div data-l=""></div><div data-l="    println!(&quot;p.x = {}&quot;, p.x());"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 10-9: Implementing a method named <code>x</code> on the <code>Point&lt;T&gt;</code> struct that will return a reference to the <code>x</code> field of type <code>T</code></span></span> <span class=caption>リスト10-9： <code>T</code>型の<code>x</code>フィールドへの参照を返す<code>Point&lt;T&gt;</code>構造体に<code>x</code>という名前のメソッドを実装する</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here, we&#39;ve defined a method named <code>x</code> on <code>Point&lt;T&gt;</code> that returns a reference to the data in the field <code>x</code> .</span>ここでは、フィールド<code>x</code>データへの参照を返す<code>Point&lt;T&gt;</code> <code>x</code>という名前のメソッドを定義しました。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that we have to declare <code>T</code> just after <code>impl</code> so we can use it to specify that we&#39;re implementing methods on the type <code>Point&lt;T&gt;</code> .</span>私たちは<code>impl</code>直後に<code>T</code>を宣言しなければならないので、 <code>Point&lt;T&gt;</code>型のメソッドを実装するよう指定する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">By declaring <code>T</code> as a generic type after <code>impl</code> , Rust can identify that the type in the angle brackets in <code>Point</code> is a generic type rather than a concrete type.</span> <code>impl</code>後に<code>T</code>をジェネリック型として宣言することで、Rustは<code>Point</code>の角括弧内の型が具体的な型ではなくジェネリック型であることを識別できます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We could, for example, implement methods only on <code>Point&lt;f32&gt;</code> instances rather than on <code>Point&lt;T&gt;</code> instances with any generic type.</span>たとえば、一般的な型の<code>Point&lt;T&gt;</code>インスタンスではなく、 <code>Point&lt;f32&gt;</code>インスタンスでのみメソッドを実装できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In Listing 10-10 we use the concrete type <code>f32</code> , meaning we don&#39;t declare any types after <code>impl</code> .</span>リスト10-10では、具体的な型<code>f32</code>を使用します。つまり、 <code>impl</code>後に型を宣言しません。</span> </p><br><div data-lang=rust><div data-l="# struct Point&lt;T&gt; {"></div><div data-l="#     x: T,"></div><div data-l="#     y: T,"></div><div data-l="# }"></div><div data-l=#></div><div data-l="impl Point&lt;f32&gt; {"></div><div data-l="    fn distance_from_origin(&amp;self) -&gt; f32 {"></div><div data-l="        (self.x.powi(2) + self.y.powi(2)).sqrt()"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 10-10: An <code>impl</code> block that only applies to a struct with a particular concrete type for the generic type parameter <code>T</code></span></span> <span class=caption>リスト10-10：ジェネリック型のパラメータ<code>T</code>特定の具体的な型を持つ構造体にのみ適用される<code>impl</code>ブロック</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This code means the type <code>Point&lt;f32&gt;</code> will have a method named <code>distance_from_origin</code> and other instances of <code>Point&lt;T&gt;</code> where <code>T</code> is not of type <code>f32</code> will not have this method defined.</span>このコードは、 <code>Point&lt;f32&gt;</code>型に<code>distance_from_origin</code>という名前のメソッドがあり、 <code>T</code>が<code>f32</code>型ではない<code>Point&lt;T&gt;</code>他のインスタンスにこのメソッドが定義されていないことを意味します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The method measures how far our point is from the point at coordinates (0.0, 0.0) and uses mathematical operations that are available only for floating point types.</span>このメソッドは、ポイントが座標（0.0、0.0）のポイントからどれだけ離れているかを測定し、浮動小数点タイプに対してのみ使用可能な数学演算を使用します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Generic type parameters in a struct definition aren&#39;t always the same as those you use in that struct&#39;s method signatures.</span>構造体定義の汎用型のパラメータは、その構造体のメソッドのシグネチャで使用するものと必ずしも同じではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, Listing 10-11 defines the method <code>mixup</code> on the <code>Point&lt;T, U&gt;</code> struct from Listing 10-8.</span>例えば、リスト10-11は、リスト10-8の<code>Point&lt;T, U&gt;</code>構造体のメソッド<code>mixup</code>を定義しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The method takes another <code>Point</code> as a parameter, which might have different types than the <code>self</code> <code>Point</code> we&#39;re calling <code>mixup</code> on.</span>この方法は、別のかかる<code>Point</code>とは異なるタイプかもしれませんパラメータとして<code>self</code> <code>Point</code>私たちが呼んでいる<code>mixup</code>上に。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The method creates a new <code>Point</code> instance with the <code>x</code> value from the <code>self</code> <code>Point</code> (of type <code>T</code> ) and the <code>y</code> value from the passed-in <code>Point</code> (of type <code>W</code> ).</span>この方法は、新規作成<code>Point</code>とインスタンス<code>x</code>の値<code>self</code> <code>Point</code> （タイプの<code>T</code> ）と<code>y</code>の値を渡された<code>Point</code> （型の<code>W</code> ）。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="struct Point&lt;T, U&gt; {"></div><div data-l="    x: T,"></div><div data-l="    y: U,"></div><div data-l=}></div><div data-l=""></div><div data-l="impl&lt;T, U&gt; Point&lt;T, U&gt; {"></div><div data-l="    fn mixup&lt;V, W&gt;(self, other: Point&lt;V, W&gt;) -&gt; Point&lt;T, W&gt; {"></div><div data-l="        Point {"></div><div data-l="            x: self.x,"></div><div data-l="            y: other.y,"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let p1 = Point { x: 5, y: 10.4 };"></div><div data-l="    let p2 = Point { x: &quot;Hello&quot;, y: 'c'};"></div><div data-l=""></div><div data-l="    let p3 = p1.mixup(p2);"></div><div data-l=""></div><div data-l="    println!(&quot;p3.x = {}, p3.y = {}&quot;, p3.x, p3.y);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 10-11: A method that uses different generic types than its struct&#39;s definition</span></span> <span class=caption>リスト10-11：構造体の定義とは異なるジェネリック型を使用するメソッド</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In <code>main</code> , we&#39;ve defined a <code>Point</code> that has an <code>i32</code> for <code>x</code> (with value <code>5</code> ) and an <code>f64</code> for <code>y</code> (with value <code>10.4</code> ).</span> <code>main</code>では、 <code>x</code> <code>i32</code> （値<code>5</code> ）と<code>y</code> <code>f64</code> （値<code>10.4</code> ）を持つ<code>Point</code>を定義しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>p2</code> variable is a <code>Point</code> struct that has a string slice for <code>x</code> (with value <code>&quot;Hello&quot;</code> ) and a <code>char</code> for <code>y</code> (with value <code>c</code> ).</span> <code>p2</code>変数である<code>Point</code>の文字列スライス有する構造体<code>x</code> （値が<code>&quot;Hello&quot;</code> ）及び<code>char</code>用の<code>y</code> （値と<code>c</code> ）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Calling <code>mixup</code> on <code>p1</code> with the argument <code>p2</code> gives us <code>p3</code> , which will have an <code>i32</code> for <code>x</code> , because <code>x</code> came from <code>p1</code> .</span> <code>p1</code>を引数<code>p2</code>で<code>mixup</code>すると、私たちは<code>p3</code> <code>i32</code> <code>x</code>は<code>p1</code>から来たので、 <code>x</code> <code>i32</code>を持ちます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>p3</code> variable will have a <code>char</code> for <code>y</code> , because <code>y</code> came from <code>p2</code> .</span> <code>y</code>は<code>p2</code>から来たので、 <code>p3</code>変数は<code>y</code> <code>char</code>を持ちます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>println€</code> macro call will print <code>p3.x = 5, p3.y = c</code> .</span> <code>println€</code>マクロ呼び出しは<code>p3.x = 5, p3.y = c</code>ます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The purpose of this example is to demonstrate a situation in which some generic parameters are declared with <code>impl</code> and some are declared with the method definition.</span>この例の目的は、いくつかのジェネリックパラメータが<code>impl</code>で宣言され、いくつかがメソッド定義で宣言される状況を示すことです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here, the generic parameters <code>T</code> and <code>U</code> are declared after <code>impl</code> , because they go with the struct definition.</span>ここでは、一般的なパラメータ<code>T</code>と<code>U</code>は、構造体定義に従うため、 <code>impl</code>後に宣言されています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The generic parameters <code>V</code> and <code>W</code> are declared after <code>fn mixup</code> , because they&#39;re only relevant to the method.</span>ジェネリックパラメータ<code>V</code>と<code>W</code>は、 <code>fn mixup</code>後に宣言されます。なぜなら、それらはメソッドにのみ関連しているからです。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Performance of Code Using Generics</span> Genericsを使用したコードのパフォーマンス</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You might be wondering whether there is a runtime cost when you&#39;re using generic type parameters.</span>ジェネリック型パラメータを使用しているときにランタイムコストがあるかどうか疑問に思うかもしれません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The good news is that Rust implements generics in such a way that your code doesn&#39;t run any slower using generic types than it would with concrete types.</span>良いニュースは、Rustはジェネリック型を具体的な型よりも遅く実行しないようにジェネリック型を実装することです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust accomplishes this by performing monomorphization of the code that is using generics at compile time.</span> Rustは、コンパイル時にジェネリックを使用しているコードの単体化を実行することでこれを実現します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><i>Monomorphization</i> is the process of turning generic code into specific code by filling in the concrete types that are used when compiled.</span> <i>単体化</i>は、コンパイル時に使用される具体的な型を<i>埋め込む</i>ことによって、汎用コードを特定のコードに変換するプロセスです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this process, the compiler does the opposite of the steps we used to create the generic function in Listing 10-5: the compiler looks at all the places where generic code is called and generates code for the concrete types the generic code is called with.</span>このプロセスでは、コンパイラはコードリスト10-5のジェネリック関数を作成するために使用した手順の逆を行います。コンパイラはジェネリックコードが呼び出されるすべての場所を調べ、ジェネリックコードが呼び出される具象型のコードを生成します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s look at how this works with an example that uses the standard library&#39;s <code>Option&lt;T&gt;</code> enum:</span>これは、標準ライブラリの<code>Option&lt;T&gt;</code>列挙型を使用する例でどのように動作するかを見てみましょう：</span> </p><br><div data-lang=rust><div data-l="let integer = Some(5);"></div><div data-l="let float = Some(5.0);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When Rust compiles this code, it performs monomorphization.</span> Rustがこのコードをコンパイルすると、単形化が実行されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">During that process, the compiler reads the values that have been used in <code>Option&lt;T&gt;</code> instances and identifies two kinds of <code>Option&lt;T&gt;</code> : one is <code>i32</code> and the other is <code>f64</code> .</span>このプロセス中、コンパイラは<code>Option&lt;T&gt;</code>インスタンスで使用された値を読み込み、2種類の<code>Option&lt;T&gt;</code>を識別します.1つは<code>i32</code>で、もう1つは<code>f64</code>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As such, it expands the generic definition of <code>Option&lt;T&gt;</code> into <code>Option_i32</code> and <code>Option_f64</code> , thereby replacing the generic definition with the specific ones.</span>そのため、 <code>Option&lt;T&gt;</code>の汎用定義を<code>Option_i32</code>と<code>Option_f64</code> 、汎用定義を特定のものに置き換えます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The monomorphized version of the code looks like the following.</span>コードの単形化バージョンは以下のようになります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The generic <code>Option&lt;T&gt;</code> is replaced with the specific definitions created by the compiler:</span>一般的な<code>Option&lt;T&gt;</code>は、コンパイラによって作成された特定の定義に置き換えられます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="enum Option_i32 {"></div><div data-l="    Some(i32),"></div><div data-l="    None,"></div><div data-l=}></div><div data-l=""></div><div data-l="enum Option_f64 {"></div><div data-l="    Some(f64),"></div><div data-l="    None,"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let integer = Option_i32::Some(5);"></div><div data-l="    let float = Option_f64::Some(5.0);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because Rust compiles generic code into code that specifies the type in each instance, we pay no runtime cost for using generics.</span> Rustはジェネリックコードを各インスタンスの型を指定するコードにコンパイルするので、ジェネリックの使用にはランタイムコストはかかりません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When the code runs, it performs just as it would if we had duplicated each definition by hand.</span>コードが実行されると、各定義を手作業で複製した場合と同じように機能します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The process of monomorphization makes Rust&#39;s generics extremely efficient at runtime.</span>単相化のプロセスは、実行時にRustのジェネリックを非常に効率的にします。</span> </p><script>_addload(function(){_setupIW('com');_csi('en','ja','ch10-01-syntax.html');});</script>