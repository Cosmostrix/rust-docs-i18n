<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180709_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=ch13-02-iterators.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Processing a Series of Items with Iterators</span>イテレータを使用した一連のアイテムの処理</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The iterator pattern allows you to perform some task on a sequence of items in turn.</span>イテレーター・パターンを使用すると、アイテムのシーケンスに対して何らかのタスクを順番に実行できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">An iterator is responsible for the logic of iterating over each item and determining when the sequence has finished.</span>イテレータは、各アイテムの反復処理のロジックと、シーケンスがいつ終了したかを判断します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When you use iterators, you don&#39;t have to reimplement that logic yourself.</span>イテレーターを使用する場合、そのロジックを自分自身で再実装する必要はありません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In Rust, iterators are <i>lazy</i> , meaning they have no effect until you call methods that consume the iterator to use it up.</span> Rustでは、イテレータは<i>遅延してい</i>ます。イテレータは、イテレータを消費するメソッドを呼び出すまで効果がありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, the code in Listing 13-13 creates an iterator over the items in the vector <code>v1</code> by calling the <code>iter</code> method defined on <code>Vec&lt;T&gt;</code> .</span>たとえば、リスト13-13のコードは、 <code>Vec&lt;T&gt;</code>定義されている<code>iter</code>メソッドを呼び出すことによって、ベクトル<code>v1</code>項目に対するイテレータを作成します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This code by itself doesn&#39;t do anything useful.</span>このコード自体は役に立ちません。</span> </p><br><div data-lang=rust><div data-l="let v1 = vec![1, 2, 3];"></div><div data-l=""></div><div data-l="let v1_iter = v1.iter();"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 13-13: Creating an iterator</span></span> <span class=caption>リスト13-13：イテレータの作成</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Once we&#39;ve created an iterator, we can use it in a variety of ways.</span>イテレータを作成したら、さまざまな方法で使用できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In Listing 3-5 in Chapter 3, we used iterators with <code>for</code> loops to execute some code on each item, although we glossed over what the call to <code>iter</code> did until now.</span>第3章のリスト3-5では、 <code>iter</code>と<code>for</code>ループを使用して各項目にいくつかのコードを実行しましたが、今まで<code>iter</code>の呼び出しが何をしていたのかを詳しく説明しました。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The example in Listing 13-14 separates the creation of the iterator from the use of the iterator in the <code>for</code> loop.</span>コードリスト13-14の例は、イテレータの作成と、 <code>for</code>ループのイテレータの使用を分けています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The iterator is stored in the <code>v1_iter</code> variable, and no iteration takes place at that time.</span>イテレータは<code>v1_iter</code>変数に格納され、その時点で反復は行われません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When the <code>for</code> loop is called using the iterator in <code>v1_iter</code> , each element in the iterator is used in one iteration of the loop, which prints out each value.</span> <code>v1_iter</code>のイテレータを使用して<code>for</code>ループを呼び出すと、ループの1回の反復でイテレータの各要素が使用され、各値が出力されます。</span> </p><br><div data-lang=rust><div data-l="let v1 = vec![1, 2, 3];"></div><div data-l=""></div><div data-l="let v1_iter = v1.iter();"></div><div data-l=""></div><div data-l="for val in v1_iter {"></div><div data-l="    println!(&quot;Got: {}&quot;, val);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 13-14: Using an iterator in a <code>for</code> loop</span></span> <span class=caption>リスト13-14： <code>for</code>ループでイテレータを使う</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In languages that don&#39;t have iterators provided by their standard libraries, you would likely write this same functionality by starting a variable at index 0, using that variable to index into the vector to get a value, and incrementing the variable value in a loop until it reached the total number of items in the vector.</span>標準ライブラリによって提供されるイテレータを持たない言語では、インデックス0で変数を開始し、その変数を使用してベクトルにインデックスを付けて値を取得し、変数値をループ内でインクリメントすることによって、ベクトル内のアイテムの総数に達するまで続けます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Iterators handle all that logic for you, cutting down on repetitive code you could potentially mess up.</span>反復子はあなたのためにすべてのロジックを処理し、潜在的に混乱する可能性のある繰り返しコードを減らします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Iterators give you more flexibility to use the same logic with many different kinds of sequences, not just data structures you can index into, like vectors.</span>イテレーターは、ベクトルのようにインデックスを付けることができるデータ構造だけでなく、さまざまな種類のシーケンスで同じロジックを使用する柔軟性を提供します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s examine how iterators do that.</span>イテレータがどのようにそれを行うのかを見てみましょう。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Iterator</code> Trait and the <code>next</code> Method</span> <code>Iterator</code>特性と<code>next</code>メソッド</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">All iterators implement a trait named <code>Iterator</code> that is defined in the standard library.</span>すべてのイテレータは、標準ライブラリで定義されている<code>Iterator</code>という名前の特性を実装しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The definition of the trait looks like this:</span>形質の定義は次のようになります。</span> </p><br><div data-lang=rust><div data-l="pub trait Iterator {"></div><div data-l="    type Item;"></div><div data-l=""></div><div data-l="    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;"></div><div data-l=""></div><div data-l="#    // methods with default implementations elided"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">methods with default implementations elided</span>デフォルト実装を持つメソッドは省略されました</span> </div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Notice this definition uses some new syntax: <code>type Item</code> and <code>Self::Item</code> , which are defining an <i>associated type</i> with this trait.</span>この定義には、いくつかの新しい構文、 <code>type Item</code>と<code>Self::Item</code>使用されていることに注目してください。これらは、この特性で<i>関連する型</i>を定義しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll talk about associated types in depth in Chapter 19. For now, all you need to know is that this code says implementing the <code>Iterator</code> trait requires that you also define an <code>Item</code> type, and this <code>Item</code> type is used in the return type of the <code>next</code> method.</span>関連する型については、第19章で詳しく説明します。ここでは、このコードでは<code>Iterator</code>特性を実装するために<code>Item</code>型も定義する必要があり、この<code>Item</code>型は<code>next</code>方法。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In other words, the <code>Item</code> type will be the type returned from the iterator.</span>つまり、 <code>Item</code>型はイテレータから返される型になります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Iterator</code> trait only requires implementors to define one method: the <code>next</code> method, which returns one item of the iterator at a time wrapped in <code>Some</code> and, when iteration is over, returns <code>None</code> .</span> <code>Iterator</code> ：特性は、唯一の方法を定義するために実装する必要が<code>next</code>に包まれた時に、イテレータの一つのアイテムを返すメソッド、 <code>Some</code>反復が終わったとき、返さないと、 <code>None</code> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can call the <code>next</code> method on iterators directly;</span>イテレータの<code>next</code>メソッドを直接呼び出すことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 13-15 demonstrates what values are returned from repeated calls to <code>next</code> on the iterator created from the vector.</span>リスト13-15は、ベクトルから作成されたイテレータの<code>next</code>への繰り返し呼び出しから返される値を示しています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/lib.rs</span></span> <span class=filename>ファイル名：src / lib.rs</span></span> </p><br><div data-lang=rust><div data-l=#[test]></div><div data-l="fn iterator_demonstration() {"></div><div data-l="    let v1 = vec![1, 2, 3];"></div><div data-l=""></div><div data-l="    let mut v1_iter = v1.iter();"></div><div data-l=""></div><div data-l="    assert_eq!(v1_iter.next(), Some(&amp;1));"></div><div data-l="    assert_eq!(v1_iter.next(), Some(&amp;2));"></div><div data-l="    assert_eq!(v1_iter.next(), Some(&amp;3));"></div><div data-l="    assert_eq!(v1_iter.next(), None);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 13-15: Calling the <code>next</code> method on an iterator</span></span> <span class=caption>リスト13-15：イテレータで<code>next</code>メソッドを呼び出す</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that we needed to make <code>v1_iter</code> mutable: calling the <code>next</code> method on an iterator changes internal state that the iterator uses to keep track of where it is in the sequence.</span> <code>v1_iter</code>変更可能にする必要があることに注意してください。イテレータで<code>next</code>メソッドを呼び出すと、イテレータがシーケンス内のどこにあるかを追跡するために内部状態が変更されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In other words, this code <i>consumes</i> , or uses up, the iterator.</span>言い換えると、このコードはイテレータを<i>消費する</i>か、またはそれを使い果たします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Each call to <code>next</code> eats up an item from the iterator.</span> <code>next</code>各呼び出しは、イテレータからアイテムを取得します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We didn&#39;t need to make <code>v1_iter</code> mutable when we used a <code>for</code> loop because the loop took ownership of <code>v1_iter</code> and made it mutable behind the scenes.</span> <code>for</code>ループを使用したときに<code>v1_iter</code>変更する必要はありませんでした。なぜなら、ループが<code>v1_iter</code>所有権を<code>v1_iter</code> 、その背後で可変にできるからです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Also note that the values we get from the calls to <code>next</code> are immutable references to the values in the vector.</span>また、 <code>next</code>の呼び出しから得られる値は、ベクトル内の値への不変な参照であることにも注意してください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>iter</code> method produces an iterator over immutable references.</span> <code>iter</code>メソッドは、不変参照のイテレータを生成します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we want to create an iterator that takes ownership of <code>v1</code> and returns owned values, we can call <code>into_iter</code> instead of <code>iter</code> .</span> <code>v1</code>所有権を持ち、所有されている値を返すイテレータを作成したい場合は、 <code>iter</code>代わりに<code>into_iter</code>を呼び出すことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Similarly, if we want to iterate over mutable references, we can call <code>iter_mut</code> instead of <code>iter</code> .</span>同様に、変更可能な参照を反復したい場合、 <code>iter</code>代わりに<code>iter_mut</code>を呼び出すことができます。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Methods that Consume the Iterator</span>イテレータを消費するメソッド</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Iterator</code> trait has a number of different methods with default implementations provided by the standard library;</span> <code>Iterator</code>特性には、標準ライブラリによって提供されるデフォルトの実装を使用してさまざまなメソッドがあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">you can find out about these methods by looking in the standard library API documentation for the <code>Iterator</code> trait.</span>これらのメソッドについては、 <code>Iterator</code>特性の標準ライブラリAPIドキュメントを参照してください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Some of these methods call the <code>next</code> method in their definition, which is why you&#39;re required to implement the <code>next</code> method when implementing the <code>Iterator</code> trait.</span>これらのメソッドの中には、その定義内で<code>next</code>メソッドを呼び出すものがあります。そのため、 <code>Iterator</code>特性を実装する際に<code>next</code>メソッドを実装する必要があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Methods that call <code>next</code> are called <i>consuming adaptors</i> , because calling them uses up the iterator.</span> <code>next</code>呼び出すメソッドは、呼び出すメソッドがイテレータを使い果たすので、 <i>消費アダプタ</i>と呼ばれます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">One example is the <code>sum</code> method, which takes ownership of the iterator and iterates through the items by repeatedly calling <code>next</code> , thus consuming the iterator.</span> 1つの例は、イテレータの所有権を取得し、 <code>next</code>繰り返し呼び出すことによってアイテムを反復し、イテレータを消費する<code>sum</code>メソッドです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As it iterates through, it adds each item to a running total and returns the total when iteration is complete.</span>反復処理が繰り返されると、実行中の合計に各項目が追加され、繰り返しが完了すると合計が返されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 13-16 has a test illustrating a use of the <code>sum</code> method:</span>コードリスト13-16に<code>sum</code>メソッドの使い方を示すテストがあります：</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/lib.rs</span></span> <span class=filename>ファイル名：src / lib.rs</span></span> </p><br><div data-lang=rust><div data-l=#[test]></div><div data-l="fn iterator_sum() {"></div><div data-l="    let v1 = vec![1, 2, 3];"></div><div data-l=""></div><div data-l="    let v1_iter = v1.iter();"></div><div data-l=""></div><div data-l="    let total: i32 = v1_iter.sum();"></div><div data-l=""></div><div data-l="    assert_eq!(total, 6);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 13-16: Calling the <code>sum</code> method to get the total of all items in the iterator</span></span> <span class=caption>リスト13-16： <code>sum</code>メソッドを呼び出してイテレータ内のすべてのアイテムの合計を取得する</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We aren&#39;t allowed to use <code>v1_iter</code> after the call to <code>sum</code> because <code>sum</code> takes ownership of the iterator we call it on.</span> <code>sum</code>が呼び出したイテレータの所有権を取るので、 <code>v1_iter</code>を<code>sum</code>の呼び出しの後に使用することはできません。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Methods that Produce Other Iterators</span>他のイテレータを生成するメソッド</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Other methods defined on the <code>Iterator</code> trait, known as <i>iterator adaptors</i> , allow you to change iterators into different kinds of iterators.</span>上で定義されたその他の方法<code>Iterator</code> <i>イテレータアダプタ</i>として知られている特徴は、あなたがイテレータの異なる種類にイテレータを変更することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can chain multiple calls to iterator adaptors to perform complex actions in a readable way.</span>イテレーター・アダプターへの複数の呼び出しをチェーン化して、複雑なアクションを読み取り可能な方法で実行することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But because all iterators are lazy, you have to call one of the consuming adaptor methods to get results from calls to iterator adaptors.</span>しかし、すべてのイテレータは怠惰なので、イテレータアダプタを呼び出して結果を得るためには、消費するアダプタメソッドの1つを呼び出さなければなりません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 13-17 shows an example of calling the iterator adaptor method <code>map</code> , which takes a closure to call on each item to produce a new iterator.</span>コードリスト13-17に、イテレータ・アダプタ・メソッド・<code>map</code>をコールする例を示し<code>map</code> 。この<code>map</code>では、各イテレータをコールするクロージャを使用して新しいイテレータを生成します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The closure here creates a new iterator in which each item from the vector has been incremented by 1. However, this code produces a warning:</span>ここでのクロージャは、新しいイテレータを作成します。このイテレータでは、ベクトルの各アイテムが1つずつインクリメントされます。ただし、このコードでは警告が生成されます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="let v1: Vec&lt;i32&gt; = vec![1, 2, 3];"></div><div data-l=""></div><div data-l="v1.iter().map(|x| x + 1);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 13-17: Calling the iterator adaptor <code>map</code> to create a new iterator</span></span> <span class=caption>リスト13-17：イテレータ・アダプタ・<code>map</code>をコールして新しいイテレータを作成する</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The warning we get is this:</span>私たちが得る警告はこれです：</span> </p><br><div data-lang=text><div data-l="warning: unused `std::iter::Map` which must be used: iterator adaptors are lazy"></div><div data-l="and do nothing unless consumed"></div><div data-l=" --&gt; src/main.rs:4:5"></div><div data-l="  |"></div><div data-l="4 |     v1.iter().map(|x| x + 1);"></div><div data-l="  |     ^^^^^^^^^^^^^^^^^^^^^^^^^"></div><div data-l="  |"></div><div data-l="  = note: #[warn(unused_must_use)] on by default"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The code in Listing 13-17 doesn&#39;t do anything;</span>リスト13-17のコードは何もしません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">the closure we&#39;ve specified never gets called.</span>指定したクロージャは決して呼び出されません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The warning reminds us why: iterator adaptors are lazy, and we need to consume the iterator here.</span>この警告は、なぜイテレータアダプタが怠惰であるかを思い出させるもので、イテレータをここで消費する必要があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To fix this and consume the iterator, we&#39;ll use the <code>collect</code> method, which we used in Chapter 12 with <code>env::args</code> in Listing 12-1.</span>これを修正してイテレータを使用するには、リスト12-1の<code>env::args</code>で第12章で使用した<code>collect</code>メソッドを使用します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This method consumes the iterator and collects the resulting values into a collection data type.</span>このメソッドはイテレータを使用し、結果の値をコレクションデータ型に集めます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In Listing 13-18, we collect the results of iterating over the iterator that&#39;s returned from the call to <code>map</code> into a vector.</span>コードリスト13-18では、呼び出しから返されたイテレータをベクトルに<code>map</code>するための反復の結果を収集します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This vector will end up containing each item from the original vector incremented by 1.</span>このベクトルは、元のベクトルから各項目を1つずつインクリメントしたものになります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="let v1: Vec&lt;i32&gt; = vec![1, 2, 3];"></div><div data-l=""></div><div data-l="let v2: Vec&lt;_&gt; = v1.iter().map(|x| x + 1).collect();"></div><div data-l=""></div><div data-l="assert_eq!(v2, vec![2, 3, 4]);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 13-18: Calling the <code>map</code> method to create a new iterator and then calling the <code>collect</code> method to consume the new iterator and create a vector</span></span> <span class=caption>リスト13-18： <code>map</code>メソッドを呼び出して新しいイテレータを作成し、次に新しいイテレータを消費する<code>collect</code>メソッドを呼び出してベクトルを作成する</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because <code>map</code> takes a closure, we can specify any operation we want to perform on each item.</span> <code>map</code>はクロージャを使用するため、各アイテムで実行する操作を指定できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is a great example of how closures let you customize some behavior while reusing the iteration behavior that the <code>Iterator</code> trait provides.</span>これは、 <code>Iterator</code>特性が提供する反復動作を再利用しながらクロージャがいくつかの動作をカスタマイズする方法の素晴らしい例です。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Using Closures that Capture Their Environment</span>環境を取り込むクロージャを使用する</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now that we&#39;ve introduced iterators, we can demonstrate a common use of closures that capture their environment by using the <code>filter</code> iterator adaptor.</span>イテレータを導入したので、 <code>filter</code>イテレータアダプタを使用して環境をキャプチャするクロージャの一般的な使用方法を示すことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>filter</code> method on an iterator takes a closure that takes each item from the iterator and returns a Boolean.</span>イテレータの<code>filter</code>メソッドは、各アイテムをイテレータから<code>filter</code> 、ブール値を返すクロージャを受け取ります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If the closure returns <code>true</code> , the value will be included in the iterator produced by <code>filter</code> .</span>クロージャが<code>true</code>返す<code>true</code> 、値は<code>filter</code>によって生成されたイテレータに含まれ<code>filter</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If the closure returns <code>false</code> , the value won&#39;t be included in the resulting iterator.</span>クロージャが<code>false</code>返すと、結果のイテレータに値は含まれません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In Listing 13-19, we use <code>filter</code> with a closure that captures the <code>shoe_size</code> variable from its environment to iterate over a collection of <code>Shoe</code> struct instances.</span>リスト13-19では、環境から<code>shoe_size</code>変数を取得して<code>Shoe</code>構造体インスタンスのコレクションを反復処理するクロージャを使用して<code>filter</code>を使用します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It will return only shoes that are the specified size.</span>指定されたサイズの靴だけが返されます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/lib.rs</span></span> <span class=filename>ファイル名：src / lib.rs</span></span> </p><br><div data-lang=rust><div data-l="#[derive(PartialEq, Debug)]"></div><div data-l="struct Shoe {"></div><div data-l="    size: u32,"></div><div data-l="    style: String,"></div><div data-l=}></div><div data-l=""></div><div data-l="fn shoes_in_my_size(shoes: Vec&lt;Shoe&gt;, shoe_size: u32) -&gt; Vec&lt;Shoe&gt; {"></div><div data-l="    shoes.into_iter()"></div><div data-l="        .filter(|s| s.size == shoe_size)"></div><div data-l="        .collect()"></div><div data-l=}></div><div data-l=""></div><div data-l=#[test]></div><div data-l="fn filters_by_size() {"></div><div data-l="    let shoes = vec!["></div><div data-l="        Shoe { size: 10, style: String::from(&quot;sneaker&quot;) },"></div><div data-l="        Shoe { size: 13, style: String::from(&quot;sandal&quot;) },"></div><div data-l="        Shoe { size: 10, style: String::from(&quot;boot&quot;) },"></div><div data-l="    ];"></div><div data-l=""></div><div data-l="    let in_my_size = shoes_in_my_size(shoes, 10);"></div><div data-l=""></div><div data-l="    assert_eq!("></div><div data-l="        in_my_size,"></div><div data-l="        vec!["></div><div data-l="            Shoe { size: 10, style: String::from(&quot;sneaker&quot;) },"></div><div data-l="            Shoe { size: 10, style: String::from(&quot;boot&quot;) },"></div><div data-l="        ]"></div><div data-l="    );"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 13-19: Using the <code>filter</code> method with a closure that captures <code>shoe_size</code></span></span> <span class=caption>リスト13-19： <code>shoe_size</code>をキャプチャするクロージャでの<code>filter</code>メソッドの使用</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>shoes_in_my_size</code> function takes ownership of a vector of shoes and a shoe size as parameters.</span> <code>shoes_in_my_size</code>関数は、パラメータとして靴のベクトルと靴のサイズの所有権を取得します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It returns a vector containing only shoes of the specified size.</span>指定されたサイズの靴のみを含むベクトルを返します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In the body of <code>shoes_in_my_size</code> , we call <code>into_iter</code> to create an iterator that takes ownership of the vector.</span>ボディで<code>shoes_in_my_size</code> 、我々は呼んで<code>into_iter</code>ベクトルの所有権を取得イテレータを作成します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then we call <code>filter</code> to adapt that iterator into a new iterator that only contains elements for which the closure returns <code>true</code> .</span>次に、 <code>filter</code>を呼び出して、そのイテレータを、イテレータが<code>true</code>返す要素のみを含む新しいイテレータに適合させるようにします。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The closure captures the <code>shoe_size</code> parameter from the environment and compares the value with each shoe&#39;s size, keeping only shoes of the size specified.</span>クロージャは、環境から<code>shoe_size</code>パラメータを取得し、値を各靴のサイズと比較し、指定されたサイズの靴のみを保持します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Finally, calling <code>collect</code> gathers the values returned by the adapted iterator into a vector that&#39;s returned by the function.</span>最後に、 <code>collect</code>を呼び出すと、適合イテレータによって返された値が関数によって返されたベクトルに集まります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The test shows that when we call <code>shoes_in_my_size</code> , we get back only shoes that have the same size as the value we specified.</span>テストでは、 <code>shoes_in_my_size</code>を呼び出すと、指定した値と同じサイズのシューズのみが返されることが示されています。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Creating Our Own Iterators with the <code>Iterator</code> Trait</span> <code>Iterator</code>特性を使った独自のイテレータの作成</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ve shown that you can create an iterator by calling <code>iter</code> , <code>into_iter</code> , or <code>iter_mut</code> on a vector.</span>ベクトルの<code>iter</code> 、 <code>into_iter</code> 、または<code>iter_mut</code>を呼び出すことによって、イテレータを作成できることが<code>iter_mut</code>ました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can create iterators from the other collection types in the standard library, such as hash map.</span>標準ライブラリの他のコレクションタイプ（ハッシュマップなど）からイテレーターを作成できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can also create iterators that do anything you want by implementing the <code>Iterator</code> trait on your own types.</span>独自の型の<code>Iterator</code>特性を実装することで、任意の操作を行うイテレータを作成することもできます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As previously mentioned, the only method you&#39;re required to provide a definition for is the <code>next</code> method.</span>前述のように、定義を提供するために必要な唯一の方法は<code>next</code>方法です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Once you&#39;ve done that, you can use all other methods that have default implementations provided by the <code>Iterator</code> trait!</span>これを済ませたら、 <code>Iterator</code>特性によって提供されるデフォルトの実装を持つ他のすべてのメソッドを使うことができます！</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To demonstrate, let&#39;s create an iterator that will only ever count from 1 to 5. First, we&#39;ll create a struct to hold some values.</span>デモを行うには、1から5までしかカウントしないイテレータを作成しましょう。まず、いくつかの値を保持する構造体を作成します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then we&#39;ll make this struct into an iterator by implementing the <code>Iterator</code> trait and using the values in that implementation.</span>次に、 <code>Iterator</code>特性を実装し、その実装の値を使用して、この構造体をイテレータにします。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 13-20 has the definition of the <code>Counter</code> struct and an associated <code>new</code> function to create instances of <code>Counter</code> :</span>定義13-20たリスト<code>Counter</code>構造体と関連した<code>new</code>のインスタンスを作成するための機能<code>Counter</code> ：</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/lib.rs</span></span> <span class=filename>ファイル名：src / lib.rs</span></span> </p><br><div data-lang=rust><div data-l="struct Counter {"></div><div data-l="    count: u32,"></div><div data-l=}></div><div data-l=""></div><div data-l="impl Counter {"></div><div data-l="    fn new() -&gt; Counter {"></div><div data-l="        Counter { count: 0 }"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 13-20: Defining the <code>Counter</code> struct and a <code>new</code> function that creates instances of <code>Counter</code> with an initial value of 0 for <code>count</code></span></span> <span class=caption>リスト13-20： <code>count</code>初期値0を持つ<code>Counter</code>インスタンスを作成する<code>Counter</code>構造体と<code>new</code>関数の定義</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Counter</code> struct has one field named <code>count</code> .</span> <code>Counter</code>構造体には、 <code>count</code>という名前の1つのフィールドがあり<code>count</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This field holds a <code>u32</code> value that will keep track of where we are in the process of iterating from 1 to 5. The <code>count</code> field is private because we want the implementation of <code>Counter</code> to manage its value.</span>このフィールドには、保持している<code>u32</code>我々は1から5まで反復の過程のどこにいるのを追跡します値<code>count</code>我々は実装したいので、プライベートでフィールドを<code>Counter</code> 、その値を管理すること。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>new</code> function enforces the behavior of always starting new instances with a value of 0 in the <code>count</code> field.</span>この<code>new</code>関数は、 <code>count</code>フィールドに値0の新しいインスタンスを常に開始する動作を強制します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Next, we&#39;ll implement the <code>Iterator</code> trait for our <code>Counter</code> type by defining the body of the <code>next</code> method to specify what we want to happen when this iterator is used, as shown in Listing 13-21:</span>次に、反復子が使用されているときに何を実行するかを指定する<code>next</code>メソッドの本体を定義することによって、 <code>Counter</code>型の<code>Iterator</code>特性を実装します（コードリスト13-21を参照）。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/lib.rs</span></span> <span class=filename>ファイル名：src / lib.rs</span></span> </p><br><div data-lang=rust><div data-l="# struct Counter {"></div><div data-l="#     count: u32,"></div><div data-l="# }"></div><div data-l=#></div><div data-l="impl Iterator for Counter {"></div><div data-l="    type Item = u32;"></div><div data-l=""></div><div data-l="    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {"></div><div data-l="        self.count += 1;"></div><div data-l=""></div><div data-l="        if self.count &lt; 6 {"></div><div data-l="            Some(self.count)"></div><div data-l="        } else {"></div><div data-l="            None"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 13-21: Implementing the <code>Iterator</code> trait on our <code>Counter</code> struct</span></span> <span class=caption>リスト13-21： <code>Counter</code>構造体の<code>Iterator</code>特性の実装</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We set the associated <code>Item</code> type for our iterator to <code>u32</code> , meaning the iterator will return <code>u32</code> values.</span>私たちは、関連する設定<code>Item</code>に対する当社のイテレータの型<code>u32</code>イテレータが返されますを意味し、 <code>u32</code>値を。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Again, don&#39;t worry about associated types yet, we&#39;ll cover them in Chapter 19.</span>ここでも、関連付けられた型については心配しないでください。第19章でそれらを扱います。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We want our iterator to add 1 to the current state, so we initialized <code>count</code> to 0 so it would return 1 first.</span>イテレータは現在の状態に1を加算したいので、最初に1を返すように<code>count</code>を0に初期化し<code>count</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If the value of <code>count</code> is less than 6, <code>next</code> will return the current value wrapped in <code>Some</code> , but if <code>count</code> is 6 or higher, our iterator will return <code>None</code> .</span> <code>count</code>の値が6より小さい場合、 <code>next</code>は、 <code>Some</code>でラップされた現在の値を返しますが、 <code>count</code>が6以上であれば、イテレータは<code>None</code>を返します。</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Using Our <code>Counter</code> Iterator&#39;s <code>next</code> Method</span> <code>Counter</code> Iteratorの<code>next</code>メソッドの使用</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Once we&#39;ve implemented the <code>Iterator</code> trait, we have an iterator!</span> <code>Iterator</code>特性を実装したら、イテレータを使用します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 13-22 shows a test demonstrating that we can use the iterator functionality of our <code>Counter</code> struct by calling the <code>next</code> method on it directly, just as we did with the iterator created from a vector in Listing 13-15.</span> 13-22のリスト我々はのイテレータの機能を使用できることを実証テストを示す<code>Counter</code>呼び出すことにより、構造体を<code>next</code>私たちは、リスト13-15でベクターから作成されたイテレータでやったように、直接それに方法を。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/lib.rs</span></span> <span class=filename>ファイル名：src / lib.rs</span></span> </p><br><div data-lang=rust><div data-l="# struct Counter {"></div><div data-l="#     count: u32,"></div><div data-l="# }"></div><div data-l=#></div><div data-l="# impl Iterator for Counter {"></div><div data-l="#     type Item = u32;"></div><div data-l=#></div><div data-l="#     fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {"></div><div data-l="#         self.count += 1;"></div><div data-l=#></div><div data-l="#         if self.count &lt; 6 {"></div><div data-l="#             Some(self.count)"></div><div data-l="#         } else {"></div><div data-l="#             None"></div><div data-l="#         }"></div><div data-l="#     }"></div><div data-l="# }"></div><div data-l=#></div><div data-l=#[test]></div><div data-l="fn calling_next_directly() {"></div><div data-l="    let mut counter = Counter::new();"></div><div data-l=""></div><div data-l="    assert_eq!(counter.next(), Some(1));"></div><div data-l="    assert_eq!(counter.next(), Some(2));"></div><div data-l="    assert_eq!(counter.next(), Some(3));"></div><div data-l="    assert_eq!(counter.next(), Some(4));"></div><div data-l="    assert_eq!(counter.next(), Some(5));"></div><div data-l="    assert_eq!(counter.next(), None);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 13-22: Testing the functionality of the <code>next</code> method implementation</span></span> <span class=caption>リスト13-22： <code>next</code>メソッド実装の機能のテスト</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This test creates a new <code>Counter</code> instance in the <code>counter</code> variable and then calls <code>next</code> repeatedly, verifying that we have implemented the behavior we want this iterator to have: returning the values from 1 to 5.</span>このテストでは、 <code>counter</code>変数に新しい<code>Counter</code>インスタンスが作成され、 <code>next</code>繰り返し呼び出して、このイテレーターに必要な動作を実装していることを確認します。値を1から5に戻します。</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Using Other <code>Iterator</code> Trait Methods</span>他の<code>Iterator</code>特性メソッドの使用</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We implemented the <code>Iterator</code> trait by defining the <code>next</code> method, so we can now use any <code>Iterator</code> trait method&#39;s default implementations as defined in the standard library, because they all use the <code>next</code> method&#39;s functionality.</span> <code>next</code>メソッドを定義することで<code>Iterator</code>特性を実装しました。標準のライブラリで定義されている<code>Iterator</code> traitメソッドのデフォルトの実装は、すべて<code>next</code>メソッドの機能を使用するため使用できます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, if for some reason we wanted to take the values produced by an instance of <code>Counter</code> , pair them with values produced by another <code>Counter</code> instance after skipping the first value, multiply each pair together, keep only those results that are divisible by 3, and add all the resulting values together, we could do so, as shown in the test in Listing 13-23:</span>たとえば、何らかの理由で<code>Counter</code>インスタンスによって生成された値を取得し、最初の値をスキップして別の<code>Counter</code>インスタンスによって生成された値とペアにし、各ペアを掛け合わせ、3で割り切れる結果を保持し、リスト13-23のテストに示されているように、すべての結果の値を一緒に追加することができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/lib.rs</span></span> <span class=filename>ファイル名：src / lib.rs</span></span> </p><br><div data-lang=rust><div data-l="# struct Counter {"></div><div data-l="#     count: u32,"></div><div data-l="# }"></div><div data-l=#></div><div data-l="# impl Counter {"></div><div data-l="#     fn new() -&gt; Counter {"></div><div data-l="#         Counter { count: 0 }"></div><div data-l="#     }"></div><div data-l="# }"></div><div data-l=#></div><div data-l="# impl Iterator for Counter {"></div><div data-l="#//#     // Our iterator will produce u32s"></div><div data-l="#     // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Our iterator will produce u32s</span>私たちのイテレータはu32sを生成します</span> </div><div data-l="#     type Item = u32;"></div><div data-l=#></div><div data-l="#     fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {"></div><div data-l="#//#         // increment our count. This is why we started at zero."></div><div data-l="#         // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">increment our count.</span>カウントを増やす。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is why we started at zero.</span>これが私たちがゼロから始めた理由です。</span> </div><div data-l="#         self.count += 1;"></div><div data-l=#></div><div data-l="#//#         // check to see if we've finished counting or not."></div><div data-l="#         // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">check to see if we&#39;ve finished counting or not.</span>カウントが終了したかどうかを確認してください。</span> </div><div data-l="#         if self.count &lt; 6 {"></div><div data-l="#             Some(self.count)"></div><div data-l="#         } else {"></div><div data-l="#             None"></div><div data-l="#         }"></div><div data-l="#     }"></div><div data-l="# }"></div><div data-l=#></div><div data-l=#[test]></div><div data-l="fn using_other_iterator_trait_methods() {"></div><div data-l="    let sum: u32 = Counter::new().zip(Counter::new().skip(1))"></div><div data-l="                                 .map(|(a, b)| a * b)"></div><div data-l="                                 .filter(|x| x % 3 == 0)"></div><div data-l="                                 .sum();"></div><div data-l="    assert_eq!(18, sum);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 13-23: Using a variety of <code>Iterator</code> trait methods on our <code>Counter</code> iterator</span></span> <span class=caption>リスト13-23： <code>Counter</code> iteratorでさまざまな<code>Iterator</code> traitメソッドを使う</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that <code>zip</code> produces only four pairs;</span> <code>zip</code>は4ペアしか生成しないことに注意してください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">the theoretical fifth pair <code>(5, None)</code> is never produced because <code>zip</code> returns <code>None</code> when either of its input iterators return <code>None</code> .</span>入力イテレータのいずれかが<code>None</code>返すとき、 <code>zip</code>は<code>None</code>返すので、理論上の5番目のペア<code>(5, None)</code>は決して生成され<code>None</code> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">All of these method calls are possible because we specified how the <code>next</code> method works, and the standard library provides default implementations for other methods that call <code>next</code> .</span> <code>next</code>メソッドがどのように動作するかを指定したので、これらのメソッド呼び出しはすべて可能です。標準ライブラリは、 <code>next</code>呼び出すメソッドのデフォルトの実装を提供します。</span> </p><script>_addload(function(){_setupIW('com');_csi('en','ja','ch13-02-iterators.html');});</script>