<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180709_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=ch16-02-message-passing.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Using Message Passing to Transfer Data Between Threads</span>メッセージの受け渡しを使用してスレッド間でデータを転送する</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">One increasingly popular approach to ensuring safe concurrency is <i>message passing</i> , where threads or actors communicate by sending each other messages containing data.</span>安全な並行性を確保するために普及しているアプローチの1つは、スレッドまたはアクターが互いにデータを含むメッセージを送信して通信する<i>メッセージの受け渡し</i>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here&#39;s the idea in a slogan from <a href=#2http://golang.org/doc/effective_go.html>the Go language documentation</a> : “Do not communicate by sharing memory;</span> <a href=#2http://golang.org/doc/effective_go.html>Go言語のドキュメントの</a>スローガンには<a href=#2http://golang.org/doc/effective_go.html>、次</a>のような考えがあり<a href=#2http://golang.org/doc/effective_go.html>ます</a> 。「メモリを共有して通信しないでください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">instead, share memory by communicating.”</span>代わりに、通信によってメモリを共有してください。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">One major tool Rust has for accomplishing message-sending concurrency is the <i>channel</i> , a programming concept that Rust&#39;s standard library provides an implementation of.</span> Rustがメッセージ送信の並行処理を実現するための主要なツールの1つは、Rustの標準ライブラリが実装を提供するプログラミングコンセプトである<i>チャンネル</i>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can imagine a channel in programming as being like a channel of water, such as a stream or a river.</span>番組のチャンネルは、川や川などの水路のようなものであると想像することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you put something like a rubber duck or boat into a stream, it will travel downstream to the end of the waterway.</span>ラバーダックやボートのようなものをストリームに入れると、ストリームは下流の水路まで移動します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A channel in programming has two halves: a transmitter and a receiver.</span>プログラミングのチャンネルには、トランスミッタとレシーバの2つの半分があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The transmitter half is the upstream location where you put rubber ducks into the river, and the receiver half is where the rubber duck ends up downstream.</span>トランスミッターの半分は、あなたがラバーアヒルを川に入れる上流の場所であり、レシーバーの半分はラバーダックが下流に終わるところです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">One part of your code calls methods on the transmitter with the data you want to send, and another part checks the receiving end for arriving messages.</span>コードの1つの部分は、送信したいデータを持つトランスミッタのメソッドを呼び出し、別の部分は到着するメッセージの受信側をチェックします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A channel is said to be <i>closed</i> if either the transmitter or receiver half is dropped.</span>送信機または受信機の半分が落とさ<i>れた</i>場合、チャネルは<i>閉じられた</i>と言われます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here, we&#39;ll work up to a program that has one thread to generate values and send them down a channel, and another thread that will receive the values and print them out.</span>ここでは、値を生成してチャンネルに送る1つのスレッドと、値を受け取り、それらを出力するスレッドを持つプログラムを扱います。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll be sending simple values between threads using a channel to illustrate the feature.</span>私たちは、機能を説明するためにチャンネルを使ってスレッド間で簡単な値を送信します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Once you&#39;re familiar with the technique, you could use channels to implement a chat system or a system where many threads perform parts of a calculation and send the parts to one thread that aggregates the results.</span>このテクニックに精通したら、チャネルを使用してチャットシステムや、多くのスレッドが計算の一部を実行し、その結果を集約する1つのスレッドにそのパーツを送信するシステムを実装できます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">First, in Listing 16-6, we&#39;ll create a channel but not do anything with it.</span>まず、リスト16-6では、チャンネルを作成しますが、何もしません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that this won&#39;t compile yet because Rust can&#39;t tell what type of values we want to send over the channel.</span>これはまだコンパイルされません。なぜなら、Rustはチャンネルを通じて送信したい値のタイプを知ることができないからです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="use std::sync::mpsc;"></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let (tx, rx) = mpsc::channel();"></div><div data-l="#     tx.send(()).unwrap();"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 16-6: Creating a channel and assigning the two halves to <code>tx</code> and <code>rx</code></span></span> <span class=caption>リスト16-6：チャネルを作成し、2つの半分を<code>tx</code>と<code>rx</code>割り当てる</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We create a new channel using the <code>mpsc::channel</code> function;</span> <code>mpsc::channel</code>関数を使用して新しいチャンネルを作成します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>mpsc</code> stands for <i>multiple producer, single consumer</i> .</span> <code>mpsc</code>は、 <i>複数のプロデューサ、単一のコンシューマを</i>表します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In short, the way Rust&#39;s standard library implements channels means a channel can have multiple <i>sending</i> ends that produce values but only one <i>receiving</i> end that consumes those values.</span>要するに、Rustの標準ライブラリがチャネルを実装する方法は、チャネルが値を生成する複数の<i>送信側</i>を持つことができ、それらの値を消費する<i>受信</i>側は1つだけであることを意味します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Imagine multiple streams flowing together into one big river: everything sent down any of the streams will end up in one river at the end.</span>複数の川がひとつの大きな川に流れ込んでいることを想像してください。ストリームのいずれかを下って送られてくるものはすべて、最後の1つの川で終わるでしょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll start with a single producer for now, but we&#39;ll add multiple producers when we get this example working.</span>ここでは1つのプロデューサーから始めますが、この例が有効になったら複数のプロデューサーを追加します。</span> </p><br><p><!-- NEXT PARAGRAPH WRAPPED WEIRD INTENTIONALLY SEE #199 --></p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>mpsc::channel</code> function returns a tuple, the first element of which is the sending end and the second element is the receiving end.</span> <code>mpsc::channel</code>関数はタプルを返します。最初の要素は送信側で、2番目の要素は受信側です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The abbreviations <code>tx</code> and <code>rx</code> are traditionally used in many fields for <i>transmitter</i> and <i>receiver</i> respectively, so we name our variables as such to indicate each end.</span>略語<code>tx</code>と<code>rx</code>は伝統的に<i>トランスミッタ</i>と<i>レシーバの</i>多くのフィールドで使用されています。したがって、各エンドを示すように変数を指定します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;re using a <code>let</code> statement with a pattern that destructures the tuples;</span> <code>let</code>文にタプルを破棄するパターンを使用しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">we&#39;ll discuss the use of patterns in <code>let</code> statements and destructuring in Chapter 18. Using a <code>let</code> statement this way is a convenient approach to extract the pieces of the tuple returned by <code>mpsc::channel</code> .</span> <code>let</code>文とdestructuringのパターンの使用については第18章で説明します。このように<code>let</code>文を使うと、 <code>mpsc::channel</code>返すタプルの断片を抽出する便利な方法です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s move the transmitting end into a spawned thread and have it send one string so the spawned thread is communicating with the main thread, as shown in Listing 16-7.</span>リスト16-7に示すように、送信側を生成されたスレッドに移動し、生成されたスレッドがメインスレッドと通信するように1つの文字列を送信します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is like putting a rubber duck in the river upstream or sending a chat message from one thread to another.</span>これは上流の川にゴム製の鴨を入れたり、あるスレッドから別のスレッドにチャットメッセージを送信するようなものです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="use std::thread;"></div><div data-l="use std::sync::mpsc;"></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let (tx, rx) = mpsc::channel();"></div><div data-l=""></div><div data-l="    thread::spawn(move || {"></div><div data-l="        let val = String::from(&quot;hi&quot;);"></div><div data-l="        tx.send(val).unwrap();"></div><div data-l="    });"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 16-7: Moving <code>tx</code> to a spawned thread and sending “hi”</span></span> <span class=caption>リスト16-7： <code>tx</code>を生成されたスレッドに移動し、 &quot;hi&quot;</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Again, we&#39;re using <code>thread::spawn</code> to create a new thread and then using <code>move</code> to move <code>tx</code> into the closure so the spawned thread owns <code>tx</code> .</span>ここでも、 <code>thread::spawn</code>を使って新しいスレッドを作成し、 <code>move</code>を使って<code>tx</code>をクロージャに移動し、生成されたスレッドが<code>tx</code>所有するようにしています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The spawned thread needs to own the transmitting end of the channel to be able to send messages through the channel.</span>生成されたスレッドは、チャネルを介してメッセージを送信できるようにチャネルの送信側を所有する必要があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The transmitting end has a <code>send</code> method that takes the value we want to send.</span>送信側には、 <code>send</code>たい値をとる<code>send</code>メソッドがあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>send</code> method returns a <code>Result&lt;T, E&gt;</code> type, so if the receiving end has already been dropped and there&#39;s nowhere to send a value, the send operation will return an error.</span> <code>send</code>メソッドは<code>Result&lt;T, E&gt;</code>型を返します。したがって、受信側が既に破棄されていて、値を送信する場所がない場合、送信操作はエラーを返します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this example, we&#39;re calling <code>unwrap</code> to panic in case of an error.</span>この例では、エラーが発生した場合に<code>unwrap</code>をパニックに呼びます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But in a real application, we would handle it properly: return to Chapter 9 to review strategies for proper error handling.</span>しかし、実際のアプリケーションでは、適切に処理します。第9章に戻って、適切なエラー処理の戦略を見直してください。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In Listing 16-8, we&#39;ll get the value from the receiving end of the channel in the main thread.</span>リスト16-8では、メインスレッドのチャネルの受信側から値を取得します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is like retrieving the rubber duck from the water at the end of the river or like getting a chat message.</span>これは、川の端にある水からゴム製の鴨を回収するか、チャットメッセージを受け取るようなものです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="use std::thread;"></div><div data-l="use std::sync::mpsc;"></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let (tx, rx) = mpsc::channel();"></div><div data-l=""></div><div data-l="    thread::spawn(move || {"></div><div data-l="        let val = String::from(&quot;hi&quot;);"></div><div data-l="        tx.send(val).unwrap();"></div><div data-l="    });"></div><div data-l=""></div><div data-l="    let received = rx.recv().unwrap();"></div><div data-l="    println!(&quot;Got: {}&quot;, received);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 16-8: Receiving the value “hi” in the main thread and printing it</span></span> <span class=caption>リスト16-8：メインスレッドで値 &quot;hi&quot;を受け取って印刷する</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The receiving end of a channel has two useful methods: <code>recv</code> and <code>try_recv</code> .</span>チャンネルの受信側には、 <code>recv</code>と<code>try_recv</code> 2つの便利なメソッドがあり<code>try_recv</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;re using <code>recv</code> , short for <i>receive</i> , which will block the main thread&#39;s execution and wait until a value is sent down the channel.</span>私たちは<code>recv</code>を使用しています。これは<i>receiveの</i>略で、メインスレッドの実行をブロックし、チャンネルに値が送信されるまで待機します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Once a value is sent, <code>recv</code> will return it in a <code>Result&lt;T, E&gt;</code> .</span>値が送られると、 <code>recv</code>はそれを<code>Result&lt;T, E&gt;</code>返します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When the sending end of the channel closes, <code>recv</code> will return an error to signal that no more values will be coming.</span>チャネルの送信側が終了すると、 <code>recv</code>はそれ以上の値が来ないことを知らせるエラーを返します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>try_recv</code> method doesn&#39;t block, but will instead return a <code>Result&lt;T, E&gt;</code> immediately: an <code>Ok</code> value holding a message if one is available and an <code>Err</code> value if there aren&#39;t any messages this time.</span> <code>try_recv</code>メソッドはブロックされませんが<code>Result&lt;T, E&gt;</code>すぐに<code>Result&lt;T, E&gt;</code>返されます。メッセージが存在する場合はそれを保持する<code>Ok</code>値、今回はメッセージがない場合は<code>Err</code>値です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Using <code>try_recv</code> is useful if this thread has other work to do while waiting for messages: we could write a loop that calls <code>try_recv</code> every so often, handles a message if one is available, and otherwise does other work for a little while until checking again.</span>使用<code>try_recv</code>メッセージを待っている間、このスレッドが実行する他の仕事を持っている場合に便利です：私たちは呼び出すループ書くことができ<code>try_recv</code> 1が利用可能であり、そうでない場合は、再びチェックするまで、しばらくの間、他の作業を行う場合はそう頻繁ごとに、メッセージを処理します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ve used <code>recv</code> in this example for simplicity;</span> <code>recv</code>やすくするために、この例では<code>recv</code>を使用しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">we don&#39;t have any other work for the main thread to do other than wait for messages, so blocking the main thread is appropriate.</span>メインスレッドがメッセージを待つ以外の作業を行うための他の作業がないため、メインスレッドをブロックすることが適切です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When we run the code in Listing 16-8, we&#39;ll see the value printed from the main thread:</span>リスト16-8のコードを実行すると、メインスレッドから出力された値が表示されます。</span> </p><br><div data-lang=text><div data-l="Got: hi"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Perfect!</span>完璧！</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Channels and Ownership Transference</span>チャネルと所有権移転</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The ownership rules play a vital role in message sending because they help you write safe, concurrent code.</span>所有ルールは、安全で並行したコードを書くのに役立つため、メッセージ送信に不可欠な役割を果たします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Preventing errors in concurrent programming is the advantage of thinking about ownership throughout your Rust programs.</span>並行プログラミングのエラーを防ぐことは、Rustプログラム全体の所有権について考えることの利点です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s do an experiment to show how channels and ownership work together to prevent problems: we&#39;ll try to use a <code>val</code> value in the spawned thread <i>after</i> we&#39;ve sent it down the channel.</span>問題を防ぐためにチャネルと所有権がどのように連携しているかを示すための実験を行いましょう。生成したスレッドをチャンネルに送り込んだ<i>後に</i> <code>val</code>値を使用しようとします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Try compiling the code in Listing 16-9 to see why this code isn&#39;t allowed:</span>リスト16-9のコードをコンパイルして、このコードが許可されていない理由を調べてください。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust,ignore><div data-l="use std::thread;"></div><div data-l="use std::sync::mpsc;"></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let (tx, rx) = mpsc::channel();"></div><div data-l=""></div><div data-l="    thread::spawn(move || {"></div><div data-l="        let val = String::from(&quot;hi&quot;);"></div><div data-l="        tx.send(val).unwrap();"></div><div data-l="        println!(&quot;val is {}&quot;, val);"></div><div data-l="    });"></div><div data-l=""></div><div data-l="    let received = rx.recv().unwrap();"></div><div data-l="    println!(&quot;Got: {}&quot;, received);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 16-9: Attempting to use <code>val</code> after we&#39;ve sent it down the channel</span></span> <span class=caption>リスト16-9： <code>val</code>をchannelの下に送信した後で<code>val</code>を使用しようとしています</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here, we try to print <code>val</code> after we&#39;ve sent it down the channel via <code>tx.send</code> .</span>ここでは、 <code>val</code>を<code>tx.send</code>経由でチャンネルに送った後に<code>val</code>を表示しようとしています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Allowing this would be a bad idea: once the value has been sent to another thread, that thread could modify or drop it before we try to use the value again.</span>これを許すことは悪い考えです。いったん値が別のスレッドに送られると、値を再び使用する前にそのスレッドが変更または削除する可能性があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Potentially, the other thread&#39;s modifications could cause errors or unexpected results due to inconsistent or nonexistent data.</span>潜在的に、他のスレッドの変更は、一貫性のないデータや存在しないデータのためにエラーや予期しない結果を引き起こす可能性があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, Rust gives us an error if we try to compile the code in Listing 16-9:</span>しかし、リスト16-9のコードをコンパイルしようとすると、Rustはエラーを返します。</span> </p><br><div data-lang=text><div data-l="error[E0382]: use of moved value: `val`"></div><div data-l="  --&gt; src/main.rs:10:31"></div><div data-l="   |"></div><div data-l="9  |         tx.send(val).unwrap();"></div><div data-l="   |                 --- value moved here"></div><div data-l="10 |         println!(&quot;val is {}&quot;, val);"></div><div data-l="   |                               ^^^ value used here after move"></div><div data-l="   |"></div><div data-l="   = note: move occurs because `val` has type `std::string::String`, which does"></div><div data-l="not implement the `Copy` trait"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Our concurrency mistake has caused a compile time error.</span>私たちの同時実行間違いは、コンパイル時にエラーを引き起こしました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>send</code> function takes ownership of its parameter, and when the value is moved, the receiver takes ownership of it.</span> <code>send</code>関数はパラメータの所有権を持ち、値が移動されると、受信者はそのパラメータの所有権を取得します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This stops us from accidentally using the value again after sending it;</span>これにより、送信後に誤って値を再使用することがなくなります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">the ownership system checks that everything is okay.</span>所有権システムはすべてが正常であることをチェックします。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Sending Multiple Values and Seeing the Receiver Waiting</span>複数の値を送信し、受信側が待機中であることを確認する</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The code in Listing 16-8 compiled and ran, but it didn&#39;t clearly show us that two separate threads were talking to each other over the channel.</span>リスト16-8のコードはコンパイルされて実行されましたが、2つの別々のスレッドがチャネル上でお互いに話していたことが明確に示されていませんでした。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In Listing 16-10 we&#39;ve made some modifications that will prove the code in Listing 16-8 is running concurrently: the spawned thread will now send multiple messages and pause for a second between each message.</span>リスト16-10では、リスト16-8のコードが同時に実行されていることを証明するいくつかの変更を行いました。生成されたスレッドは複数のメッセージを送信し、各メッセージ間で1秒間ポーズします。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="use std::thread;"></div><div data-l="use std::sync::mpsc;"></div><div data-l="use std::time::Duration;"></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let (tx, rx) = mpsc::channel();"></div><div data-l=""></div><div data-l="    thread::spawn(move || {"></div><div data-l="        let vals = vec!["></div><div data-l="            String::from(&quot;hi&quot;),"></div><div data-l="            String::from(&quot;from&quot;),"></div><div data-l="            String::from(&quot;the&quot;),"></div><div data-l="            String::from(&quot;thread&quot;),"></div><div data-l="        ];"></div><div data-l=""></div><div data-l="        for val in vals {"></div><div data-l="            tx.send(val).unwrap();"></div><div data-l="            thread::sleep(Duration::from_secs(1));"></div><div data-l="        }"></div><div data-l="    });"></div><div data-l=""></div><div data-l="    for received in rx {"></div><div data-l="        println!(&quot;Got: {}&quot;, received);"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 16-10: Sending multiple messages and pausing between each</span></span> <span class=caption>リスト16-10：複数のメッセージを送信し、それぞれの間で一時停止する</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This time, the spawned thread has a vector of strings that we want to send to the main thread.</span>今回、生成されたスレッドには、メインスレッドに送信したい文字列のベクトルがあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We iterate over them, sending each individually, and pause between each by calling the <code>thread::sleep</code> function with a <code>Duration</code> value of 1 second.</span>それぞれを個別に送信し、 <code>thread::sleep</code>関数を呼び出して<code>Duration</code>値を1秒にして、それぞれを一時停止し<code>thread::sleep</code> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In the main thread, we&#39;re not calling the <code>recv</code> function explicitly anymore: instead, we&#39;re treating <code>rx</code> as an iterator.</span>メインスレッドでは、 <code>recv</code>関数を明示的に呼び出すことはもうありません。代わりに、 <code>rx</code>をイテレータとして扱います。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For each value received, we&#39;re printing it.</span>受け取った値ごとに印刷しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When the channel is closed, iteration will end.</span>チャンネルが閉じられると、繰り返しが終了します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When running the code in Listing 16-10, you should see the following output with a 1-second pause in between each line:</span>コードリスト10-10のコードを実行すると、各行の間に1秒の休止時間を持つ次の出力が表示されます。</span> </p><br><div data-lang=text><div data-l="Got: hi"></div><div data-l="Got: from"></div><div data-l="Got: the"></div><div data-l="Got: thread"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because we don&#39;t have any code that pauses or delays in the <code>for</code> loop in the main thread, we can tell that the main thread is waiting to receive values from the spawned thread.</span>メインスレッドの<code>for</code>ループで中断または遅延するコードがないため、メインスレッドが生成されたスレッドから値を受け取るのを待っていることがわかります。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Creating Multiple Producers by Cloning the Transmitter</span>トランスミッタのクローニングによる複数のプロデューサの作成</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Earlier we mentioned that <code>mpsc</code> was an acronym for <i>multiple producer, single consumer</i> .</span>以前は、 <code>mpsc</code>は<i>複数のプロデューサー、単一の消費者の</i>頭字語であると述べました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s put <code>mpsc</code> to use and expand the code in Listing 16-10 to create multiple threads that all send values to the same receiver.</span>リスト16-10のコードを<code>mpsc</code>に使用して展開し、すべて同じスレッドに値を送る複数のスレッドを作成しましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can do so by cloning the transmitting half of the channel, as shown in Listing 16-11:</span>コードリスト16-11に示すように、チャネルの送信側の半分を複製することで、これを行うことができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="# use std::thread;"></div><div data-l="# use std::sync::mpsc;"></div><div data-l="# use std::time::Duration;"></div><div data-l=#></div><div data-l="# fn main() {"></div><div data-l="#// --snip--"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">--snip--</span> --snip--</span> </div><div data-l=""></div><div data-l="let (tx, rx) = mpsc::channel();"></div><div data-l=""></div><div data-l="let tx1 = mpsc::Sender::clone(&amp;tx);"></div><div data-l="thread::spawn(move || {"></div><div data-l="    let vals = vec!["></div><div data-l="        String::from(&quot;hi&quot;),"></div><div data-l="        String::from(&quot;from&quot;),"></div><div data-l="        String::from(&quot;the&quot;),"></div><div data-l="        String::from(&quot;thread&quot;),"></div><div data-l="    ];"></div><div data-l=""></div><div data-l="    for val in vals {"></div><div data-l="        tx1.send(val).unwrap();"></div><div data-l="        thread::sleep(Duration::from_secs(1));"></div><div data-l="    }"></div><div data-l=});></div><div data-l=""></div><div data-l="thread::spawn(move || {"></div><div data-l="    let vals = vec!["></div><div data-l="        String::from(&quot;more&quot;),"></div><div data-l="        String::from(&quot;messages&quot;),"></div><div data-l="        String::from(&quot;for&quot;),"></div><div data-l="        String::from(&quot;you&quot;),"></div><div data-l="    ];"></div><div data-l=""></div><div data-l="    for val in vals {"></div><div data-l="        tx.send(val).unwrap();"></div><div data-l="        thread::sleep(Duration::from_secs(1));"></div><div data-l="    }"></div><div data-l=});></div><div data-l=""></div><div data-l="for received in rx {"></div><div data-l="    println!(&quot;Got: {}&quot;, received);"></div><div data-l=}></div><div data-l=""></div><div data-l="#// --snip--"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">--snip--</span> --snip--</span> </div><div data-l="# }"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 16-11: Sending multiple messages from multiple producers</span></span> <span class=caption>リスト16-11：複数のプロデューサから複数のメッセージを送信する</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This time, before we create the first spawned thread, we call <code>clone</code> on the sending end of the channel.</span>今回は、最初に生成されたスレッドを作成する前に、チャネルの送信側で<code>clone</code>を呼び出します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This will give us a new sending handle we can pass to the first spawned thread.</span>これにより、最初に生成されたスレッドに渡すことができる新しい送信ハンドルが得られます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We pass the original sending end of the channel to a second spawned thread.</span>チャネルの最初の送信側を2番目の生成スレッドに渡します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This gives us two threads, each sending different messages to the receiving end of the channel.</span>これにより、2つのスレッドが生成され、それぞれが異なるメッセージをチャネルの受信側に送信します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When you run the code, your output should look something like this:</span>コードを実行すると、出力は次のようになります。</span> </p><br><div data-lang=text><div data-l="Got: hi"></div><div data-l="Got: more"></div><div data-l="Got: from"></div><div data-l="Got: messages"></div><div data-l="Got: for"></div><div data-l="Got: the"></div><div data-l="Got: thread"></div><div data-l="Got: you"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You might see the values in another order;</span>別の順序で値が表示されることがあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">it depends on your system.</span>それはあなたのシステムによって異なります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is what makes concurrency interesting as well as difficult.</span>これは並行性を面白く、難しくする要因です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you experiment with <code>thread::sleep</code> , giving it various values in the different threads, each run will be more nondeterministic and create different output each time.</span> <code>thread::sleep</code>を試して、別のスレッドでさまざまな値を与えると、それぞれの実行は非決定論的になり、毎回異なる出力を生成します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now that we&#39;ve looked at how channels work, let&#39;s look at a different method of concurrency.</span>チャネルの仕組みを見てきたので、並行性の別の方法を見てみましょう。</span> </p><script>_addload(function(){_setupIW('com');_csi('en','ja','ch16-02-message-passing.html');});</script>