<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180709_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=ch15-01-box.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Using <code>Box&lt;T&gt;</code> to Point to Data on the Heap</span> <code>Box&lt;T&gt;</code>を使用してヒープのデータをポイントする</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The most straightforward smart pointer is a <i>box</i> , whose type is written <code>Box&lt;T&gt;</code> .</span>最も単純なスマートポインタは<i>ボックスで</i> 、そのタイプは<code>Box&lt;T&gt;</code>と書かれています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Boxes allow you to store data on the heap rather than the stack.</span>ボックスを使用すると、スタックではなくヒープにデータを格納できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">What remains on the stack is the pointer to the heap data.</span>スタックに残っているのは、ヒープデータへのポインタです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Refer to Chapter 4 to review the difference between the stack and the heap.</span>スタックとヒープの違いを確認するには、第4章を参照してください。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Boxes don&#39;t have performance overhead, other than storing their data on the heap instead of on the stack.</span>ボックスには、スタック上ではなくヒープ上にデータを格納する以外に、パフォーマンスのオーバーヘッドはありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But they don&#39;t have many extra capabilities either.</span>しかし、彼らは多くの余分な能力も持っていません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You&#39;ll use them most often in these situations:</span>次のような状況で最も頻繁に使用します。</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When you have a type whose size can&#39;t be known at compile time and you want to use a value of that type in a context that requires an exact size</span>コンパイル時にサイズを知ることができない型を持っていて、正確なサイズを必要とするコンテキストでその型の値を使用したい場合</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When you have a large amount of data and you want to transfer ownership but ensure the data won&#39;t be copied when you do so</span>大量のデータを所有していて、所有権を譲渡したいが、そうしたときにデータがコピーされないようにする場合</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When you want to own a value and you care only that it&#39;s a type that implements a particular trait rather than being of a specific type</span>値を所有したいと思うときには、それは特定の型ではなく特定の特性を実装する型です</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll demonstrate the first situation in the “Enabling Recursive Types with Boxes” section.</span> 「再帰型をボックスで有効にする」セクションの最初の状況を示します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In the second case, transferring ownership of a large amount of data can take a long time because the data is copied around on the stack.</span> 2番目のケースでは、データがスタックにコピーされるため、大量のデータの所有権を移譲するのに時間がかかることがあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To improve performance in this situation, we can store the large amount of data on the heap in a box.</span>このような状況でパフォーマンスを向上させるために、大量のデータをヒープ上のボックスに格納することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then, only the small amount of pointer data is copied around on the stack, while the data it references stays in one place on the heap.</span>次に、参照するデータはヒープ上の1か所にとどまりますが、少量のポインタデータだけがスタックにコピーされます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The third case is known as a <i>trait object</i> , and Chapter 17 devotes an entire section, “Using Trait Objects That Allow for Values of Different Types,” just to that topic.</span> 3番目のケースは<i>特性オブジェクト</i>として知られており、第17章では、そのトピックだけを対象とした「さまざまなタイプの値を可能にする特性オブジェクトの使用」のセクション全体を示しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So what you learn here you&#39;ll apply again in Chapter 17!</span>ここで学んだことは、第17章で再び適用されます！</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Using a <code>Box&lt;T&gt;</code> to Store Data on the Heap</span> <code>Box&lt;T&gt;</code>を使用してヒープにデータを格納する</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Before we discuss this use case for <code>Box&lt;T&gt;</code> , we&#39;ll cover the syntax and how to interact with values stored within a <code>Box&lt;T&gt;</code> .</span> <code>Box&lt;T&gt;</code>このユースケースについて説明する前に、構文と、 <code>Box&lt;T&gt;</code>格納された値とやり取りする方法について説明します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 15-1 shows how to use a box to store an <code>i32</code> value on the heap:</span>リスト15-1は、ボックスを使用してヒープに<code>i32</code>値を格納する方法を示しています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="fn main() {"></div><div data-l="    let b = Box::new(5);"></div><div data-l="    println!(&quot;b = {}&quot;, b);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 15-1: Storing an <code>i32</code> value on the heap using a box</span></span> <span class=caption>リスト15-1：ボックスを使ってヒープに<code>i32</code>値を格納する</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We define the variable <code>b</code> to have the value of a <code>Box</code> that points to the value <code>5</code> , which is allocated on the heap.</span>変数<code>b</code>は、ヒープに割り当てられた値<code>5</code>をポイントする<code>Box</code>の値を持つように定義します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This program will print <code>b = 5</code> ;</span>このプログラムは<code>b = 5</code>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">in this case, we can access the data in the box similar to how we would if this data were on the stack.</span>この場合、このデータがスタック上にあった場合と同様に、ボックス内のデータにアクセスすることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Just like any owned value, when a box goes out of scope, as <code>b</code> does at the end of <code>main</code> , it will be deallocated.</span>所有している値と同じように、ボックスが範囲外になると、 <code>b</code>が<code>main</code>の最後になると、割り当てが解除されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The deallocation happens for the box (stored on the stack) and the data it points to (stored on the heap).</span>割り振り解除は、（スタックに格納されている）ボックスとそれが指している（ヒープに格納されている）データに対して発生します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Putting a single value on the heap isn&#39;t very useful, so you won&#39;t use boxes by themselves in this way very often.</span>ヒープ上に単一の値を置くことはあまり有用ではないので、このように頻繁にボックスを使用することはありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Having values like a single <code>i32</code> on the stack, where they&#39;re stored by default, is more appropriate in the majority of situations.</span>デフォルトで格納されているスタック上の単一の<code>i32</code>ような値を持つことは、大部分の状況でより適切です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s look at a case where boxes allow us to define types that we wouldn&#39;t be allowed to if we didn&#39;t have boxes.</span>箱がなければ、許可されないタイプをボックスで定義することができます。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Enabling Recursive Types with Boxes</span>ボックスによる再帰型の有効化</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">At compile time, Rust needs to know how much space a type takes up.</span>コンパイル時に、Rustはタイプがどれくらいのスペースを占めるかを知る必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">One type whose size can&#39;t be known at compile time is a <i>recursive type</i> , where a value can have as part of itself another value of the same type.</span>コンパイル時にサイズを知ることのできない1つの型は<i>再帰</i>型です。値はその型の一部として同じ型の別の値を持つことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because this nesting of values could theoretically continue infinitely, Rust doesn&#39;t know how much space a value of a recursive type needs.</span>この値のネストは理論的に無限に続く可能性があるので、Rustは再帰型の値が必要とする空間の量を知らない。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, boxes have a known size, so by inserting a box in a recursive type definition, you can have recursive types.</span>ただし、ボックスのサイズは既知であるため、再帰型定義にボックスを挿入すると、再帰型を持つことができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s explore the <i>cons list</i> , which is a data type common in functional programming languages, as an example of a recursive type.</span>再帰型の例として、関数型プログラミング言語で一般的なデータ型である<i>consリストを</i>調べてみましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The cons list type we&#39;ll define is straightforward except for the recursion;</span>定義するconsリストの型は、再帰を除いて単純です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">therefore, the concepts in the example we&#39;ll work with will be useful any time you get into more complex situations involving recursive types.</span>したがって、この例のコンセプトは、再帰型を含むより複雑な状況になるたびに役立ちます。</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">More Information About the Cons List</span>短所リストの詳細</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A <i>cons list</i> is a data structure that comes from the Lisp programming language and its dialects.</span> <i>consリスト</i>は、Lispプログラミング言語とその方言に由来するデータ構造です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In Lisp, the <code>cons</code> function (short for “construct function”) constructs a new pair from its two arguments, which usually are a single value and another pair.</span> Lispでは、 <code>cons</code>関数（「構築関数」の略）は、通常は単一の値ともう1つのペアである2つの引数から新しいペアを構築します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These pairs containing pairs form a list.</span>ペアを含むこれらのペアはリストを形成する。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The cons function concept has made its way into more general functional programming jargon: “to cons <i>x</i> onto <i>y</i> ” informally means to construct a new container instance by putting the element <i>x</i> at the start of this new container, followed by the container <i>y</i> .</span> cons関数のコンセプトはより一般的な関数プログラミングの専門用語になりました。「to cons <i>x</i> to <i>y</i> 」は、要素<i>x</i>をこの新しいコンテナの先頭に置き、コンテナ<i>yを</i>続けて新しいコンテナインスタンスを作成することを非公式に意味します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Each item in a cons list contains two elements: the value of the current item and the next item.</span>コンスリストの各アイテムには、現在のアイテムの値と次のアイテムの2つの要素が含まれています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The last item in the list contains only a value called <code>Nil</code> without a next item.</span>リストの最後の項目には、次の項目なしで<code>Nil</code>という値のみが含まれます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A cons list is produced by recursively calling the <code>cons</code> function.</span> consリストは、 <code>cons</code>関数を再帰的に呼び出すことによって生成されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The canonical name to denote the base case of the recursion is <code>Nil</code> .</span>再帰の基底を表す正規名は<code>Nil</code>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that this is not the same as the “null” or “nil” concept in Chapter 6, which is an invalid or absent value.</span>これは、第6章の &quot;null&quot;または &quot;nil&quot;の概念と同じではないことに注意してください。これは無効または欠損値です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Although functional programming languages use cons lists frequently, the cons list isn&#39;t a commonly used data structure in Rust.</span>関数型プログラミング言語ではconsリストを頻繁に使用しますが、consリストはRustの一般的なデータ構造ではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Most of the time when you have a list of items in Rust, <code>Vec&lt;T&gt;</code> is a better choice to use.</span>ほとんどの場合、Rustにアイテムのリストがある場合は、 <code>Vec&lt;T&gt;</code>を使用する方が適しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Other, more complex recursive data types <i>are</i> useful in various situations, but by starting with the cons list, we can explore how boxes let us define a recursive data type without much distraction.</span>他のより複雑な再帰的データ型<i>は</i>様々な状況で有用ですが、consリストから始めて、ボックスがどのように再帰的データ型をあまり気をそらさずに定義できるかを調べることができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 15-2 contains an enum definition for a cons list.</span>コードリスト15-2はconsリストのenum定義を含んでいます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that this code won&#39;t compile yet because the <code>List</code> type doesn&#39;t have a known size, which we&#39;ll demonstrate.</span>このコードは、 <code>List</code>型が既知のサイズを持っていないので、まだコンパイルされないことに注意してください。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust,ignore><div data-l="enum List {"></div><div data-l="    Cons(i32, List),"></div><div data-l="    Nil,"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 15-2: The first attempt at defining an enum to represent a cons list data structure of <code>i32</code> values</span></span> <span class=caption>リスト15-2： <code>i32</code>値のコンス・リスト・データ構造を表すためのenumを定義する最初の試み</span></span> </p><br><blockquote><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note: We&#39;re implementing a cons list that holds only <code>i32</code> values for the purposes of this example.</span>注：この例では、 <code>i32</code>値のみを保持するconsリストを実装しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We could have implemented it using generics, as we discussed in Chapter 10, to define a cons list type that could store values of any type.</span>第10章で説明したように、ジェネリックを使って実装することで、任意の型の値を格納できるコンスリスト型を定義することができました。</span> </p></blockquote><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Using the <code>List</code> type to store the list <code>1, 2, 3</code> would look like the code in Listing 15-3:</span> <code>List</code>型を使用してリスト<code>1, 2, 3</code>を格納すると、リスト15-3のコードのようになります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust,ignore><div data-l="use List::{Cons, Nil};"></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let list = Cons(1, Cons(2, Cons(3, Nil)));"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 15-3: Using the <code>List</code> enum to store the list <code>1, 2, 3</code></span></span> <span class=caption>リスト15-3： <code>List</code> enumを使ってリスト<code>1, 2, 3</code>を格納する</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The first <code>Cons</code> value holds <code>1</code> and another <code>List</code> value.</span>最初の<code>Cons</code>値は<code>1</code>と別の<code>List</code>値を保持します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This <code>List</code> value is another <code>Cons</code> value that holds <code>2</code> and another <code>List</code> value.</span>この<code>List</code>値は、 <code>2</code>と別の<code>List</code>値を保持する別の<code>Cons</code>値です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This <code>List</code> value is one more <code>Cons</code> value that holds <code>3</code> and a <code>List</code> value, which is finally <code>Nil</code> , the non-recursive variant that signals the end of the list.</span>この<code>List</code>値は1つの以上である<code>Cons</code>保持している値<code>3</code>し、 <code>List</code>最後にある値、 <code>Nil</code> 、リストの終わりを非再帰的変種。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we try to compile the code in Listing 15-3, we get the error shown in Listing 15-4:</span>リスト15-3のコードをコンパイルしようとすると、コードリスト15-4に示すエラーが発生します。</span> </p><br><div data-lang=text><div data-l="error[E0072]: recursive type `List` has infinite size"></div><div data-l=" --&gt; src/main.rs:1:1"></div><div data-l="  |"></div><div data-l="1 | enum List {"></div><div data-l="  | ^^^^^^^^^ recursive type has infinite size"></div><div data-l="2 |     Cons(i32, List),"></div><div data-l="  |               ----- recursive without indirection"></div><div data-l="  |"></div><div data-l="  = help: insert indirection (e.g., a `Box`, `Rc`, or `&amp;`) at some point to"></div><div data-l="  make `List` representable"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 15-4: The error we get when attempting to define a recursive enum</span></span> <span class=caption>リスト15-4：再帰的なenumを定義しようとしたときに発生するエラー</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The error shows this type “has infinite size.” The reason is that we&#39;ve defined <code>List</code> with a variant that is recursive: it holds another value of itself directly.</span>このエラーは、このタイプが「無限のサイズを持つ」ことを示しています。その理由は、再帰的なバリアントで<code>List</code>を定義したことです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As a result, Rust can&#39;t figure out how much space it needs to store a <code>List</code> value.</span>その結果、Rustは<code>List</code>値を格納するために必要なスペースを把握することができません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s break down why we get this error a bit.</span>なぜこのエラーが発生するのかを解説しましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">First, let&#39;s look at how Rust decides how much space it needs to store a value of a non-recursive type.</span>まず、Rustが非再帰型の値を格納するために必要なスペースを決定する方法を見てみましょう。</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Computing the Size of a Non-Recursive Type</span>非再帰型のサイズの計算</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Recall the <code>Message</code> enum we defined in Listing 6-2 when we discussed enum definitions in Chapter 6:</span>リスト6-2で定義した<code>Message</code> enumを思い出してみましょう。</span> </p><br><div data-lang=rust><div data-l="enum Message {"></div><div data-l="    Quit,"></div><div data-l="    Move { x: i32, y: i32 },"></div><div data-l="    Write(String),"></div><div data-l="    ChangeColor(i32, i32, i32),"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To determine how much space to allocate for a <code>Message</code> value, Rust goes through each of the variants to see which variant needs the most space.</span> <code>Message</code>値に割り当てるスペースを決定するために、Rustはそれぞれのバリアントを調べて、どのバリアントが最も多くのスペースを必要としているかを確認します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust sees that <code>Message::Quit</code> doesn&#39;t need any space, <code>Message::Move</code> needs enough space to store two <code>i32</code> values, and so forth.</span> Rustは、 <code>Message::Quit</code>はスペースが必要ないと判断し、 <code>Message::Move</code>は2つの<code>i32</code>値を格納するのに十分なスペースを必要とします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because only one variant will be used, the most space a <code>Message</code> value will need is the space it would take to store the largest of its variants.</span> 1つのバリアントしか使用されないため、 <code>Message</code>値に必要なスペースの最大値は、そのバリアントの最大サイズを格納するために必要なスペースです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Contrast this with what happens when Rust tries to determine how much space a recursive type like the <code>List</code> enum in Listing 15-2 needs.</span> Rustがリスト15-2の<code>List</code> enumのような再帰型にどれだけのスペースが必要かを判断しようとするときに何が起きるかと対照的に考えてください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The compiler starts by looking at the <code>Cons</code> variant, which holds a value of type <code>i32</code> and a value of type <code>List</code> .</span>コンパイラは<code>Cons</code>型を見ることから始まります<code>i32</code>型は、型<code>i32</code>の値と<code>List</code>型の値を保持します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Therefore, <code>Cons</code> needs an amount of space equal to the size of an <code>i32</code> plus the size of a <code>List</code> .</span>したがって、 <code>Cons</code>は、 <code>i32</code>のサイズに<code>List</code>サイズを加えたものに等しい量のスペースが必要です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To figure out how much memory the <code>List</code> type needs, the compiler looks at the variants, starting with the <code>Cons</code> variant.</span> <code>List</code>型が必要とするメモリ量を調べるために、コンパイラは<code>Cons</code>型から始まるバリアントを調べます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Cons</code> variant holds a value of type <code>i32</code> and a value of type <code>List</code> , and this process continues infinitely, as shown in Figure 15-1.</span> <code>Cons</code>変形は、図15-1に示すように、タイプ<code>i32</code>の値とタイプ<code>List</code>値を保持し、このプロセスは無限に続きます。</span> </p><br><p><img alt="無限コンスリスト" src=img/trpl15-01.svg class=center style="width: 50%;" /></p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Figure 15-1: An infinite <code>List</code> consisting of infinite <code>Cons</code> variants</span></span> <span class=caption>図15-1：無限<code>Cons</code>バリアントからなる無限<code>List</code></span></span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Using <code>Box&lt;T&gt;</code> to Get a Recursive Type with a Known Size</span> <code>Box&lt;T&gt;</code>を使用して既知サイズの再帰型を取得する</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust can&#39;t figure out how much space to allocate for recursively defined types, so the compiler gives the error in Listing 15-4.</span> Rustは、再帰的に定義された型にどれだけの領域を割り当てるか分からないため、コンパイラはリスト15-4のエラーを返します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But the error does include this helpful suggestion:</span>しかし、エラーには、この有益な提案が含まれています：</span> </p><br><div data-lang=text><div data-l="  = help: insert indirection (e.g., a `Box`, `Rc`, or `&amp;`) at some point to"></div><div data-l="  make `List` representable"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this suggestion, “indirection” means that instead of storing a value directly, we&#39;ll change the data structure to store the value indirectly by storing a pointer to the value instead.</span>この提案では、「間接指定」とは、値を直接格納する代わりに、値へのポインタを間接的に格納するようにデータ構造を変更することを意味します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because a <code>Box&lt;T&gt;</code> is a pointer, Rust always knows how much space a <code>Box&lt;T&gt;</code> needs: a pointer&#39;s size doesn&#39;t change based on the amount of data it&#39;s pointing to.</span> <code>Box&lt;T&gt;</code>はポインタなので、Rustは<code>Box&lt;T&gt;</code>必要なスペースを常に知っています。ポインターのサイズはポインターのデータ量に基づいて変化しません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This means we can put a <code>Box&lt;T&gt;</code> inside the <code>Cons</code> variant instead of another <code>List</code> value directly.</span>つまり、別の<code>List</code>値の代わりに<code>Cons</code>バリアントの中に<code>Box&lt;T&gt;</code>置くことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Box&lt;T&gt;</code> will point to the next <code>List</code> value that will be on the heap rather than inside the <code>Cons</code> variant.</span> <code>Box&lt;T&gt;</code>は、 <code>Cons</code>バリアント内ではなく、ヒープ上にある次の<code>List</code>値を指します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Conceptually, we still have a list, created with lists “holding” other lists, but this implementation is now more like placing the items next to one another rather than inside one another.</span>概念的には、他のリストを「保持」したリストで作成されたリストはまだありますが、この実装は、相互に内包されているのではなく、隣り合わせに配置されているようになりました。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can change the definition of the <code>List</code> enum in Listing 15-2 and the usage of the <code>List</code> in Listing 15-3 to the code in Listing 15-5, which will compile:</span>リスト15-2の<code>List</code> enumの定義と、リスト15-3の<code>List</code>の使い方をリスト15-5のコードに変更することができます。これはコンパイルされます：</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="enum List {"></div><div data-l="    Cons(i32, Box&lt;List&gt;),"></div><div data-l="    Nil,"></div><div data-l=}></div><div data-l=""></div><div data-l="use List::{Cons, Nil};"></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let list = Cons(1,"></div><div data-l="        Box::new(Cons(2,"></div><div data-l="            Box::new(Cons(3,"></div><div data-l="                Box::new(Nil))))));"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 15-5: Definition of <code>List</code> that uses <code>Box&lt;T&gt;</code> in order to have a known size</span></span> <span class=caption>定義：15-5リスト<code>List</code>使用しています<code>Box&lt;T&gt;</code>既知のサイズを持つためには</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Cons</code> variant will need the size of an <code>i32</code> plus the space to store the box&#39;s pointer data.</span> <code>Cons</code>バリアントは、サイズが必要になります<code>i32</code>ボックスのポインタデータを保存するために、プラスのスペースを。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Nil</code> variant stores no values, so it needs less space than the <code>Cons</code> variant.</span> <code>Nil</code>バリアントには値が格納されないため、 <code>Cons</code>バリアントよりもスペースが少なくて済みます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We now know that any <code>List</code> value will take up the size of an <code>i32</code> plus the size of a box&#39;s pointer data.</span> <code>List</code>値は、 <code>i32</code>のサイズにボックスのポインタデータのサイズを加えた値になります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">By using a box, we&#39;ve broken the infinite, recursive chain, so the compiler can figure out the size it needs to store a <code>List</code> value.</span>ボックスを使うことで、無限の再帰的チェーンが壊れているので、コンパイラは<code>List</code>値を格納するのに必要なサイズを知ることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Figure 15-2 shows what the <code>Cons</code> variant looks like now.</span>図15-2に<code>Cons</code>変形例を示します。</span> </p><br><p><img alt="有限コンスリスト" src=img/trpl15-02.svg class=center /></p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Figure 15-2: A <code>List</code> that is not infinitely sized because <code>Cons</code> holds a <code>Box</code></span></span> <span class=caption>図15-2： <code>Cons</code>が<code>Box</code>保持しているため無限大ではない<code>List</code></span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Boxes provide only the indirection and heap allocation;</span>ボックスはインダイレクションとヒープ割り当てのみを提供します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">they don&#39;t have any other special capabilities, like those we&#39;ll see with the other smart pointer types.</span>他のスマートポインタの種類と同じような特殊な機能はありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">They also don&#39;t have any performance overhead that these special capabilities incur, so they can be useful in cases like the cons list where the indirection is the only feature we need.</span>これらの特殊機能にはパフォーマンス上のオーバーヘッドはありません。したがって、間接指定が必要な唯一の機能であるコンスリストのような場合に便利です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll look at more use cases for boxes in Chapter 17, too.</span>第17章のボックスの使用例ももっと見ていきます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Box&lt;T&gt;</code> type is a smart pointer because it implements the <code>Deref</code> trait, which allows <code>Box&lt;T&gt;</code> values to be treated like references.</span> <code>Box&lt;T&gt;</code>型はスマートポインタです<code>Deref</code>型を実装しているため、 <code>Box&lt;T&gt;</code>値を参照のように扱うことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When a <code>Box&lt;T&gt;</code> value goes out of scope, the heap data that the box is pointing to is cleaned up as well because of the <code>Drop</code> trait implementation.</span> <code>Box&lt;T&gt;</code>値が有効範囲外になると、 <code>Drop</code>特性の実装のために、ボックスが指しているヒープデータも同様にクリーンアップされます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s explore these two traits in more detail.</span>これらの2つの特性をより詳細に調べてみましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These two traits will be even more important to the functionality provided by the other smart pointer types we&#39;ll discuss in the rest of this chapter.</span>これらの2つの特性は、この章の後半で説明する他のスマートポインタ型によって提供される機能にとってさらに重要になります。</span> </p><script>_addload(function(){_setupIW('com');_csi('en','ja','ch15-01-box.html');});</script>