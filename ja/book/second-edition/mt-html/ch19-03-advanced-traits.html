<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180716_RC01/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=ch19-03-advanced-traits.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Advanced Traits</span>高度な特性</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We first covered traits in the “Traits: Defining Shared Behavior” section of Chapter 10, but as with lifetimes, we didn&#39;t discuss the more advanced details.</span>第10章の「特性：共有行動の定義」のセクションで最初に特性を説明しましたが、生存期間と同様に、より高度な詳細については説明しませんでした。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now that you know more about Rust, we can get into the nitty-gritty.</span>あなたがRustについてもっと知った今、私たちは素敵なものになることができます。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Specifying Placeholder Types in Trait Definitions with Associated Types</span>関連型の特性定義におけるプレースホルダ型の指定</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><i>Associated types</i> connect a type placeholder with a trait such that the trait method definitions can use these placeholder types in their signatures.</span> <i>関連するタイプは、</i>形質メソッドの定義は、それらのシグネチャこれらのプレースホルダのタイプを使用することができるように形質とタイププレースホルダを接続します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The implementor of a trait will specify the concrete type to be used in this type&#39;s place for the particular implementation.</span>特性の実装者は、特定の実装に対してこの型の場所で使用される具体的な型を指定します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That way, we can define a trait that uses some types without needing to know exactly what those types are until the trait is implemented.</span>このようにして、我々は、形質が導入されるまでこれらの型が何であるかを正確に知る必要なしに、いくつかの型を使用する形質を定義することができる。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ve described most of the advanced features in this chapter as being rarely needed.</span>この章の高度な機能のほとんどは、まれに必要とされるものであると説明しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Associated types are somewhere in the middle: they&#39;re used more rarely than features explained in the rest of the book but more commonly than many of the other features discussed in this chapter.</span>関連付けられた型は、本の中で説明されている機能よりもめったに使用されませんが、この章で説明する他の機能の多くよりも一般的に使用されています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">One example of a trait with an associated type is the <code>Iterator</code> trait that the standard library provides.</span>関連する型を持つ特性の一例は、標準ライブラリが提供する<code>Iterator</code>特性です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The associated type is named <code>Item</code> and stands in for the type of the values the type implementing the <code>Iterator</code> trait is iterating over.</span>関連する型は<code>Item</code>と名付けられ、 <code>Iterator</code>特性を実装する型が反復処理される値の型を表します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In “The <code>Iterator</code> Trait and the <code>next</code> Method” section of Chapter 13, we mentioned that the definition of the <code>Iterator</code> trait is as shown in Listing 19-20.</span>第13章の「 <code>Iterator</code>特性と<code>next</code>メソッド」のセクションでは、 <code>Iterator</code>特性の定義がリスト19-20に示されていると述べました。</span> </p><br><div data-lang=rust><div data-l="pub trait Iterator {"></div><div data-l="    type Item;"></div><div data-l=""></div><div data-l="    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 19-20: The definition of the <code>Iterator</code> trait that has an associated type <code>Item</code></span></span> <span class=caption>リスト19-20：関連した型<code>Item</code>を持つ<code>Iterator</code>型の<code>Item</code></span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The type <code>Item</code> is a placeholder type, and the <code>next</code> method&#39;s definition shows that it will return values of type <code>Option&lt;Self::Item&gt;</code> .</span> <code>Item</code>型はプレースホルダ型であり、 <code>next</code>メソッドの定義は、 <code>Option&lt;Self::Item&gt;</code>型の値を返すことを示しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Implementors of the <code>Iterator</code> trait will specify the concrete type for <code>Item</code> , and the <code>next</code> method will return an <code>Option</code> containing a value of that concrete type.</span> <code>Iterator</code>特性の実装者は、 <code>Item</code>の具体的な型を指定し、 <code>next</code>メソッドは、その具体的な型の値を含む<code>Option</code>を返します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Associated types might seem like a similar concept to generics, in that the latter allow us to define a function without specifying what types it can handle.</span>関連型は、ジェネリックスと同様の概念のように見えるかもしれません。後者は、処理できる型を指定せずに関数を定義することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So why use associated types?</span>だから関連する型を使うのはなぜですか？</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s examine the difference between the two concepts with an example from Chapter 13 that implements the <code>Iterator</code> trait on the <code>Counter</code> struct.</span> <code>Counter</code>構造体の<code>Iterator</code>特性を実装する第13章の例を使って、2つの概念の違いを調べてみましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In Listing 13-21, we specified that the <code>Item</code> type was <code>u32</code> :</span>コードリスト13-21では、 <code>Item</code>タイプが<code>u32</code> ：</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/lib.rs</span></span> <span class=filename>ファイル名：src / lib.rs</span></span> </p><br><div data-lang=rust,ignore><div data-l="impl Iterator for Counter {"></div><div data-l="    type Item = u32;"></div><div data-l=""></div><div data-l="    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {"></div><div data-l="#        // --snip--"></div><div data-l="        // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">--snip--</span> --snip--</span> </div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This syntax seems comparable to that of generics.</span>この構文は、ジェネリックの構文に匹敵するようです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So why not just define the <code>Iterator</code> trait with generics, as shown in Listing 19-21?</span>リスト19-21に示すように、ジェネリックで<code>Iterator</code>特性を定義するだけではどうですか？</span> </p><br><div data-lang=rust><div data-l="pub trait Iterator&lt;T&gt; {"></div><div data-l="    fn next(&amp;mut self) -&gt; Option&lt;T&gt;;"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 19-21: A hypothetical definition of the <code>Iterator</code> trait using generics</span></span> <span class=caption>リスト19-21：ジェネリックを使った<code>Iterator</code>特性の仮説的定義</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The difference is that when using generics, as in Listing 19-21, we must annotate the types in each implementation;</span>違いは、リスト19-21のようにジェネリックを使用する場合は、各実装で型に注釈を付ける必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">because we can also implement <code>Iterator&lt;String&gt; for Counter</code> or any other type, we could have multiple implementations of <code>Iterator</code> for <code>Counter</code> .</span> <code>Iterator&lt;String&gt; for Counter</code>やその他の型の<code>Iterator&lt;String&gt; for Counter</code>実装することもできるため、 <code>Counter</code>用<code>Iterator</code>実装は複数ある可能性があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In other words, when a trait has a generic parameter, it can be implemented for a type multiple times, changing the concrete types of the generic type parameters each time.</span>言い換えれば、特性に汎用パラメータがある場合、そのタイプごとに汎用タイプパラメータの具体的なタイプを変更して、タイプごとに複数回実装することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When we use the <code>next</code> method on <code>Counter</code> , we would have to provide type annotations to indicate which implementation of <code>Iterator</code> we want to use.</span> <code>Counter</code>で<code>next</code>メソッドを使用する場合は、使用する<code>Iterator</code>実装を示すためにタイプ注釈を提供する必要があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">With associated types, we don&#39;t need to annotate types because we can&#39;t implement a trait on a type multiple times.</span>関連する型では、型に注釈を付ける必要はありません。型に対して何度も型を実装できないからです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In Listing 19-20 with the definition that uses associated types, we can only choose what the type of <code>Item</code> will be once, because there can only be one <code>impl Iterator for Counter</code> .</span>リスト19-20では、関連付けられた型を使用する定義を使用して<code>impl Iterator for Counter</code> 1つの<code>impl Iterator for Counter</code>しか<code>impl Iterator for Counter</code>ことができないため、 <code>Item</code>の型を1回だけ選択できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We don&#39;t have to specify that we want an iterator of <code>u32</code> values everywhere that we call <code>next</code> on <code>Counter</code> .</span>我々は、 <code>Counter</code> <code>next</code>に呼び出すすべての<code>u32</code>値のイテレータを必要とすることを指定する必要はありません。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Default Generic Type Parameters and Operator Overloading</span>デフォルトの汎用型のパラメータと演算子のオーバーロード</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When we use generic type parameters, we can specify a default concrete type for the generic type.</span>ジェネリック型パラメータを使用するときは、ジェネリック型のデフォルトコンクリート型を指定できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This eliminates the need for implementors of the trait to specify a concrete type if the default type works.</span>これにより、デフォルト型が動作する場合に、具体的な型を指定するために、特性の実装者が必要なくなります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The syntax for specifying a default type for a generic type is <code>&lt;PlaceholderType=ConcreteType&gt;</code> when declaring the generic type.</span>ジェネリック型を宣言するときは、ジェネリック型の既定の型を指定する構文は<code>&lt;PlaceholderType=ConcreteType&gt;</code>です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A great example of a situation where this technique is useful is with operator overloading.</span>この技法が有用な状況の大きな例は、演算子のオーバーロードにあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><i>Operator overloading</i> is customizing the behavior of an operator (such as <code>+</code> ) in particular situations.</span> <i>オペレータのオーバーロード</i>は、特定の状況でオペレータ（ <code>+</code>など）の動作をカスタマイズすることです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust doesn&#39;t allow you to create your own operators or overload arbitrary operators.</span> Rustでは、独自の演算子を作成したり、任意の演算子をオーバーロードすることはできません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But you can overload the operations and corresponding traits listed in <code>std::ops</code> by implementing the traits associated with the operator.</span>しかし、演算子に関連する特性を実装することで、 <code>std::ops</code>リストされている演算とそれに対応する特性をオーバーロードすることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, in Listing 19-22 we overload the <code>+</code> operator to add two <code>Point</code> instances together.</span>たとえば、リスト19-22では<code>+</code>演算子をオーバーロードして2つの<code>Point</code>インスタンスを一緒に追加します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We do this by implementing the <code>Add</code> trait on a <code>Point</code> struct:</span>これを行うには、 <code>Point</code>構造体に<code>Add</code>特性を実装します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="use std::ops::Add;"></div><div data-l=""></div><div data-l="#[derive(Debug, PartialEq)]"></div><div data-l="struct Point {"></div><div data-l="    x: i32,"></div><div data-l="    y: i32,"></div><div data-l=}></div><div data-l=""></div><div data-l="impl Add for Point {"></div><div data-l="    type Output = Point;"></div><div data-l=""></div><div data-l="    fn add(self, other: Point) -&gt; Point {"></div><div data-l="        Point {"></div><div data-l="            x: self.x + other.x,"></div><div data-l="            y: self.y + other.y,"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    assert_eq!(Point { x: 1, y: 0 } + Point { x: 2, y: 3 },"></div><div data-l="               Point { x: 3, y: 3 });"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 19-22: Implementing the <code>Add</code> trait to overload the <code>+</code> operator for <code>Point</code> instances</span></span> <span class=caption>リスト19-22： <code>Point</code>インスタンスの<code>+</code>演算子をオーバーロードする<code>Add</code>特性の実装</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>add</code> method adds the <code>x</code> values of two <code>Point</code> instances and the <code>y</code> values of two <code>Point</code> instances to create a new <code>Point</code> .</span> <code>add</code>方法は、追加<code>x</code> 2つの値<code>Point</code>インスタンスと<code>y</code> 2つの値<code>Point</code>新しい作成するために、インスタンスを<code>Point</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Add</code> trait has an associated type named <code>Output</code> that determines the type returned from the <code>add</code> method.</span> <code>Add</code>特性は、 <code>add</code>メソッドから返される型を決定する<code>Output</code>という名前の関連する型を持ちます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The default generic type in this code is within the <code>Add</code> trait.</span>このコードのデフォルトジェネリック型は、 <code>Add</code> trait内にあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here is its definition:</span>ここにその定義があります：</span> </p><br><div data-lang=rust><div data-l="trait Add&lt;RHS=Self&gt; {"></div><div data-l="    type Output;"></div><div data-l=""></div><div data-l="    fn add(self, rhs: RHS) -&gt; Self::Output;"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This code should look generally familiar: a trait with one method and an associated type.</span>このコードは一般的によく知られているはずです。一つのメソッドとそれに関連する型を持つものです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The new part is <code>RHS=Self</code> : this syntax is called <i>default type parameters</i> .</span>新しい部分は<code>RHS=Self</code>です：この構文は<i>デフォルトの型パラメータ</i>と呼ばれ<i>ます</i> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>RHS</code> generic type parameter (short for “right hand side”) defines the type of the <code>rhs</code> parameter in the <code>add</code> method.</span> <code>RHS</code>ジェネリック型パラメータ（「右辺」の略）は、 <code>add</code>メソッドの<code>rhs</code>パラメータの型を定義します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we don&#39;t specify a concrete type for <code>RHS</code> when we implement the <code>Add</code> trait, the type of <code>RHS</code> will default to <code>Self</code> , which will be the type we&#39;re implementing <code>Add</code> on.</span> <code>Add</code>特性を実装するときに<code>RHS</code>具体的な型を指定しなければ、 <code>RHS</code>の型はデフォルトで<code>Self</code>になります。これは<code>Add</code>を実装する型になります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When we implemented <code>Add</code> for <code>Point</code> , we used the default for <code>RHS</code> because we wanted to add two <code>Point</code> instances.</span> <code>Add</code> for <code>Point</code>を実装したとき、2つの<code>Point</code>インスタンスを追加したいので、 <code>RHS</code>のデフォルトを使用しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s look at an example of implementing the <code>Add</code> trait where we want to customize the <code>RHS</code> type rather than using the default.</span>デフォルトを使用するのではなく、 <code>RHS</code>タイプをカスタマイズする<code>Add</code>特性を実装する例を見てみましょう。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We have two structs, <code>Millimeters</code> and <code>Meters</code> , holding values in different units.</span> <code>Millimeters</code>と<code>Meters</code> 2つの構造体があり、それぞれ異なる単位で値が保持されています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We want to add values in millimeters to values in meters and have the implementation of <code>Add</code> do the conversion correctly.</span>ミリメートル単位の値をメートル単位の値に<code>Add</code>し、「 <code>Add</code>の実装で変換を正しく実行する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can implement <code>Add</code> for <code>Millimeters</code> with <code>Meters</code> as the <code>RHS</code> , as shown in Listing 19-23.</span>リスト19-23に示すように、 <code>RHS</code>として「 <code>Meters</code>を持つ<code>Add</code> for <code>Millimeters</code> 」を実装できます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/lib.rs</span></span> <span class=filename>ファイル名：src / lib.rs</span></span> </p><br><div data-lang=rust><div data-l="use std::ops::Add;"></div><div data-l=""></div><div data-l="struct Millimeters(u32);"></div><div data-l="struct Meters(u32);"></div><div data-l=""></div><div data-l="impl Add&lt;Meters&gt; for Millimeters {"></div><div data-l="    type Output = Millimeters;"></div><div data-l=""></div><div data-l="    fn add(self, other: Meters) -&gt; Millimeters {"></div><div data-l="        Millimeters(self.0 + (other.0 * 1000))"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 19-23: Implementing the <code>Add</code> trait on <code>Millimeters</code> to add <code>Millimeters</code> to <code>Meters</code></span></span> <span class=caption>リスト19-23： <code>Millimeters</code>を<code>Meters</code>に追加するための<code>Millimeters</code>の<code>Add</code>特性の実装</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To add <code>Millimeters</code> and <code>Meters</code> , we specify <code>impl Add&lt;Meters&gt;</code> to set the value of the <code>RHS</code> type parameter instead of using the default of <code>Self</code> .</span> <code>Millimeters</code>と<code>Meters</code>を追加するには、デフォルトの<code>Self</code>を使用する代わりに、 <code>RHS</code>タイプのパラメータの値を設定するために、 <code>impl Add&lt;Meters&gt;</code>を指定します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You&#39;ll use default type parameters in two main ways:</span>デフォルトの型パラメータは、主に2つの方法で使用されます：</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To extend a type without breaking existing code</span>既存のコードを壊さずに型を拡張するには</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To allow customization in specific cases most users won&#39;t need</span>特定のケースでカスタマイズを可能にするために、ほとんどのユーザーは</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The standard library&#39;s <code>Add</code> trait is an example of the second purpose: usually, you&#39;ll add two like types, but the <code>Add</code> trait provides the ability to customize beyond that.</span>標準ライブラリの<code>Add</code> traitは2番目の目的の例です：通常、2つのタイプを追加しますが、 <code>Add</code>特性はそれを超えてカスタマイズする機能を提供します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Using a default type parameter in the <code>Add</code> trait definition means you don&#39;t have to specify the extra parameter most of the time.</span> 「特性の<code>Add</code>定義でデフォルトのタイプ・パラメーターを使用すると、ほとんどの場合、余分なパラメーターを指定する必要はありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In other words, a bit of implementation boilerplate isn&#39;t needed, making it easier to use the trait.</span>言い換えれば、少年実装の定型文は必要ないので、その形質を使いやすくします。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The first purpose is similar to the second but in reverse: if you want to add a type parameter to an existing trait, you can give it a default to allow extension of the functionality of the trait without breaking the existing implementation code.</span>第1の目的は、第2の目的と似ていますが、既存の特性に型パラメータを追加する場合は、既存の実装コードを破ることなく、特性の機能拡張を可能にするデフォルトを与えることができます。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Fully Qualified Syntax for Disambiguation: Calling Methods with the Same Name</span>曖昧さ回避のための完全修飾構文：同じ名前のメソッドの呼び出し</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Nothing in Rust prevents a trait from having a method with the same name as another trait&#39;s method, nor does Rust prevent you from implementing both traits on one type.</span> Rustの何も、形質が別の形質のメソッドと同じ名前のメソッドを持つのを防ぎません。また、Rustは、両方の型を1つのタイプに実装することもできません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It&#39;s also possible to implement a method directly on the type with the same name as methods from traits.</span>また、メソッドの型と同じ名前の型に直接メソッドを実装することも可能です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When calling methods with the same name, you&#39;ll need to tell Rust which one you want to use.</span>同じ名前のメソッドを呼び出すときは、使用したいメソッドをRustに伝える必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Consider the code in Listing 19-24 where we&#39;ve defined two traits, <code>Pilot</code> and <code>Wizard</code> , that both have a method called <code>fly</code> .</span>リスト19-24のコードで、 <code>Pilot</code>と<code>Wizard</code> 2つの特性を定義していますが、どちらも<code>fly</code>と呼ばれるメソッドを持ってい<code>fly</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We then implement both traits on a type <code>Human</code> that already has a method named <code>fly</code> implemented on it.</span>私たちは、すでに、 <code>fly</code>という名前のメソッド<code>fly</code>実装されている型<code>Human</code>両方の型を実装します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Each <code>fly</code> method does something different.</span>各<code>fly</code>メソッドは、何か違うことをします。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="trait Pilot {"></div><div data-l="    fn fly(&amp;self);"></div><div data-l=}></div><div data-l=""></div><div data-l="trait Wizard {"></div><div data-l="    fn fly(&amp;self);"></div><div data-l=}></div><div data-l=""></div><div data-l="struct Human;"></div><div data-l=""></div><div data-l="impl Pilot for Human {"></div><div data-l="    fn fly(&amp;self) {"></div><div data-l="        println!(&quot;This is your captain speaking.&quot;);"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="impl Wizard for Human {"></div><div data-l="    fn fly(&amp;self) {"></div><div data-l="        println!(&quot;Up!&quot;);"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="impl Human {"></div><div data-l="    fn fly(&amp;self) {"></div><div data-l="        println!(&quot;*waving arms furiously*&quot;);"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 19-24: Two traits are defined to have a <code>fly</code> method and are implemented on the <code>Human</code> type, and a <code>fly</code> method is implemented on <code>Human</code> directly</span></span> <span class=caption>リスト19-24：2つの特性は、 <code>fly</code>メソッドを持つように定義され、 <code>Human</code>タイプで実装され、 <code>fly</code>メソッドは<code>Human</code>直接実装されます</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When we call <code>fly</code> on an instance of <code>Human</code> , the compiler defaults to calling the method that is directly implemented on the type, as shown in Listing 19-25.</span> <code>Human</code>インスタンスに対して<code>fly</code>を呼び出すと、コンパイラはデフォルトで、型に直接実装されているメソッドを呼び出すようにします（コードリスト19-25を参照）。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="# trait Pilot {"></div><div data-l="#     fn fly(&amp;self);"></div><div data-l="# }"></div><div data-l=#></div><div data-l="# trait Wizard {"></div><div data-l="#     fn fly(&amp;self);"></div><div data-l="# }"></div><div data-l=#></div><div data-l="# struct Human;"></div><div data-l=#></div><div data-l="# impl Pilot for Human {"></div><div data-l="#     fn fly(&amp;self) {"></div><div data-l="#         println!(&quot;This is your captain speaking.&quot;);"></div><div data-l="#     }"></div><div data-l="# }"></div><div data-l=#></div><div data-l="# impl Wizard for Human {"></div><div data-l="#     fn fly(&amp;self) {"></div><div data-l="#         println!(&quot;Up!&quot;);"></div><div data-l="#     }"></div><div data-l="# }"></div><div data-l=#></div><div data-l="# impl Human {"></div><div data-l="#     fn fly(&amp;self) {"></div><div data-l="#         println!(&quot;*waving arms furiously*&quot;);"></div><div data-l="#     }"></div><div data-l="# }"></div><div data-l=#></div><div data-l="fn main() {"></div><div data-l="    let person = Human;"></div><div data-l="    person.fly();"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 19-25: Calling <code>fly</code> on an instance of <code>Human</code></span></span> <span class=caption>リスト19-25： <code>Human</code>インスタンスで<code>fly</code>を呼び出す</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Running this code will print <code>*waving arms furiously*</code> , showing that Rust called the <code>fly</code> method implemented on <code>Human</code> directly.</span>このコードを実行すると、 <code>*waving arms furiously*</code> 、 <code>Human</code>直接実装された<code>fly</code>メソッドと呼ばれるRustを表示します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To call the <code>fly</code> methods from either the <code>Pilot</code> trait or the <code>Wizard</code> trait, we need to use more explicit syntax to specify which <code>fly</code> method we mean.</span> <code>Pilot</code>特性または<code>Wizard</code>特性のいずれかから<code>fly</code>メソッドを呼び出すには、より明示的な構文を使用して、どの<code>fly</code>メソッドを指定する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 19-26 demonstrates this syntax.</span>リスト19-26は、この構文を示しています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="# trait Pilot {"></div><div data-l="#     fn fly(&amp;self);"></div><div data-l="# }"></div><div data-l=#></div><div data-l="# trait Wizard {"></div><div data-l="#     fn fly(&amp;self);"></div><div data-l="# }"></div><div data-l=#></div><div data-l="# struct Human;"></div><div data-l=#></div><div data-l="# impl Pilot for Human {"></div><div data-l="#     fn fly(&amp;self) {"></div><div data-l="#         println!(&quot;This is your captain speaking.&quot;);"></div><div data-l="#     }"></div><div data-l="# }"></div><div data-l=#></div><div data-l="# impl Wizard for Human {"></div><div data-l="#     fn fly(&amp;self) {"></div><div data-l="#         println!(&quot;Up!&quot;);"></div><div data-l="#     }"></div><div data-l="# }"></div><div data-l=#></div><div data-l="# impl Human {"></div><div data-l="#     fn fly(&amp;self) {"></div><div data-l="#         println!(&quot;*waving arms furiously*&quot;);"></div><div data-l="#     }"></div><div data-l="# }"></div><div data-l=#></div><div data-l="fn main() {"></div><div data-l="    let person = Human;"></div><div data-l="    Pilot::fly(&amp;person);"></div><div data-l="    Wizard::fly(&amp;person);"></div><div data-l="    person.fly();"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 19-26: Specifying which trait&#39;s <code>fly</code> method we want to call</span></span> <span class=caption>リスト19-26：呼び出すtraitの<code>fly</code>メソッドを指定する</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Specifying the trait name before the method name clarifies to Rust which implementation of <code>fly</code> we want to call.</span>メソッド名の前に特性名を指定すると、呼び出したい<code>fly</code>実装をRustに明確にします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We could also write <code>Human::fly(&amp;person)</code> , which is equivalent to the <code>person.fly()</code> that we used in Listing 19-26, but this is a bit longer to write if we don&#39;t need to disambiguate.</span>また、リスト19-26で使用した<code>person.fly()</code>と同等の<code>Human::fly(&amp;person)</code>を記述することもできますが、曖昧さを除去する必要がない場合は、書き込むのに少し時間が<code>person.fly()</code>ます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Running this code prints the following:</span>このコードを実行すると、以下が出力されます。</span> </p><br><div data-lang=text><div data-l="This is your captain speaking."></div><div data-l=Up!></div><div data-l="*waving arms furiously*"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because the <code>fly</code> method takes a <code>self</code> parameter, if we had two <i>types</i> that both implement one <i>trait</i> , Rust could figure out which implementation of a trait to use based on the type of <code>self</code> .</span> <code>fly</code>メソッドは<code>self</code>パラメータを取るので、両方とも1つの<i>特性を</i>実装する2つの<i>タイプが</i>ある場合、Rustは<code>self</code>のタイプに基づいて使用する特性の実装を把握することができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, associated functions that are part of traits don&#39;t have a <code>self</code> parameter.</span>しかし、特性の一部である関連する機能には、 <code>self</code>パラメータはありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When two types in the same scope implement that trait, Rust can&#39;t figure out which type you mean unless you use <i>fully qualified syntax</i> .</span>同じスコープ内の2つの型がその特性を実装するとき、Rustは<i>完全修飾構文</i>を使用しない限り、どの型を意味するのか把握できません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, the <code>Animal</code> trait in Listing 19-27 has the associated function <code>baby_name</code> , the implementation of <code>Animal</code> for the struct <code>Dog</code> , and the associated function <code>baby_name</code> defined on <code>Dog</code> directly.</span>たとえば、リスト19-27の<code>Animal</code>特性には、関連する関数<code>baby_name</code> 、構造体<code>Dog</code> <code>Animal</code>の実装、 <code>Dog</code>直接定義された関連する関数<code>baby_name</code>ます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="trait Animal {"></div><div data-l="    fn baby_name() -&gt; String;"></div><div data-l=}></div><div data-l=""></div><div data-l="struct Dog;"></div><div data-l=""></div><div data-l="impl Dog {"></div><div data-l="    fn baby_name() -&gt; String {"></div><div data-l="        String::from(&quot;Spot&quot;)"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="impl Animal for Dog {"></div><div data-l="    fn baby_name() -&gt; String {"></div><div data-l="        String::from(&quot;puppy&quot;)"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    println!(&quot;A baby dog is called a {}&quot;, Dog::baby_name());"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 19-27: A trait with an associated function and a type with an associated function of the same name that also implements the trait</span></span> <span class=caption>リスト19-27：関連する関数と同じ名前の関連する関数を持ち、その特性も実装している型</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This code is for an animal shelter that wants to name all puppies Spot, which is implemented in the <code>baby_name</code> associated function that is defined on <code>Dog</code> .</span>このコードは<code>Dog</code>定義されている<code>baby_name</code>関連の関数に実装されているすべての子犬Spotの名前を付ける動物避難所のコードです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Dog</code> type also implements the trait <code>Animal</code> , which describes characteristics that all animals have.</span> <code>Dog</code>型はまた、すべての動物が持つ特性を記述する特性<code>Animal</code>実装します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Baby dogs are called puppies, and that is expressed in the implementation of the <code>Animal</code> trait on <code>Dog</code> in the <code>baby_name</code> function associated with the <code>Animal</code> trait.</span>赤ちゃんの犬は子犬と呼ばれ、そのはの実装で表現された<code>Animal</code>の形質の<code>Dog</code>で<code>baby_name</code>に関連した機能<code>Animal</code>特性。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In <code>main</code> , we call the <code>Dog::baby_name</code> function, which calls the associated function defined on <code>Dog</code> directly.</span> <code>main</code>では、 <code>Dog::baby_name</code>関数を呼び出します。これは、 <code>Dog</code>定義された関連関数を直接呼び出します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This code prints the following:</span>このコードは、以下を出力します。</span> </p><br><div data-lang=text><div data-l="A baby dog is called a Spot"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This output isn&#39;t what we wanted.</span>この出力は私たちが望むものではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We want to call the <code>baby_name</code> function that is part of the <code>Animal</code> trait that we implemented on <code>Dog</code> so the code prints <code>A baby dog is called a puppy</code> .</span>私たちは<code>Dog</code>に実装した<code>Animal</code>特性の一部である<code>baby_name</code>関数を呼び出したいので、コードが出力します<code>A baby dog is called a puppy</code>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The technique of specifying the trait name that we used in Listing 19-26 doesn&#39;t help here;</span>リスト19-26で使用した特性名を指定する方法は、ここでは役に立ちません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">if we change <code>main</code> to the code in Listing 19-28, we&#39;ll get a compilation error.</span>リスト19-28のコードに<code>main</code>を変更すると、コンパイルエラーが発生します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust,ignore><div data-l="fn main() {"></div><div data-l="    println!(&quot;A baby dog is called a {}&quot;, Animal::baby_name());"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 19-28: Attempting to call the <code>baby_name</code> function from the <code>Animal</code> trait, but Rust doesn&#39;t know which implementation to use</span></span> <span class=caption>リスト19-28： <code>Animal</code>特性から<code>baby_name</code>関数を呼び出そうとしましたが、Rustは使用する実装を知らない</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because <code>Animal::baby_name</code> is an associated function rather than a method, and thus doesn&#39;t have a <code>self</code> parameter, Rust can&#39;t figure out which implementation of <code>Animal::baby_name</code> we want.</span> <code>Animal::baby_name</code>はメソッドではなく関連する関数であるため、 <code>self</code>パラメータを持たないため、Rustは<code>Animal::baby_name</code>実装が必要なのか把握できません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll get this compiler error:</span>このコンパイラエラーが発生します：</span> </p><br><div data-lang=text><div data-l="error[E0283]: type annotations required: cannot resolve `_: Animal`"></div><div data-l="  --&gt; src/main.rs:20:43"></div><div data-l="   |"></div><div data-l="20 |     println!(&quot;A baby dog is called a {}&quot;, Animal::baby_name());"></div><div data-l="   |                                           ^^^^^^^^^^^^^^^^^"></div><div data-l="   |"></div><div data-l="   = note: required by `Animal::baby_name`"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To disambiguate and tell Rust that we want to use the implementation of <code>Animal</code> for <code>Dog</code> , we need to use fully qualified syntax.</span>我々はの実装を使用したい錆明確と言うと<code>Animal</code>のための<code>Dog</code> 、私たちは、完全修飾された構文を使用する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 19-29 demonstrates how to use fully qualified syntax.</span>リスト19-29は、完全修飾構文を使用する方法を示しています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="# trait Animal {"></div><div data-l="#     fn baby_name() -&gt; String;"></div><div data-l="# }"></div><div data-l=#></div><div data-l="# struct Dog;"></div><div data-l=#></div><div data-l="# impl Dog {"></div><div data-l="#     fn baby_name() -&gt; String {"></div><div data-l="#         String::from(&quot;Spot&quot;)"></div><div data-l="#     }"></div><div data-l="# }"></div><div data-l=#></div><div data-l="# impl Animal for Dog {"></div><div data-l="#     fn baby_name() -&gt; String {"></div><div data-l="#         String::from(&quot;puppy&quot;)"></div><div data-l="#     }"></div><div data-l="# }"></div><div data-l=#></div><div data-l="fn main() {"></div><div data-l="    println!(&quot;A baby dog is called a {}&quot;, &lt;Dog as Animal&gt;::baby_name());"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 19-29: Using fully qualified syntax to specify that we want to call the <code>baby_name</code> function from the <code>Animal</code> trait as implemented on <code>Dog</code></span></span> <span class=caption>リスト19-29： <code>Dog</code>実装されている<code>Animal</code>特性から<code>baby_name</code>関数を呼び出すように完全修飾構文を使用する</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;re providing Rust with a type annotation within the angle brackets, which indicates we want to call the <code>baby_name</code> method from the <code>Animal</code> trait as implemented on <code>Dog</code> by saying that we want to treat the <code>Dog</code> type as an <code>Animal</code> for this function call.</span>この関数コールの<code>Animal</code>として<code>Dog</code>型を扱いたいと言って、 <code>Dog</code>実装されている<code>Animal</code>特性から<code>baby_name</code>メソッドを呼び出すことを示す、山括弧内の型注釈をRustに提供しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This code will now print what we want:</span>このコードは今私たちが望むものを印刷します：</span> </p><br><div data-lang=text><div data-l="A baby dog is called a puppy"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In general, fully qualified syntax is defined as follows:</span>一般に、完全修飾構文は次のように定義されます。</span> </p><br><div data-lang=rust,ignore><div data-l="&lt;Type as Trait&gt;::function(receiver_if_method, next_arg, ...);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For associated functions, there would not be a <code>receiver</code> : there would only be the list of other arguments.</span>関連する関数については、 <code>receiver</code>は存在しません。他の引数のリストのみが存在します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You could use fully qualified syntax everywhere that you call functions or methods.</span>関数やメソッドを呼び出すときは、どこでも完全修飾構文を使用できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, you&#39;re allowed to omit any part of this syntax that Rust can figure out from other information in the program.</span>しかし、この構文の中で、Rustがプログラムの他の情報から把握できる部分を省略することは許されています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You only need to use this more verbose syntax in cases where there are multiple implementations that use the same name and Rust needs help to identify which implementation you want to call.</span>同じ名前を使用する複数の実装があり、Rustが呼び出す実装を識別するのに役立つ必要がある場合は、このより冗長な構文を使用する必要があります。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Using Supertraits to Require One Trait&#39;s Functionality Within Another Trait</span> Supertraitsを使用して別の形質内にある特性の機能を要求する</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Sometimes, you might need one trait to use another trait&#39;s functionality.</span>場合によっては、別の形質の機能を使用するために、ある形質を必要とするかもしれません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this case, you need to rely on the dependent trait&#39;s also being implemented.</span>この場合、依存する特性が実装されていることに依存する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The trait you rely on is a <i>supertrait</i> of the trait you&#39;re implementing.</span>あなたが依存している形質は、あなたが実施している形質の<i>スーパートライト</i>です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, let&#39;s say we want to make an <code>OutlinePrint</code> trait with an <code>outline_print</code> method that will print a value framed in asterisks.</span>たとえば、アスタリスクで囲まれた値を出力する<code>outline_print</code>メソッドを使用して<code>OutlinePrint</code>特性を作成したいとします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That is, given a <code>Point</code> struct that implements <code>Display</code> to result in <code>(x, y)</code> , when we call <code>outline_print</code> on a <code>Point</code> instance that has <code>1</code> for <code>x</code> and <code>3</code> for <code>y</code> , it should print the following:</span>つまり、 <code>Display</code>を実装する<code>Point</code>構造体が<code>(x, y)</code>になる場合、 <code>x</code>が<code>1</code> 、 <code>y</code> <code>3</code> <code>Point</code>インスタンスで<code>outline_print</code>を呼び出すと、次のように出力されます。</span> </p><br><div data-lang=text><div data-l=**********></div><div data-l="*        *"></div><div data-l="* (1, 3) *"></div><div data-l="*        *"></div><div data-l=**********></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In the implementation of <code>outline_print</code> , we want to use the <code>Display</code> trait&#39;s functionality.</span> <code>outline_print</code>の実装では、 <code>Display</code>特性の機能を使用したいと考えています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Therefore, we need to specify that the <code>OutlinePrint</code> trait will work only for types that also implement <code>Display</code> and provide the functionality that <code>OutlinePrint</code> needs.</span>したがって、 <code>OutlinePrint</code>特性は、 <code>Display</code>を実装し、 <code>OutlinePrint</code>が必要とする機能を提供するタイプに対してのみ機能するように<code>OutlinePrint</code>する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can do that in the trait definition by specifying <code>OutlinePrint: Display</code> .</span> <code>OutlinePrint: Display</code>指定することで、特性定義でこれを行うことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This technique is similar to adding a trait bound to the trait.</span>この技法は、形質に結合した形質を加えることと同様である。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 19-30 shows an implementation of the <code>OutlinePrint</code> trait.</span>リスト19-30に、 <code>OutlinePrint</code>特性の実装を示します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="use std::fmt;"></div><div data-l=""></div><div data-l="trait OutlinePrint: fmt::Display {"></div><div data-l="    fn outline_print(&amp;self) {"></div><div data-l="        let output = self.to_string();"></div><div data-l="        let len = output.len();"></div><div data-l="        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));"></div><div data-l="        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));"></div><div data-l="        println!(&quot;* {} *&quot;, output);"></div><div data-l="        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));"></div><div data-l="        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 19-30: Implementing the <code>OutlinePrint</code> trait that requires the functionality from <code>Display</code></span></span> <span class=caption>リスト19-30： <code>Display</code>からの機能を必要とする<code>OutlinePrint</code>特性の実装</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because we&#39;ve specified that <code>OutlinePrint</code> requires the <code>Display</code> trait, we can use the <code>to_string</code> function that is automatically implemented for any type that implements <code>Display</code> .</span>私たちがいることを指定したので<code>OutlinePrint</code>必要と<code>Display</code>形質を、我々は使用することができます<code>to_string</code> 、自動的に実装する任意のタイプのために実装された機能<code>Display</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we tried to use <code>to_string</code> without adding a colon and specifying the <code>Display</code> trait after the trait name, we&#39;d get an error saying that no method named <code>to_string</code> was found for the type <code>&amp;Self</code> in the current scope.</span>コロンを追加せずに<code>to_string</code>を使用して特性名の後に<code>Display</code>特性を指定しようとすると、現在のスコープ内の<code>&amp;Self</code>型の<code>to_string</code>という名前の<code>to_string</code>が見つかりませんでした。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s see what happens when we try to implement <code>OutlinePrint</code> on a type that doesn&#39;t implement <code>Display</code> , such as the <code>Point</code> struct:</span> <code>Point</code>構造体など、 <code>Display</code>実装しない型で<code>OutlinePrint</code>を実装しようとしたときにどうなるかを見てみましょう。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="# trait OutlinePrint {}"></div><div data-l="struct Point {"></div><div data-l="    x: i32,"></div><div data-l="    y: i32,"></div><div data-l=}></div><div data-l=""></div><div data-l="impl OutlinePrint for Point {}"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We get an error saying that <code>Display</code> is required but not implemented:</span> <code>Display</code>が必須であるが実装されていないというエラーが<code>Display</code>される：</span> </p><br><div data-lang=text><div data-l="error[E0277]: the trait bound `Point: std::fmt::Display` is not satisfied"></div><div data-l="  --&gt; src/main.rs:20:6"></div><div data-l="   |"></div><div data-l="20 | impl OutlinePrint for Point {}"></div><div data-l="   |      ^^^^^^^^^^^^ `Point` cannot be formatted with the default formatter;"></div><div data-l="try using `:?` instead if you are using a format string"></div><div data-l="   |"></div><div data-l="   = help: the trait `std::fmt::Display` is not implemented for `Point`"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To fix this, we implement <code>Display</code> on <code>Point</code> and satisfy the constraint that <code>OutlinePrint</code> requires, like so:</span>これを修正するために、 <code>Display</code> on <code>Point</code>を実装し、 <code>OutlinePrint</code>必要な制約を満たすようにします。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="# struct Point {"></div><div data-l="#     x: i32,"></div><div data-l="#     y: i32,"></div><div data-l="# }"></div><div data-l=#></div><div data-l="use std::fmt;"></div><div data-l=""></div><div data-l="impl fmt::Display for Point {"></div><div data-l="    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {"></div><div data-l="        write!(f, &quot;({}, {})&quot;, self.x, self.y)"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then implementing the <code>OutlinePrint</code> trait on <code>Point</code> will compile successfully, and we can call <code>outline_print</code> on a <code>Point</code> instance to display it within an outline of asterisks.</span>次に、 <code>Point</code>上で<code>OutlinePrint</code>特性を実装すると、正常にコンパイルされ、 <code>Point</code>インスタンスに対して<code>outline_print</code>を呼び出して、アスタリスクのアウトライン内に表示することができます。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Using the Newtype Pattern to Implement External Traits on External Types</span>外部型に外部型を実装するためのNewtypeパターンの使用</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In Chapter 10 in the “Implementing a Trait on a Type” section, we mentioned the orphan rule that states we&#39;re allowed to implement a trait on a type as long as either the trait or the type are local to our crate.</span>第10章の「型の型の実装」のセクションでは、型または型が私たちの箱のローカルである限り、型に対して型を実装することを許可されている孤児のルールについて述べました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It&#39;s possible to get around this restriction using the <i>newtype pattern</i> , which involves creating a new type in a tuple struct.</span> <i>newtypeパターン</i>を使用してこの制限を回避することができ<i>ます</i> 。これには、タプル構造体に新しい型を作成することが含まれます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">(We covered tuple structs in the “Using Tuple Structs without Named Fields to Create Different Types” section of Chapter 5.) The tuple struct will have one field and be a thin wrapper around the type we want to implement a trait for.</span> （タプル構造体については、第5章の「名前付きフィールドを持たないタプル構造体を使用して異なる型を作成する」セクションを参照してください。）タプル構造体は、1つのフィールドを持ち、特性を実装する型の周りに薄いラッパーになります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then the wrapper type is local to our crate, and we can implement the trait on the wrapper.</span>次に、ラッパータイプは私たちのクレートにローカルであり、ラッパーにその特性を実装することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><i>Newtype</i> is a term that originates from the Haskell programming language.</span> <i>Newtype</i>は、Haskellプログラミング言語に由来する用語です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There is no runtime performance penalty for using this pattern, and the wrapper type is elided at compile time.</span>このパターンの使用には、実行時のパフォーマンス上のペナルティはなく、ラッパー・タイプはコンパイル時に省略されます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As an example, let&#39;s say we want to implement <code>Display</code> on <code>Vec&lt;T&gt;</code> , which the orphan rule prevents us from doing directly because the <code>Display</code> trait and the <code>Vec&lt;T&gt;</code> type are defined outside our crate.</span>一例として、 <code>Display</code> traitと<code>Vec&lt;T&gt;</code>タイプが私たちの枠の外で定義されているため、Orphanルールが直接行うことを妨げる<code>Display</code> on <code>Vec&lt;T&gt;</code>を実装したいとしましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can make a <code>Wrapper</code> struct that holds an instance of <code>Vec&lt;T&gt;</code> ;</span> <code>Vec&lt;T&gt;</code>インスタンスを保持する<code>Wrapper</code>構造体を作ることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">then we can implement <code>Display</code> on <code>Wrapper</code> and use the <code>Vec&lt;T&gt;</code> value, as shown in Listing 19-31.</span>リスト19-31に示すように、 <code>Display</code> on <code>Wrapper</code>を実装して<code>Vec&lt;T&gt;</code>値を使用することができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="use std::fmt;"></div><div data-l=""></div><div data-l="struct Wrapper(Vec&lt;String&gt;);"></div><div data-l=""></div><div data-l="impl fmt::Display for Wrapper {"></div><div data-l="    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {"></div><div data-l="        write!(f, &quot;[{}]&quot;, self.0.join(&quot;, &quot;))"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let w = Wrapper(vec![String::from(&quot;hello&quot;), String::from(&quot;world&quot;)]);"></div><div data-l="    println!(&quot;w = {}&quot;, w);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 19-31: Creating a <code>Wrapper</code> type around <code>Vec&lt;String&gt;</code> to implement <code>Display</code></span></span> <span class=caption>リスト19-31： <code>Display</code>を実装する<code>Vec&lt;String&gt;</code>周りに<code>Wrapper</code>タイプを作成する</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The implementation of <code>Display</code> uses <code>self.0</code> to access the inner <code>Vec&lt;T&gt;</code> , because <code>Wrapper</code> is a tuple struct and <code>Vec&lt;T&gt;</code> is the item at index 0 in the tuple.</span> <code>Wrapper</code>はタプル構造体であり、 <code>Vec&lt;T&gt;</code>はタプル内のインデックス0の項目であるため、 <code>Display</code>の実装では内部<code>Vec&lt;T&gt;</code>にアクセスするために<code>self.0</code>が使用<code>self.0</code>れます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then we can use the functionality of the <code>Display</code> type on <code>Wrapper</code> .</span>次に、 <code>Wrapper</code> <code>Display</code>タイプの機能を使用することができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The downside of using this technique is that <code>Wrapper</code> is a new type, so it doesn&#39;t have the methods of the value it&#39;s holding.</span>この手法を使用することの欠点は、 <code>Wrapper</code>は新しいタイプなので、それが保持している値のメソッドはありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We would have to implement all the methods of <code>Vec&lt;T&gt;</code> directly on <code>Wrapper</code> such that the methods delegate to <code>self.0</code> , which would allow us to treat <code>Wrapper</code> exactly like a <code>Vec&lt;T&gt;</code> .</span> <code>Vec&lt;T&gt;</code>すべてのメソッドを<code>Wrapper</code>直接実装する必要があり、メソッドが<code>self.0</code>に委譲されるため、 <code>Wrapper</code> <code>Vec&lt;T&gt;</code>ように扱うことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we wanted the new type to have every method the inner type has, implementing the <code>Deref</code> trait (discussed in Chapter 15 in the “Treating Smart Pointers like Regular References with the <code>Deref</code> Trait” section) on the <code>Wrapper</code> to return the inner type would be a solution.</span>我々は実装し、内側の型が持っているすべてのメソッドを持っている新しいタイプのを望んでいた場合は<code>Deref</code>形質を（「との定期的な参考資料のようなスマートポインタ治療に15章で説明<code>Deref</code>のセクション形質」）を<code>Wrapper</code>インナータイプは次のようになり返すように解決策。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we don&#39;t want the <code>Wrapper</code> type to have all the methods of the inner type—for example, to restrict the <code>Wrapper</code> type&#39;s behavior—we would have to implement just the methods we do want manually.</span> <code>Wrapper</code>タイプに内部型のすべてのメソッドを持たせたくない場合（例えば、 <code>Wrapper</code>タイプの振る舞いを制限する場合）、手動で行うメソッドを実装する必要があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now you know how the newtype pattern is used in relation to traits;</span>今では、newtypeパターンがどのように特性に関連して使われているかを知っています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">it&#39;s also a useful pattern even when traits are not involved.</span>それは、形質が関与していなくても有用なパターンです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s switch focus and look at some advanced ways to interact with Rust&#39;s type system.</span> Rustのタイプシステムと対話するためのいくつかの高度な方法を見てみましょう。</span> </p><script>_addload(function(){_setupIW('com');_csi('en','ja','ch19-03-advanced-traits.html');});</script>