<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180709_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=ch10-03-lifetime-syntax.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Validating References with Lifetimes</span>ライフタイムによる参照の検証</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">One detail we didn&#39;t discuss in the “References and Borrowing” section in Chapter 4 is that every reference in Rust has a <i>lifetime</i> , which is the scope for which that reference is valid.</span>我々は、第4章の「参考資料と貸出」のセクションで説明していない1つの詳細は、錆内のすべての参照は、その参照が有効な範囲である<i>寿命を</i>有することです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Most of the time, lifetimes are implicit and inferred, just like most of the time, types are inferred.</span>ほとんどの場合、生涯は暗黙的に推論され、ほとんどの場合と同様に型が推論されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We must annotate types when multiple types are possible.</span>複数の型が可能な場合、型に注釈を付ける必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In a similar way, we must annotate lifetimes when the lifetimes of references could be related in a few different ways.</span>同様の方法で、参照の存続期間がいくつかの異なる方法で関連する可能性がある場合、生涯に注釈を付ける必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust requires us to annotate the relationships using generic lifetime parameters to ensure the actual references used at runtime will definitely be valid.</span> Rustでは、実行時に使用される実際の参照が確実に有効であることを保証するために、一般的な有効期間パラメータを使用して関係に注釈を付ける必要があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The concept of lifetimes is somewhat different from tools in other programming languages, arguably making lifetimes Rust&#39;s most distinctive feature.</span>生涯のコンセプトは、他のプログラミング言語のツールとは多少異なります。間違いなく、Rustの最も特徴的な機能です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Although we won&#39;t cover lifetimes in their entirety in this chapter, we&#39;ll discuss common ways you might encounter lifetime syntax so you can become familiar with the concepts.</span>この章では、ライフタイム全体については触れませんが、生涯の構文に遭遇する可能性のある一般的な方法について説明し、概念に慣れることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">See the “Advanced Lifetimes” section in Chapter 19 for more detailed information.</span>詳細については、第19章の「高度なライフタイム」の項を参照してください。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Preventing Dangling References with Lifetimes</span>ライフタイムを参照するダングリングの防止</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The main aim of lifetimes is to prevent dangling references, which cause a program to reference data other than the data it&#39;s intended to reference.</span>生存時間の主な目的は、参照することを意図したデータ以外のデータをプログラムが参照させるダングリング参照を防止することです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Consider the program in Listing 10-17, which has an outer scope and an inner scope.</span>外側スコープと内側スコープを持つリスト10-17のプログラムを考えてみましょう。</span> </p><br><div data-lang=rust,ignore><div data-l={></div><div data-l="    let r;"></div><div data-l=""></div><div data-l="    {"></div><div data-l="        let x = 5;"></div><div data-l="        r = &amp;x;"></div><div data-l="    }"></div><div data-l=""></div><div data-l="    println!(&quot;r: {}&quot;, r);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 10-17: An attempt to use a reference whose value has gone out of scope</span></span> <span class=caption>リスト10-17：値がスコープ外にある参照を使用しようとした</span></span> </p><br><blockquote><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note: The examples in Listings 10-17, 10-18, and 10-24 declare variables without giving them an initial value, so the variable name exists in the outer scope.</span>注：リスト10-17,10-18、および10-24の例では、変数に初期値を指定せずに変数を宣言しているため、変数名は外部スコープに存在します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">At first glance, this might appear to be in conflict with Rust&#39;s having no null values.</span>一見すると、この値はヌル値を持たないRustと競合しているように見えるかもしれません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, if we try to use a variable before giving it a value, we&#39;ll get a compile-time error, which shows that Rust indeed does not allow null values.</span>しかし、変数に値を渡す前に変数を使用しようとすると、コンパイル時エラーが発生します。これは、Rustが実際にnull値を許可しないことを示しています。</span> </p></blockquote><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The outer scope declares a variable named <code>r</code> with no initial value, and the inner scope declares a variable named <code>x</code> with the initial value of 5. Inside the inner scope, we attempt to set the value of <code>r</code> as a reference to <code>x</code> .</span>外側スコープは<code>r</code>という名前の変数を初期値なしで宣言し、内側スコープは<code>x</code>という名前の変数を初期値5で宣言します。内側スコープ内で、 <code>r</code>の値を<code>x</code>への参照として設定しようとします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then the inner scope ends, and we attempt to print the value in <code>r</code> .</span>内側のスコープは終了し、 <code>r</code>値を出力しようとします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This code won&#39;t compile because the value <code>r</code> is referring to has gone out of scope before we try to use it.</span>値<code>r</code>が参照を参照しているため、このコードはコンパイルされません。使用する前に有効範囲外になっています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here is the error message:</span>エラーメッセージは次のとおりです。</span> </p><br><div data-lang=text><div data-l="error[E0597]: `x` does not live long enough"></div><div data-l="  --&gt; src/main.rs:7:5"></div><div data-l="   |"></div><div data-l="6  |         r = &amp;x;"></div><div data-l="   |              - borrow occurs here"></div><div data-l="7  |     }"></div><div data-l="   |     ^ `x` dropped here while still borrowed"></div><div data-l=...></div><div data-l="10 | }"></div><div data-l="   | - borrowed value needs to live until here"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The variable <code>x</code> doesn&#39;t “live long enough.” The reason is that <code>x</code> will be out of scope when the inner scope ends on line 7. But <code>r</code> is still valid for the outer scope;</span>変数<code>x</code>は &quot;十分に長く生きていません&quot;。なぜなら、内部スコープが7行目で終了すると、 <code>x</code>はスコープから外れるからです。しかし、 <code>r</code>はまだ外側スコープに対して有効です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">because its scope is larger, we say that it “lives longer.” If Rust allowed this code to work, <code>r</code> would be referencing memory that was deallocated when <code>x</code> went out of scope, and anything we tried to do with <code>r</code> wouldn&#39;t work correctly.</span>その範囲が大きいので錆はこのコードが動作するように許可されている場合、我々はそれが「長く住んでいます。」と言い、 <code>r</code>時に割り当て解除されたメモリ参照されるだろう<code>x</code>スコープ外に行ってきましたが、私たちはして実行しようとしました何も<code>r</code>動作しません正しく</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So how does Rust determine that this code is invalid?</span>では、Rustはこのコードが無効であるとどのように判断しますか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It uses a borrow checker.</span>それは借用チェッカーを使用します。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The Borrow Checker</span>貸借チェッカー</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The Rust compiler has a <i>borrow checker</i> that compares scopes to determine whether all borrows are valid.</span> Rustコンパイラには、スコープを比較してすべての借用が有効かどうかを判断する<i>貸借チェッカー</i>があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 10-18 shows the same code as Listing 10-17 but with annotations showing the lifetimes of the variables.</span>コードリスト10-18は、コードリスト10-17と同じコードを示していますが、注釈には変数の存続期間が表示されています。</span> </p><br><div data-lang=rust,ignore><div data-l={></div><div data-l="#//    let r;                // ---------+-- 'a"></div><div data-l="#                          //          |"></div><div data-l="    let r;                // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">---------+-- &#39;a |</span> --------- +  -  &#39;a |</span> </div><div data-l="#//    {                     //          |"></div><div data-l="    {                     // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">|</span> |</span> </div><div data-l="#//        let x = 5;        // -+-- 'b  |"></div><div data-l="        let x = 5;        // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">-+-- &#39;b |</span> -  +  -  &#39;b |</span> </div><div data-l="#//        r = &amp;x;           //  |       |"></div><div data-l="        r = &amp;x;           // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">|</span> |</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">|</span> |</span> </div><div data-l="#//    }                     // -+       |"></div><div data-l="#                          //          |"></div><div data-l="    }                     // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">-+ |</span> -  + |</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">|</span> |</span> </div><div data-l="#//    println!(&quot;r: {}&quot;, r); //          |"></div><div data-l="    println!(&quot;r: {}&quot;, r); // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">|</span> |</span> </div><div data-l="#//}                         // ---------+"></div><div data-l="}                         // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">---------+</span> --------- +</span> </div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 10-18: Annotations of the lifetimes of <code>r</code> and <code>x</code> , named <code>&#39;a</code> and <code>&#39;b</code> , respectively</span></span> <span class=caption>リスト10-18：それぞれ<code>&#39;b</code>と<code>&#39;b</code>という名前<code>&#39;a</code> <code>r</code>と<code>x</code>生存時間の注釈</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here, we&#39;ve annotated the lifetime of <code>r</code> with <code>&#39;a</code> and the lifetime of <code>x</code> with <code>&#39;b</code> .</span>ここでは、 <code>r</code>の生涯に<code>&#39;b</code>と<code>&#39;b</code> <code>x</code>の生涯<code>&#39;a</code>と注釈をつけた。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As you can see, the inner <code>&#39;b</code> block is much smaller than the outer <code>&#39;a</code> lifetime block.</span>あなたが見ることができるように、内側の<code>&#39;b</code>ブロック<code>&#39;a</code>外側<code>&#39;a</code>ブロック<code>&#39;a</code>よりもはるかに小さいです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">At compile time, Rust compares the size of the two lifetimes and sees that <code>r</code> has a lifetime of <code>&#39;a</code> but that it refers to memory with a lifetime of <code>&#39;b</code> .</span>コンパイル時に、Rustは2つのライフタイムのサイズを比較し、 <code>r</code>のライフタイムが<code>&#39;a</code>が、それは<code>&#39;b</code>ライフタイムを持つメモリを参照することを確認します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The program is rejected because <code>&#39;b</code> is shorter than <code>&#39;a</code> : the subject of the reference doesn&#39;t live as long as the reference.</span>ので、プログラムが拒否される<code>&#39;b</code>より短い<code>&#39;a</code> ：参照の主題は限り基準に住んでいません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 10-19 fixes the code so it doesn&#39;t have a dangling reference and compiles without any errors.</span>コードリスト10-19はコードを修正して、ダグリング参照がなく、エラーなくコンパイルします。</span> </p><br><div data-lang=rust><div data-l={></div><div data-l="#//    let x = 5;            // ----------+-- 'b"></div><div data-l="#                          //           |"></div><div data-l="    let x = 5;            // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">----------+-- &#39;b |</span> ---------- +  -  &#39;b |</span> </div><div data-l="#//    let r = &amp;x;           // --+-- 'a  |"></div><div data-l="#                          //   |       |"></div><div data-l="    let r = &amp;x;           // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">--+-- &#39;a |</span> -  +  -  &#39;a |</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">|</span> |</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">|</span> |</span> </div><div data-l="#//    println!(&quot;r: {}&quot;, r); //   |       |"></div><div data-l="#                          // --+       |"></div><div data-l="    println!(&quot;r: {}&quot;, r); // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">|</span> |</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">|</span> |</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">--+ |</span> -  + |</span> </div><div data-l="#//}                         // ----------+"></div><div data-l="}                         // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">----------+</span> ---------- +</span> </div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 10-19: A valid reference because the data has a longer lifetime than the reference</span></span> <span class=caption>コードリスト10-19：データの参照寿命より長いため、有効な参照</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here, <code>x</code> has the lifetime <code>&#39;b</code> , which in this case is larger than <code>&#39;a</code> .</span>ここで、 <code>x</code>寿命有する<code>&#39;b</code>この場合、より大きく、 <code>&#39;a</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This means <code>r</code> can reference <code>x</code> because Rust knows that the reference in <code>r</code> will always be valid while <code>x</code> is valid.</span>これは、 <code>r</code>参照できる<code>x</code>錆がで参照することを知っているので<code>r</code>一方で常に有効になり<code>x</code>有効です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now that you know where the lifetimes of references are and how Rust analyzes lifetimes to ensure references will always be valid, let&#39;s explore generic lifetimes of parameters and return values in the context of functions.</span>リファレンスの存続期間と、Rustが生存期間をどのように分析して参照が常に有効になるかを知ったので、関数のコンテキストでパラメータと戻り値の一般的なライフタイムを調べてみましょう。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Generic Lifetimes in Functions</span>関数の一般的な生涯</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s write a function that returns the longer of two string slices.</span> 2つの文字列スライスのうち長い方を返す関数を記述しましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This function will take two string slices and return a string slice.</span>この関数は、2つの文字列スライスを取り、文字列スライスを返します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">After we&#39;ve implemented the <code>longest</code> function, the code in Listing 10-20 should print <code>The longest string is abcd</code> .</span> <code>longest</code>関数を実装した後、コードリスト10-20のコードで<code>The longest string is abcd</code>です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust,ignore><div data-l="fn main() {"></div><div data-l="    let string1 = String::from(&quot;abcd&quot;);"></div><div data-l="    let string2 = &quot;xyz&quot;;"></div><div data-l=""></div><div data-l="    let result = longest(string1.as_str(), string2);"></div><div data-l="    println!(&quot;The longest string is {}&quot;, result);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 10-20: A <code>main</code> function that calls the <code>longest</code> function to find the longer of two string slices</span></span> <span class=caption>リスト10-20：2つの文字列スライスのうち<code>longest</code>ものを見つけるために<code>longest</code>関数を呼び出す<code>main</code>関数</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that we want the function to take string slices, which are references, because we don&#39;t want the <code>longest</code> function to take ownership of its parameters.</span> <code>longest</code>関数がそのパラメータの所有権を奪うことは望ましくないので、関数は参照である文字列スライスを取ることを望むことに注意してください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We want to allow the function to accept slices of a <code>String</code> (the type stored in the variable <code>string1</code> ) as well as string literals (which is what variable <code>string2</code> contains).</span>我々は、 <code>String</code>列リテラル（変数<code>string2</code>含まれるもの）だけでなく、文字列（変数<code>string1</code>格納されている型）のスライスを受け入れる機能を許可したい。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Refer to the “String Slices as Parameters” section in Chapter 4 for more discussion about why the parameters we use in Listing 10-20 are the ones we want.</span>リスト10-20で使用するパラメータがなぜ必要なのかについては、第4章の「パラメータとしての文字列スライス」を参照してください。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we try to implement the <code>longest</code> function as shown in Listing 10-21, it won&#39;t compile.</span>リスト10-21に示すように<code>longest</code>関数を実装しようとすると、コンパイルされません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust,ignore><div data-l="fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {"></div><div data-l="    if x.len() &gt; y.len() {"></div><div data-l="        x"></div><div data-l="    } else {"></div><div data-l="        y"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 10-21: An implementation of the <code>longest</code> function that returns the longer of two string slices but does not yet compile</span></span> <span class=caption>リスト10-21：長い2つの文字列スライスを返しますが、まだコンパイルしていない<code>longest</code>関数の実装</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Instead, we get the following error that talks about lifetimes:</span>代わりに、私たちは生涯について語る以下のエラーを受け取ります：</span> </p><br><div data-lang=text><div data-l="error[E0106]: missing lifetime specifier"></div><div data-l=" --&gt; src/main.rs:1:33"></div><div data-l="  |"></div><div data-l="1 | fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {"></div><div data-l="  |                                 ^ expected lifetime parameter"></div><div data-l="  |"></div><div data-l="  = help: this function's return type contains a borrowed value, but the"></div><div data-l="signature does not say whether it is borrowed from `x` or `y`"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The help text reveals that the return type needs a generic lifetime parameter on it because Rust can&#39;t tell whether the reference being returned refers to <code>x</code> or <code>y</code> .</span>ヘルプテキストは、返されたリファレンスが<code>x</code>または<code>y</code>を参照しているかどうかをRustが知ることができないため、戻り値の型に汎用の生涯パラメータが必要であることを示しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Actually, we don&#39;t know either, because the <code>if</code> block in the body of this function returns a reference to <code>x</code> and the <code>else</code> block returns a reference to <code>y</code> !</span>実際には、この関数の本体の<code>if</code>ブロックは<code>x</code>への参照を返し、 <code>else</code>ブロックは<code>y</code>への参照を返すので、どちらも知らない。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When we&#39;re defining this function, we don&#39;t know the concrete values that will be passed into this function, so we don&#39;t know whether the <code>if</code> case or the <code>else</code> case will execute.</span>この関数を定義するとき、この関数に渡す具体的な値はわからないので、 <code>if</code> caseか<code>else</code> caseが実行されるかどうかはわかりません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We also don&#39;t know the concrete lifetimes of the references that will be passed in, so we can&#39;t look at the scopes as we did in Listings 10-18 and 10-19 to determine whether the reference we return will always be valid.</span>また、渡される参照の具体的な存続期間もわからないため、リスト10-18および10-19で行ったようにスコープを見ることができず、返す参照が常に有効かどうかが判断されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The borrow checker can&#39;t determine this either, because it doesn&#39;t know how the lifetimes of <code>x</code> and <code>y</code> relate to the lifetime of the return value.</span> <code>x</code>と<code>y</code>の存続期間が返り値の存続期間にどのように関係しているか分からないため、借用チェッカーはこれを判別することができません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To fix this error, we&#39;ll add generic lifetime parameters that define the relationship between the references so the borrow checker can perform its analysis.</span>このエラーを修正するために、借用チェッカーが分析を実行できるように、参照間の関係を定義する一般的な有効期間パラメーターを追加します。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Lifetime Annotation Syntax</span>生涯の注釈構文</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Lifetime annotations don&#39;t change how long any of the references live.</span>生涯の注釈は参照の存続期間を変更しません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Just as functions can accept any type when the signature specifies a generic type parameter, functions can accept references with any lifetime by specifying a generic lifetime parameter.</span>シグネチャがジェネリック型パラメータを指定するときに関数が任意の型を受け入れるのと同じように、関数はジェネリックな生涯パラメータを指定することで、任意の生涯の参照を受け入れることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Lifetime annotations describe the relationships of the lifetimes of multiple references to each other without affecting the lifetimes.</span>ライフタイムアノテーションは、ライフタイムに影響を与えることなく、複数のリファレンスのライフタイムの相互関係を記述します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Lifetime annotations have a slightly unusual syntax: the names of lifetime parameters must start with an apostrophe ( <code>&#39;</code> ) and are usually all lowercase and very short, like generic types.</span>生涯の注釈には少し珍しい構文があります。生涯パラメータの名前はアポストロフィ（ <code>&#39;</code> ）で始まり、通常はジェネリック型のように小文字で非常に短いものです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Most people use the name <code>&#39;a</code> .</span>ほとんどの人は<code>&#39;a</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We place lifetime parameter annotations after the <code>&amp;</code> of a reference, using a space to separate the annotation from the reference&#39;s type.</span>参照の型から注釈を区切るためのスペースを使用して、参照の<code>&amp;</code>の後に生涯パラメータ注釈を置きます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here are some examples: a reference to an <code>i32</code> without a lifetime parameter, a reference to an <code>i32</code> that has a lifetime parameter named <code>&#39;a</code> , and a mutable reference to an <code>i32</code> that also has the lifetime <code>&#39;a</code> .</span>ここではいくつかの例です：への参照<code>i32</code>寿命パラメータなしで、参照<code>i32</code>という名前の寿命パラメータを持っている<code>&#39;a</code>とに変更可能な参照<code>i32</code>も寿命があります<code>&#39;a</code> 。</span> </p><br><div data-lang=rust,ignore><div data-l="#//&amp;i32        // a reference"></div><div data-l="&amp;i32        // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">a reference</span>リファレンス</span> </div><div data-l="#//&amp;'a i32     // a reference with an explicit lifetime"></div><div data-l="&amp;'a i32     // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">a reference with an explicit lifetime</span>明示的な存続期間を持つ参照</span> </div><div data-l="#//&amp;'a mut i32 // a mutable reference with an explicit lifetime"></div><div data-l="&amp;'a mut i32 // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">a mutable reference with an explicit lifetime</span>明示的な存続期間を持つ変更可能な参照</span> </div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">One lifetime annotation by itself doesn&#39;t have much meaning, because the annotations are meant to tell Rust how generic lifetime parameters of multiple references relate to each other.</span> Rustに、複数の参照の一般的な有効期間パラメータが互いにどのように関連しているかを示すために、1つの生涯注釈だけでは意味がありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, let&#39;s say we have a function with the parameter <code>first</code> that is a reference to an <code>i32</code> with lifetime <code>&#39;a</code> .</span>たとえば、生存期間が<code>&#39;a</code> <code>i32</code>への参照であるパラメータ<code>first</code>を持つ関数があるとします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The function also has another parameter named <code>second</code> that is another reference to an <code>i32</code> that also has the lifetime <code>&#39;a</code> .</span>また、この関数には<code>second</code>という名前の別のパラメータがあります。このパラメータは、ライフタイム<code>&#39;a</code>持つ<code>i32</code>別の参照です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The lifetime annotations indicate that the references <code>first</code> and <code>second</code> must both live as long as that generic lifetime.</span>生涯の注釈は、 <code>first</code>および<code>second</code>の参照がその一般的な生存期間の両方で存続しなければならないことを示している。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Lifetime Annotations in Function Signatures</span>関数シグネチャの生涯アノテーション</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now let&#39;s examine lifetime annotations in the context of the <code>longest</code> function.</span>次に、 <code>longest</code>関数のコンテキストで生涯の注釈を調べてみましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As with generic type parameters, we need to declare generic lifetime parameters inside angle brackets between the function name and the parameter list.</span>ジェネリック型パラメータの場合と同様に、関数名とパラメータリストの間に山括弧で囲んだジェネリックライフタイムパラメータを宣言する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The constraint we want to express in this signature is that all the references in the parameters and the return value must have the same lifetime.</span>このシグネチャで表現したい制約は、パラメータ内のすべての参照と戻り値の寿命が同じでなければならないということです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll name the lifetime <code>&#39;a</code> and then add it to each reference, as shown in Listing 10-22.</span>リスト10-22に示すように、ライフ・タイムに<code>&#39;a</code>名前をつけ、それを各リファレンスに追加します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {"></div><div data-l="    if x.len() &gt; y.len() {"></div><div data-l="        x"></div><div data-l="    } else {"></div><div data-l="        y"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 10-22: The <code>longest</code> function definition specifying that all the references in the signature must have the same lifetime <code>&#39;a</code></span></span> <span class=caption>リスト10-22：署名のすべての参照が同じ生存期間を持つ必要があることを指定する<code>longest</code>関数定義<code>&#39;a</code></span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This code should compile and produce the result we want when we use it with the <code>main</code> function in Listing 10-20.</span>このコードは、リスト10-20の<code>main</code>関数で使用するときに、必要な結果をコンパイルして生成する必要があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The function signature now tells Rust that for some lifetime <code>&#39;a</code> , the function takes two parameters, both of which are string slices that live at least as long as lifetime <code>&#39;a</code> .</span>関数シグネチャ<code>&#39;a</code> 、生存時間<code>&#39;a</code>に対して、関数は2つのパラメータをとります。どちらも少なくとも生涯<code>&#39;a</code>長さと同じ長さの文字列スライスです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The function signature also tells Rust that the string slice returned from the function will live at least as long as lifetime <code>&#39;a</code> .</span>関数のシグネチャは、関数から返された文字列スライスが少なくとも生涯<code>&#39;a</code>長さで存続することをRustに伝えます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These constraints are what we want Rust to enforce.</span>これらの制約は、私たちがRustに要求しているものです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Remember, when we specify the lifetime parameters in this function signature, we&#39;re not changing the lifetimes of any values passed in or returned.</span>この関数シグネチャで寿命パラメータを指定するとき、渡された値または返された値の有効期間は変更されません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rather, we&#39;re specifying that the borrow checker should reject any values that don&#39;t adhere to these constraints.</span>むしろ、借用チェッカーがこれらの制約に従わない値を拒否するように指定しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that the <code>longest</code> function doesn&#39;t need to know exactly how long <code>x</code> and <code>y</code> will live, only that some scope can be substituted for <code>&#39;a</code> that will satisfy this signature.</span> <code>longest</code>関数は、 <code>x</code>と<code>y</code>がどのくらい長く生きるかを正確に知る必要はなく、このシグネチャを満たす<code>&#39;a</code>代わりにいくつかのスコープしか使えないことに注意してください。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When annotating lifetimes in functions, the annotations go in the function signature, not in the function body.</span>関数の生存時間に注釈を付けるとき、注釈は関数の本体ではなく関数のシグネチャに入ります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust can analyze the code within the function without any help.</span>錆は、助けを借りずに関数内のコードを分析することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, when a function has references to or from code outside that function, it becomes almost impossible for Rust to figure out the lifetimes of the parameters or return values on its own.</span>しかし、ある関数がその関数の外にあるコードを参照したり、その関数の外にあるコードから参照を受け取ったりすると、Rustはパラメータの存続期間や独自の戻り値を把握することがほとんど不可能になります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The lifetimes might be different each time the function is called.</span>機能が呼び出されるたびに寿命が異なる場合があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is why we need to annotate the lifetimes manually.</span>このため、生涯に手動で注釈を付ける必要があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When we pass concrete references to <code>longest</code> , the concrete lifetime that is substituted for <code>&#39;a</code> is the part of the scope of <code>x</code> that overlaps with the scope of <code>y</code> .</span>具体的な参照を<code>longest</code>渡すと、 <code>&#39;a</code>と置き換えられる具体的な存続期間は、 <code>y</code>の範囲と重なる<code>x</code>の範囲の一部です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In other words, the generic lifetime <code>&#39;a</code> will get the concrete lifetime that is equal to the smaller of the lifetimes of <code>x</code> and <code>y</code> .</span>言い換えれば、一般的な寿命が<code>&#39;a</code>の寿命の小さい方に等しい具体的な寿命を取得します<code>x</code>と<code>y</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because we&#39;ve annotated the returned reference with the same lifetime parameter <code>&#39;a</code> , the returned reference will also be valid for the length of the smaller of the lifetimes of <code>x</code> and <code>y</code> .</span>返された参照に同じ生涯パラメータ<code>&#39;a</code>ので、返された参照も<code>x</code>と<code>y</code>寿命のうち小さい方の長さに対して有効になります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s look at how the lifetime annotations restrict the <code>longest</code> function by passing in references that have different concrete lifetimes.</span>生涯の注釈が、異なる具体的な生涯を持つ参照を渡すことによって、 <code>longest</code>機能を制限する方法を見てみましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 10-23 is a straightforward example.</span>リスト10-23は簡単な例です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="# fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {"></div><div data-l="#     if x.len() &gt; y.len() {"></div><div data-l="#         x"></div><div data-l="#     } else {"></div><div data-l="#         y"></div><div data-l="#     }"></div><div data-l="# }"></div><div data-l=#></div><div data-l="fn main() {"></div><div data-l="    let string1 = String::from(&quot;long string is long&quot;);"></div><div data-l=""></div><div data-l="    {"></div><div data-l="        let string2 = String::from(&quot;xyz&quot;);"></div><div data-l="        let result = longest(string1.as_str(), string2.as_str());"></div><div data-l="        println!(&quot;The longest string is {}&quot;, result);"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 10-23: Using the <code>longest</code> function with references to <code>String</code> values that have different concrete lifetimes</span></span> <span class=caption>リスト10-23： <code>longest</code>関数を使用して、具体的な生涯が異なる<code>String</code>値への参照</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this example, <code>string1</code> is valid until the end of the outer scope, <code>string2</code> is valid until the end of the inner scope, and <code>result</code> references something that is valid until the end of the inner scope.</span>この例では、 <code>string1</code>は外側のスコープの終わりまで有効であり、 <code>string2</code>は内側のスコープの終わりまで有効であり、 <code>result</code>は内側のスコープの終わりまで有効なものを参照します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Run this code, and you&#39;ll see that the borrow checker approves of this code;</span>このコードを実行すると、借用チェッカーがこのコードを承認していることがわかります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">it will compile and print <code>The longest string is long string is long</code> .</span>コンパイルして印刷します<code>The longest string is long string is long</code> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Next, let&#39;s try an example that shows that the lifetime of the reference in <code>result</code> must be the smaller lifetime of the two arguments.</span>次に、 <code>result</code>内の参照の存続期間が2つの引数のうちのより小さい有効期間でなければならないことを示す例を試してみましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll move the declaration of the <code>result</code> variable outside the inner scope but leave the assignment of the value to the <code>result</code> variable inside the scope with <code>string2</code> .</span> <code>result</code>変数の宣言を内部スコープの外側に移動しますが、スコープ内の<code>result</code>変数に<code>string2</code>という値を代入し<code>string2</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then we&#39;ll move the <code>println€</code> that uses <code>result</code> outside the inner scope, after the inner scope has ended.</span>次に、内部スコープが終了した後に、 <code>result</code>内部スコープ外で使用する<code>println€</code>移動します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The code in Listing 10-24 will not compile.</span>リスト10-24のコードはコンパイルされません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust,ignore><div data-l="fn main() {"></div><div data-l="    let string1 = String::from(&quot;long string is long&quot;);"></div><div data-l="    let result;"></div><div data-l="    {"></div><div data-l="        let string2 = String::from(&quot;xyz&quot;);"></div><div data-l="        result = longest(string1.as_str(), string2.as_str());"></div><div data-l="    }"></div><div data-l="    println!(&quot;The longest string is {}&quot;, result);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 10-24: Attempting to use <code>result</code> after <code>string2</code> has gone out of scope</span></span> <span class=caption>リスト10-24：使用しようとすると<code>result</code>後に<code>string2</code>スコープの外に行ってきました</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When we try to compile this code, we&#39;ll get this error:</span>このコードをコンパイルしようとすると、次のエラーが表示されます。</span> </p><br><div data-lang=text><div data-l="error[E0597]: `string2` does not live long enough"></div><div data-l="  --&gt; src/main.rs:15:5"></div><div data-l="   |"></div><div data-l="14 |         result = longest(string1.as_str(), string2.as_str());"></div><div data-l="   |                                            ------- borrow occurs here"></div><div data-l="15 |     }"></div><div data-l="   |     ^ `string2` dropped here while still borrowed"></div><div data-l="16 |     println!(&quot;The longest string is {}&quot;, result);"></div><div data-l="17 | }"></div><div data-l="   | - borrowed value needs to live until here"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The error shows that for <code>result</code> to be valid for the <code>println€</code> statement, <code>string2</code> would need to be valid until the end of the outer scope.</span>エラーは、 <code>result</code>が<code>println€</code>ステートメントに対して有効である<code>result</code>を示しています<code>string2</code>は、外側スコープの終わりまで有効である必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust knows this because we annotated the lifetimes of the function parameters and return values using the same lifetime parameter <code>&#39;a</code> .</span> Rustはこれを知っています。なぜなら、同じ生涯パラメーター<code>&#39;a</code>を使用して関数パラメーターと戻り値の有効期間に注釈を付けたからです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As humans, we can look at this code and see that <code>string1</code> is longer than <code>string2</code> and therefore <code>result</code> will contain a reference to <code>string1</code> .</span>人間は、このコードを見れば、 <code>string1</code>が<code>string2</code>よりも長いことが<code>string2</code>ます。その<code>result</code> 、 <code>string1</code>への参照が含まれます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because <code>string1</code> has not gone out of scope yet, a reference to <code>string1</code> will still be valid for the <code>println€</code> statement.</span> <code>string1</code>はまだ有効範囲外になっていないので、 <code>string1</code>への参照は<code>println€</code>ステートメントに対して有効です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, the compiler can&#39;t see that the reference is valid in this case.</span>ただし、コンパイラはこの場合参照が有効であることを認識できません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ve told Rust that the lifetime of the reference returned by the <code>longest</code> function is the same as the smaller of the lifetimes of the references passed in. Therefore, the borrow checker disallows the code in Listing 10-24 as possibly having an invalid reference.</span> <code>longest</code>関数によって返される参照の有効期間は、渡された参照の有効期間のうちの小さいものと同じであることをRustに伝えました。したがって、貸借チェッカーは、リスト10-24のコードが無効な参照を持つ可能性があると判断しません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Try designing more experiments that vary the values and lifetimes of the references passed in to the <code>longest</code> function and how the returned reference is used.</span> <code>longest</code>関数に渡された参照の値と有効期間、および返された参照がどのように使用されるかを変更するより多くの実験を設計してみてください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Make hypotheses about whether or not your experiments will pass the borrow checker before you compile;</span>コンパイルする前に実験が借用チェッカーを通過するかどうかについて仮説を立てる。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">then check to see if you&#39;re right!</span>あなたが正しいかどうかを確認してください！</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Thinking in Terms of Lifetimes</span>生涯を考える</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The way in which you need to specify lifetime parameters depends on what your function is doing.</span>寿命パラメータを指定する必要がある方法は、関数が何をしているかによって異なります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, if we changed the implementation of the <code>longest</code> function to always return the first parameter rather than the longest string slice, we wouldn&#39;t need to specify a lifetime on the <code>y</code> parameter.</span>たとえば、 <code>longest</code>関数の実装を、最長の文字列スライスではなく最初のパラメータを常に返すように変更した場合、 <code>y</code>パラメータに有効期間を指定する必要はありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The following code will compile:</span>以下のコードがコンパイルされます：</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;str) -&gt; &amp;'a str {"></div><div data-l="    x"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this example, we&#39;ve specified a lifetime parameter <code>&#39;a</code> for the parameter <code>x</code> and the return type, but not for the parameter <code>y</code> , because the lifetime of <code>y</code> does not have any relationship with the lifetime of <code>x</code> or the return value.</span>この例では、パラメータ<code>x</code>と戻り値の型に対しては生涯パラメータ<code>&#39;a</code>を指定しましたが、 <code>y</code>の有効期間は<code>x</code>の有効期間または返り値とは関係がないため、パラメータ<code>y</code>では指定しませんでした。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When returning a reference from a function, the lifetime parameter for the return type needs to match the lifetime parameter for one of the parameters.</span>関数から参照を返すときは、戻り値の型の有効期間パラメータは、いずれかのパラメータの有効期間パラメータと一致する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If the reference returned does <i>not</i> refer to one of the parameters, it must refer to a value created within this function, which would be a dangling reference because the value will go out of scope at the end of the function.</span>返された参照がパラメータのいずれかを参照してい<i>ない</i>場合は、この関数内で作成された値を参照する必要があります。これは、関数の最後に値が範囲外になるためです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Consider this attempted implementation of the <code>longest</code> function that won&#39;t compile:</span>コンパイルされない<code>longest</code>関数のこの試行された実装を考えてみましょう。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust,ignore><div data-l="fn longest&lt;'a&gt;(x: &amp;str, y: &amp;str) -&gt; &amp;'a str {"></div><div data-l="    let result = String::from(&quot;really long string&quot;);"></div><div data-l="    result.as_str()"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here, even though we&#39;ve specified a lifetime parameter <code>&#39;a</code> for the return type, this implementation will fail to compile because the return value lifetime is not related to the lifetime of the parameters at all.</span>ここでは、戻り値の型に生涯パラメータ<code>&#39;a</code>を指定したにもかかわらず、戻り値の有効期間がパラメータの存続期間にまったく関係しないため、この実装はコンパイルに失敗します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here is the error message we get:</span>ここに私たちが受け取るエラーメッセージがあります：</span> </p><br><div data-lang=text><div data-l="error[E0597]: `result` does not live long enough"></div><div data-l=" --&gt; src/main.rs:3:5"></div><div data-l="  |"></div><div data-l="3 |     result.as_str()"></div><div data-l="  |     ^^^^^^ does not live long enough"></div><div data-l="4 | }"></div><div data-l="  | - borrowed value only lives until here"></div><div data-l="  |"></div><div data-l="note: borrowed value must be valid for the lifetime 'a as defined on the"></div><div data-l="function body at 1:1..."></div><div data-l=" --&gt; src/main.rs:1:1"></div><div data-l="  |"></div><div data-l="1 | / fn longest&lt;'a&gt;(x: &amp;str, y: &amp;str) -&gt; &amp;'a str {"></div><div data-l="2 | |     let result = String::from(&quot;really long string&quot;);"></div><div data-l="3 | |     result.as_str()"></div><div data-l="4 | | }"></div><div data-l="  | |_^"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The problem is that <code>result</code> goes out of scope and gets cleaned up at the end of the <code>longest</code> function.</span>問題は、 <code>result</code>が範囲外になり、 <code>longest</code>関数の最後に<code>result</code>がクリーンアップされることです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;re also trying to return a reference to <code>result</code> from the function.</span>また、関数の<code>result</code>への参照を返そうとしています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There is no way we can specify lifetime parameters that would change the dangling reference, and Rust won&#39;t let us create a dangling reference.</span>ダングリングリファレンスを変更する寿命パラメータを指定する方法はありません.Rustはダングリングリファレンスを作成させません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this case, the best fix would be to return an owned data type rather than a reference so the calling function is then responsible for cleaning up the value.</span>この場合、最も良い解決策は、参照ではなく所有されたデータ型を返すことであり、呼び出し側の関数が値を整理することになります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Ultimately, lifetime syntax is about connecting the lifetimes of various parameters and return values of functions.</span>最終的に、生涯構文は、さまざまなパラメータのライフタイムと関数の戻り値を結びつけることです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Once they&#39;re connected, Rust has enough information to allow memory-safe operations and disallow operations that would create dangling pointers or otherwise violate memory safety.</span>それらが接続されると、Rustは、メモリセーフな操作を許可し、ポインタがつぶれたり、メモリの安全性に違反する操作を禁止するのに十分な情報を持っています。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Lifetime Annotations in Struct Definitions</span>構造定義における生涯の注釈</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So far, we&#39;ve only defined structs to hold owned types.</span>これまでは、所有している型を保持する構造体しか定義していませんでした。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It&#39;s possible for structs to hold references, but in that case we would need to add a lifetime annotation on every reference in the struct&#39;s definition.</span>構造体が参照を保持することは可能ですが、その場合は構造体の定義内のすべての参照に生涯の注釈を追加する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 10-25 has a struct named <code>ImportantExcerpt</code> that holds a string slice.</span>リスト10-25には、文字列sliceを保持する<code>ImportantExcerpt</code>という名前の構造体があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="struct ImportantExcerpt&lt;'a&gt; {"></div><div data-l="    part: &amp;'a str,"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let novel = String::from(&quot;Call me Ishmael. Some years ago...&quot;);"></div><div data-l="    let first_sentence = novel.split('.')"></div><div data-l="        .next()"></div><div data-l="        .expect(&quot;Could not find a '.'&quot;);"></div><div data-l="    let i = ImportantExcerpt { part: first_sentence };"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 10-25: A struct that holds a reference, so its definition needs a lifetime annotation</span></span> <span class=caption>リスト10-25：参照を保持する構造体なので、その定義には生涯の注釈が必要です</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This struct has one field, <code>part</code> , that holds a string slice, which is a reference.</span>この構造体には、参照用の文字列スライスを保持する1つのフィールド<code>part</code>があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As with generic data types, we declare the name of the generic lifetime parameter inside angle brackets after the name of the struct so we can use the lifetime parameter in the body of the struct definition.</span>一般的なデータ型と同様に、構造体の名前の後ろに山形括弧の中にある一般的な生涯パラメータの名前を宣言して、構造体定義の本体でlifetimeパラメータを使用することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This annotation means an instance of <code>ImportantExcerpt</code> can&#39;t outlive the reference it holds in its <code>part</code> field.</span>この注釈は、 <code>ImportantExcerpt</code>インスタンスが、その<code>part</code>フィールドに保持されている参照を保持できないことを意味します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>main</code> function here creates an instance of the <code>ImportantExcerpt</code> struct that holds a reference to the first sentence of the <code>String</code> owned by the variable <code>novel</code> .</span> <code>main</code>関数は、変数<code>novel</code>が所有する<code>String</code>最初の文への参照を保持する、 <code>ImportantExcerpt</code>構造体のインスタンスを作成します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The data in <code>novel</code> exists before the <code>ImportantExcerpt</code> instance is created.</span> <code>novel</code>のデータは、 <code>ImportantExcerpt</code>インスタンスが作成される前に存在します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In addition, <code>novel</code> doesn&#39;t go out of scope until after the <code>ImportantExcerpt</code> goes out of scope, so the reference in the <code>ImportantExcerpt</code> instance is valid.</span>また、 <code>novel</code>後までの範囲の外に出ていない<code>ImportantExcerpt</code>スコープ外になる、そうで参照<code>ImportantExcerpt</code>インスタンスが有効です。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Lifetime Elision</span>ライフタイムエリート</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You&#39;ve learned that every reference has a lifetime and that you need to specify lifetime parameters for functions or structs that use references.</span>すべてのリファレンスには寿命があり、リファレンスを使用する関数や構造体の有効期間パラメータを指定する必要があることがわかりました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, in Chapter 4 we had a function in Listing 4-9, which is shown again in Listing 10-26, that compiled without lifetime annotations.</span>しかし、第4章ではリスト4-9の関数がありました。これはリスト10-26にもあり、生涯の注釈なしでコンパイルされています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/lib.rs</span></span> <span class=filename>ファイル名：src / lib.rs</span></span> </p><br><div data-lang=rust><div data-l="fn first_word(s: &amp;str) -&gt; &amp;str {"></div><div data-l="    let bytes = s.as_bytes();"></div><div data-l=""></div><div data-l="    for (i, &amp;item) in bytes.iter().enumerate() {"></div><div data-l="        if item == b' ' {"></div><div data-l="            return &amp;s[0..i];"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=""></div><div data-l="    &amp;s[..]"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 10-26: A function we defined in Listing 4-9 that compiled without lifetime annotations, even though the parameter and return type are references</span></span> <span class=caption>リスト10-26：リスト4-9で定義した関数で、たとえパラメータと戻り値の型が参照であっても、生涯の注釈なしでコンパイルされた関数</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The reason this function compiles without lifetime annotations is historical: in early versions (pre-1.0) of Rust, this code wouldn&#39;t have compiled because every reference needed an explicit lifetime.</span>この関数が生涯アノテーションなしでコンパイルされる理由は歴史的です.Rustの初期バージョン（1.0より前）では、すべての参照で明示的な存続期間が必要だったため、このコードはコンパイルされませんでした。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">At that time, the function signature would have been written like this:</span>その時、関数シグネチャは次のように書かれています：</span> </p><br><div data-lang=rust,ignore><div data-l="fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">After writing a lot of Rust code, the Rust team found that Rust programmers were entering the same lifetime annotations over and over in particular situations.</span>多くのRustコードを書いた後、Rustチームは、Rustプログラマーが特定の状況で何度も同じ生涯アノテーションを何度も繰り返していたことを発見しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These situations were predictable and followed a few deterministic patterns.</span>これらの状況は予測可能であり、いくつかの決定論的パターンに従った。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The developers programmed these patterns into the compiler&#39;s code so the borrow checker could infer the lifetimes in these situations and wouldn&#39;t need explicit annotations.</span>開発者はこれらのパターンをコンパイラのコードにプログラムしたので、借用チェッカーはこのような状況で寿命を推論でき、明示的な注釈は必要ありません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This piece of Rust history is relevant because it&#39;s possible that more deterministic patterns will emerge and be added to the compiler.</span>この錆履歴の部分は、より決定論的なパターンが出現し、コンパイラに追加される可能性があるため、関連性があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In the future, even fewer lifetime annotations might be required.</span>将来的には生涯の注釈が必要になることもあります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The patterns programmed into Rust&#39;s analysis of references are called the <i>lifetime elision rules</i> .</span> Rustの参考文献の分析にプログラムされたパターンは、 <i>ライフタイムエリシエーションルール</i>と呼ばれ<i>ます</i> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These aren&#39;t rules for programmers to follow;</span>これはプログラマーが従うべきルールではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">they&#39;re a set of particular cases that the compiler will consider, and if your code fits these cases, you don&#39;t need to write the lifetimes explicitly.</span>コンパイラが考慮する一連の特殊なケースであり、コードがこれらのケースに適合する場合は、明示的にライフタイムを書く必要はありません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The elision rules don&#39;t provide full inference.</span>エリシオンルールは完全な推論を提供しません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If Rust deterministically applies the rules but there is still ambiguity as to what lifetimes the references have, the compiler won&#39;t guess what the lifetime of the remaining references should be.</span> Rustが規則を決定論的に適用するが、参照がどのような存続期間にあるかについてのあいまいさが残っている場合、コンパイラは残りの参照の存続期間を推測しません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this case, instead of guessing, the compiler will give you an error that you can resolve by adding the lifetime annotations that specify how the references relate to each other.</span>この場合、コンパイラは、推測の代わりに、参照が互いにどのように関係しているかを指定するライフタイムアノテーションを追加することで解決できるエラーを表示します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Lifetimes on function or method parameters are called <i>input lifetimes</i> , and lifetimes on return values are called <i>output lifetimes</i> .</span>関数またはメソッドのパラメータの<i>寿命</i>は<i>入力寿命</i>と呼ばれ、戻り値の<i>寿命</i>は<i>出力寿命</i>と呼ばれ<i>ます</i> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The compiler uses three rules to figure out what lifetimes references have when there aren&#39;t explicit annotations.</span>コンパイラは、3つのルールを使用して、明示的なアノテーションがない場合に参照されるライフタイムを把握します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The first rule applies to input lifetimes, and the second and third rules apply to output lifetimes.</span>第1のルールは入力寿命に適用され、第2および第3のルールは出力寿命に適用されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If the compiler gets to the end of the three rules and there are still references for which it can&#39;t figure out lifetimes, the compiler will stop with an error.</span>コンパイラが3つのルールの終わりに達し、まだ寿命がわからない参照がある場合、コンパイラはエラーで停止します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The first rule is that each parameter that is a reference gets its own lifetime parameter.</span>最初のルールは、参照である各パラメータが独自の有効期間パラメータを取得することです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In other words, a function with one parameter gets one lifetime parameter: <code>fn foo&lt;&#39;a&gt;(x: &amp;&#39;a i32)</code> ;</span>言い換えると、1つのパラメータを持つ関数は、1つの有効期間パラメータを取得します<code>fn foo&lt;&#39;a&gt;(x: &amp;&#39;a i32)</code> ;</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">a function with two parameters gets two separate lifetime parameters: <code>fn foo&lt;&#39;a, &#39;b&gt;(x: &amp;&#39;a i32, y: &amp;&#39;b i32)</code> ;</span> 2つのパラメータを持つ関数は、 <code>fn foo&lt;&#39;a, &#39;b&gt;(x: &amp;&#39;a i32, y: &amp;&#39;b i32)</code> ;という2つの別々の有効期間パラメータを取得します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">and so on.</span>等々。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The second rule is if there is exactly one input lifetime parameter, that lifetime is assigned to all output lifetime parameters: <code>fn foo&lt;&#39;a&gt;(x: &amp;&#39;a i32) -&gt; &amp;&#39;a i32</code> .</span>第2の規則は、正確に1つの入力有効期間パラメータが存在する場合、その有効期間はすべての出力有効期間パラメータに割り当てられます<code>fn foo&lt;&#39;a&gt;(x: &amp;&#39;a i32) -&gt; &amp;&#39;a i32</code> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The third rule is if there are multiple input lifetime parameters, but one of them is <code>&amp;self</code> or <code>&amp;mut self</code> because this is a method, the lifetime of <code>self</code> is assigned to all output lifetime parameters.</span>第3のルールは、複数の入力有効期間パラメータがある場合ですが、その1つは<code>&amp;self</code>または<code>&amp;mut self</code>です。これはメソッドなので、 <code>self</code>の有効期間はすべての出力有効期間パラメータに割り当てられます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This third rule makes methods much nicer to read and write because fewer symbols are necessary.</span>この第3のルールは、より少ないシンボルが必要であるため、メソッドを読み書きするのがはるかに優れています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s pretend we&#39;re the compiler.</span>私たちがコンパイラであるとふりましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll apply these rules to figure out what the lifetimes of the references in the signature of the <code>first_word</code> function in Listing 10-26 are.</span>これらのルールを適用して、リスト10-26の<code>first_word</code>関数のシグネチャ内の参照の存続期間を<code>first_word</code>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The signature starts without any lifetimes associated with the references:</span>署名は、参照に関連する生存期間なしで開始されます。</span> </p><br><div data-lang=rust,ignore><div data-l="fn first_word(s: &amp;str) -&gt; &amp;str {"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then the compiler applies the first rule, which specifies that each parameter gets its own lifetime.</span>コンパイラは最初のルールを適用します。このルールは、各パラメータが独自の有効期間を取得するように指定します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll call it <code>&#39;a</code> as usual, so now the signature is this:</span>我々はそれを呼ぶよ<code>&#39;a</code>いつものように、今署名はこれです：</span> </p><br><div data-lang=rust,ignore><div data-l="fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;str {"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The second rule applies because there is exactly one input lifetime.</span>正確に1つの入力寿命が存在するため、2番目のルールが適用されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The second rule specifies that the lifetime of the one input parameter gets assigned to the output lifetime, so the signature is now this:</span> 2番目のルールは、1つの入力パラメータの存続期間が出力有効期間に割り当てられるように指定しているので、今度は署名がこれになります。</span> </p><br><div data-lang=rust,ignore><div data-l="fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now all the references in this function signature have lifetimes, and the compiler can continue its analysis without needing the programmer to annotate the lifetimes in this function signature.</span>この関数シグネチャの中のすべての参照は生涯を持ち、コンパイラはこの関数シグネチャのライフタイムに注釈を付けることなくプログラマが分析を続けることができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s look at another example, this time using the <code>longest</code> function that had no lifetime parameters when we started working with it in Listing 10-21:</span>別の例を見てみましょう。今回は、リスト10-21で作業を開始したときに寿命パラメータを持たない<code>longest</code>関数を使用します。</span> </p><br><div data-lang=rust,ignore><div data-l="fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s apply the first rule: each parameter gets its own lifetime.</span>最初のルールを適用してみましょう。各パラメータは独自の有効期間を取得します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This time we have two parameters instead of one, so we have two lifetimes:</span>今回は、1つではなく2つのパラメータがあるため、2つのライフタイムがあります。</span> </p><br><div data-lang=rust,ignore><div data-l="fn longest&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; &amp;str {"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can see that the second rule doesn&#39;t apply because there is more than one input lifetime.</span>入力寿命が複数あるため、2番目のルールは適用されないことがわかります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The third rule doesn&#39;t apply either, because <code>longest</code> is a function rather than a method, so none of the parameters are <code>self</code> .</span>第3のルールはどちらも適用されません。 <code>longest</code>はメソッドではなく関数なので、パラメータのいずれも<code>self</code>ではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">After working through all three rules, we still haven&#39;t figured out what the return type&#39;s lifetime is.</span> 3つのルールをすべて実行した後も、戻りタイプの生存期間はまだわかりません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is why we got an error trying to compile the code in Listing 10-21: the compiler worked through the lifetime elision rules but still couldn&#39;t figure out all the lifetimes of the references in the signature.</span>このため、コードリスト10-21のコードをコンパイルしようとしたときにエラーが発生しました。コンパイラはライフタイム・エリジョン・ルールを処理しましたが、シグネチャ内の参照の存続期間をすべて把握できませんでした。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because the third rule really only applies in method signatures, we&#39;ll look at lifetimes in that context next to see why the third rule means we don&#39;t have to annotate lifetimes in method signatures very often.</span> 3番目のルールは実際にメソッドシグネチャにのみ適用されるため、次にそのコンテキストのライフタイムを見て、3番目のルールでメソッドシグネチャのライフサイクルに非常に頻繁に注釈を付ける必要がないことを確認します。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Lifetime Annotations in Method Definitions</span>メソッド定義における生涯アノテーション</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When we implement methods on a struct with lifetimes, we use the same syntax as that of generic type parameters shown in Listing 10-11.</span>長寿命の構造体にメソッドを実装するときは、リスト10-11に示すジェネリック型のパラメータと同じ構文を使用します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Where we declare and use the lifetime parameters depends on whether they&#39;re related to the struct fields or the method parameters and return values.</span>宣言して生涯パラメータを使用する場所は、構造体フィールド、メソッドのパラメータ、および戻り値に関連しているかどうかによって異なります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Lifetime names for struct fields always need to be declared after the <code>impl</code> keyword and then used after the struct&#39;s name, because those lifetimes are part of the struct&#39;s type.</span>構造体フィールドの生涯名前は、常に<code>impl</code>キーワードの後に​​宣言し、構造体の型の一部であるため、構造体の名前の後に使用する必要があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In method signatures inside the <code>impl</code> block, references might be tied to the lifetime of references in the struct&#39;s fields, or they might be independent.</span> <code>impl</code>ブロック内のメソッドシグネチャでは、参照は構造体のフィールド内の参照の存続期間に関連付けられているか、独立している可能性があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In addition, the lifetime elision rules often make it so that lifetime annotations aren&#39;t necessary in method signatures.</span>さらに、生涯エリシエーションルールでは、生涯の注釈がメソッドシグネチャに必要ないようにすることがよくあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s look at some examples using the struct named <code>ImportantExcerpt</code> that we defined in Listing 10-25.</span>リスト10-25で定義した<code>ImportantExcerpt</code>という名前の構造体を使用したいくつかの例を見てみましょう。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">First, we&#39;ll use a method named <code>level</code> whose only parameter is a reference to <code>self</code> and whose return value is an <code>i32</code> , which is not a reference to anything:</span>最初に、 <code>level</code>という名前のメソッドを使用します。このメソッドのパラメータは<code>self</code>への参照であり、戻り値は<code>i32</code> 。これは何も参照しません。</span> </p><br><div data-lang=rust><div data-l="# struct ImportantExcerpt&lt;'a&gt; {"></div><div data-l="#     part: &amp;'a str,"></div><div data-l="# }"></div><div data-l=#></div><div data-l="impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {"></div><div data-l="    fn level(&amp;self) -&gt; i32 {"></div><div data-l="        3"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The lifetime parameter declaration after <code>impl</code> and use after the type name is required, but we&#39;re not required to annotate the lifetime of the reference to <code>self</code> because of the first elision rule.</span>型名の後の<code>impl</code>とuseの後の生涯パラメータ宣言は必須ですが、最初のelution規則のために<code>self</code>への参照の有効期間に注釈を付ける必要はありません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here is an example where the third lifetime elision rule applies:</span>第3回寿命ルールが適用される例を次に示します。</span> </p><br><div data-lang=rust><div data-l="# struct ImportantExcerpt&lt;'a&gt; {"></div><div data-l="#     part: &amp;'a str,"></div><div data-l="# }"></div><div data-l=#></div><div data-l="impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {"></div><div data-l="    fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str {"></div><div data-l="        println!(&quot;Attention please: {}&quot;, announcement);"></div><div data-l="        self.part"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There are two input lifetimes, so Rust applies the first lifetime elision rule and gives both <code>&amp;self</code> and <code>announcement</code> their own lifetimes.</span>入力寿命には2つの要素があるため、Rustは最初の有効期間ルールを適用し、 <code>&amp;self</code>と<code>announcement</code>両方に独自のライフタイムを与えます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then, because one of the parameters is <code>&amp;self</code> , the return type gets the lifetime of <code>&amp;self</code> , and all lifetimes have been accounted for.</span>次に、パラメータの1つが<code>&amp;self</code>であるため、戻り値の型は<code>&amp;self</code>の有効期間を取得し、すべての有効期間が考慮されます。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The Static Lifetime</span>静的な生涯</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">One special lifetime we need to discuss is <code>&#39;static</code> , which denotes the entire duration of the program.</span>我々が議論する必要がある特別な生涯の1つは<code>&#39;static</code>であり、それはプログラムの全期間を意味する。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">All string literals have the <code>&#39;static</code> lifetime, which we can annotate as follows:</span>すべての文字列リテラルには<code>&#39;static</code>有効期間（ <code>&#39;static</code> lifetime）があり<code>&#39;static</code> 。これを次のように注釈することができます：</span> </p><br><div data-lang=rust><div data-l="let s: &amp;'static str = &quot;I have a static lifetime.&quot;;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The text of this string is stored directly in the binary of your program, which is always available.</span>この文字列のテキストは、プログラムのバイナリに直接格納されます。このバイナリは、常に利用可能です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Therefore, the lifetime of all string literals is <code>&#39;static</code> .</span>したがって、すべての文字列リテラルの有効期間は<code>&#39;static</code>です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You might see suggestions to use the <code>&#39;static</code> lifetime in error messages.</span>エラーメッセージで<code>&#39;static</code>寿命<code>&#39;static</code>を使用することをおすすめします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But before specifying <code>&#39;static</code> as the lifetime for a reference, think about whether the reference you have actually lives the entire lifetime of your program or not.</span>しかし、参照の生存期間として<code>&#39;static</code>指定する前に、実際にリファレンスがあなたのプログラムの生涯にわたって生きているかどうかを考えてください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You might consider whether you want it to live that long, even if it could.</span>可能な場合であっても、それを長く生きたいかどうかを検討するかもしれません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Most of the time, the problem results from attempting to create a dangling reference or a mismatch of the available lifetimes.</span>ほとんどの場合、問題は、利用可能なライフタイムの不一致または不一致を作成しようとした場合に発生します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In such cases, the solution is fixing those problems, not specifying the <code>&#39;static</code> lifetime.</span>このような場合、解決策は<code>&#39;static</code>寿命を指定するのではなく、これらの問題を修正することです。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Generic Type Parameters, Trait Bounds, and Lifetimes Together</span>ジェネリック型パラメータ、特性境界、および生存期間のまとめ</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s briefly look at the syntax of specifying generic type parameters, trait bounds, and lifetimes all in one function!</span>ジェネリック型パラメータ、特性境界、およびすべての関数を1つの関数で指定する構文を簡単に見てみましょう。</span> </p><br><div data-lang=rust><div data-l="use std::fmt::Display;"></div><div data-l=""></div><div data-l="fn longest_with_an_announcement&lt;'a, T&gt;(x: &amp;'a str, y: &amp;'a str, ann: T) -&gt; &amp;'a str"></div><div data-l="    where T: Display"></div><div data-l={></div><div data-l="    println!(&quot;Announcement! {}&quot;, ann);"></div><div data-l="    if x.len() &gt; y.len() {"></div><div data-l="        x"></div><div data-l="    } else {"></div><div data-l="        y"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is the <code>longest</code> function from Listing 10-22 that returns the longer of two string slices.</span>これは、リスト10-22の<code>longest</code>関数であり、2つの文字列スライスのうち長いものを返します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But now it has an extra parameter named <code>ann</code> of the generic type <code>T</code> , which can be filled in by any type that implements the <code>Display</code> trait as specified by the <code>where</code> clause.</span>しかし、これには、ジェネリック型<code>T</code> <code>ann</code>という追加のパラメータがあります。これは、 <code>where</code>句で指定された<code>Display</code>特性を実装する任意の型で埋め込むことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This extra parameter will be printed before the function compares the lengths of the string slices, which is why the <code>Display</code> trait bound is necessary.</span>関数が文字列スライスの長さを比較する前に、この余分なパラメータが表示されます。これは、 <code>Display</code>特性の境界が必要な理由です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because lifetimes are a type of generic, the declarations of the lifetime parameter <code>&#39;a</code> and the generic type parameter <code>T</code> go in the same list inside the angle brackets after the function name.</span>ライフタイムは一種のジェネリック型なので、生涯パラメータ<code>&#39;a</code>とジェネリック型パラメータ<code>T</code>の宣言は、関数名の後に山括弧の中の同じリストに入ります。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Summary</span>概要</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We covered a lot in this chapter!</span>私たちはこの章で多くをカバーしました！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now that you know about generic type parameters, traits and trait bounds, and generic lifetime parameters, you&#39;re ready to write code without repetition that works in many different situations.</span>ジェネリック型のパラメータ、特性と特性の境界、および一般的な有効期間のパラメータについて知ったので、さまざまな状況で動作する繰り返しなしでコードを書く準備が整いました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Generic type parameters let you apply the code to different types.</span>汎用タイプのパラメータを使用すると、さまざまなタイプにコードを適用できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Traits and trait bounds ensure that even though the types are generic, they&#39;ll have the behavior the code needs.</span>特性と特性境界は、型が汎用であっても、コードが必要とする動作を保証します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You learned how to use lifetime annotations to ensure that this flexible code won&#39;t have any dangling references.</span>生涯の注釈を使用して、この柔軟なコードにダングリングリファレンスがないようにする方法を学びました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">And all of this analysis happens at compile time, which doesn&#39;t affect runtime performance!</span>この分析はすべてコンパイル時に実行されますが、実行時のパフォーマンスには影響しません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Believe it or not, there is much more to learn on the topics we discussed in this chapter: Chapter 17 discusses trait objects, which are another way to use traits.</span>それを信じてもいなくても、この章で説明したトピックでもっと学ぶべきことがあります。第17章では、形質を使用する別の方法である形質オブジェクトについて説明します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Chapter 19 covers more complex scenarios involving lifetime annotations as well as some advanced type system features.</span>第19章では、生涯の注釈を含むより複雑なシナリオや、いくつかの高度なタイプのシステム機能について説明します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But next, you&#39;ll learn how to write tests in Rust so you can make sure your code is working the way it should.</span>しかし、次に、Rustでテストを書く方法を学ぶので、あなたのコードが確実に動作するようにすることができます。</span> </p><script>_addload(function(){_setupIW('com');_csi('en','ja','ch10-03-lifetime-syntax.html');});</script>