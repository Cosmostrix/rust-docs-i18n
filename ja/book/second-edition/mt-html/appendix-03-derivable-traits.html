<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180709_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=appendix-03-derivable-traits.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Appendix C: Derivable Traits</span>付録C：派生可能な形質</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In various places in the book, we&#39;ve discussed the <code>derive</code> attribute, which you can apply to a struct or enum definition.</span>本のさまざまな場所では、structまたはenum定義に適用できる<code>derive</code>属性について説明しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>derive</code> attribute generates code that will implement a trait with its own default implementation on the type you&#39;ve annotated with the <code>derive</code> syntax.</span> <code>derive</code>属性は、 <code>derive</code>構文で注釈を付けた型で独自のデフォルト実装を持つ特性を実装するコードを生成します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this appendix, we provide a reference of all the traits in the standard library that you can use with <code>derive</code> .</span>この付録では、標準ライブラリーのすべての特性を<code>derive</code>使用することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Each section covers:</span>各セクションの内容は次のとおりです。</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">What operators and methods deriving this trait will enable</span>この特性を導く演算子とメソッドが可能にするもの</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">What the implementation of the trait provided by <code>derive</code> does</span> <code>derive</code>によって提供さ<code>derive</code>形質の実装が</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">What implementing the trait signifies about the type</span>どのような特性を実装するのがタイプを意味するのか</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The conditions in which you&#39;re allowed or not allowed to implement the trait</span>あなたがその特性を実現することを許されているか否かの条件</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Examples of operations that require the trait</span>特性を必要とする操作の例</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you want different behavior than that provided by the <code>derive</code> attribute, consult the standard library documentation for each trait for details on how to manually implement them.</span> <code>derive</code>属性によって提供される動作と異なる動作が必要な場合は、手動で実装する方法の詳細について、各特性の標準ライブラリのマニュアルを参照してください。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The rest of the traits defined in the standard library can&#39;t be implemented on your types using <code>derive</code> .</span>標準ライブラリで定義された形質の残りの部分は、使用して、あなたのタイプに実装することはできません<code>derive</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These traits don&#39;t have sensible default behavior, so it&#39;s up to you to implement them in the way that makes sense for what you&#39;re trying to accomplish.</span>これらの特性は、賢明なデフォルトの動作を持たないため、達成しようとしていることに合った方法で実装する必要があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">An example of a trait that can&#39;t be derived is <code>Display</code> , which handles formatting for end users.</span>派生することができない形質の例は、エンドユーザーの書式設定を処理する<code>Display</code>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You should always consider the appropriate way to display a type to an end user.</span>エンドユーザーにタイプを表示する適切な方法を常に検討する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">What parts of the type should an end user be allowed to see?</span>エンドユーザーはどのような部分を見なければなりませんか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">What parts would they find relevant?</span>彼らはどの部分に関連性があると思いますか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">What format of the data would be most relevant to them?</span>どのような形式のデータが最も関連性がありますか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The Rust compiler doesn&#39;t have this insight, so it can&#39;t provide appropriate default behavior for you.</span> Rustコンパイラにはこの洞察がないため、適切なデフォルトの動作を提供することはできません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The list of derivable traits provided in this appendix is not comprehensive: libraries can implement <code>derive</code> for their own traits, making the list of traits you can use <code>derive</code> with truly open-ended.</span>この付録で提供特性誘導のリストは包括的ではありません：ライブラリが実装でき<code>derive</code>使用できる特性のリストを作り、自分の形質について<code>derive</code>真にオープンエンドで。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Implementing <code>derive</code> involves using a procedural macro, which is covered in Appendix D.</span>実装<code>derive</code> 、付録Dで覆われている手続きマクロを使用することを含みます</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>Debug</code> for Programmer Output</span>プログラマ出力の<code>Debug</code></span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Debug</code> trait enables debug formatting in format strings, which you indicate by adding <code>:?</code></span> <code>Debug</code>特性は、書式文字列のデバッグ書式を有効にします<code>:?</code></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">within <code>{}</code> placeholders.</span> <code>{}</code>プレースホルダ内にあります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Debug</code> trait allows you to print instances of a type for debugging purposes, so you and other programmers using your type can inspect an instance at a particular point in a program&#39;s execution.</span> <code>Debug</code>特性を使用すると、デバッグ目的でタイプのインスタンスを印刷できます。したがって、あなたと他のタイプのプログラマは、プログラムの実行中の特定のポイントでインスタンスを検査できます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Debug</code> trait is required, for example, in use of the <code>assert_eq€</code> macro.</span>たとえば、 <code>assert_eq€</code>マクロを使用する場合は、 <code>Debug</code>特性が必要です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This macro prints the values of instances given as arguments if the equality assertion fails so programmers can see why the two instances weren&#39;t equal.</span>このマクロは、等価アサーションが失敗した場合に引数として指定されたインスタンスの値を出力するので、2つのインスタンスが同じでない理由をプログラマが確認できます。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>PartialEq</code> and <code>Eq</code> for Equality Comparisons</span>等価比較のための<code>PartialEq</code>と<code>Eq</code></span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>PartialEq</code> trait allows you to compare instances of a type to check for equality and enables use of the <code>==</code> and <code>€=</code> operators.</span> <code>PartialEq</code>特性では、型のインスタンスを比較して等しいかどうかをチェックし、 <code>==</code>および<code>€=</code>演算子を使用できます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Deriving <code>PartialEq</code> implements the <code>eq</code> method.</span> <code>PartialEq</code>すると、 <code>eq</code>メソッドが実装されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When <code>PartialEq</code> is derived on structs, two instances are equal only if <i>all</i> fields are equal, and the instances are not equal if any fields are not equal.</span> structで<code>PartialEq</code>が導出されると、2つのインスタンスは<i>すべての</i>フィールドが等しい場合にのみ等しくなり、フィールドが等しくない場合にはインスタンスが等しくなりません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When derived on enums, each variant is equal to itself and not equal to the other variants.</span>列挙型で派生すると、各変種はそれ自体に等しく、他の変種と等しくはありません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>PartialEq</code> trait is required, for example, with the use of the <code>assert_eq€</code> macro, which needs to be able to compare two instances of a type for equality.</span> <code>PartialEq</code>特性は、たとえば、 <code>assert_eq€</code>マクロの使用で必要となります<code>assert_eq€</code>は、型の2つのインスタンスを比較できるようにする必要があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Eq</code> trait has no methods.</span> <code>Eq</code>特性にはメソッドがありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Its purpose is to signal that for every value of the annotated type, the value is equal to itself.</span>その目的は、注釈付きタイプのすべての値に対して、その値がそれ自身と等しいことを通知することです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Eq</code> trait can only be applied to types that also implement <code>PartialEq</code> , although not all types that implement <code>PartialEq</code> can implement <code>Eq</code> .</span> <code>Eq</code>特性は<code>PartialEq</code>実装する型にのみ適用できますが、 <code>PartialEq</code>を実装するすべての型が<code>Eq</code>を実装できるわけではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">One example of this is floating point number types: the implementation of floating point numbers states that two instances of the not-a-number ( <code>NaN</code> ) value are not equal to each other.</span>これの1つの例は浮動小数点数型です。浮動小数点数の実装では、非数（ <code>NaN</code> ）値の2つのインスタンスが互いに等しくないことが示されています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">An example of when <code>Eq</code> is required is for keys in a <code>HashMap&lt;K, V&gt;</code> so the <code>HashMap&lt;K, V&gt;</code> can tell whether two keys are the same.</span>場合の例<code>Eq</code>のキーのために必要とされている<code>HashMap&lt;K, V&gt;</code>ので<code>HashMap&lt;K, V&gt;</code> 2つのキーが同じであるかどうかを伝えることができます。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>PartialOrd</code> and <code>Ord</code> for Ordering Comparisons</span> <code>PartialOrd</code>と<code>Ord</code></span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>PartialOrd</code> trait allows you to compare instances of a type for sorting purposes.</span> <code>PartialOrd</code>特性では、ソートの目的で型のインスタンスを比較できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A type that implements <code>PartialOrd</code> can be used with the <code>&lt;</code> , <code>&gt;</code> , <code>&lt;=</code> , and <code>&gt;=</code> operators.</span> <code>PartialOrd</code>を実装する型は、 <code>&lt;</code> 、 <code>&gt;</code> 、 <code>&lt;=</code> 、および<code>&gt;=</code>演算子で使用できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can only apply the <code>PartialOrd</code> trait to types that also implement <code>PartialEq</code> .</span>あなただけ適用することができます<code>PartialOrd</code>も実装する型に形質を<code>PartialEq</code> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Deriving <code>PartialOrd</code> implements the <code>partial_cmp</code> method, which returns an <code>Option&lt;Ordering&gt;</code> that will be <code>None</code> when the values given don&#39;t produce an ordering.</span> <code>PartialOrd</code>すると<code>partial_cmp</code>メソッドが実装され、 <code>PartialOrd</code>された値が順序付けを生成しない場合は<code>None</code>になる<code>Option&lt;Ordering&gt;</code>が返されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">An example of a value that doesn&#39;t produce an ordering, even though most values of that type can be compared, is the not-a-number ( <code>NaN</code> ) floating point value.</span>順序を生成しない値の例は、その型のほとんどの値を比較できる場合でも、非数（ <code>NaN</code> ）の浮動小数点値です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Calling <code>partial_cmp</code> with any floating point number and the <code>NaN</code> floating point value will return <code>None</code> .</span> <code>partial_cmp</code>を任意の浮動小数点数と<code>NaN</code>浮動小数点数で呼び出すと、 <code>None</code>が返されます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When derived on structs, <code>PartialOrd</code> compares two instances by comparing the value in each field in the order in which the fields appear in the struct definition.</span> structで派生すると、 <code>PartialOrd</code>は、各フィールドの値を構造体定義に現れる順序で比較して2つのインスタンスを比較します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When derived on enums, variants of the enum declared earlier in the enum definition are considered less than the variants listed later.</span>列挙型で派生すると、列挙型定義で前に宣言された列挙型の変形は、後で列挙する変形よりも小さいとみなされます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>PartialOrd</code> trait is required, for example, for the <code>gen_range</code> method from the <code>rand</code> crate that generates a random value in the range specified by a low value and a high value.</span> <code>PartialOrd</code>特性は、たとえば、低い値と高い値で指定された範囲でランダム値を生成する<code>rand</code> <code>gen_range</code>メソッドの場合に必要です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Ord</code> trait allows you to know that for any two values of the annotated type, a valid ordering will exist.</span> <code>Ord</code>特性は、注釈付きタイプの任意の2つの値に対して、有効な順序付けが存在することを知ることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Ord</code> trait implements the <code>cmp</code> method, which returns an <code>Ordering</code> rather than an <code>Option&lt;Ordering&gt;</code> because a valid ordering will always be possible.</span> <code>Ord</code>特性は、有効な順序付けが常に可能であるため、 <code>Option&lt;Ordering&gt;</code>ではなく<code>Ordering</code>を返す<code>cmp</code>メソッドを実装します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can only apply the <code>Ord</code> trait to types that also implement <code>PartialOrd</code> and <code>Eq</code> (and <code>Eq</code> requires <code>PartialEq</code> ).</span> <code>PartialOrd</code>と<code>Eq</code> （ <code>PartialEq</code>と<code>Eq</code>は<code>PartialEq</code>が必要）を実装している型に対してのみ、 <code>Ord</code>特性を適用することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When derived on structs and enums, <code>cmp</code> behaves the same way as the derived implementation for <code>partial_cmp</code> does with <code>PartialOrd</code> .</span>構造体と列挙型で派生すると、 <code>cmp</code>は<code>PartialOrd</code>で<code>partial_cmp</code>の派生実装と同じように動作し<code>PartialOrd</code> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">An example of when <code>Ord</code> is required is when storing values in a <code>BTreeSet&lt;T&gt;</code> , a data structure that stores data based on the sort order of the values.</span> <code>Ord</code>が必要な場合の例は、値のソート順に基づいてデータを格納するデータ構造である<code>BTreeSet&lt;T&gt;</code>に値を格納する場合です。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>Clone</code> and <code>Copy</code> for Duplicating Values</span>値を複製するための<code>Clone</code>と<code>Copy</code></span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Clone</code> trait allows you to explicitly create a deep copy of a value, and the duplication process might involve running arbitrary code and copying heap data.</span> <code>Clone</code>特性を使用すると、明示的に値のディープコピーを作成できます。複製プロセスでは、任意のコードを実行してヒープデータをコピーすることがあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">See the “Ways Variables and Data Interact: Clone” section in Chapter 4 for more information on <code>Clone</code> .</span>詳細については、第4章のセクション：「クローン方法の変数とデータのインターアクト」を参照してください<code>Clone</code> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Deriving <code>Clone</code> implements the <code>clone</code> method, which when implemented for the whole type, calls <code>clone</code> on each of the parts of the type.</span> <code>Clone</code>導出は、 <code>clone</code>メソッドを実装します。 <code>clone</code>メソッドは、型全体に実装された場合、その型の各部分で<code>clone</code>を呼び出します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This means all the fields or values in the type must also implement <code>Clone</code> to derive <code>Clone</code> .</span>また、これは実装しなければならないタイプのすべてのフィールドまたは値を意味<code>Clone</code>導出する<code>Clone</code> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">An example of when <code>Clone</code> is required is when calling the <code>to_vec</code> method on a slice.</span> <code>Clone</code>が必要な場合の例は、スライス上で<code>to_vec</code>メソッドを呼び出す場合です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The slice doesn&#39;t own the type instances it contains, but the vector returned from <code>to_vec</code> will need to own its instances, so <code>to_vec</code> calls <code>clone</code> on each item.</span>スライスには型インスタンスが含まれていませんが、 <code>to_vec</code>から返されたベクトルはインスタンスを所有する必要があるため、 <code>to_vec</code>は各アイテムの<code>clone</code>を呼び出します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Thus, the type stored in the slice must implement <code>Clone</code> .</span>したがって、スライスに格納された型は<code>Clone</code>実装する必要があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Copy</code> trait allows you to duplicate a value by only copying bits stored on the stack;</span> <code>Copy</code>特性では、スタックに格納されたビットをコピーするだけで値を複製できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">no arbitrary code is necessary.</span>任意のコードは必要ありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">See the “Stack-Only Data: Copy” section in Chapter 4 for more information on <code>Copy</code> .</span>詳細については、第4章のセクション：「コピースタック専用データ」を参照してください<code>Copy</code> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Copy</code> trait doesn&#39;t define any methods to prevent programmers from overloading those methods and violating the assumption that no arbitrary code is being run.</span> <code>Copy</code>特性では、プログラマーがそれらのメソッドをオーバーロードしたり、任意のコードが実行されていないという前提に違反しないようにするためのメソッドは定義されていません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That way, all programmers can assume that copying a value will be very fast.</span>そうすれば、すべてのプログラマーは値のコピーが非常に高速になると考えることができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can derive <code>Copy</code> on any type whose parts all implement <code>Copy</code> .</span>パーツがすべて<code>Copy</code>実装するすべてのタイプで<code>Copy</code>を派生させることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can only apply the <code>Copy</code> trait to types that also implement <code>Clone</code> , because a type that implements <code>Copy</code> has a trivial implementation of <code>Clone</code> that performs the same task as <code>Copy</code> .</span>あなただけ適用することができます<code>Copy</code>も実装する型に形質を<code>Clone</code>実装タイプので、 <code>Copy</code>の些細な実装がある<code>Clone</code>と同じタスクを実行し<code>Copy</code> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Copy</code> trait is rarely required;</span> <code>Copy</code>特性はめったに必要ありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">types that implement <code>Copy</code> have optimizations available, meaning you don&#39;t have to call <code>clone</code> , which makes the code more concise.</span> <code>Copy</code>を実装する型には最適化が用意されています。つまり、コードをより簡潔にするために<code>clone</code>を呼び出す必要はありません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Everything possible with <code>Copy</code> you can also accomplish with <code>Clone</code> , but the code might be slower or have to use <code>clone</code> in places.</span> <code>Copy</code>可能なことはすべて、 <code>Clone</code>でも達成できますが、コードは遅くなるか、場所で<code>clone</code>を使用する必要があります。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>Hash</code> for Mapping a Value to a Value of Fixed Size</span>値を固定サイズの値にマッピングするための<code>Hash</code></span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Hash</code> trait allows you to take an instance of a type of arbitrary size and map that instance to a value of fixed size using a hash function.</span> <code>Hash</code>特性を使用すると、任意のサイズの型のインスタンスを取得し、そのインスタンスをハッシュ関数を使用して固定サイズの値にマップできます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Deriving <code>Hash</code> implements the <code>hash</code> method.</span> <code>Hash</code>導出すると、 <code>hash</code>メソッドが実装されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The derived implementation of the <code>hash</code> method combines the result of calling <code>hash</code> on each of the parts of the type, meaning all fields or values must also implement <code>Hash</code> to derive <code>Hash</code> .</span>派生した<code>hash</code>メソッドの実装は、型の各部分で<code>hash</code>を呼び出した結果を結合します。つまり、すべてのフィールドまたは値が<code>Hash</code>を導出するために<code>Hash</code>実装する必要があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">An example of when <code>Hash</code> is required is in storing keys in a <code>HashMap&lt;K, V&gt;</code> to store data efficiently.</span> <code>Hash</code>が必要な場合の例は、データを効率的に格納するためにキーを<code>HashMap&lt;K, V&gt;</code>に格納する場合です。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>Default</code> for Default Values</span> <code>Default</code>値のデフォルト</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Default</code> trait allows you to create a default value for a type.</span> <code>Default</code>特性を使用すると、あるタイプのデフォルト値を作成できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Deriving <code>Default</code> implements the <code>default</code> function.</span> <code>Default</code>導出すると<code>default</code>関数が実装され<code>default</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The derived implementation of the <code>default</code> function calls the <code>default</code> function on each part of the type, meaning all fields or values in the type must also implement <code>Default</code> to derive <code>Default.</code></span>派生した<code>default</code>関数の実装では、型の各部分で<code>default</code>関数が呼び出され<code>default</code> 。つまり、型のすべてのフィールドまたは値は<code>Default</code>を導出するために<code>Default.</code>実装する必要があります<code>Default.</code></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Default::default</code> function is commonly used in combination with the struct update syntax discussed in the “Creating Instances From Other Instances With Struct Update Syntax” section in Chapter 5. You can customize a few fields of a struct and then set and use a default value for the rest of the fields by using <code>..Default::default()</code> .</span> <code>Default::default</code>関数は、第5章の「構造体更新構文による他のインスタンスからのインスタンスの作成」で説明した構造体の更新構文と組み合わせて一般に使用されます。構造体のいくつかのフィールドをカスタマイズし、 <code>..Default::default()</code>を使用して残りのフィールドのデフォルト値を設定します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Default</code> trait is required when you use the method <code>unwrap_or_default</code> on <code>Option&lt;T&gt;</code> instances, for example.</span>たとえば、 <code>Option&lt;T&gt;</code>インスタンスで<code>unwrap_or_default</code>メソッドを使用する場合は、 <code>Default</code>特性が必要です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If the <code>Option&lt;T&gt;</code> is <code>None</code> , the method <code>unwrap_or_default</code> will return the result of <code>Default::default</code> for the type <code>T</code> stored in the <code>Option&lt;T&gt;</code> .</span> <code>Option&lt;T&gt;</code>が<code>None</code>場合、 <code>unwrap_or_default</code>メソッドは<code>Option&lt;T&gt;</code>格納された<code>T</code>型の<code>Default::default</code>結果を返し<code>Default::default</code> 。</span> </p><script>_addload(function(){_setupIW('com');_csi('en','ja','appendix-03-derivable-traits.html');});</script>