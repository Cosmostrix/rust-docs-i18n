<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180709_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=ch16-03-shared-state.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Shared-State Concurrency</span>共有状態の同時実行性</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Message passing is a fine way of handling concurrency, but it&#39;s not the only one.</span>メッセージの受け渡しは、並行処理の優れた方法ですが、それだけではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Consider this part of the slogan from the Go language documentation again: “communicate by sharing memory.”</span> Go言語のドキュメントのスローガンのこの部分をもう一度「共有メモリで共有する」と考えてください。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">What would communicating by sharing memory look like?</span>共有メモリによる通信はどのように見えますか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In addition, why would message-passing enthusiasts not use it and do the opposite instead?</span>さらに、メッセージを伝える愛好家はなぜそれを使用せず、代わりにその逆を行うのでしょうか？</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In a way, channels in any programming language are similar to single ownership, because once you transfer a value down a channel, you should no longer use that value.</span>ある種のプログラミング言語のチャネルは、一度値をチャネルに転送すると、その値を使用しないようにするため、単一の所有権と似ています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Shared memory concurrency is like multiple ownership: multiple threads can access the same memory location at the same time.</span>共有メモリの同時実行性は、複数の所有権に似ています。複数のスレッドが同じメモリ位置に同時にアクセスできます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As you saw in Chapter 15, where smart pointers made multiple ownership possible, multiple ownership can add complexity because these different owners need managing.</span>第15章で紹介したように、スマートポインタによって複数の所有権が可能になった場合、複数の所有者が管理を必要とするため、複数の所有権が複雑になります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust&#39;s type system and ownership rules greatly assist in getting this management correct.</span> Rustのタイプのシステムと所有権のルールは、この管理を正しく行うのに大いに役立ちます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For an example, let&#39;s look at mutexes, one of the more common concurrency primitives for shared memory.</span>例として、共有メモリのより一般的な並行処理プリミティブの1つであるmutexを見てみましょう。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Using Mutexes to Allow Access to Data from One Thread at a Time</span>ミューテックスを使用して一度に1つのスレッドからデータへのアクセスを許可する</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><i>Mutex</i> is an abbreviation for <i>mutual exclusion</i> , as in, a mutex allows only one thread to access some data at any given time.</span> <i>ミューテックス</i>は<i>相互排除の</i>略語であり、ミューテックスは1つのスレッドのみがいつでも何らかのデータにアクセスすることを許す。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To access the data in a mutex, a thread must first signal that it wants access by asking to acquire the mutex&#39;s <i>lock</i> .</span>ミューテックス内のデータにアクセスするには、スレッドは最初にミューテックスの<i>ロック</i>を取得するように要求することによってアクセスを希望することを通知する必要があり<i>ます</i> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The lock is a data structure that is part of the mutex that keeps track of who currently has exclusive access to the data.</span>ロックは、現在データに排他的にアクセスできるユーザーを追跡するミューテックスの一部であるデータ構造です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Therefore, the mutex is described as <i>guarding</i> the data it holds via the locking system.</span>したがって、ミューテックスは、ロッキングシステムを介して保持しているデータを<i>保護</i>するものとして説明され<i>て</i>います。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Mutexes have a reputation for being difficult to use because you have to remember two rules:</span>ミューテックスは、2つのルールを覚えておく必要があるため、使いにくいという評判を持っています。</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You must attempt to acquire the lock before using the data.</span>データを使用する前に、ロックの取得を試みる必要があります。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When you&#39;re done with the data that the mutex guards, you must unlock the data so other threads can acquire the lock.</span>ミューテックスがガードするデータが終了したら、他のスレッドがロックを取得できるようにデータをロック解除する必要があります。</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For a real-world metaphor for a mutex, imagine a panel discussion at a conference with only one microphone.</span>ミューテックスの現実的なメタファについては、1つのマイクロホンだけで会議でのパネルディスカッションを想像してみてください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Before a panelist can speak, they have to ask or signal that they want to use the microphone.</span>パネリストが話すことができる前に、彼らはマイクを使用したいと尋ねるか、信号を送る必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When they get the microphone, they can talk for as long as they want to and then hand the microphone to the next panelist who requests to speak.</span>彼らがマイクを手に入れたら、話したい次のパネリストにマイクを渡したいと思っている限り、話すことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If a panelist forgets to hand the microphone off when they&#39;re finished with it, no one else is able to speak.</span>パネリストが終了したらマイクをオフにすることを忘れた場合、他の誰も話すことはできません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If management of the shared microphone goes wrong, the panel won&#39;t work as planned!</span>共有マイクの管理が間違っていると、パネルは計画どおりに動作しません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Management of mutexes can be incredibly tricky to get right, which is why so many people are enthusiastic about channels.</span>ミューテックスの管理は非常に難しいので、多くの人がチャンネルに熱心である理由です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, thanks to Rust&#39;s type system and ownership rules, you can&#39;t get locking and unlocking wrong.</span>しかし、Rustのタイプのシステムと所有権のおかげで、あなたはロックとロック解除を間違えることはありません。</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The API of <code>Mutex&lt;T&gt;</code></span> <code>Mutex&lt;T&gt;</code>のAPIは、</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As an example of how to use a mutex, let&#39;s start by using a mutex in a single-threaded context, as shown in Listing 16-12:</span>ミューテックスを使用する方法の例として、リスト16-12に示すように、シングルスレッド・コンテキストでミューテックスを使用します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="use std::sync::Mutex;"></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let m = Mutex::new(5);"></div><div data-l=""></div><div data-l="    {"></div><div data-l="        let mut num = m.lock().unwrap();"></div><div data-l="        *num = 6;"></div><div data-l="    }"></div><div data-l=""></div><div data-l="    println!(&quot;m = {:?}&quot;, m);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 16-12: Exploring the API of <code>Mutex&lt;T&gt;</code> in a single-threaded context for simplicity</span></span> <span class=caption>リスト16-12：簡単にするために、シングルスレッドのコンテキストで<code>Mutex&lt;T&gt;</code> APIを探る</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As with many types, we create a <code>Mutex&lt;T&gt;</code> using the associated function <code>new</code> .</span>多くの型と同様に、関連する関数<code>new</code>を使用して<code>Mutex&lt;T&gt;</code>を作成します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To access the data inside the mutex, we use the <code>lock</code> method to acquire the lock.</span>ミューテックス内のデータにアクセスするには、 <code>lock</code>メソッドを使用して<code>lock</code>を取得します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This call will block the current thread so it can&#39;t do any work until it&#39;s our turn to have the lock.</span>この呼び出しは現在のスレッドをブロックし、ロックを行うまでは何もできません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The call to <code>lock</code> would fail if another thread holding the lock panicked.</span> <code>lock</code>を保持している別のスレッドがパニックに陥った場合、 <code>lock</code>の呼び出しは失敗し<code>lock</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In that case, no one would ever be able to get the lock, so we&#39;ve chosen to <code>unwrap</code> and have this thread panic if we&#39;re in that situation.</span>その場合、誰もロックを取得することはできませんので、私たちはその状況にある場合には、このスレッドのパニックを<code>unwrap</code>ことにしました。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">After we&#39;ve acquired the lock, we can treat the return value, named <code>num</code> in this case, as a mutable reference to the data inside.</span>ロックを取得した後、 <code>num</code>という名前の戻り値を内部のデータへの変更可能な参照として扱うことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The type system ensures that we acquire a lock before using the value in <code>m</code> : <code>Mutex&lt;i32&gt;</code> is not an <code>i32</code> , so we <i>must</i> acquire the lock to be able to use the <code>i32</code> value.</span>型システムは、我々がの値を使用する前にロックを取得することを保証<code>m</code> ： <code>Mutex&lt;i32&gt;</code>ない<code>i32</code>ので、我々は、使用できるようにロックを取得<i>しなければならない</i> <code>i32</code>値。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can&#39;t forget;</span>私たちは忘れることができません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">the type system won&#39;t let us access the inner <code>i32</code> otherwise.</span>タイプシステムは、それ以外の場合は内部の<code>i32</code>アクセスさせません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As you might suspect, <code>Mutex&lt;T&gt;</code> is a smart pointer.</span>あなたが疑うように、 <code>Mutex&lt;T&gt;</code>はスマートなポインタです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">More accurately, the call to <code>lock</code> <i>returns</i> a smart pointer called <code>MutexGuard</code> .</span>より正確には、 <code>lock</code>の呼び出しは<code>MutexGuard</code>というスマートポインタを<i>返します</i> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This smart pointer implements <code>Deref</code> to point at our inner data;</span>このスマートポインタは、 <code>Deref</code>をインナーデータを指すように実装します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">the smart pointer also has a <code>Drop</code> implementation that releases the lock automatically when a <code>MutexGuard</code> goes out of scope, which happens at the end of the inner scope in Listing 16-12.</span>スマートポインタには、 <code>MutexGuard</code>が範囲外になったときに自動的にロックを解除する<code>Drop</code>実装もあります（リスト16-12の内部スコープの終わりで発生します）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As a result, we don&#39;t risk forgetting to release the lock and blocking the mutex from being used by other threads because the lock release happens automatically.</span>その結果、ロックの解放を忘れて、ロックの解放が自動的に行われるため、他のスレッドによってミューテックスが使用されるのを防ぐことができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">After dropping the lock, we can print the mutex value and see that we were able to change the inner <code>i32</code> to 6.</span>ロックを解除した後、mutexの値を出力し、内側の<code>i32</code>を6に変更できたことを確認できます。</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Sharing a <code>Mutex&lt;T&gt;</code> Between Multiple Threads</span>複数のスレッド間の<code>Mutex&lt;T&gt;</code>共有</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now, let&#39;s try to share a value between multiple threads using <code>Mutex&lt;T&gt;</code> .</span>では、 <code>Mutex&lt;T&gt;</code>を使用して複数のスレッド間で値を共有しようとします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll spin up 10 threads and have them each increment a counter value by 1, so the counter goes from 0 to 10. Note that the next few examples will have compiler errors, and we&#39;ll use those errors to learn more about using <code>Mutex&lt;T&gt;</code> and how Rust helps us use it correctly.</span> 10個のスレッドをスピンアップし、カウンタの値を1ずつインクリメントするので、カウンタは0から10になります。次のいくつかの例ではコンパイラエラーが発生します。これらのエラーを使用して、 <code>Mutex&lt;T&gt;</code>とそれが正しく使用するのにRustがどのように役立つかを説明します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 16-13 has our starting example:</span>リスト16-13に、私たちの最初の例を示します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust,ignore><div data-l="use std::sync::Mutex;"></div><div data-l="use std::thread;"></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let counter = Mutex::new(0);"></div><div data-l="    let mut handles = vec![];"></div><div data-l=""></div><div data-l="    for _ in 0..10 {"></div><div data-l="        let handle = thread::spawn(move || {"></div><div data-l="            let mut num = counter.lock().unwrap();"></div><div data-l=""></div><div data-l="            *num += 1;"></div><div data-l="        });"></div><div data-l="        handles.push(handle);"></div><div data-l="    }"></div><div data-l=""></div><div data-l="    for handle in handles {"></div><div data-l="        handle.join().unwrap();"></div><div data-l="    }"></div><div data-l=""></div><div data-l="    println!(&quot;Result: {}&quot;, *counter.lock().unwrap());"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 16-13: Ten threads each increment a counter guarded by a <code>Mutex&lt;T&gt;</code></span></span> <span class=caption>リスト16-13： <code>Mutex&lt;T&gt;</code>によって保護されたカウンタをインクリメントする10個のスレッド</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We create a <code>counter</code> variable to hold an <code>i32</code> inside a <code>Mutex&lt;T&gt;</code> , as we did in Listing 16-12.</span>リスト16-12のように、 <code>Mutex&lt;T&gt;</code>内に<code>i32</code>を保持する<code>counter</code>変数を作成します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Next, we create 10 threads by iterating over a range of numbers.</span>次に、一連の数値を反復して10のスレッドを作成します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We use <code>thread::spawn</code> and give all the threads the same closure, one that moves the counter into the thread, acquires a lock on the <code>Mutex&lt;T&gt;</code> by calling the <code>lock</code> method, and then adds 1 to the value in the mutex.</span> <code>thread::spawn</code>を使用して、すべてのスレッドに同じクロージャを与え、カウンタをスレッドに移動させ、 <code>lock</code>メソッドを呼び出して<code>Mutex&lt;T&gt;</code>ロックを取得してから、mutexの値に1を加算します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When a thread finishes running its closure, <code>num</code> will go out of scope and release the lock so another thread can acquire it.</span>スレッドがクロージャを実行し終えると、 <code>num</code>はスコープから外れてロックを解放し、別のスレッドがロックを獲得できるようにします。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In the main thread, we collect all the join handles.</span>メインスレッドでは、すべての結合ハンドルを収集します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then, as we did in Listing 16-2, we call <code>join</code> on each handle to make sure all the threads finish.</span>リスト16-2で行ったよう<code>join</code> 、各ハンドルに対して<code>join</code>を呼び出して、すべてのスレッドが終了していることを確認します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">At that point, the main thread will acquire the lock and print the result of this program.</span>その時点で、メインスレッドはロックを取得し、このプログラムの結果を出力します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We hinted that this example wouldn&#39;t compile.</span>私たちは、この例はコンパイルされないことを暗示しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now let&#39;s find out why!</span>今、なぜそれを見つけよう！</span> </p><br><div data-lang=text><div data-l="error[E0382]: capture of moved value: `counter`"></div><div data-l="  --&gt; src/main.rs:10:27"></div><div data-l="   |"></div><div data-l="9  |         let handle = thread::spawn(move || {"></div><div data-l="   |                                    ------- value moved (into closure) here"></div><div data-l="10 |             let mut num = counter.lock().unwrap();"></div><div data-l="   |                           ^^^^^^^ value captured here after move"></div><div data-l="   |"></div><div data-l="   = note: move occurs because `counter` has type `std::sync::Mutex&lt;i32&gt;`,"></div><div data-l="   which does not implement the `Copy` trait"></div><div data-l=""></div><div data-l="error[E0382]: use of moved value: `counter`"></div><div data-l="  --&gt; src/main.rs:21:29"></div><div data-l="   |"></div><div data-l="9  |         let handle = thread::spawn(move || {"></div><div data-l="   |                                    ------- value moved (into closure) here"></div><div data-l=...></div><div data-l="21 |     println!(&quot;Result: {}&quot;, *counter.lock().unwrap());"></div><div data-l="   |                             ^^^^^^^ value used here after move"></div><div data-l="   |"></div><div data-l="   = note: move occurs because `counter` has type `std::sync::Mutex&lt;i32&gt;`,"></div><div data-l="   which does not implement the `Copy` trait"></div><div data-l=""></div><div data-l="error: aborting due to 2 previous errors"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The error message states that the <code>counter</code> value is moved into the closure and then captured when we call <code>lock</code> .</span>エラーメッセージは、 <code>counter</code>値がクロージャに移動され、 <code>lock</code>を呼び出すとキャプチャされることを示し<code>lock</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That description sounds like what we wanted, but it&#39;s not allowed!</span>その説明は私たちが望むように聞こえるが、許可されていない！</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s figure this out by simplifying the program.</span>プログラムを単純化することでこれを理解しよう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Instead of making 10 threads in a <code>for</code> loop, let&#39;s just make two threads without a loop and see what happens.</span> <code>for</code>ループで10個のスレッドを作成するのではなく、ループのない2つのスレッドを作成し、何が起こるかを見てみましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Replace the first <code>for</code> loop in Listing 16-13 with this code instead:</span>コードリスト16-13の最初の<code>for</code>ループを代わりにこのコードに置き換えます。</span> </p><br><div data-lang=rust,ignore><div data-l="use std::sync::Mutex;"></div><div data-l="use std::thread;"></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let counter = Mutex::new(0);"></div><div data-l="    let mut handles = vec![];"></div><div data-l=""></div><div data-l="    let handle = thread::spawn(move || {"></div><div data-l="        let mut num = counter.lock().unwrap();"></div><div data-l=""></div><div data-l="        *num += 1;"></div><div data-l="    });"></div><div data-l="    handles.push(handle);"></div><div data-l=""></div><div data-l="    let handle2 = thread::spawn(move || {"></div><div data-l="        let mut num2 = counter.lock().unwrap();"></div><div data-l=""></div><div data-l="        *num2 += 1;"></div><div data-l="    });"></div><div data-l="    handles.push(handle2);"></div><div data-l=""></div><div data-l="    for handle in handles {"></div><div data-l="        handle.join().unwrap();"></div><div data-l="    }"></div><div data-l=""></div><div data-l="    println!(&quot;Result: {}&quot;, *counter.lock().unwrap());"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We make two threads and change the variable names used with the second thread to <code>handle2</code> and <code>num2</code> .</span> 2つのスレッドを作成し、2番目のスレッドで使用する変数名を<code>handle2</code>と<code>num2</code>変更します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When we run the code this time, compiling gives us the following:</span>今回コードを実行すると、コンパイルによって次のようになります。</span> </p><br><div data-lang=text><div data-l="error[E0382]: capture of moved value: `counter`"></div><div data-l="  --&gt; src/main.rs:16:24"></div><div data-l="   |"></div><div data-l="8  |     let handle = thread::spawn(move || {"></div><div data-l="   |                                ------- value moved (into closure) here"></div><div data-l=...></div><div data-l="16 |         let mut num2 = counter.lock().unwrap();"></div><div data-l="   |                        ^^^^^^^ value captured here after move"></div><div data-l="   |"></div><div data-l="   = note: move occurs because `counter` has type `std::sync::Mutex&lt;i32&gt;`,"></div><div data-l="   which does not implement the `Copy` trait"></div><div data-l=""></div><div data-l="error[E0382]: use of moved value: `counter`"></div><div data-l="  --&gt; src/main.rs:26:29"></div><div data-l="   |"></div><div data-l="8  |     let handle = thread::spawn(move || {"></div><div data-l="   |                                ------- value moved (into closure) here"></div><div data-l=...></div><div data-l="26 |     println!(&quot;Result: {}&quot;, *counter.lock().unwrap());"></div><div data-l="   |                             ^^^^^^^ value used here after move"></div><div data-l="   |"></div><div data-l="   = note: move occurs because `counter` has type `std::sync::Mutex&lt;i32&gt;`,"></div><div data-l="   which does not implement the `Copy` trait"></div><div data-l=""></div><div data-l="error: aborting due to 2 previous errors"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Aha!</span>ああ！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The first error message indicates that <code>counter</code> is moved into the closure for the thread associated with <code>handle</code> .</span>最初のエラーメッセージは、 <code>counter</code>が<code>handle</code>関連付けられたスレッドのクロージャに移動されたことを示します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That move is preventing us from capturing <code>counter</code> when we try to call <code>lock</code> on it and store the result in <code>num2</code> in the second thread!</span>その動きは、 <code>lock</code>を呼び出して2番目のスレッドの<code>num2</code>に結果を格納しようとすると、 <code>counter</code>をキャプチャできなくなります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So Rust is telling us that we can&#39;t move ownership of <code>counter</code> into multiple threads.</span>そこでRustは、 <code>counter</code>所有権を複数のスレッドに移動することはできないと伝えています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This was hard to see earlier because our threads were in a loop, and Rust can&#39;t point to different threads in different iterations of the loop.</span>私たちのスレッドがループしていて、ループの異なる反復で異なるスレッドを指し示すことができないため、以前はこれを見るのが難しかったです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s fix the compiler error with a multiple-ownership method we discussed in Chapter 15.</span>第15章で説明した多重所有方法を使ってコンパイラエラーを修正しましょう。</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Multiple Ownership with Multiple Threads</span>複数のスレッドを持つ複数の所有権</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In Chapter 15, we gave a value multiple owners by using the smart pointer <code>Rc&lt;T&gt;</code> to create a reference counted value.</span>第15章では、スマートポインタ<code>Rc&lt;T&gt;</code>を使用して複数の所有者に値を渡し、参照カウント値を作成しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s do the same here and see what happens.</span>ここでも同じことをして、何が起こるか見てみましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll wrap the <code>Mutex&lt;T&gt;</code> in <code>Rc&lt;T&gt;</code> in Listing 16-14 and clone the <code>Rc&lt;T&gt;</code> before moving ownership to the thread.</span>リスト16-14の<code>Rc&lt;T&gt;</code>に<code>Mutex&lt;T&gt;</code>ラップし、所有権をスレッドに移す前に<code>Rc&lt;T&gt;</code>をクローンします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now that we&#39;ve seen the errors, we&#39;ll also switch back to using the <code>for</code> loop, and we&#39;ll keep the <code>move</code> keyword with the closure.</span>このエラーを見たので、 <code>for</code>ループの使用に戻って、 <code>move</code>キーワードをクロージャで保持します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust,ignore><div data-l="use std::rc::Rc;"></div><div data-l="use std::sync::Mutex;"></div><div data-l="use std::thread;"></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let counter = Rc::new(Mutex::new(0));"></div><div data-l="    let mut handles = vec![];"></div><div data-l=""></div><div data-l="    for _ in 0..10 {"></div><div data-l="        let counter = Rc::clone(&amp;counter);"></div><div data-l="        let handle = thread::spawn(move || {"></div><div data-l="            let mut num = counter.lock().unwrap();"></div><div data-l=""></div><div data-l="            *num += 1;"></div><div data-l="        });"></div><div data-l="        handles.push(handle);"></div><div data-l="    }"></div><div data-l=""></div><div data-l="    for handle in handles {"></div><div data-l="        handle.join().unwrap();"></div><div data-l="    }"></div><div data-l=""></div><div data-l="    println!(&quot;Result: {}&quot;, *counter.lock().unwrap());"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 16-14: Attempting to use <code>Rc&lt;T&gt;</code> to allow multiple threads to own the <code>Mutex&lt;T&gt;</code></span></span> <span class=caption>リスト16-14：複数のスレッドが<code>Mutex&lt;T&gt;</code>を所有できるように<code>Rc&lt;T&gt;</code>を使用しようとすると、</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Once again, we compile and get... different errors!</span>もう一度、コンパイルして...違うエラーが出ます！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The compiler is teaching us a lot.</span>コンパイラは私たちに多くのことを教えています。</span> </p><br><div data-lang=text><div data-l="error[E0277]: the trait bound `std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;:"></div><div data-l="std::marker::Send` is not satisfied in `[closure@src/main.rs:11:36:"></div><div data-l="15:10 counter:std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;]`"></div><div data-l="  --&gt; src/main.rs:11:22"></div><div data-l="   |"></div><div data-l="11 |         let handle = thread::spawn(move || {"></div><div data-l="   |                      ^^^^^^^^^^^^^ `std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;`"></div><div data-l="cannot be sent between threads safely"></div><div data-l="   |"></div><div data-l="   = help: within `[closure@src/main.rs:11:36: 15:10"></div><div data-l="counter:std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;]`, the trait `std::marker::Send` is"></div><div data-l="not implemented for `std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;`"></div><div data-l="   = note: required because it appears within the type"></div><div data-l="`[closure@src/main.rs:11:36: 15:10 counter:std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;]`"></div><div data-l="   = note: required by `std::thread::spawn`"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Wow, that error message is very wordy!</span>うわー、そのエラーメッセージは非常に言葉です！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here are some important parts to focus on: the first inline error says <code class=2>`std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely</code> .</span>最初のインラインエラーは、 <code class=2>`std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The reason for this is in the next important part to focus on, the error message.</span>その理由は次の重要な部分であり、エラーメッセージです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The distilled error message says <code class=2>the trait bound `Send` is not satisfied</code> .</span>蒸留されたエラーメッセージは<code class=2>the trait bound `Send` is not satisfied</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll talk about <code>Send</code> in the next section: it&#39;s one of the traits that ensures the types we use with threads are meant for use in concurrent situations.</span>次のセクションで<code>Send</code>について説明します。これは、スレッドで使用する型が同時の状況で使用されることを保証する特性の1つです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Unfortunately, <code>Rc&lt;T&gt;</code> is not safe to share across threads.</span>残念ながら、 <code>Rc&lt;T&gt;</code>はスレッド間で共有することは安全ではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When <code>Rc&lt;T&gt;</code> manages the reference count, it adds to the count for each call to <code>clone</code> and subtracts from the count when each clone is dropped.</span> <code>Rc&lt;T&gt;</code>が参照カウントを管理するとき、それは<code>clone</code>する各呼び出しのカウントに加算し、各複製がドロップされたときのカウントから減算します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But it doesn&#39;t use any concurrency primitives to make sure that changes to the count can&#39;t be interrupted by another thread.</span>しかし、カウントの変更が別のスレッドによって中断されないことを確認するために並行処理プリミティブを使用することはありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This could lead to wrong counts—subtle bugs that could in turn lead to memory leaks or a value being dropped before we&#39;re done with it.</span>これは間違ったカウントにつながる可能性があります。微妙なバグは、メモリリークや値を落としてしまい、終了する前に終了する可能性があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">What we need is a type exactly like <code>Rc&lt;T&gt;</code> but one that makes changes to the reference count in a thread-safe way.</span>私たちが必要とするのは、 <code>Rc&lt;T&gt;</code>全く同じ型ですが、スレッドセーフな方法で参照カウントを変更するものです。</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Atomic Reference Counting with <code>Arc&lt;T&gt;</code></span> <code>Arc&lt;T&gt;</code>による原子参照カウント</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Fortunately, <code>Arc&lt;T&gt;</code> <i>is</i> a type like <code>Rc&lt;T&gt;</code> that is safe to use in concurrent situations.</span>幸運なことに、 <code>Arc&lt;T&gt;</code> <i>は</i> <code>Rc&lt;T&gt;</code>ようなタイプで、同時の状況でも安全に使用できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <i>a</i> stands for <i>atomic</i> , meaning it&#39;s an <i>atomically reference counted</i> type.</span> <i>a</i>は<i>原子を</i>表し、 <i>原子</i> <i>的に参照カウントされる</i>タイプを意味します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Atomics are an additional kind of concurrency primitive that we won&#39;t cover in detail here: see the standard library documentation for <code>std::sync::atomic</code> for more details.</span> Atomicsは、並行処理プリミティブの追加の種類です。詳細については、 <code>std::sync::atomic</code>の標準ライブラリのドキュメントを参照してください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">At this point, you just need to know that atomics work like primitive types but are safe to share across threads.</span>この時点で、アトミックはプリミティブ型のように機能するが、スレッド間で共有することは安全であることを知る必要があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You might then wonder why all primitive types aren&#39;t atomic and why standard library types aren&#39;t implemented to use <code>Arc&lt;T&gt;</code> by default.</span>なぜ、すべてのプリミティブ型がアトミックでないのか、標準ライブラリ型が<code>Arc&lt;T&gt;</code>をデフォルトで使用するように実装されていないのはなぜだろうか。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The reason is that thread safety comes with a performance penalty that you only want to pay when you really need to.</span>理由は、スレッドの安全性には、本当に必要なときに支払うだけのパフォーマンスペナルティが伴うからです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you&#39;re just performing operations on values within a single thread, your code can run faster if it doesn&#39;t have to enforce the guarantees atomics provide.</span>単一のスレッド内の値に対して操作を実行しているだけの場合、アトミックが提供する保証を強制する必要がない場合、コードはより高速に実行できます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s return to our example: <code>Arc&lt;T&gt;</code> and <code>Rc&lt;T&gt;</code> have the same API, so we fix our program by changing the <code>use</code> line, the call to <code>new</code> , and the call to <code>clone</code> .</span> <code>Arc&lt;T&gt;</code>と<code>Rc&lt;T&gt;</code>には同じAPIがありますので、 <code>use</code>行、 <code>new</code>への呼び出し、 <code>clone</code>への呼び出しを変更してプログラムを修正します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The code in Listing 16-15 will finally compile and run:</span>コードリスト16-15のコードが最終的にコンパイルされ、実行されます：</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="use std::sync::{Mutex, Arc};"></div><div data-l="use std::thread;"></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let counter = Arc::new(Mutex::new(0));"></div><div data-l="    let mut handles = vec![];"></div><div data-l=""></div><div data-l="    for _ in 0..10 {"></div><div data-l="        let counter = Arc::clone(&amp;counter);"></div><div data-l="        let handle = thread::spawn(move || {"></div><div data-l="            let mut num = counter.lock().unwrap();"></div><div data-l=""></div><div data-l="            *num += 1;"></div><div data-l="        });"></div><div data-l="        handles.push(handle);"></div><div data-l="    }"></div><div data-l=""></div><div data-l="    for handle in handles {"></div><div data-l="        handle.join().unwrap();"></div><div data-l="    }"></div><div data-l=""></div><div data-l="    println!(&quot;Result: {}&quot;, *counter.lock().unwrap());"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 16-15: Using an <code>Arc&lt;T&gt;</code> to wrap the <code>Mutex&lt;T&gt;</code> to be able to share ownership across multiple threads</span></span> <span class=caption>リスト16-15： <code>Mutex&lt;T&gt;</code>をラップして複数のスレッド間で所有権を共有できるようにするために、 <code>Arc&lt;T&gt;</code>を使用する</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This code will print the following:</span>このコードは以下を出力します：</span> </p><br><div data-lang=text><div data-l="Result: 10"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We did it!</span>やった！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We counted from 0 to 10, which may not seem very impressive, but it did teach us a lot about <code>Mutex&lt;T&gt;</code> and thread safety.</span>私たちは0から10までカウントしましたが、これはあまり印象的ではないかもしれませんが、 <code>Mutex&lt;T&gt;</code>とスレッドの安全性について多くのことを教えてくれました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You could also use this program&#39;s structure to do more complicated operations than just incrementing a counter.</span>また、このプログラムの構造を使用して、カウンタをインクリメントするだけの複雑な操作を行うこともできます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Using this strategy, you can divide a calculation into independent parts, split those parts across threads, and then use a <code>Mutex&lt;T&gt;</code> to have each thread update the final result with its part.</span>この戦略を使用すると、計算を独立した部分に分割し、それらの部分をスレッド間で分割し、 <code>Mutex&lt;T&gt;</code>を使用して各スレッドが最終結果をその部分で更新するようにすることができます。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Similarities Between <code>RefCell&lt;T&gt;</code> / <code>Rc&lt;T&gt;</code> and <code>Mutex&lt;T&gt;</code> / <code>Arc&lt;T&gt;</code></span> <code>RefCell&lt;T&gt;</code> / <code>Rc&lt;T&gt;</code>と<code>Mutex&lt;T&gt;</code> / <code>Arc&lt;T&gt;</code> <code>Mutex&lt;T&gt;</code>との間の類似性は、</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You might have noticed that <code>counter</code> is immutable but we could get a mutable reference to the value inside it;</span>その<code>counter</code>が不変であることに気づいたかもしれませんが、内部の値を変更可能な参照を得ることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">this means <code>Mutex&lt;T&gt;</code> provides interior mutability, as the <code>Cell</code> family does.</span>これは、 <code>Mutex&lt;T&gt;</code>が<code>Cell</code>ファミリのように内部の可変性を提供することを意味します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In the same way we used <code>RefCell&lt;T&gt;</code> in Chapter 15 to allow us to mutate contents inside an <code>Rc&lt;T&gt;</code> , we use <code>Mutex&lt;T&gt;</code> to mutate contents inside an <code>Arc&lt;T&gt;</code> .</span>第15章で<code>RefCell&lt;T&gt;</code>を使って<code>Rc&lt;T&gt;</code>内の内容を変更するのと同じ方法で、 <code>Mutex&lt;T&gt;</code>を使用して<code>Arc&lt;T&gt;</code>内の内容を変更します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Another detail to note is that Rust can&#39;t protect you from all kinds of logic errors when you use <code>Mutex&lt;T&gt;</code> .</span>注意すべきもう一つの細部は、 <code>Mutex&lt;T&gt;</code>を使用すると、Rustはあらゆる種類の論理エラーからあなたを守ることができないということです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Recall in Chapter 15 that using <code>Rc&lt;T&gt;</code> came with the risk of creating reference cycles, where two <code>Rc&lt;T&gt;</code> values refer to each other, causing memory leaks.</span>第15章で<code>Rc&lt;T&gt;</code>を使用すると、2つの<code>Rc&lt;T&gt;</code>値が互いに参照してメモリリークを引き起こす参照サイクルを作成するリスクがあることを思い出してください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Similarly, <code>Mutex&lt;T&gt;</code> comes with the risk of creating <i>deadlocks</i> .</span>同様に、 <code>Mutex&lt;T&gt;</code>は<i>デッドロック</i>を生成する危険性があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These occur when an operation needs to lock two resources and two threads have each acquired one of the locks, causing them to wait for each other forever.</span>これらは、操作が2つのリソースをロックする必要があり、2つのスレッドがそれぞれロックの1つを取得し、互いを永遠に待つときに発生します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you&#39;re interested in deadlocks, try creating a Rust program that has a deadlock;</span>デッドロックに興味がある場合は、デッドロックのあるRustプログラムを作成してみてください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">then research deadlock mitigation strategies for mutexes in any language and have a go at implementing them in Rust.</span> mutexのためのデッドロック軽減戦略をあらゆる言語で研究し、Rustでそれらを実装することに行きます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The standard library API documentation for <code>Mutex&lt;T&gt;</code> and <code>MutexGuard</code> offers useful information.</span> <code>Mutex&lt;T&gt;</code>および<code>MutexGuard</code>の標準ライブラリAPIドキュメントは、有用な情報を提供します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll round out this chapter by talking about the <code>Send</code> and <code>Sync</code> traits and how we can use them with custom types.</span>この章では、 <code>Send</code>と<code>Sync</code>特性について説明し、それらをカスタムタイプで使用する方法について説明します。</span> </p><script>_addload(function(){_setupIW('com');_csi('en','ja','ch16-03-shared-state.html');});</script>