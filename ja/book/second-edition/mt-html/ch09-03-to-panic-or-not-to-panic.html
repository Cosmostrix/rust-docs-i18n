<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180709_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=ch09-03-to-panic-or-not-to-panic.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To <code>panic€</code> or Not to <code>panic€</code></span> <code>panic€</code>か、 <code>panic€</code></span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So how do you decide when you should call <code>panic€</code> and when you should return <code>Result</code> ?</span>だから<code>panic€</code>を呼び出すべき時と、 <code>Result</code>を返すべき時を決める方法は？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When code panics, there&#39;s no way to recover.</span>コードがパニックすると、回復する方法はありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You could call <code>panic€</code> for any error situation, whether there&#39;s a possible way to recover or not, but then you&#39;re making the decision on behalf of the code calling your code that a situation is unrecoverable.</span>復旧の可能性があるかどうかに関わらず、エラー状況については<code>panic€</code>呼び出すことができますが、状況を回復できないコードを呼び出すコードに代わって決定を下しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When you choose to return a <code>Result</code> value, you give the calling code options rather than making the decision for it.</span> <code>Result</code>値を返すことを選択した場合、呼び出しコードオプションの決定を行うのではなく、そのコードオプションを指定します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The calling code could choose to attempt to recover in a way that&#39;s appropriate for its situation, or it could decide that an <code>Err</code> value in this case is unrecoverable, so it can call <code>panic€</code> and turn your recoverable error into an unrecoverable one.</span>呼び出し元のコードは、その状況に応じて適切だ方法で回復しようとすることを選択することができ、またはそれはそれを決めることができました<code>Err</code>それが呼び出すことができるように、この場合の値は、回復不能な<code>panic€</code>し、回復不能一つに、あなたの回復可能なエラーをオンにします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Therefore, returning <code>Result</code> is a good default choice when you&#39;re defining a function that might fail.</span>したがって、失敗する可能性のある関数を定義するときは、 <code>Result</code>返すのが適切なデフォルトの選択です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In rare situations, it&#39;s more appropriate to write code that panics instead of returning a <code>Result</code> .</span>まれな状況では、 <code>Result</code>を返す代わりにパニックするコードを記述する方が適切です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s explore why it&#39;s appropriate to panic in examples, prototype code, and tests.</span>サンプル、プロトタイプコード、テストでなぜパニックになるのが適切かを調べてみましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then we&#39;ll discuss situations in which the compiler can&#39;t tell that failure is impossible, but you as a human can.</span>そして、コンパイラが失敗は不可能だが、あなたは人間として考えることができない状況について話し合う。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The chapter will conclude with some general guidelines on how to decide whether to panic in library code.</span>この章では、ライブラリコードをパニックするかどうかを決定する方法に関する一般的なガイドラインを示します。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Examples, Prototype Code, and Tests</span>例、プロトタイプコード、およびテスト</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When you&#39;re writing an example to illustrate some concept, having robust error-handling code in the example as well can make the example less clear.</span>いくつかの概念を説明するための例を書くときには、この例でも堅牢なエラー処理コードを使用することで、この例をあまり明確にすることはできません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In examples, it&#39;s understood that a call to a method like <code>unwrap</code> that could panic is meant as a placeholder for the way you&#39;d want your application to handle errors, which can differ based on what the rest of your code is doing.</span>例では、 <code>unwrap</code>ようなパニックに陥る可能性のあるメソッドへの呼び出しは、アプリケーションでエラーを処理する方法のプレースホルダーとして意味され、コードの残りの部分に基づいて異なる場合があることが理解されます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Similarly, the <code>unwrap</code> and <code>expect</code> methods are very handy when prototyping, before you&#39;re ready to decide how to handle errors.</span>同様に、 <code>unwrap</code>と<code>expect</code>メソッドはプロトタイプ作成時に非常に便利です。エラーを処理する方法を決める準備が整う前に、</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">They leave clear markers in your code for when you&#39;re ready to make your program more robust.</span>プログラムをより堅牢にする準備ができたら、コードに明瞭なマーカーが残っています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If a method call fails in a test, you&#39;d want the whole test to fail, even if that method isn&#39;t the functionality under test.</span>テストでメソッド呼び出しが失敗した場合、たとえそのメソッドがテスト中の機能ではなくても、テスト全体が失敗することが望まれます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because <code>panic€</code> is how a test is marked as a failure, calling <code>unwrap</code> or <code>expect</code> is exactly what should happen.</span> <code>panic€</code>とは、テストが失敗としてマークされる方法であるため、 <code>unwrap</code>や<code>expect</code>呼び出す<code>expect</code>はまさに何が起こるべきかです。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Cases in Which You Have More Information Than the Compiler</span>あなたがコンパイラより多くの情報を持っている場合</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It would also be appropriate to call <code>unwrap</code> when you have some other logic that ensures the <code>Result</code> will have an <code>Ok</code> value, but the logic isn&#39;t something the compiler understands.</span>また、 <code>Result</code>に<code>Ok</code>値があることを保証する他のロジックがあるときに<code>unwrap</code>を呼び出すのが適切ですが、ロジックはコンパイラが理解できるものではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You&#39;ll still have a <code>Result</code> value that you need to handle: whatever operation you&#39;re calling still has the possibility of failing in general, even though it&#39;s logically impossible in your particular situation.</span>あなたはまだ処理しなければならない<code>Result</code>値を持っています。あなたの特定の状況では論理的に不可能であるにもかかわらず、あなたが呼び出している操作はどれも、一般的には失敗する可能性があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you can ensure by manually inspecting the code that you&#39;ll never have an <code>Err</code> variant, it&#39;s perfectly acceptable to call <code>unwrap</code> .</span> <code>Err</code>バリアントを使用しないコードを手動で検査することで確実にできれば、 <code>unwrap</code>を呼び出すことは完全に受け入れられます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here&#39;s an example:</span>ここに例があります：</span> </p><br><div data-lang=rust><div data-l="use std::net::IpAddr;"></div><div data-l=""></div><div data-l="let home: IpAddr = &quot;127.0.0.1&quot;.parse().unwrap();"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;re creating an <code>IpAddr</code> instance by parsing a hardcoded string.</span>ハードコードされた文字列を解析することによって<code>IpAddr</code>インスタンスを作成して<code>IpAddr</code>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can see that <code>127.0.0.1</code> is a valid IP address, so it&#39;s acceptable to use <code>unwrap</code> here.</span> <code>127.0.0.1</code>が有効なIPアドレスであることがわかります。ここで<code>unwrap</code>を使用しても問題あり<code>unwrap</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, having a hardcoded, valid string doesn&#39;t change the return type of the <code>parse</code> method: we still get a <code>Result</code> value, and the compiler will still make us handle the <code>Result</code> as if the <code>Err</code> variant is a possibility because the compiler isn&#39;t smart enough to see that this string is always a valid IP address.</span>ただし、ハードコードされた有効な文字列を使用しても、 <code>parse</code>メソッドの戻り値の型は変更されません<code>Result</code>値が返されますが、コンパイラは<code>Err</code>バリアントが可能であるかのように<code>Result</code>を処理します。この文字列が常に有効なIPアドレスであることが分かります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If the IP address string came from a user rather than being hardcoded into the program and therefore <i>did</i> have a possibility of failure, we&#39;d definitely want to handle the <code>Result</code> in a more robust way instead.</span> IPアドレスの文字列は、ユーザから来たのではなくプログラムにハードコードされているため、故障の可能性を持って<i>いた</i>場合、我々は間違いなく処理したいと思います<code>Result</code>代わりに、より堅牢な方法で。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Guidelines for Error Handling</span>エラー処理のガイドライン</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It&#39;s advisable to have your code panic when it&#39;s possible that your code could end up in a bad state.</span>コードが悪い状態になる可能性がある場合は、コードパニックを起こすことをお勧めします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this context, a <i>bad state</i> is when some assumption, guarantee, contract, or invariant has been broken, such as when invalid values, contradictory values, or missing values are passed to your code—plus one or more of the following:</span>このコンテキストでは、無効な値、矛盾する値、欠損値がコードに渡されたり、次のうちの1つ以上が発生した場合など、いくつかの前提条件、保証、契約、または不変条件が破られた<i>状態</i>が<i>悪い状態</i>です。</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The bad state is not something that&#39;s <i>expected</i> to happen occasionally.</span>悪い状態は時々起こると<i>思われる</i>ものではありません。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Your code after this point needs to rely on not being in this bad state.</span>この時点以降のコードは、この悪い状態にないことに依存する必要があります。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There&#39;s not a good way to encode this information in the types you use.</span>この情報を使用するタイプでエンコードする良い方法はありません。</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If someone calls your code and passes in values that don&#39;t make sense, the best choice might be to call <code>panic€</code> and alert the person using your library to the bug in their code so they can fix it during development.</span>誰かがあなたのコードを呼び出し、意味をなさない値を渡した場合、最良の選択は<code>panic€</code>を呼び出して、開発中に修正できるように、コード内のバグにライブラリを使用している人に警告することです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Similarly, <code>panic€</code> is often appropriate if you&#39;re calling external code that is out of your control and it returns an invalid state that you have no way of fixing.</span>同様に、あなたのコントロールから外れている外部コードを呼び出していて、あなたが修正する方法がない無効な状態を返す場合、 <code>panic€</code>はしばしば適切です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When a bad state is reached, but it&#39;s expected to happen no matter how well you write your code, it&#39;s still more appropriate to return a <code>Result</code> rather than to make a <code>panic€</code> call.</span>悪い状態になっても、コードを書いても問題は起こりませんが、 <code>panic€</code>通話をするのではなく、 <code>Result</code>を返す方が適切<code>panic€</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Examples include a parser being given malformed data or an HTTP request returning a status that indicates you have hit a rate limit.</span>例としては、不正なデータが与えられたパーサーや、レート制限を超えたことを示すステータスを返すHTTPリクエストなどがあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In these cases, you should indicate that failure is an expected possibility by returning a <code>Result</code> to propagate these bad states upward so the calling code can decide how to handle the problem.</span>このような場合、 <code>Result</code>を返してこれらの不良状態を上方に伝播させ、呼び出しコードが問題の処理方法を決定できるようにすることで、失敗が予想される可能性があることを示す必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To call <code>panic€</code> wouldn&#39;t be the best way to handle these cases.</span> <code>panic€</code>を呼び出すことは、これらのケースを処理する最良の方法ではありません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When your code performs operations on values, your code should verify the values are valid first and panic if the values aren&#39;t valid.</span>コードが値に対して操作を実行するとき、コードは値が有効であることを確認し、値が有効でない場合はパニックにする必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is mostly for safety reasons: attempting to operate on invalid data can expose your code to vulnerabilities.</span>これは主に安全上の理由によるものです。無効なデータを操作しようとすると、コードが脆弱性にさらされる可能性があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is the main reason the standard library will call <code>panic€</code> if you attempt an out-of-bounds memory access: trying to access memory that doesn&#39;t belong to the current data structure is a common security problem.</span>これは、標準ライブラリが境界外のメモリアクセスを試みた場合に<code>panic€</code>を呼び出す主な理由です。現在のデータ構造に属していないメモリにアクセスしようとするのはセキュリティ上の一般的な問題です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Functions often have <i>contracts</i> : their behavior is only guaranteed if the inputs meet particular requirements.</span>関数はしばしば<i>契約を結ぶ</i> 。入力が特定の要件を満たしていれば、その動作は保証される。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Panicking when the contract is violated makes sense because a contract violation always indicates a caller-side bug and it&#39;s not a kind of error you want the calling code to have to explicitly handle.</span>契約違反は常に呼び出し側のバグを示し、呼び出しコードで明示的に処理しなければならない種類のエラーではないため、契約違反時にパニックが発生します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In fact, there&#39;s no reasonable way for calling code to recover;</span>実際、コードを呼び出すための合理的な方法はありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">the calling <i>programmers</i> need to fix the code.</span>呼び出す<i>プログラマ</i>はコードを修正する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Contracts for a function, especially when a violation will cause a panic, should be explained in the API documentation for the function.</span>関数の契約、特に違反がパニックの原因となる場合は、関数のAPIドキュメントで説明する必要があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, having lots of error checks in all of your functions would be verbose and annoying.</span>しかし、すべての機能で多くのエラーチェックを行うと、冗長で迷惑になります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Fortunately, you can use Rust&#39;s type system (and thus the type checking the compiler does) to do many of the checks for you.</span>幸いなことに、Rustの型システム（したがってコンパイラが行う型チェック）を使用して、多くのチェックを行うことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If your function has a particular type as a parameter, you can proceed with your code&#39;s logic knowing that the compiler has already ensured you have a valid value.</span>関数にパラメータとして特定の型がある場合は、コンパイラが有効な値を持つことを既に確認していることを確認して、コードのロジックを進めることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, if you have a type rather than an <code>Option</code> , your program expects to have <i>something</i> rather than <i>nothing</i> .</span>たとえば、 <code>Option</code>ではなくTypeを持つ場合、プログラムは<i>何も</i>持たずに<i>何か</i>を持つ<i>ことを</i>想定しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Your code then doesn&#39;t have to handle two cases for the <code>Some</code> and <code>None</code> variants: it will only have one case for definitely having a value.</span>あなたのコードでは、 <code>Some</code>と<code>None</code> 2つのケースを処理する必要はありません。値を確実に持つケースは1つだけです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Code trying to pass nothing to your function won&#39;t even compile, so your function doesn&#39;t have to check for that case at runtime.</span>あなたの関数に何も渡そうとしないコードはコンパイルされないので、実行時にその関数をチェックする必要はありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Another example is using an unsigned integer type such as <code>u32</code> , which ensures the parameter is never negative.</span>別の例では、パラメータが負でないことを保証する<code>u32</code>などの符号なし整数型を使用しています。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Creating Custom Types for Validation</span>検証のためのカスタム型の作成</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s take the idea of using Rust&#39;s type system to ensure we have a valid value one step further and look at creating a custom type for validation.</span> Rustのタイプシステムを使用して、有効な値をさらに確実に取得し、検証用のカスタムタイプを作成する方法を考えてみましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Recall the guessing game in Chapter 2 in which our code asked the user to guess a number between 1 and 100. We never validated that the user&#39;s guess was between those numbers before checking it against our secret number;</span>第2章の推測ゲームを思い出してください。このコードでは、1から100までの数字を推測するようにユーザーに求めました。私たちは、その数字の間にユーザーの推測があることを確認してから、</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">we only validated that the guess was positive.</span>私たちは、推測が肯定的であることを確認しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this case, the consequences were not very dire: our output of “Too high” or “Too low” would still be correct.</span>この場合、その結果は非常に悲惨ではありませんでした。「高すぎる」または「低すぎる」という結果は依然として正しいでしょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But it would be a useful enhancement to guide the user toward valid guesses and have different behavior when a user guesses a number that&#39;s out of range versus when a user types, for example, letters instead.</span>しかし、ユーザーが正当な推測に向かうのに役立ち、ユーザーが範囲外の数字を推測したときと、ユーザーがたとえば文字を入力したときとでは異なる動作をするのは便利です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">One way to do this would be to parse the guess as an <code>i32</code> instead of only a <code>u32</code> to allow potentially negative numbers, and then add a check for the number being in range, like so:</span>これを行う1つの方法は、負の数を可能にする<code>u32</code>代わりに<code>i32</code>ような推測を解析し、範囲内にある数のチェックを追加することです。</span> </p><br><div data-lang=rust,ignore><div data-l="loop {"></div><div data-l="#    // --snip--"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">--snip--</span> --snip--</span> </div><div data-l=""></div><div data-l="    let guess: i32 = match guess.trim().parse() {"></div><div data-l="        Ok(num) =&gt; num,"></div><div data-l="        Err(_) =&gt; continue,"></div><div data-l="    };"></div><div data-l=""></div><div data-l="    if guess &lt; 1 || guess &gt; 100 {"></div><div data-l="        println!(&quot;The secret number will be between 1 and 100.&quot;);"></div><div data-l="        continue;"></div><div data-l="    }"></div><div data-l=""></div><div data-l="    match guess.cmp(&amp;secret_number) {"></div><div data-l="#    // --snip--"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">--snip--</span> --snip--</span> </div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>if</code> expression checks whether our value is out of range, tells the user about the problem, and calls <code>continue</code> to start the next iteration of the loop and ask for another guess.</span> <code>if</code>式は、値が範囲外であるかどうかをチェックし、問題についてユーザーに通知し、呼び出し<code>continue</code>ループの次の反復を開始し<code>continue</code> 、別の推測を要求します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">After the <code>if</code> expression, we can proceed with the comparisons between <code>guess</code> and the secret number knowing that <code>guess</code> is between 1 and 100.</span> <code>if</code>式の後に、 <code>guess</code>が1と100の間であることを知って、 <code>guess</code>と秘密の数の比較を続行できます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, this is not an ideal solution: if it was absolutely critical that the program only operated on values between 1 and 100, and it had many functions with this requirement, having a check like this in every function would be tedious (and might impact performance).</span>しかし、これは理想的な解決策ではありません。プログラムが1〜100の値でしか動作しないことが絶対に重要で、この要件を持つ多くの機能を持っていれば、このようなチェックをすべての機能に持たせることは面倒ですパフォーマンス）。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Instead, we can make a new type and put the validations in a function to create an instance of the type rather than repeating the validations everywhere.</span>その代わりに、新しい型を作成し、検証をどこにでも繰り返すのではなく、型のインスタンスを作成する関数に入れることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That way, it&#39;s safe for functions to use the new type in their signatures and confidently use the values they receive.</span>そうすれば、関数が新しい型をシグネチャに使用し、受け取った値を確実に使用することは安全です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 9-9 shows one way to define a <code>Guess</code> type that will only create an instance of <code>Guess</code> if the <code>new</code> function receives a value between 1 and 100.</span>リスト9-9は、 <code>new</code>関数が1から100の間の値を受け取った場合にのみ<code>Guess</code>インスタンスを作成する<code>Guess</code>型を定義する1つの方法を示しています。</span> </p><br><div data-lang=rust><div data-l="pub struct Guess {"></div><div data-l="    value: u32,"></div><div data-l=}></div><div data-l=""></div><div data-l="impl Guess {"></div><div data-l="    pub fn new(value: u32) -&gt; Guess {"></div><div data-l="        if value &lt; 1 || value &gt; 100 {"></div><div data-l="            panic!(&quot;Guess value must be between 1 and 100, got {}.&quot;, value);"></div><div data-l="        }"></div><div data-l=""></div><div data-l="        Guess {"></div><div data-l="            value"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=""></div><div data-l="    pub fn value(&amp;self) -&gt; u32 {"></div><div data-l="        self.value"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 9-9: A <code>Guess</code> type that will only continue with values between 1 and 100</span></span> <span class=caption>リスト9-9：1と100の間の値だけを続ける<code>Guess</code>型</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">First, we define a struct named <code>Guess</code> that has a field named <code>value</code> that holds a <code>u32</code> .</span>まず、 <code>u32</code>を保持する<code>value</code>という名前のフィールドを持つ<code>Guess</code>という名前のstructを定義します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is where the number will be stored.</span>これが番号が格納される場所です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then we implement an associated function named <code>new</code> on <code>Guess</code> that creates instances of <code>Guess</code> values.</span>次に<code>Guess</code> <code>new</code>という名前の関連する関数を実装し、 <code>Guess</code>値のインスタンスを作成します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>new</code> function is defined to have one parameter named <code>value</code> of type <code>u32</code> and to return a <code>Guess</code> .</span> <code>new</code>関数は、 <code>u32</code>型の<code>value</code>という名前の1つのパラメータを持ち、 <code>Guess</code> <code>value</code>を返すように定義されています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The code in the body of the <code>new</code> function tests <code>value</code> to make sure it&#39;s between 1 and 100. If <code>value</code> doesn&#39;t pass this test, we make a <code>panic€</code> call, which will alert the programmer who is writing the calling code that they have a bug they need to fix, because creating a <code>Guess</code> with a <code>value</code> outside this range would violate the contract that <code>Guess::new</code> is relying on.</span> <code>new</code>関数の本体にあるコードは、 <code>value</code>が1から100の間であることをテストし<code>value</code> 。 <code>value</code>がこのテストに合格しない場合は、 <code>panic€</code>コールを行い、プログラマーが呼び出したコードを記述していることを警告しますこの範囲外の<code>value</code>で<code>Guess</code>を作成すると、 <code>Guess::new</code>が依存している契約に違反するため、修正する必要があるバグです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The conditions in which <code>Guess::new</code> might panic should be discussed in its public-facing API documentation;</span> <code>Guess::new</code>がパニックに陥る可能性のある条件は、公開されているAPIドキュメントで議論されるべきです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">we&#39;ll cover documentation conventions indicating the possibility of a <code>panic€</code> in the API documentation that you create in Chapter 14. If <code>value</code> does pass the test, we create a new <code>Guess</code> with its <code>value</code> field set to the <code>value</code> parameter and return the <code>Guess</code> .</span>我々は可能性を示す文書の規則取り上げる<code>panic€</code>場合は、第14章で作成するAPIドキュメントの<code>value</code>試験に合格しないと、私たちは新しい作成<code>Guess</code>その持つ<code>value</code>に設定し、フィールド<code>value</code>パラメータをと返し<code>Guess</code> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Next, we implement a method named <code>value</code> that borrows <code>self</code> , doesn&#39;t have any other parameters, and returns a <code>u32</code> .</span>次に、 <code>self</code>を借り、他のパラメータを持たず、 <code>u32</code>を返す<code>value</code>という名前のメソッドを実装します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This kind of method is sometimes called a <i>getter</i> , because its purpose is to get some data from its fields and return it.</span>この種のメソッドは、 <i>getter</i>と呼ばれることもあります。その目的は、フィールドからデータを取得して返すことです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This public method is necessary because the <code>value</code> field of the <code>Guess</code> struct is private.</span> <code>Guess</code>構造体の<code>value</code>フィールドはprivateであるため、このパブリックメソッドは必要です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It&#39;s important that the <code>value</code> field be private so code using the <code>Guess</code> struct is not allowed to set <code>value</code> directly: code outside the module <i>must</i> use the <code>Guess::new</code> function to create an instance of <code>Guess</code> , thereby ensuring there&#39;s no way for a <code>Guess</code> to have a <code>value</code> that hasn&#39;t been checked by the conditions in the <code>Guess::new</code> function.</span>それはすることが重要です<code>value</code>フィールドはプライベートでそう使用してコード<code>Guess</code>構造体を設定することが許可されていない<code>value</code>直接：モジュール外のコードが使用<i>する必要があります</i> <code>Guess::new</code>インスタンスを作成する機能を<code>Guess</code> 、それによってための方法はありません確実に、 <code>Guess</code>には、 <code>Guess::new</code>関数の条件でチェックされていない<code>value</code>があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A function that has a parameter or returns only numbers between 1 and 100 could then declare in its signature that it takes or returns a <code>Guess</code> rather than a <code>u32</code> and wouldn&#39;t need to do any additional checks in its body.</span>パラメータを持つ関数、または1から100の間の数値しか返さない関数は、 <code>u32</code>ではなく、 <code>Guess</code> <code>u32</code>か返すというシグネチャを宣言し、その本体で追加のチェックを行う必要はありません。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Summary</span>概要</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust&#39;s error handling features are designed to help you write more robust code.</span> Rustのエラー処理機能は、より堅牢なコードを書くのに役立つように設計されています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>panic€</code> macro signals that your program is in a state it can&#39;t handle and lets you tell the process to stop instead of trying to proceed with invalid or incorrect values.</span> <code>panic€</code>マクロは、プログラムが処理できない状態にあることを知らせ、無効または間違った値で処理するのではなくプロセスを停止するように指示します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Result</code> enum uses Rust&#39;s type system to indicate that operations might fail in a way that your code could recover from.</span> <code>Result</code> enumは、Rustの型システムを使用して、コードが回復する方法で操作が失敗する可能性があることを示します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can use <code>Result</code> to tell code that calls your code that it needs to handle potential success or failure as well.</span> <code>Result</code>を使用してコードを呼び出すコードに、潜在的な成功または失敗を処理する必要があることを伝えることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Using <code>panic€</code> and <code>Result</code> in the appropriate situations will make your code more reliable in the face of inevitable problems.</span>使用して<code>panic€</code>と<code>Result</code>適切な状況では、避けられない問題に直面してあなたのコードはより信頼性の高いようになります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now that you&#39;ve seen useful ways that the standard library uses generics with the <code>Option</code> and <code>Result</code> enums, we&#39;ll talk about how generics work and how you can use them in your code.</span>標準ライブラリが<code>Option</code>と<code>Result</code>列挙型でジェネリックスを使用する便利な方法を見てきたので、ジェネリックの仕組みとコードでの使用方法について説明します。</span> </p><script>_addload(function(){_setupIW('com');_csi('en','ja','ch09-03-to-panic-or-not-to-panic.html');});</script>