<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180709_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=ch08-01-vectors.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Storing Lists of Values with Vectors</span>ベクトルによる値のリストの格納</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The first collection type we&#39;ll look at is <code>Vec&lt;T&gt;</code> , also known as a <i>vector</i> .</span>最初に<code>Vec&lt;T&gt;</code>コレクションの種類は<code>Vec&lt;T&gt;</code>で、 <i>ベクトル</i>とも呼ばれます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Vectors allow you to store more than one value in a single data structure that puts all the values next to each other in memory.</span>ベクトルを使用すると、複数の値を1つのデータ構造体に格納して、すべての値を互いに隣り合うメモリに格納することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Vectors can only store values of the same type.</span>ベクトルには同じ型の値しか格納できません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">They are useful when you have a list of items, such as the lines of text in a file or the prices of items in a shopping cart.</span>ファイル内のテキスト行やショッピングカート内のアイテムの価格など、アイテムのリストがある場合に便利です。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Creating a New Vector</span>新しいベクターの作成</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To create a new, empty vector, we can call the <code>Vec::new</code> function, as shown in Listing 8-1.</span>新しい空ベクトルを作成するには、リスト8-1に示すように<code>Vec::new</code>関数を呼び出すことができます。</span> </p><br><div data-lang=rust><div data-l="let v: Vec&lt;i32&gt; = Vec::new();"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 8-1: Creating a new, empty vector to hold values of type <code>i32</code></span></span> <span class=caption>リスト8-1：タイプ<code>i32</code>値を保持する新しい空のベクトルの作成</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that we added a type annotation here.</span>タイプ注釈をここに追加したことに注意してください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because we aren&#39;t inserting any values into this vector, Rust doesn&#39;t know what kind of elements we intend to store.</span>このベクトルに値を挿入しないため、Rustは格納する要素の種類を知らない。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is an important point.</span>これは重要なポイントです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Vectors are implemented using generics;</span>ベクトルはジェネリックを使用して実装されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">we&#39;ll cover how to use generics with your own types in Chapter 10. For now, know that the <code>Vec&lt;T&gt;</code> type provided by the standard library can hold any type, and when a specific vector holds a specific type, the type is specified within angle brackets.</span>第10章で独自の型でジェネリックを使用する方法について説明します。今のところ、標準ライブラリによって提供される<code>Vec&lt;T&gt;</code>型は任意の型を保持でき、特定の型が特定の型を保持する場合、型は山括弧で囲んで指定します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In Listing 8-1, we&#39;ve told Rust that the <code>Vec&lt;T&gt;</code> in <code>v</code> will hold elements of the <code>i32</code> type.</span>リスト8-1では、我々は錆言った<code>Vec&lt;T&gt;</code>で<code>v</code>の要素を保持する<code>i32</code>タイプを。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In more realistic code, Rust can often infer the type of value you want to store once you insert values, so you rarely need to do this type annotation.</span>もっと現実的なコードでは、Rustは一度値を挿入すると保存したい値の型を推論することができるので、この型の注釈を行う必要はほとんどありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It&#39;s more common to create a <code>Vec&lt;T&gt;</code> that has initial values, and Rust provides the <code>vec€</code> macro for convenience.</span>初期値を持つ<code>Vec&lt;T&gt;</code>を作成する方が一般的<code>vec€</code> .Rustは便宜上<code>vec€</code>マクロを提供します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The macro will create a new vector that holds the values you give it.</span>マクロは、与えた値を保持する新しいベクトルを作成します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 8-2 creates a new <code>Vec&lt;i32&gt;</code> that holds the values <code>1</code> , <code>2</code> , and <code>3</code> .</span> 8-2のリストに新しい作成<code>Vec&lt;i32&gt;</code>の値を保持<code>1</code> 、 <code>2</code> 、および<code>3</code> 。</span> </p><br><div data-lang=rust><div data-l="let v = vec![1, 2, 3];"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 8-2: Creating a new vector containing values</span></span> <span class=caption>リスト8-2：値を含む新しいベクトルを作成する</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because we&#39;ve given initial <code>i32</code> values, Rust can infer that the type of <code>v</code> is <code>Vec&lt;i32&gt;</code> , and the type annotation isn&#39;t necessary.</span>最初の<code>i32</code>値を与えたので、Rustは<code>v</code>の型が<code>Vec&lt;i32&gt;</code>であると推測でき、型注釈は必要ありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Next, we&#39;ll look at how to modify a vector.</span>次に、ベクトルを変更する方法を見ていきます。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Updating a Vector</span>ベクターの更新</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To create a vector and then add elements to it, we can use the <code>push</code> method, as shown in Listing 8-3.</span>ベクトルを作成して要素を追加するには、リスト8-3に示すように<code>push</code>メソッドを使用します。</span> </p><br><div data-lang=rust><div data-l="let mut v = Vec::new();"></div><div data-l=""></div><div data-l=v.push(5);></div><div data-l=v.push(6);></div><div data-l=v.push(7);></div><div data-l=v.push(8);></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 8-3: Using the <code>push</code> method to add values to a vector</span></span> <span class=caption>リスト8-3： <code>push</code>メソッドを使ってベクトルに値を追加する</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As with any variable, if we want to be able to change its value, we need to make it mutable using the <code>mut</code> keyword, as discussed in Chapter 3. The numbers we place inside are all of type <code>i32</code> , and Rust infers this from the data, so we don&#39;t need the <code>Vec&lt;i32&gt;</code> annotation.</span>変数と同様に、値を変更できるようにするには、第3章で説明した<code>mut</code>キーワードを使用してmutableを変更可能にする必要があります。内部に配置する数字はすべて<code>i32</code>型で、Rustは<code>Vec&lt;i32&gt;</code>注釈は必要ありません。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Dropping a Vector Drops Its Elements</span>ベクターを削除するとその要素が削除される</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Like any other <code>struct</code> , a vector is freed when it goes out of scope, as annotated in Listing 8-4.</span>他の<code>struct</code>と同様に、リスト8-4に示すように、ベクトルが範囲外になると解放されます。</span> </p><br><div data-lang=rust><div data-l={></div><div data-l="    let v = vec![1, 2, 3, 4];"></div><div data-l=""></div><div data-l="#    // do stuff with v"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">do stuff with v</span> vと一緒にやる</span> </div><div data-l=""></div><div data-l="#//} // &lt;- v goes out of scope and is freed here"></div><div data-l="} // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">&lt;- v goes out of scope and is freed here</span> &lt; -  vは範囲外になり、ここで解放されます</span> </div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 8-4: Showing where the vector and its elements are dropped</span></span> <span class=caption>リスト8-4：ベクトルとその要素がどこにドロップされたかを示す</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When the vector gets dropped, all of its contents are also dropped, meaning those integers it holds will be cleaned up.</span>ベクタが削除されると、その内容もすべて削除されます。つまり、保持している整数はクリーンアップされます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This may seem like a straightforward point but can get a bit more complicated when you start to introduce references to the elements of the vector.</span>これは簡単な点のように思えるかもしれませんが、ベクトルの要素への参照を導入するときに少し複雑になることがあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s tackle that next!</span>次はそれに取り組んでみましょう！</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Reading Elements of Vectors</span>ベクトルの要素を読む</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now that you know how to create, update, and destroy vectors, knowing how to read their contents is a good next step.</span>ベクトルを作成、更新、破棄する方法を知ったので、内容を読む方法を知っておくことは、次の良いステップです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There are two ways to reference a value stored in a vector.</span>ベクトルに格納された値を参照するには、2つの方法があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In the examples, we&#39;ve annotated the types of the values that are returned from these functions for extra clarity.</span>例では、わかりやすくするために、これらの関数から返される値の型に注釈を付けました。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 8-5 shows both methods of accessing a value in a vector, either with indexing syntax or the <code>get</code> method.</span>コードリスト8-5に、インデックス構文または<code>get</code>メソッドを使用してベクトルの値にアクセスする両方のメソッドを示します。</span> </p><br><div data-lang=rust><div data-l="let v = vec![1, 2, 3, 4, 5];"></div><div data-l=""></div><div data-l="let third: &amp;i32 = &amp;v[2];"></div><div data-l="let third: Option&lt;&amp;i32&gt; = v.get(2);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 8-5: Using indexing syntax or the <code>get</code> method to access an item in a vector</span></span> <span class=caption>コードリスト8-5：索引付け構文または<code>get</code>メソッドを使用してベクトル内の項目にアクセスする</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note two details here.</span>ここで2つの詳細を注意してください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">First, we use the index value of <code>2</code> to get the third element: vectors are indexed by number, starting at zero.</span>最初に、インデックス値<code>2</code>を使用して3番目の要素を取得します。ベクトルはゼロから始まる番号でインデックス付けされます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Second, the two ways to get the third element are by using <code>&amp;</code> and <code>[]</code> , which gives us a reference, or by using the <code>get</code> method with the index passed as an argument, which gives us an <code>Option&lt;&amp;T&gt;</code> .</span>次に、3番目の要素を取得する2つの方法は、 <code>&amp;</code>と<code>[]</code>を使用して参照を与えたり、インデックスとして引数を渡した<code>get</code>メソッドを使用して、 <code>Option&lt;&amp;T&gt;</code>を与えます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust has two ways to reference an element so you can choose how the program behaves when you try to use an index value that the vector doesn&#39;t have an element for.</span> Rustには要素を参照する2つの方法がありますので、ベクトルが要素を持たないインデックス値を使用しようとしたときにプログラムがどのように動作するかを選択できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As an example, let&#39;s see what a program will do if it has a vector that holds five elements and then tries to access an element at index 100, as shown in Listing 8-6.</span>例として、リスト8-6に示すように、プログラムが5つの要素を保持し、次にインデックス100の要素にアクセスしようとするベクトルを持つ場合、プログラムが何をするかを見てみましょう。</span> </p><br><div data-lang=rust,should_panic><div data-l="let v = vec![1, 2, 3, 4, 5];"></div><div data-l=""></div><div data-l="let does_not_exist = &amp;v[100];"></div><div data-l="let does_not_exist = v.get(100);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 8-6: Attempting to access the element at index 100 in a vector containing five elements</span></span> <span class=caption>リスト8-6：5つの要素を含むベクトルのインデックス100の要素にアクセスしようとする</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When we run this code, the first <code>[]</code> method will cause the program to panic because it references a nonexistent element.</span>このコードを実行すると、存在しない要素を参照するため、最初の<code>[]</code>メソッドはプログラムにパニックを引き起こします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This method is best used when you want your program to crash if there&#39;s an attempt to access an element past the end of the vector.</span>このメソッドは、ベクトルの最後を過ぎた要素にアクセスしようとするとプログラムがクラッシュするようにしたいときに最適です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When the <code>get</code> method is passed an index that is outside the vector, it returns <code>None</code> without panicking.</span> <code>get</code>メソッドがベクトルの外側にあるインデックスを渡すと、パニックを起こさずに<code>None</code>を返します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You would use this method if accessing an element beyond the range of the vector happens occasionally under normal circumstances.</span>通常の状況下で時々起こるベクタの範囲を超えた要素にアクセスする場合は、このメソッドを使用します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Your code will then have logic to handle having either <code>Some(&amp;element)</code> or <code>None</code> , as discussed in Chapter 6. For example, the index could be coming from a person entering a number.</span>あなたのコードには、第6章で説明したように、 <code>Some(&amp;element)</code>または<code>None</code>いずれかを扱うロジックがあります。たとえば、数字を入力した人が索引を作成している可能性があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If they accidentally enter a number that&#39;s too large and the program gets a <code>None</code> value, you could tell the user how many items are in the current vector and give them another chance to enter a valid value.</span>誤って大きすぎる数値を入力し、プログラムが<code>None</code>値を取得した場合、現在のベクトルにあるアイテムの数をユーザーに通知し、有効な値を入力する別の機会を与えることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That would be more user-friendly than crashing the program due to a typo!</span>これは、タイプミスのためにプログラムをクラッシュさせるよりもユーザーフレンドリーになります！</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When the program has a valid reference, the borrow checker enforces the ownership and borrowing rules (covered in Chapter 4) to ensure this reference and any other references to the contents of the vector remain valid.</span>プログラムに有効な参照がある場合、貸借チェッカーは所有権と借用の規則（第4章で説明）を強制して、この参照とベクトルの内容への他の参照が有効であることを保証します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Recall the rule that states you can&#39;t have mutable and immutable references in the same scope.</span>変更可能な不変の参照を同じスコープ内に持つことはできないというルールを思い出してください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That rule applies in Listing 8-7, where we hold an immutable reference to the first element in a vector and try to add an element to the end, which won&#39;t work.</span>このルールはリスト8-7に当てはまります。ここでは、ベクトルの最初の要素への不変参照を保持し、最後に要素を追加しようとしますが、これはうまくいきません。</span> </p><br><div data-lang=rust,ignore><div data-l="let mut v = vec![1, 2, 3, 4, 5];"></div><div data-l=""></div><div data-l="let first = &amp;v[0];"></div><div data-l=""></div><div data-l=v.push(6);></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 8-7: Attempting to add an element to a vector while holding a reference to an item</span></span> <span class=caption>リスト8-7：アイテムへの参照を保持しながらベクターに要素を追加しようとする</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Compiling this code will result in this error:</span>このコードをコンパイルすると、このエラーが発生します。</span> </p><br><div data-lang=text><div data-l="error[E0502]: cannot borrow `v` as mutable because it is also borrowed as immutable"></div><div data-l=" --&gt;"></div><div data-l="  |"></div><div data-l="4 |     let first = &amp;v[0];"></div><div data-l="  |                  - immutable borrow occurs here"></div><div data-l="5 |"></div><div data-l="6 |     v.push(6);"></div><div data-l="  |     ^ mutable borrow occurs here"></div><div data-l="7 |"></div><div data-l="8 | }"></div><div data-l="  | - immutable borrow ends here"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The code in Listing 8-7 might look like it should work: why should a reference to the first element care about what changes at the end of the vector?</span>コードリスト8-7のコードは、うまくいくように見えるかもしれません：なぜ、最初の要素への参照は、ベクトルの最後に何が変わるかを気にする必要がありますか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This error is due to the way vectors work: adding a new element onto the end of the vector might require allocating new memory and copying the old elements to the new space, if there isn&#39;t enough room to put all the elements next to each other where the vector currently is.</span>このエラーはベクトルの仕組みに起因しています。ベクトルの最後に新しい要素を追加すると、新しいメモリを割り当て、古い要素を新しい空間にコピーする必要があります。ベクトルが現在どこにあるか。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In that case, the reference to the first element would be pointing to deallocated memory.</span>その場合、最初の要素への参照は解放されたメモリを指しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The borrowing rules prevent programs from ending up in that situation.</span>借用ルールは、プログラムがその状況で終わるのを防ぎます。</span> </p><br><blockquote><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note: For more on the implementation details of the <code>Vec&lt;T&gt;</code> type, see “The Rustonomicon” at https://doc.rust-lang.org/stable/nomicon/vec.html.</span>注： <code>Vec&lt;T&gt;</code>型の実装の詳細については、https://doc.rust-lang.org/stable/nomicon/vec.htmlの「The Rustonomicon」を参照してください。</span> </p></blockquote><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Iterating over the Values in a Vector</span>ベクトルの値を反復する</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we want to access each element in a vector in turn, we can iterate through all of the elements rather than use indexes to access one at a time.</span>ベクトルの各要素に順番にアクセスしたい場合は、インデックスを使用して一度に1つずつアクセスするのではなく、すべての要素を繰り返し処理できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 8-8 shows how to use a <code>for</code> loop to get immutable references to each element in a vector of <code>i32</code> values and print them.</span>リスト8-8は<code>for</code>ループを使って、 <code>i32</code>値のベクトルの各要素への不変参照を取得して出力する方法を示しています。</span> </p><br><div data-lang=rust><div data-l="let v = vec![100, 32, 57];"></div><div data-l="for i in &amp;v {"></div><div data-l="    println!(&quot;{}&quot;, i);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 8-8: Printing each element in a vector by iterating over the elements using a <code>for</code> loop</span></span> <span class=caption>リスト8-8： <code>for</code>ループを使って要素を反復処理することにより、ベクトルの各要素を出力する</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can also iterate over mutable references to each element in a mutable vector in order to make changes to all the elements.</span>また、すべての要素を変更するために、変更可能なベクトル内の各要素への可変参照を反復処理することもできます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>for</code> loop in Listing 8-9 will add <code>50</code> to each element.</span>リスト8-9の<code>for</code>ループは各要素に<code>50</code>を追加します。</span> </p><br><div data-lang=rust><div data-l="let mut v = vec![100, 32, 57];"></div><div data-l="for i in &amp;mut v {"></div><div data-l="    *i += 50;"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 8-9: Iterating over mutable references to elements in a vector</span></span> <span class=caption>リスト8-9：ベクトル内の要素への可変参照の反復</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To change the value that the mutable reference refers to, we have to use the dereference operator ( <code>*</code> ) to get to the value in <code>i</code> before we can use the <code>+=</code> operator .</span>変更可能な参照が参照する値を変更するには、逆参照演算子（ <code>*</code> ）を使用して<code>+=</code>演算子を使用する前に<code>i</code>の値を取得する必要があります。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Using an Enum to Store Multiple Types</span>列挙型を使用して複数の型を格納する</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">At the beginning of this chapter, we said that vectors can only store values that are the same type.</span>この章の冒頭では、ベクトルには同じ型の値しか格納できないと述べました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This can be inconvenient;</span>これは不便なことがあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">there are definitely use cases for needing to store a list of items of different types.</span>異なるタイプのアイテムのリストを格納する必要があることは間違いありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Fortunately, the variants of an enum are defined under the same enum type, so when we need to store elements of a different type in a vector, we can define and use an enum!</span>幸いにも、列挙型の変種は同じ列挙型で定義されているので、異なる型の要素をベクトルに格納する必要があるときは、列挙型を定義して使用することができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, say we want to get values from a row in a spreadsheet in which some of the columns in the row contain integers, some floating-point numbers, and some strings.</span>たとえば、行の一部の列に整数、浮動小数点数、および一部の文字列が含まれているスプレッドシートの行から値を取得するとします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can define an enum whose variants will hold the different value types, and then all the enum variants will be considered the same type: that of the enum.</span>バリアントが異なる値の型を保持する列挙型を定義できます。次に、すべての列挙型が同じ型とみなされます。列挙型の型とみなされます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then we can create a vector that holds that enum and so, ultimately, holds different types.</span>その列挙型を保持するベクトルを作成し、最終的には異なる型を保持することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ve demonstrated this in Listing 8-10.</span>リスト8-10でこれを実証しました。</span> </p><br><div data-lang=rust><div data-l="enum SpreadsheetCell {"></div><div data-l="    Int(i32),"></div><div data-l="    Float(f64),"></div><div data-l="    Text(String),"></div><div data-l=}></div><div data-l=""></div><div data-l="let row = vec!["></div><div data-l="    SpreadsheetCell::Int(3),"></div><div data-l="    SpreadsheetCell::Text(String::from(&quot;blue&quot;)),"></div><div data-l="    SpreadsheetCell::Float(10.12),"></div><div data-l=];></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 8-10: Defining an <code>enum</code> to store values of different types in one vector</span></span> <span class=caption>リスト8-10：1つのベクトルに異なる型の値を格納するための<code>enum</code>型の定義</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust needs to know what types will be in the vector at compile time so it knows exactly how much memory on the heap will be needed to store each element.</span> Rustは、コンパイル時にどの型がベクタに含まれるかを知る必要があるため、各要素を格納するためにヒープ上のメモリの量が正確に分かります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A secondary advantage is that we can be explicit about what types are allowed in this vector.</span> 2番目の利点は、このベクトルでどのような型が許可されているかを明示できることです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If Rust allowed a vector to hold any type, there would be a chance that one or more of the types would cause errors with the operations performed on the elements of the vector.</span> Rustがベクタの型を保持できる場合、ベクタの要素に対して実行される操作で1つ以上の型がエラーを引き起こす可能性があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Using an enum plus a <code>match</code> expression means that Rust will ensure at compile time that every possible case is handled, as discussed in Chapter 6.</span>列挙型と<code>match</code>式を使用すると、第6章で説明するように、Rustはコンパイル時に可能なすべてのケースが処理されることを保証します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When you&#39;re writing a program, if you don&#39;t know the exhaustive set of types the program will get at runtime to store in a vector, the enum technique won&#39;t work.</span>プログラムを書くときに、プログラムが実行時にベクトルに格納されるタイプの完全な型がわからない場合、enum技法は機能しません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Instead, you can use a trait object, which we&#39;ll cover in Chapter 17.</span>代わりに、第17章で説明する特性オブジェクトを使用することができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now that we&#39;ve discussed some of the most common ways to use vectors, be sure to review the API documentation for all the many useful methods defined on <code>Vec&lt;T&gt;</code> by the standard library.</span>ベクトルを使用する最も一般的な方法のいくつかについて説明したので、標準ライブラリで<code>Vec&lt;T&gt;</code>定義されている多くの便利なメソッドのAPIドキュメントを確認してください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, in addition to <code>push</code> , a <code>pop</code> method removes and returns the last element.</span>たとえば、 <code>push</code>に加えて、 <code>pop</code>メソッドは最後の要素を削除して返します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s move on to the next collection type: <code>String</code> !</span>次のコレクションタイプに移りましょう： <code>String</code> ！</span> </p><script>_addload(function(){_setupIW('com');_csi('en','ja','ch08-01-vectors.html');});</script>