<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180709_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=ch20-02-multithreaded.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Turning Our Single-Threaded Server into a Multithreaded Server</span>シングルスレッドサーバをマルチスレッドサーバにする</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Right now, the server will process each request in turn, meaning it won&#39;t process a second connection until the first is finished processing.</span>今、サーバーは各要求を順番に処理します。つまり、最初の処理が完了するまで2番目の接続を処理しません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If the server received more and more requests, this serial execution would be less and less optimal.</span>サーバがますます多くのリクエストを受信した場合、このシリアル実行は、それほど最適ではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If the server receives a request that takes a long time to process, subsequent requests will have to wait until the long request is finished, even if the new requests can be processed quickly.</span>サーバーが処理に時間がかかる要求を受信した場合、新しい要求を迅速に処理できる場合でも、後続の要求は長い要求が完了するまで待機する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll need to fix this, but first, we&#39;ll look at the problem in action.</span>これを修正する必要がありますが、最初に実際の問題を見ていきます。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Simulating a Slow Request in the Current Server Implementation</span>現在のサーバー実装で低速要求をシミュレートする</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll look at how a slow-processing request can affect other requests made to our current server implementation.</span>処理の遅いリクエストが、現在のサーバー実装に対する他のリクエストにどのように影響するかを見ていきます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 20-10 implements handling a request to <i>/sleep</i> with a simulated slow response that will cause the server to sleep for 5 seconds before responding.</span>リスト20-10は、 <i>/</i> sleptへのリクエストの処理をシミュレートした低速レスポンスで実装しています。これにより、サーバーは応答する前に5秒間スリープします。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="use std::thread;"></div><div data-l="use std::time::Duration;"></div><div data-l="# use std::io::prelude::*;"></div><div data-l="# use std::net::TcpStream;"></div><div data-l="# use std::fs::File;"></div><div data-l="#// --snip--"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">--snip--</span> --snip--</span> </div><div data-l=""></div><div data-l="fn handle_connection(mut stream: TcpStream) {"></div><div data-l="#     let mut buffer = [0; 512];"></div><div data-l="#     stream.read(&amp;mut buffer).unwrap();"></div><div data-l="#    // --snip--"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">--snip--</span> --snip--</span> </div><div data-l=""></div><div data-l="    let get = b&quot;GET / HTTP/1.1\r\n&quot;;"></div><div data-l="    let sleep = b&quot;GET /sleep HTTP/1.1\r\n&quot;;"></div><div data-l=""></div><div data-l="    let (status_line, filename) = if buffer.starts_with(get) {"></div><div data-l="        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)"></div><div data-l="    } else if buffer.starts_with(sleep) {"></div><div data-l="        thread::sleep(Duration::from_secs(5));"></div><div data-l="        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)"></div><div data-l="    } else {"></div><div data-l="        (&quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;, &quot;404.html&quot;)"></div><div data-l="    };"></div><div data-l=""></div><div data-l="#    // --snip--"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">--snip--</span> --snip--</span> </div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 20-10: Simulating a slow request by recognizing <i>/sleep</i> and sleeping for 5 seconds</span></span> <span class=caption>リスト20-10：5秒間の認識と<i>スリープ</i>と<i>スリープ</i>による低速要求のシミュレーション</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This code is a bit messy, but it&#39;s good enough for simulation purposes.</span>このコードはちょっと面倒ですが、シミュレーション目的で十分です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We created a second request <code>sleep</code> , whose data our server recognizes.</span>私たちは、サーバが認識するデータを持つ2番目のリクエスト<code>sleep</code>を作成しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We added an <code>else if</code> after the <code>if</code> block to check for the request to <i>/sleep</i> .</span> <code>if</code>ブロックの後に<code>else if</code>を追加して、 <i>/ sleep</i>へのリクエストを確認しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When that request is received, the server will sleep for 5 seconds before rendering the successful HTML page.</span>その要求を受け取ると、サーバーは5秒間スリープしてからHTMLページが正常に表示されます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can see how primitive our server is: real libraries would handle the recognition of multiple requests in a much less verbose way!</span>私たちのサーバはどれほどプリミティブなのかを見ることができます。実際のライブラリは、あまり冗長ではない複数のリクエストの認識を処理します！</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Start the server using <code>cargo run</code> .</span>使用してサーバを起動し<code>cargo run</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then open two browser windows: one for <i>http://127.0.0.1:7878/</i> and the other for <i>http://127.0.0.1:7878/sleep</i> .</span>次に、2つのブラウザウィンドウを開き<i>ます</i> .1つは<i>http://127.0.0.1:7878/</i> 、もう1つは<i>http://127.0.0.1:7878/sleep</i>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you enter the <i>/</i> URI a few times, as before, you&#39;ll see it respond quickly.</span>以前と同じように<i>/</i> URIを数回入力すると、すぐに応答することがわかります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But if you enter <i>/sleep</i> and then load <i>/</i> , you&#39;ll see that <i>/</i> waits until <code>sleep</code> has slept for its full 5 seconds before loading.</span>あなたが<i>/スリープ</i>してからロード<i>/を</i>入力した場合しかし、あなたはまで待機<i>/</i>ことがわかります<code>sleep</code>ロードする前にその完全な5秒間眠っています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There are multiple ways we could change how our web server works to avoid having more requests back up behind a slow request;</span>遅い要求の後ろにもっと多くの要求が戻ってくることを避けるためにWebサーバーの仕組みを変更する方法はいくつかあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">the one we&#39;ll implement is a thread pool.</span>私たちが実装するのはスレッドプールです。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Improving Throughput with a Thread Pool</span>スレッドプールによるスループットの向上</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A <i>thread pool</i> is a group of spawned threads that are waiting and ready to handle a task.</span> <i>スレッドプール</i>は、待機中でタスクを処理する準備ができている、生成されたスレッドのグループです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When the program receives a new task, it assigns one of the threads in the pool to the task, and that thread will process the task.</span>プログラムは新しいタスクを受け取ると、プール内のスレッドの1つをタスクに割り当て、そのスレッドがそのタスクを処理します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The remaining threads in the pool are available to handle any other tasks that come in while the first thread is processing.</span>プール内の残りのスレッドは、最初のスレッドが処理中に入ってくる他のタスクを処理するために使用できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When the first thread is done processing its task, it&#39;s returned to the pool of idle threads, ready to handle a new task.</span>最初のスレッドがそのタスクの処理を完了すると、スレッドはアイドル状態のスレッドのプールに戻され、新しいタスクを処理できる状態になります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A thread pool allows you to process connections concurrently, increasing the throughput of your server.</span>スレッドプールを使用すると、接続を同時に処理できるため、サーバーのスループットが向上します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll limit the number of threads in the pool to a small number to protect us from Denial of Service (DoS) attacks;</span>私たちは、サービス拒否（DoS）攻撃から私たちを守るために、プール内のスレッドの数を少数に制限します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">if we had our program create a new thread for each request as it came in, someone making 10 million requests to our server could create havoc by using up all our server&#39;s resources and grinding the processing of requests to a halt.</span>プログラムが入ってくるごとにリクエストごとに新しいスレッドを作成した場合、サーバーに1000万回のリクエストを行う人は、サーバーのすべてのリソースを使い切り、要求の処理を中断することによって混乱を招く可能性があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rather than spawning unlimited threads, we&#39;ll have a fixed number of threads waiting in the pool.</span>無限のスレッドを生成するのではなく、プール内で一定数のスレッドを待機させます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As requests come in, they&#39;ll be sent to the pool for processing.</span>リクエストが入ると、リクエストがプールに送られて処理されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The pool will maintain a queue of incoming requests.</span>プールは着信要求のキューを維持します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Each of the threads in the pool will pop off a request from this queue, handle the request, and then ask the queue for another request.</span>プール内の各スレッドは、このキューからの要求をポップアウトし、要求を処理してから、キューに別の要求を要求します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">With this design, we can process <code>N</code> requests concurrently, where <code>N</code> is the number of threads.</span>この設計では、 <code>N</code>要求を同時に処理することができます。ここで、 <code>N</code>はスレッドの数です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If each thread is responding to a long-running request, subsequent requests can still back up in the queue, but we&#39;ve increased the number of long-running requests we can handle before reaching that point.</span>各スレッドが長時間実行している要求に応答していれば、それ以降の要求はキューにバックアップされますが、その時点までに処理できる長時間実行される要求の数が増えました。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This technique is just one of many ways to improve the throughput of a web server.</span>この手法は、Webサーバーのスループットを改善する多くの方法の1つに過ぎません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Other options you might explore are the fork/join model and the single-threaded async I/O model.</span>探索できるその他のオプションは、フォーク/結合モデルとシングルスレッド非同期I / Oモデルです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you&#39;re interested in this topic, you can read more about other solutions and try to implement them in Rust;</span>このトピックに興味がある場合は、他のソリューションの詳細を読んで、Rustでそれらを実装しようとすることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">with a low-level language like Rust, all of these options are possible.</span> Rustのような低レベルの言語では、これらのオプションはすべて可能です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Before we begin implementing a thread pool, let&#39;s talk about what using the pool should look like.</span>スレッドプールの実装を開始する前に、プールの使用方法について説明しましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When you&#39;re trying to design code, writing the client interface first can help guide your design.</span>コードを設計しようとするときは、最初にクライアントインターフェイスを記述することで、設計を手助けすることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Write the API of the code so it&#39;s structured in the way you want to call it;</span>コードのAPIを記述して、それを呼び出したい方法で構造化します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">then implement the functionality within that structure rather than implementing the functionality and then designing the public API.</span>機能を実装してパブリックAPIを設計するのではなく、その構造内の機能を実装します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Similar to how we used test-driven development in the project in Chapter 12, we&#39;ll use compiler-driven development here.</span>第12章のプロジェクトでテスト駆動型開発を使用したのと同様に、ここではコンパイラ主導の開発を使用します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll write the code that calls the functions we want, and then we&#39;ll look at errors from the compiler to determine what we should change next to get the code to work.</span>私たちが望む関数を呼び出すコードを書いてから、コンパイラからのエラーを見て、コードを動作させるために次に変更すべきものを決定します。</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Code Structure If We Could Spawn a Thread for Each Request</span>リクエストごとにスレッドを生成できる場合のコード構造</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">First, let&#39;s explore how our code might look if it did create a new thread for every connection.</span>まず、すべての接続に対して新しいスレッドを作成した場合のコードの外観を調べてみましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As mentioned earlier, this isn&#39;t our final plan due to the problems with potentially spawning an unlimited number of threads, but it is a starting point.</span>前述したように、スレッドの数に制限はありませんが、これは最終的な計画ではありませんが、これは出発点です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 20-11 shows the changes to make to <code>main</code> to spawn a new thread to handle each stream within the <code>for</code> loop.</span>リスト20-11は、 <code>for</code>ループ内の各ストリームを処理するための新しいスレッドを生成するための、 <code>main</code>への変更を示しています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust,no_run><div data-l="# use std::thread;"></div><div data-l="# use std::io::prelude::*;"></div><div data-l="# use std::net::TcpListener;"></div><div data-l="# use std::net::TcpStream;"></div><div data-l=#></div><div data-l="fn main() {"></div><div data-l="    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();"></div><div data-l=""></div><div data-l="    for stream in listener.incoming() {"></div><div data-l="        let stream = stream.unwrap();"></div><div data-l=""></div><div data-l="        thread::spawn(|| {"></div><div data-l="            handle_connection(stream);"></div><div data-l="        });"></div><div data-l="    }"></div><div data-l=}></div><div data-l="# fn handle_connection(mut stream: TcpStream) {}"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 20-11: Spawning a new thread for each stream</span></span> <span class=caption>リスト20-11：ストリームごとに新しいスレッドを生成する</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As you learned in Chapter 16, <code>thread::spawn</code> will create a new thread and then run the code in the closure in the new thread.</span>第16章で学んだように、 <code>thread::spawn</code>は新しいスレッドを作成し、新しいスレッドのクロージャでコードを実行します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you run this code and load <i>/sleep</i> in your browser, then <i>/</i> in two more browser tabs, you&#39;ll indeed see that the requests to <i>/</i> don&#39;t have to wait for <i>/sleep</i> to finish.</span>あなたがお使いのブラウザでこのコードとロード<i>/スリープを</i>実行すると<i>、/</i> 2以上のブラウザのタブで、あなたは確かに<i>/</i>へのリクエストが終了するのを<i>/スリープ</i>待つ必要がないことがわかります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But as we mentioned, this will eventually overwhelm the system because you&#39;d be making new threads without any limit.</span>しかし、我々が言及したように、これは最終的にシステムを圧倒するでしょう。なぜならあなたは何の制限もなく新しいスレッドを作るからです。</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Creating a Similar Interface for a Finite Number of Threads</span>有限数のスレッドのための類似のインタフェースの作成</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We want our thread pool to work in a similar, familiar way so switching from threads to a thread pool doesn&#39;t require large changes to the code that uses our API.</span>スレッドプールをスレッドプールに切り替えるために、私たちのAPIを使用するコードを大幅に変更する必要はありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 20-12 shows the hypothetical interface for a <code>ThreadPool</code> struct we want to use instead of <code>thread::spawn</code> .</span>リスト20-12は、 <code>thread::spawn</code>代わりに使用したい<code>ThreadPool</code>構造体の仮説的インタフェースを示してい<code>thread::spawn</code> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust,no_run><div data-l="# use std::thread;"></div><div data-l="# use std::io::prelude::*;"></div><div data-l="# use std::net::TcpListener;"></div><div data-l="# use std::net::TcpStream;"></div><div data-l="# struct ThreadPool;"></div><div data-l="# impl ThreadPool {"></div><div data-l="#    fn new(size: u32) -&gt; ThreadPool { ThreadPool }"></div><div data-l="#    fn execute&lt;F&gt;(&amp;self, f: F)"></div><div data-l="#        where F: FnOnce() + Send + 'static {}"></div><div data-l="# }"></div><div data-l=#></div><div data-l="fn main() {"></div><div data-l="    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();"></div><div data-l="    let pool = ThreadPool::new(4);"></div><div data-l=""></div><div data-l="    for stream in listener.incoming() {"></div><div data-l="        let stream = stream.unwrap();"></div><div data-l=""></div><div data-l="        pool.execute(|| {"></div><div data-l="            handle_connection(stream);"></div><div data-l="        });"></div><div data-l="    }"></div><div data-l=}></div><div data-l="# fn handle_connection(mut stream: TcpStream) {}"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 20-12: Our ideal <code>ThreadPool</code> interface</span></span> <span class=caption>リスト20-12：理想的な<code>ThreadPool</code>インターフェース</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We use <code>ThreadPool::new</code> to create a new thread pool with a configurable number of threads, in this case four.</span> <code>ThreadPool::new</code>を使用して、設定可能なスレッド数（この場合は4）の新しいスレッドプールを作成します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then, in the <code>for</code> loop, <code>pool.execute</code> has a similar interface as <code>thread::spawn</code> in that it takes a closure the pool should run for each stream.</span>次に、 <code>for</code>ループで<code>pool.execute</code>は、プールが各ストリームに対して実行するクロージャをとる点で、 <code>thread::spawn</code>と同様のインタフェースがあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We need to implement <code>pool.execute</code> so it takes the closure and gives it to a thread in the pool to run.</span> <code>pool.execute</code>を実装する必要があり<code>pool.execute</code>ので、クロージャを実行してプールのスレッドに渡して実行します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This code won&#39;t yet compile, but we&#39;ll try so the compiler can guide us in how to fix it.</span>このコードはまだコンパイルされませんが、コンパイラがどのように修正するかを案内することができます。</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Building the <code>ThreadPool</code> Struct Using Compiler Driven Development</span>コンパイラ駆動型開発を使用した<code>ThreadPool</code>構造体の構築</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Make the changes in Listing 20-12 to <i>src/main.rs</i> , and then let&#39;s use the compiler errors from <code>cargo check</code> to drive our development.</span> <i>コード</i>リスト20-12を<i>src / main.rs</i>に変更してから、 <code>cargo check</code>コンパイラエラーを使って開発を進めましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here is the first error we get:</span>ここで私たちが最初に犯すエラーです：</span> </p><br><div data-lang=text><div data-l="$ cargo check"></div><div data-l="   Compiling hello v0.1.0 (file:///projects/hello)"></div><div data-l="error[E0433]: failed to resolve. Use of undeclared type or module `ThreadPool`"></div><div data-l="  --&gt; src\main.rs:10:16"></div><div data-l="   |"></div><div data-l="10 |     let pool = ThreadPool::new(4);"></div><div data-l="   |                ^^^^^^^^^^^^^^^ Use of undeclared type or module"></div><div data-l="   `ThreadPool`"></div><div data-l=""></div><div data-l="error: aborting due to previous error"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Great!</span>すばらしいです！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This error tells us we need a <code>ThreadPool</code> type or module, so we&#39;ll build one now.</span>このエラーは、 <code>ThreadPool</code>型またはモジュールが必要であることを示しているので、ここで構築します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Our <code>ThreadPool</code> implementation will be independent of the kind of work our web server is doing.</span>私たちの<code>ThreadPool</code>実装は、Webサーバがやっている仕事の種類から独立しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So, let&#39;s switch the <code>hello</code> crate from a binary crate to a library crate to hold our <code>ThreadPool</code> implementation.</span>だから、 <code>hello</code>クレートをバイナリクレートからライブラリクレートに切り替えて、 <code>ThreadPool</code>実装を保持しましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">After we change to a library crate, we could also use the separate thread pool library for any work we want to do using a thread pool, not just for serving web requests.</span>ライブラリ・ボックスに変更した後は、Webリクエストを処理するだけでなく、スレッド・プールを使用して作業を行うために別のスレッド・プール・ライブラリを使用することもできます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Create a <i>src/lib.rs</i> that contains the following, which is the simplest definition of a <code>ThreadPool</code> struct that we can have for now:</span>次のものを含む<i>src / lib.rs</i>を作成します。これは、今のところできる<code>ThreadPool</code>構造体の最も単純な定義です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/lib.rs</span></span> <span class=filename>ファイル名：src / lib.rs</span></span> </p><br><div data-lang=rust><div data-l="pub struct ThreadPool;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then create a new directory, <i>src/bin</i> , and move the binary crate rooted in <i>src/main.rs</i> into <i>src/bin/main.rs</i> .</span>次に、新しいディレクトリ<i>src / binを</i>作成し、 <i>src / main.rs</i>をルートとするバイナリ・クレートを<i>src / bin / main.rsに移動し</i>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Doing so will make the library crate the primary crate in the <i>hello</i> directory;</span>そうすることで、ライブラリは<i>hello</i>ディレクトリの一次クレートになります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">we can still run the binary in <i>src/bin/main.rs</i> using <code>cargo run</code> .</span> <code>cargo run</code>を使用して<i>src / bin / main.rs</i>内のバイナリを実行することはでき<code>cargo run</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">After moving the <i>main.rs</i> file, edit it to bring the library crate in and bring <code>ThreadPool</code> into scope by adding the following code to the top of <i>src/bin/main.rs</i> :</span> <i>main.rs</i>ファイルを移動した後、 <i>src / bin / main.rsの</i>先頭に次のコードを追加して、ライブラリ<i>crateを</i>入れて<code>ThreadPool</code>をスコープにします：</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/bin/main.rs</span></span> <span class=filename>ファイル名：src / bin / main.rs</span></span> </p><br><div data-lang=rust,ignore><div data-l="extern crate hello;"></div><div data-l="use hello::ThreadPool;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This code still won&#39;t work, but let&#39;s check it again to get the next error that we need to address:</span>このコードはまだ機能しませんが、もう一度チェックして次のエラーを解決しましょう：</span> </p><br><div data-lang=text><div data-l="$ cargo check"></div><div data-l="   Compiling hello v0.1.0 (file:///projects/hello)"></div><div data-l="error[E0599]: no function or associated item named `new` found for type"></div><div data-l="`hello::ThreadPool` in the current scope"></div><div data-l=" --&gt; src/bin/main.rs:13:16"></div><div data-l="   |"></div><div data-l="13 |     let pool = ThreadPool::new(4);"></div><div data-l="   |                ^^^^^^^^^^^^^^^ function or associated item not found in"></div><div data-l="   `hello::ThreadPool`"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This error indicates that next we need to create an associated function named <code>new</code> for <code>ThreadPool</code> .</span>このエラーは、次に<code>ThreadPool</code> <code>new</code>という名前の関連する関数を作成する必要があることを示します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We also know that <code>new</code> needs to have one parameter that can accept <code>4</code> as an argument and should return a <code>ThreadPool</code> instance.</span>我々はまた、ことを知って<code>new</code>ニーズが受け入れることができる一つのパラメータ持つように<code>4</code>引数として返す必要がありますし、 <code>ThreadPool</code>インスタンスを。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s implement the simplest <code>new</code> function that will have those characteristics:</span>これらの特性を持つ最も単純な<code>new</code>関数を実装しましょう：</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/lib.rs</span></span> <span class=filename>ファイル名：src / lib.rs</span></span> </p><br><div data-lang=rust><div data-l="pub struct ThreadPool;"></div><div data-l=""></div><div data-l="impl ThreadPool {"></div><div data-l="    pub fn new(size: usize) -&gt; ThreadPool {"></div><div data-l="        ThreadPool"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We chose <code>usize</code> as the type of the <code>size</code> parameter, because we know that a negative number of threads doesn&#39;t make any sense.</span>負の数のスレッドが意味をなさないことがわかっているので、 <code>usize</code>を<code>size</code>パラメータの型として選択し<code>usize</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We also know we&#39;ll use this 4 as the number of elements in a collection of threads, which is what the <code>usize</code> type is for, as discussed in the “Integer Types” section of Chapter 3.</span>我々はまた、我々は何であるスレッドのコレクション内の要素の数として、この4を使用します知っている<code>usize</code>第3章の「整数型」の項で説明したように、タイプがためです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s check the code again:</span>コードをもう一度見てみましょう：</span> </p><br><div data-lang=text><div data-l="$ cargo check"></div><div data-l="   Compiling hello v0.1.0 (file:///projects/hello)"></div><div data-l="warning: unused variable: `size`"></div><div data-l=" --&gt; src/lib.rs:4:16"></div><div data-l="  |"></div><div data-l="4 |     pub fn new(size: usize) -&gt; ThreadPool {"></div><div data-l="  |                ^^^^"></div><div data-l="  |"></div><div data-l="  = note: #[warn(unused_variables)] on by default"></div><div data-l="  = note: to avoid this warning, consider using `_size` instead"></div><div data-l=""></div><div data-l="error[E0599]: no method named `execute` found for type `hello::ThreadPool` in the current scope"></div><div data-l="  --&gt; src/bin/main.rs:18:14"></div><div data-l="   |"></div><div data-l="18 |         pool.execute(|| {"></div><div data-l="   |              ^^^^^^^"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now we get a warning and an error.</span>今我々は警告とエラーを得る。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Ignoring the warning for a moment, the error occurs because we don&#39;t have an <code>execute</code> method on <code>ThreadPool</code> .</span>警告を無視して、 <code>ThreadPool</code> <code>execute</code>メソッドがないためにエラーが発生します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Recall from the “Creating a Similar Interface for a Finite Number of Threads” section that we decided our thread pool should have an interface similar to <code>thread::spawn</code> .</span> 「有限数のスレッドのための同様のインタフェースの作成」のセクションから、私たちのスレッドプールは<code>thread::spawn</code>似たインタフェースを持つべきだと思いました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In addition, we&#39;ll implement the <code>execute</code> function so it takes the closure it&#39;s given and gives it to an idle thread in the pool to run.</span>さらに、 <code>execute</code>関数を実装して、与えられたクロージャを受け取り、 <code>execute</code>プール内のアイドル状態のスレッドに渡します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll define the <code>execute</code> method on <code>ThreadPool</code> to take a closure as a parameter.</span> <code>ThreadPool</code>の<code>execute</code>メソッドを定義して、クロージャをパラメータとして使用します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Recall from the “Storing Closures Using Generic Parameters and the <code>Fn</code> Traits” section in Chapter 13 that we can take closures as parameters with three different traits: <code>Fn</code> , <code>FnMut</code> , and <code>FnOnce</code> .</span>第13章の「汎用パラメータと<code>Fn</code>特性を使用したクロージャの格納」のセクションから、 <code>Fn</code> 、 <code>FnMut</code> 、および<code>FnOnce</code> 3つの異なる特性を持つパラメータとしてクロージャを使用できることを<code>FnOnce</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We need to decide which kind of closure to use here.</span>ここで使用するクロージャの種類を決定する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We know we&#39;ll end up doing something similar to the standard library <code>thread::spawn</code> implementation, so we can look at what bounds the signature of <code>thread::spawn</code> has on its parameter.</span>私たちは、標準のライブラリ<code>thread::spawn</code>実装に似た何かをすることになることを知っているので、 <code>thread::spawn</code>シグネチャがそのパラメータにどのような境界を持つかを見ることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The documentation shows us the following:</span>ドキュメンテーションは私たちに以下を示します：</span> </p><br><div data-lang=rust,ignore><div data-l="pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;"></div><div data-l="    where"></div><div data-l="        F: FnOnce() -&gt; T + Send + 'static,"></div><div data-l="        T: Send + 'static"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>F</code> type parameter is the one we&#39;re concerned with here;</span> <code>F</code>型パラメータは、ここで考慮するパラメータです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">the <code>T</code> type parameter is related to the return value, and we&#39;re not concerned with that.</span> <code>T</code>型パラメータは戻り値に関連しており、我々はそれに関心がない。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can see that <code>spawn</code> uses <code>FnOnce</code> as the trait bound on <code>F</code> .</span>私たちは、 <code>spawn</code>が<code>F</code>バインドされた特性として<code>FnOnce</code>を使用<code>spawn</code>ことを見ることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is probably what we want as well, because we&#39;ll eventually pass the argument we get in <code>execute</code> to <code>spawn</code> .</span>我々は最終的に我々が取得引数渡しますので、これは、私たちが同様に欲しいものはおそらくあり<code>execute</code>する<code>spawn</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can be further confident that <code>FnOnce</code> is the trait we want to use because the thread for running a request will only execute that request&#39;s closure one time, which matches the <code>Once</code> in <code>FnOnce</code> .</span> <code>FnOnce</code>は、リクエストを実行するスレッドが<code>FnOnce</code>の<code>Once</code>に一致するリクエストのクロージャを1回だけ実行するため、 <code>FnOnce</code>が使用したい特性であることをさらに確信できます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>F</code> type parameter also has the trait bound <code>Send</code> and the lifetime bound <code>&#39;static</code> , which are useful in our situation: we need <code>Send</code> to transfer the closure from one thread to another and <code>&#39;static</code> because we don&#39;t know how long the thread will take to execute.</span> <code>F</code>型パラメータもトレイト結合した<code>Send</code>され、結合寿命<code>&#39;static</code>我々の状況において有用である、：私たちが必要<code>Send</code>別のスレッドからの閉鎖を転送する<code>&#39;static</code>私たちはどのくらいのスレッドがするかわからないので、実行する。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s create an <code>execute</code> method on <code>ThreadPool</code> that will take a generic parameter of type <code>F</code> with these bounds:</span> <code>ThreadPool</code> <code>execute</code>メソッドを作成して、これらの境界で<code>F</code>型の汎用パラメータを取得しましょう。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/lib.rs</span></span> <span class=filename>ファイル名：src / lib.rs</span></span> </p><br><div data-lang=rust><div data-l="# pub struct ThreadPool;"></div><div data-l="impl ThreadPool {"></div><div data-l="#    // --snip--"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">--snip--</span> --snip--</span> </div><div data-l=""></div><div data-l="    pub fn execute&lt;F&gt;(&amp;self, f: F)"></div><div data-l="        where"></div><div data-l="            F: FnOnce() + Send + 'static"></div><div data-l="    {"></div><div data-l=""></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We still use the <code>()</code> after <code>FnOnce</code> because this <code>FnOnce</code> represents a closure that takes no parameters and doesn&#39;t return a value.</span>我々はまだ使用して<code>()</code>した後<code>FnOnce</code>このため<code>FnOnce</code>パラメータを取らず、値を返さない閉鎖を表します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Just like function definitions, the return type can be omitted from the signature, but even if we have no parameters, we still need the parentheses.</span>関数の定義と同じように、戻り値の型はシグネチャから省略することができますが、パラメータがなくても括弧が必要です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Again, this is the simplest implementation of the <code>execute</code> method: it does nothing, but we&#39;re trying only to make our code compile.</span>繰り返しますが、これは<code>execute</code>メソッドの最も単純な実装です。何もしませんが、コードをコンパイルするだけです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s check it again:</span>それをもう一度見てみましょう：</span> </p><br><div data-lang=text><div data-l="$ cargo check"></div><div data-l="   Compiling hello v0.1.0 (file:///projects/hello)"></div><div data-l="warning: unused variable: `size`"></div><div data-l=" --&gt; src/lib.rs:4:16"></div><div data-l="  |"></div><div data-l="4 |     pub fn new(size: usize) -&gt; ThreadPool {"></div><div data-l="  |                ^^^^"></div><div data-l="  |"></div><div data-l="  = note: #[warn(unused_variables)] on by default"></div><div data-l="  = note: to avoid this warning, consider using `_size` instead"></div><div data-l=""></div><div data-l="warning: unused variable: `f`"></div><div data-l=" --&gt; src/lib.rs:8:30"></div><div data-l="  |"></div><div data-l="8 |     pub fn execute&lt;F&gt;(&amp;self, f: F)"></div><div data-l="  |                              ^"></div><div data-l="  |"></div><div data-l="  = note: to avoid this warning, consider using `_f` instead"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;re receiving only warnings now, which means it compiles!</span>私たちは警告のみを受け取ります。つまり、コンパイルされています！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But note that if you try <code>cargo run</code> and make a request in the browser, you&#39;ll see the errors in the browser that we saw at the beginning of the chapter.</span>しかし、 <code>cargo run</code>してブラウザでリクエストを行うと、章の冒頭で見たブラウザにエラーが表示されることに注意してください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Our library isn&#39;t actually calling the closure passed to <code>execute</code> yet!</span>私たちの図書館は実際にはクロージャを渡して<code>execute</code>まだ<code>execute</code>呼びかけていません！</span> </p><br><blockquote><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note: A saying you might hear about languages with strict compilers, such as Haskell and Rust, is “if the code compiles, it works.” But this saying is not universally true.</span>注：HaskellやRustのような厳密なコンパイラを使用している言語については、「コードがコンパイルされても機能する」と聞くかもしれませんが、この言葉は普遍的ではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Our project compiles, but it does absolutely nothing!</span>私たちのプロジェクトはコンパイルされますが、絶対に何もしません！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we were building a real, complete project, this would be a good time to start writing unit tests to check that the code compiles <i>and</i> has the behavior we want.</span>本当の、完全なプロジェクトを構築していたら、コードがコンパイルされ<i>、</i>私たちが望む振る舞いを持っているかどうかをチェックする単体テストを書くのはいい時期です。</span> </p></blockquote><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Validating the Number of Threads in <code>new</code></span> <code>new</code>スレッドの数の検証</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll continue to get warnings because we aren&#39;t doing anything with the parameters to <code>new</code> and <code>execute</code> .</span>私たちは、 <code>new</code>パラメータと<code>execute</code>パラメータを何もしていないので、警告を受け取り続けます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s implement the bodies of these functions with the behavior we want.</span>私たちが望むふるまいでこれらの関数の本体を実装しましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To start, let&#39;s think about <code>new</code> .</span>まず、 <code>new</code>考えましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Earlier we chose an unsigned type for the <code>size</code> parameter, because a pool with a negative number of threads makes no sense.</span>以前は、負の数のスレッドを持つプールは意味をなさないため、 <code>size</code>パラメータには符号なしの型を選択しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, a pool with zero threads also makes no sense, yet zero is a perfectly valid <code>usize</code> .</span>しかし、スレッドがゼロのプールも意味をなさないが、ゼロは完全に有効な<code>usize</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll add code to check that <code>size</code> is greater than zero before we return a <code>ThreadPool</code> instance and have the program panic if it receives a zero by using the <code>assert€</code> macro, as shown in Listing 20-13.</span>リスト20-13に示すように、 <code>ThreadPool</code>インスタンスを返す前に<code>size</code>がゼロより大きいかどうかを確認するコードを追加し、 <code>assert€</code>マクロを使用してゼロを受け取った場合にプログラムパニックを起こします。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/lib.rs</span></span> <span class=filename>ファイル名：src / lib.rs</span></span> </p><br><div data-lang=rust><div data-l="# pub struct ThreadPool;"></div><div data-l="impl ThreadPool {"></div><div data-l="#//    /// Create a new ThreadPool."></div><div data-l="    /// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Create a new ThreadPool.</span>新しいThreadPoolを作成します。</span> </div><div data-l="    ///"></div><div data-l="#//    /// The size is the number of threads in the pool."></div><div data-l="    /// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The size is the number of threads in the pool.</span>サイズは、プール内のスレッドの数です。</span> </div><div data-l="    ///"></div><div data-l="#//    /// # Panics"></div><div data-l="    /// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"># Panics</span> ＃パニック</span> </div><div data-l="    ///"></div><div data-l="#//    /// The `new` function will panic if the size is zero."></div><div data-l="    /// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>new</code> function will panic if the size is zero.</span>サイズがゼロの場合、 <code>new</code>関数はパニックに陥ります。</span> </div><div data-l="    pub fn new(size: usize) -&gt; ThreadPool {"></div><div data-l="        assert!(size &gt; 0);"></div><div data-l=""></div><div data-l="        ThreadPool"></div><div data-l="    }"></div><div data-l=""></div><div data-l="#    // --snip--"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">--snip--</span> --snip--</span> </div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 20-13: Implementing <code>ThreadPool::new</code> to panic if <code>size</code> is zero</span></span> <span class=caption>リスト20-13： <code>size</code>が0の場合、 <code>ThreadPool::new</code>をパニックに実装する</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ve added some documentation for our <code>ThreadPool</code> with doc comments.</span>私たちは、 <code>ThreadPool</code>ドキュメンテーションコメント付きのドキュメントをいくつか追加しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that we followed good documentation practices by adding a section that calls out the situations in which our function can panic, as discussed in Chapter 14. Try running <code>cargo doc --open</code> and clicking the <code>ThreadPool</code> struct to see what the generated docs for <code>new</code> look like!</span>第14章で説明したように実行してみてください、私達は私達の機能がパニックすることができている状況を呼び出しセクションを追加することによって、良いドキュメントの慣行に従っていることに注意してください<code>cargo doc --open</code>し、クリック<code>ThreadPool</code>のため何を生成したドキュメントを参照する構造体を<code>new</code>外観を好き！</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Instead of adding the <code>assert€</code> macro as we&#39;ve done here, we could make <code>new</code> return a <code>Result</code> like we did with <code>Config::new</code> in the I/O project in Listing 12-9.</span>ここで行ったように<code>assert€</code>マクロを追加する代わりに、リスト12-9のI / Oプロジェクトで<code>Config::new</code>と同じように<code>new</code> <code>Result</code>返すことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But we&#39;ve decided in this case that trying to create a thread pool without any threads should be an unrecoverable error.</span>しかし、この場合、スレッドなしでスレッドプールを作成しようとすると、回復不可能なエラーになるはずです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you&#39;re feeling ambitious, try to write a version of <code>new</code> with the following signature to compare both versions:</span>あなたが野心的だと感じたら、両方のバージョンを比較するために、次のシグネチャで<code>new</code>バージョンを作成してみてください：</span> </p><br><div data-lang=rust,ignore><div data-l="pub fn new(size: usize) -&gt; Result&lt;ThreadPool, PoolCreationError&gt; {"></div></div><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Creating Space to Store the Threads</span>スレッドを格納する領域の作成</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now that we have a way to know we have a valid number of threads to store in the pool, we can create those threads and store them in the <code>ThreadPool</code> struct before returning it.</span>プールに格納するスレッドの有効な数がわかっているので、それらのスレッドを作成し、 <code>ThreadPool</code>構造体に格納してから返すことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But how do we “store” a thread?</span>しかし、スレッドを「保存」するにはどうすればよいですか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s take another look at the <code>thread::spawn</code> signature:</span> <code>thread::spawn</code>シグネチャをもう一度見てみましょう：</span> </p><br><div data-lang=rust,ignore><div data-l="pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;"></div><div data-l="    where"></div><div data-l="        F: FnOnce() -&gt; T + Send + 'static,"></div><div data-l="        T: Send + 'static"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>spawn</code> function returns a <code>JoinHandle&lt;T&gt;</code> , where <code>T</code> is the type that the closure returns.</span> <code>spawn</code>関数は<code>JoinHandle&lt;T&gt;</code>返します。ここで、 <code>T</code>はクロージャが返す型です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s try using <code>JoinHandle</code> too and see what happens.</span> <code>JoinHandle</code>も試して<code>JoinHandle</code>て、何が起こるか見てみましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In our case, the closures we&#39;re passing to the thread pool will handle the connection and not return anything, so <code>T</code> will be the unit type <code>()</code> .</span>私たちの場合、スレッドプールに渡すクロージャは接続を処理し、何も返さないので、 <code>T</code>はユニットタイプ<code>()</code>ます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The code in Listing 20-14 will compile but doesn&#39;t create any threads yet.</span>コードリスト20-14のコードはコンパイルされますが、まだスレッドは作成されません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ve changed the definition of <code>ThreadPool</code> to hold a vector of <code>thread::JoinHandle&lt;()&gt;</code> instances, initialized the vector with a capacity of <code>size</code> , set up a <code>for</code> loop that will run some code to create the threads, and returned a <code>ThreadPool</code> instance containing them.</span> <code>thread::JoinHandle&lt;()&gt;</code>インスタンスのベクトルを保持し、 <code>size</code>容量でベクトルを初期化し、スレッドを作成するためのコードを実行する<code>for</code>ループを設定し、 <code>thread::JoinHandle&lt;()&gt;</code>ように<code>ThreadPool</code>の定義を変更しました。それらを含む<code>ThreadPool</code>インスタンス</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/lib.rs</span></span> <span class=filename>ファイル名：src / lib.rs</span></span> </p><br><div data-lang=rust,ignore><div data-l="use std::thread;"></div><div data-l=""></div><div data-l="pub struct ThreadPool {"></div><div data-l="    threads: Vec&lt;thread::JoinHandle&lt;()&gt;&gt;,"></div><div data-l=}></div><div data-l=""></div><div data-l="impl ThreadPool {"></div><div data-l="#    // --snip--"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">--snip--</span> --snip--</span> </div><div data-l="    pub fn new(size: usize) -&gt; ThreadPool {"></div><div data-l="        assert!(size &gt; 0);"></div><div data-l=""></div><div data-l="        let mut threads = Vec::with_capacity(size);"></div><div data-l=""></div><div data-l="        for _ in 0..size {"></div><div data-l="#            // create some threads and store them in the vector"></div><div data-l="            // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">create some threads and store them in the vector</span>いくつかのスレッドを作成してベクトルに格納する</span> </div><div data-l="        }"></div><div data-l=""></div><div data-l="        ThreadPool {"></div><div data-l="            threads"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=""></div><div data-l="#    // --snip--"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">--snip--</span> --snip--</span> </div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 20-14: Creating a vector for <code>ThreadPool</code> to hold the threads</span></span> <span class=caption>リスト20-14： <code>ThreadPool</code>がスレッドを保持するためのベクトルを作成する</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ve brought <code>std::thread</code> into scope in the library crate, because we&#39;re using <code>thread::JoinHandle</code> as the type of the items in the vector in <code>ThreadPool</code> .</span> <code>ThreadPool</code>のベクトルの項目の型として<code>thread::JoinHandle</code>を使用しているので、ライブラリ・クレートのスコープに<code>std::thread</code>を持ってきました。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Once a valid size is received, our <code>ThreadPool</code> creates a new vector that can hold <code>size</code> items.</span>有効なサイズが受け取られると、 <code>ThreadPool</code>は<code>size</code>アイテムを保持できる新しいベクトルを作成します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We haven&#39;t used the <code>with_capacity</code> function in this book yet, which performs the same task as <code>Vec::new</code> but with an important difference: it preallocates space in the vector.</span>本書では<code>with_capacity</code>関数を使用していませんが、これは<code>Vec::new</code>と同じタスクを実行しますが、重要な違いがあります。ベクトルにスペースをあらかじめ割り当てています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because we know we need to store <code>size</code> elements in the vector, doing this allocation up front is slightly more efficient than using <code>Vec::new</code> , which resizes itself as elements are inserted.</span>ベクトルに<code>size</code>要素を格納する必要があることが分かっているので、この割り当てを前面に<code>Vec::new</code>ことは、 <code>Vec::new</code>を使うよりも若干効率的です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When you run <code>cargo check</code> again, you&#39;ll get a few more warnings, but it should succeed.</span>再び<code>cargo check</code>を実行<code>cargo check</code>と、さらに警告が表示されますが、成功するはずです。</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A <code>Worker</code> Struct Responsible for Sending Code from the <code>ThreadPool</code> to a Thread</span> <code>ThreadPool</code>からスレッドへコードを送信する<code>Worker</code>構造体</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We left a comment in the <code>for</code> loop in Listing 20-14 regarding the creation of threads.</span>スレッドの作成に関して、リスト20-14の<code>for</code>ループにコメントを残しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here, we&#39;ll look at how we actually create threads.</span>ここでは、実際にスレッドを作成する方法を見ていきます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The standard library provides <code>thread::spawn</code> as a way to create threads, and <code>thread::spawn</code> expects to get some code the thread should run as soon as the thread is created.</span>標準ライブラリは<code>thread::spawn</code>を作成する方法として<code>thread::spawn</code>を提供し、 <code>thread::spawn</code>はスレッドが作成されるとすぐにスレッドが実行するコードを取得<code>thread::spawn</code>ことを想定しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, in our case, we want to create the threads and have them <i>wait</i> for code that we&#39;ll send later.</span>しかし、私たちの場合、スレッドを作成して、後で送信するコードを<i>待た</i>せる必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The standard library&#39;s implementation of threads doesn&#39;t include any way to do that;</span>標準ライブラリのスレッドの実装には、これを行う方法は含まれていません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">we have to implement it manually.</span>手動で実装する必要があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll implement this behavior by introducing a new data structure between the <code>ThreadPool</code> and the threads that will manage this new behavior.</span>この動作は、 <code>ThreadPool</code>とこの新しい動作を管理するスレッドとの間に新しいデータ構造を導入することで実装されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll call this data structure <code>Worker</code> , which is a common term in pooling implementations.</span>私たちはこのデータ構造を<code>Worker</code>と呼んでいます。これは、実装をプールする際の共通の用語です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Think of people working in the kitchen at a restaurant: the workers wait until orders come in from customers, and then they&#39;re responsible for taking those orders and filling them.</span>レストランで台所で働いている人々を考えてみましょう。労働者は注文が顧客から来るまで待ってから、その注文を受け取り、それらを満たす責任があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Instead of storing a vector of <code>JoinHandle&lt;()&gt;</code> instances in the thread pool, we&#39;ll store instances of the <code>Worker</code> struct.</span> <code>JoinHandle&lt;()&gt;</code>インスタンスのベクトルをスレッドプールに格納する代わりに、 <code>Worker</code>構造体のインスタンスを格納します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Each <code>Worker</code> will store a single <code>JoinHandle&lt;()&gt;</code> instance.</span>各<code>Worker</code>は1つの<code>JoinHandle&lt;()&gt;</code>インスタンスを格納します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then we&#39;ll implement a method on <code>Worker</code> that will take a closure of code to run and send it to the already running thread for execution.</span>次に、実行するコードを閉じて実行中のスレッドに送信して実行するメソッドを<code>Worker</code>実装します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll also give each worker an <code>id</code> so we can distinguish between the different workers in the pool when logging or debugging.</span>また、ロギングやデバッグ時にプール内の異なるワーカーを区別できるように、各ワーカーに<code>id</code>与えます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s make the following changes to what happens when we create a <code>ThreadPool</code> .</span> <code>ThreadPool</code>を作成するときに起こることに以下の変更を加えましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll implement the code that sends the closure to the thread after we have <code>Worker</code> set up in this way:</span>このように<code>Worker</code>設定した後、クロージャをスレッドに送信するコードを実装します。</span> </p><br><div data-b=1.> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Define a <code>Worker</code> struct that holds an <code>id</code> and a <code>JoinHandle&lt;()&gt;</code> .</span> <code>id</code>と<code>JoinHandle&lt;()&gt;</code>を保持する<code>Worker</code>構造体を定義します。</span> </div><div data-b=2.> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Change <code>ThreadPool</code> to hold a vector of <code>Worker</code> instances.</span> <code>Worker</code>インスタンスのベクトルを保持する<code>ThreadPool</code>を変更します。</span> </div><div data-b=3.> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Define a <code>Worker::new</code> function that takes an <code>id</code> number and returns a <code>Worker</code> instance that holds the <code>id</code> and a thread spawned with an empty closure.</span>定義<code>Worker::new</code>とる関数<code>id</code>番号を返しますし、 <code>Worker</code>保持しているインスタンス<code>id</code>と空の閉鎖で生成されたスレッドを。</span> </div><div data-b=4.> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In <code>ThreadPool::new</code> , use the <code>for</code> loop counter to generate an <code>id</code> , create a new <code>Worker</code> with that <code>id</code> , and store the worker in the vector.</span> <code>ThreadPool::new</code> 、使用<code>for</code>生成するために、ループカウンタを<code>id</code> 、新たに作成する<code>Worker</code>それと<code>id</code> 、およびベクター中の労働者を保存します。</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you&#39;re up for a challenge, try implementing these changes on your own before looking at the code in Listing 20-15.</span>課題がある場合は、リスト20-15のコードを調べる前に、これらの変更を自分で実装してみてください。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Ready?</span>準備？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here is Listing 20-15 with one way to make the preceding modifications.</span>リスト20-15に、前の変更を行う1つの方法を示します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/lib.rs</span></span> <span class=filename>ファイル名：src / lib.rs</span></span> </p><br><div data-lang=rust><div data-l="use std::thread;"></div><div data-l=""></div><div data-l="pub struct ThreadPool {"></div><div data-l="    workers: Vec&lt;Worker&gt;,"></div><div data-l=}></div><div data-l=""></div><div data-l="impl ThreadPool {"></div><div data-l="#    // --snip--"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">--snip--</span> --snip--</span> </div><div data-l="    pub fn new(size: usize) -&gt; ThreadPool {"></div><div data-l="        assert!(size &gt; 0);"></div><div data-l=""></div><div data-l="        let mut workers = Vec::with_capacity(size);"></div><div data-l=""></div><div data-l="        for id in 0..size {"></div><div data-l="            workers.push(Worker::new(id));"></div><div data-l="        }"></div><div data-l=""></div><div data-l="        ThreadPool {"></div><div data-l="            workers"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l="#    // --snip--"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">--snip--</span> --snip--</span> </div><div data-l=}></div><div data-l=""></div><div data-l="struct Worker {"></div><div data-l="    id: usize,"></div><div data-l="    thread: thread::JoinHandle&lt;()&gt;,"></div><div data-l=}></div><div data-l=""></div><div data-l="impl Worker {"></div><div data-l="    fn new(id: usize) -&gt; Worker {"></div><div data-l="        let thread = thread::spawn(|| {});"></div><div data-l=""></div><div data-l="        Worker {"></div><div data-l="            id,"></div><div data-l="            thread,"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 20-15: Modifying <code>ThreadPool</code> to hold <code>Worker</code> instances instead of holding threads directly</span></span> <span class=caption>リスト20-15：スレッドを直接保持するのではなく、 <code>Worker</code>インスタンスを保持する<code>ThreadPool</code>変更</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ve changed the name of the field on <code>ThreadPool</code> from <code>threads</code> to <code>workers</code> because it&#39;s now holding <code>Worker</code> instances instead of <code>JoinHandle&lt;()&gt;</code> instances.</span>私たちは、上のフィールドの名前を変更した<code>ThreadPool</code>から<code>threads</code>へ<code>workers</code> 、それが今持っているため<code>Worker</code>の代わりに、インスタンス<code>JoinHandle&lt;()&gt;</code>のインスタンスを。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We use the counter in the <code>for</code> loop as an argument to <code>Worker::new</code> , and we store each new <code>Worker</code> in the vector named <code>workers</code> .</span> <code>for</code>ループのカウンタを<code>Worker::new</code>引数として使用し、 <code>Worker::new</code>各<code>Worker</code>を<code>workers</code>という名前のベクトルに格納します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">External code (like our server in <i>src/bin/main.rs</i> ) doesn&#39;t need to know the implementation details regarding using a <code>Worker</code> struct within <code>ThreadPool</code> , so we make the <code>Worker</code> struct and its <code>new</code> function private.</span>外部コード（ <i>src / bin / main.rsの</i>私たちのサーバのような）は、 <code>ThreadPool</code>内の<code>Worker</code>構造体の使用に関する実装の詳細を知る必要はないので、 <code>Worker</code>構造体とその<code>new</code>関数をprivateにします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Worker::new</code> function uses the <code>id</code> we give it and stores a <code>JoinHandle&lt;()&gt;</code> instance that is created by spawning a new thread using an empty closure.</span> <code>Worker::new</code>関数は、与えられた<code>id</code>を使用し、空のクロージャを使用して新しいスレッドを生成することによって作成された<code>JoinHandle&lt;()&gt;</code>インスタンスを格納します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This code will compile and will store the number of <code>Worker</code> instances we specified as an argument to <code>ThreadPool::new</code> .</span>このコードは、 <code>ThreadPool::new</code>への引数として指定した<code>Worker</code>インスタンスの数をコンパイルして格納します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But we&#39;re <i>still</i> not processing the closure that we get in <code>execute</code> .</span>しかし、我々は<i>まだ</i>我々が得る閉鎖処理していない<code>execute</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s look at how to do that next.</span>それを次に行う方法を見てみましょう。</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Sending Requests to Threads via Channels</span>チャネル経由でのスレッドへのリクエストの送信</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now we&#39;ll tackle the problem that the closures given to <code>thread::spawn</code> do absolutely nothing.</span>今度は、 <code>thread::spawn</code>与えられたクロージャが全く何もしないという問題に取り組みます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Currently, we get the closure we want to execute in the <code>execute</code> method.</span>現在、 <code>execute</code>メソッドで実行したいクロージャを取得します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But we need to give <code>thread::spawn</code> a closure to run when we create each <code>Worker</code> during the creation of the <code>ThreadPool</code> .</span>しかし<code>ThreadPool</code>作成中に各<code>Worker</code>を作成するときに実行するクロージャを<code>thread::spawn</code>に与える必要があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We want the <code>Worker</code> structs that we just created to fetch code to run from a queue held in the <code>ThreadPool</code> and send that code to its thread to run.</span>私たちは、作成した<code>Worker</code>構造体が、 <code>ThreadPool</code>保持されているキューから実行するコードをフェッチし、そのコードをそのスレッドに送信して実行するようにします。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In Chapter 16, you learned about <i>channels</i> —a simple way to communicate between two threads—that would be perfect for this use case.</span>第16章では、2つのスレッド間で通信する簡単な方法である<i>チャネル</i>について学習しました。このユースケースには最適です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll use a channel to function as the queue of jobs, and <code>execute</code> will send a job from the <code>ThreadPool</code> to the <code>Worker</code> instances, which will send the job to its thread.</span>私たちはチャネルをジョブの待ち行列として機能させ、 <code>execute</code>は<code>ThreadPool</code>から<code>Worker</code>インスタンスにジョブを送信し、そのスレッドにジョブを送ります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here is the plan:</span>ここに計画があります：</span> </p><br><div data-b=1.> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>ThreadPool</code> will create a channel and hold on to the sending side of the channel.</span> <code>ThreadPool</code>はチャネルを作成し、チャネルの送信側を保持します。</span> </div><div data-b=2.> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Each <code>Worker</code> will hold on to the receiving side of the channel.</span>各<code>Worker</code>は、チャンネルの受信側を保持します。</span> </div><div data-b=3.> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll create a new <code>Job</code> struct that will hold the closures we want to send down the channel.</span>私たちはチャンネルを送信したいクロージャを保持する新しい<code>Job</code>構造体を作成します。</span> </div><div data-b=4.> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>execute</code> method will send the job it wants to execute down the sending side of the channel.</span> <code>execute</code>メソッドは、チャネルの送信側で実行したいジョブを送信します。</span> </div><div data-b=5.> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In its thread, the <code>Worker</code> will loop over its receiving side of the channel and execute the closures of any jobs it receives.</span>スレッドでは、 <code>Worker</code>はチャネルの受信側をループし、受け取ったジョブのクロージャを実行します。</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s start by creating a channel in <code>ThreadPool::new</code> and holding the sending side in the <code>ThreadPool</code> instance, as shown in Listing 20-16.</span>まず、 <code>ThreadPool::new</code>チャネルを作成し、送信側を<code>ThreadPool</code>インスタンスに保持してみましょう（リスト20-16を参照）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Job</code> struct doesn&#39;t hold anything for now but will be the type of item we&#39;re sending down the channel.</span> <code>Job</code>構造体には現在何も保持されていませんが、チャネルを送信するアイテムのタイプになります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/lib.rs</span></span> <span class=filename>ファイル名：src / lib.rs</span></span> </p><br><div data-lang=rust><div data-l="# use std::thread;"></div><div data-l="#// --snip--"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">--snip--</span> --snip--</span> </div><div data-l="use std::sync::mpsc;"></div><div data-l=""></div><div data-l="pub struct ThreadPool {"></div><div data-l="    workers: Vec&lt;Worker&gt;,"></div><div data-l="    sender: mpsc::Sender&lt;Job&gt;,"></div><div data-l=}></div><div data-l=""></div><div data-l="struct Job;"></div><div data-l=""></div><div data-l="impl ThreadPool {"></div><div data-l="#    // --snip--"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">--snip--</span> --snip--</span> </div><div data-l="    pub fn new(size: usize) -&gt; ThreadPool {"></div><div data-l="        assert!(size &gt; 0);"></div><div data-l=""></div><div data-l="        let (sender, receiver) = mpsc::channel();"></div><div data-l=""></div><div data-l="        let mut workers = Vec::with_capacity(size);"></div><div data-l=""></div><div data-l="        for id in 0..size {"></div><div data-l="            workers.push(Worker::new(id));"></div><div data-l="        }"></div><div data-l=""></div><div data-l="        ThreadPool {"></div><div data-l="            workers,"></div><div data-l="            sender,"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l="#    // --snip--"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">--snip--</span> --snip--</span> </div><div data-l=}></div><div data-l=#></div><div data-l="# struct Worker {"></div><div data-l="#     id: usize,"></div><div data-l="#     thread: thread::JoinHandle&lt;()&gt;,"></div><div data-l="# }"></div><div data-l=#></div><div data-l="# impl Worker {"></div><div data-l="#     fn new(id: usize) -&gt; Worker {"></div><div data-l="#         let thread = thread::spawn(|| {});"></div><div data-l=#></div><div data-l="#         Worker {"></div><div data-l="#             id,"></div><div data-l="#             thread,"></div><div data-l="#         }"></div><div data-l="#     }"></div><div data-l="# }"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 20-16: Modifying <code>ThreadPool</code> to store the sending end of a channel that sends <code>Job</code> instances</span></span> <span class=caption>20-16リスト：変更<code>ThreadPool</code>送信チャネルの送信側格納する<code>Job</code>インスタンスを</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In <code>ThreadPool::new</code> , we create our new channel and have the pool hold the sending end.</span> <code>ThreadPool::new</code>では、新しいチャネルを作成し、プールに送信側を保持させます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This will successfully compile, still with warnings.</span>これは正常にコンパイルされ、それでも警告が表示されます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s try passing a receiving end of the channel into each worker as the thread pool creates the channel.</span>スレッドプールがチャネルを作成するときに、チャネルの受信側を各ワーカーに渡してみましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We know we want to use the receiving end in the thread that the workers spawn, so we&#39;ll reference the <code>receiver</code> parameter in the closure.</span>私たちは、ワーカーがスレッドを生成するスレッドで受信側を使用したいので、クロージャの<code>receiver</code>パラメータを参照します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The code in Listing 20-17 won&#39;t quite compile yet.</span>コードリスト20-17のコードはまだコンパイルされません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/lib.rs</span></span> <span class=filename>ファイル名：src / lib.rs</span></span> </p><br><div data-lang=rust,ignore><div data-l="impl ThreadPool {"></div><div data-l="#    // --snip--"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">--snip--</span> --snip--</span> </div><div data-l="    pub fn new(size: usize) -&gt; ThreadPool {"></div><div data-l="        assert!(size &gt; 0);"></div><div data-l=""></div><div data-l="        let (sender, receiver) = mpsc::channel();"></div><div data-l=""></div><div data-l="        let mut workers = Vec::with_capacity(size);"></div><div data-l=""></div><div data-l="        for id in 0..size {"></div><div data-l="            workers.push(Worker::new(id, receiver));"></div><div data-l="        }"></div><div data-l=""></div><div data-l="        ThreadPool {"></div><div data-l="            workers,"></div><div data-l="            sender,"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l="#    // --snip--"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">--snip--</span> --snip--</span> </div><div data-l=}></div><div data-l=""></div><div data-l="#// --snip--"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">--snip--</span> --snip--</span> </div><div data-l=""></div><div data-l="impl Worker {"></div><div data-l="    fn new(id: usize, receiver: mpsc::Receiver&lt;Job&gt;) -&gt; Worker {"></div><div data-l="        let thread = thread::spawn(|| {"></div><div data-l="            receiver;"></div><div data-l="        });"></div><div data-l=""></div><div data-l="        Worker {"></div><div data-l="            id,"></div><div data-l="            thread,"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 20-17: Passing the receiving end of the channel to the workers</span></span> <span class=caption>リスト20-17：チャンネルの受信側をワーカーに渡す</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ve made some small and straightforward changes: we pass the receiving end of the channel into <code>Worker::new</code> , and then we use it inside the closure.</span>いくつかの簡単で小さな変更を加えました。チャンネルの受信側を<code>Worker::new</code>に渡してから、クロージャー内で使用します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When we try to check this code, we get this error:</span>このコードをチェックしようとすると、次のエラーが表示されます。</span> </p><br><div data-lang=text><div data-l="$ cargo check"></div><div data-l="   Compiling hello v0.1.0 (file:///projects/hello)"></div><div data-l="error[E0382]: use of moved value: `receiver`"></div><div data-l="  --&gt; src/lib.rs:27:42"></div><div data-l="   |"></div><div data-l="27 |             workers.push(Worker::new(id, receiver));"></div><div data-l="   |                                          ^^^^^^^^ value moved here in"></div><div data-l="   previous iteration of loop"></div><div data-l="   |"></div><div data-l="   = note: move occurs because `receiver` has type"></div><div data-l="   `std::sync::mpsc::Receiver&lt;Job&gt;`, which does not implement the `Copy` trait"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The code is trying to pass <code>receiver</code> to multiple <code>Worker</code> instances.</span>コードは、 <code>receiver</code>を複数の<code>Worker</code>インスタンスに渡そうとしています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This won&#39;t work, as you&#39;ll recall from Chapter 16: the channel implementation that Rust provides is multiple <i>producer</i> , single <i>consumer</i> .</span>これはうまくいきません.16章から思い出してください.Rustが提供するチャンネルの実装は、複数の<i>プロデューサー</i> 、単一の<i>コンシューマー</i>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This means we can&#39;t just clone the consuming end of the channel to fix this code.</span>つまり、このコードを修正するためにチャネルの消費側をクローンするだけでは意味がありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Even if we could, that is not the technique we would want to use;</span>たとえできたとしても、それは私たちが使いたい技術ではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">instead, we want to distribute the jobs across threads by sharing the single <code>receiver</code> among all the workers.</span>代わりに、すべてのワーカー間で単一の<code>receiver</code>者を共有することによって、スレッド間でジョブを分散したいと考えています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Additionally, taking a job off the channel queue involves mutating the <code>receiver</code> , so the threads need a safe way to share and modify <code>receiver</code> ;</span>また、チャネルキューから仕事を取ることは変異が含ま<code>receiver</code> 、そのスレッドが共有し、変更する安全な方法を必要とする<code>receiver</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">otherwise, we might get race conditions (as covered in Chapter 16).</span>さもなければ、我々は競争条件を得るかもしれない（第16章で説明した通り）。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Recall the thread-safe smart pointers discussed in Chapter 16: to share ownership across multiple threads and allow the threads to mutate the value, we need to use <code>Arc&lt;Mutex&lt;T&gt;&gt;</code> .</span>第16章で説明したスレッドセーフなスマートポインタを思い出してください。複数のスレッド間で所有権を共有し、スレッドが値を変更できるようにするには、 <code>Arc&lt;Mutex&lt;T&gt;&gt;</code>を使用する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Arc</code> type will let multiple workers own the receiver, and <code>Mutex</code> will ensure that only one worker gets a job from the receiver at a time.</span> <code>Arc</code>型は複数の作業者が受信機を所有できるようにし、 <code>Mutex</code>は一度に1人の作業者だけが受信機から仕事を得ることを保証します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 20-18 shows the changes we need to make.</span>リスト20-18は、変更が必要であることを示しています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/lib.rs</span></span> <span class=filename>ファイル名：src / lib.rs</span></span> </p><br><div data-lang=rust><div data-l="# use std::thread;"></div><div data-l="# use std::sync::mpsc;"></div><div data-l="use std::sync::Arc;"></div><div data-l="use std::sync::Mutex;"></div><div data-l="#// --snip--"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">--snip--</span> --snip--</span> </div><div data-l=""></div><div data-l="# pub struct ThreadPool {"></div><div data-l="#     workers: Vec&lt;Worker&gt;,"></div><div data-l="#     sender: mpsc::Sender&lt;Job&gt;,"></div><div data-l="# }"></div><div data-l="# struct Job;"></div><div data-l=#></div><div data-l="impl ThreadPool {"></div><div data-l="#    // --snip--"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">--snip--</span> --snip--</span> </div><div data-l="    pub fn new(size: usize) -&gt; ThreadPool {"></div><div data-l="        assert!(size &gt; 0);"></div><div data-l=""></div><div data-l="        let (sender, receiver) = mpsc::channel();"></div><div data-l=""></div><div data-l="        let receiver = Arc::new(Mutex::new(receiver));"></div><div data-l=""></div><div data-l="        let mut workers = Vec::with_capacity(size);"></div><div data-l=""></div><div data-l="        for id in 0..size {"></div><div data-l="            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));"></div><div data-l="        }"></div><div data-l=""></div><div data-l="        ThreadPool {"></div><div data-l="            workers,"></div><div data-l="            sender,"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=""></div><div data-l="#    // --snip--"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">--snip--</span> --snip--</span> </div><div data-l=}></div><div data-l=""></div><div data-l="# struct Worker {"></div><div data-l="#     id: usize,"></div><div data-l="#     thread: thread::JoinHandle&lt;()&gt;,"></div><div data-l="# }"></div><div data-l=#></div><div data-l="impl Worker {"></div><div data-l="    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {"></div><div data-l="#        // --snip--"></div><div data-l="        // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">--snip--</span> --snip--</span> </div><div data-l="#         let thread = thread::spawn(|| {"></div><div data-l="#            receiver;"></div><div data-l="#         });"></div><div data-l=#></div><div data-l="#         Worker {"></div><div data-l="#             id,"></div><div data-l="#             thread,"></div><div data-l="#         }"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 20-18: Sharing the receiving end of the channel among the workers using <code>Arc</code> and <code>Mutex</code></span></span> <span class=caption>リスト20-18： <code>Arc</code>と<code>Mutex</code>を使って作業者の間でチャンネルの受信側を共有する</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In <code>ThreadPool::new</code> , we put the receiving end of the channel in an <code>Arc</code> and a <code>Mutex</code> .</span> <code>ThreadPool::new</code>では、チャネルの受信側を<code>Arc</code>と<code>Mutex</code>に置きます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For each new worker, we clone the <code>Arc</code> to bump the reference count so the workers can share ownership of the receiving end.</span>新しい作業者ごとに<code>Arc</code>をクローンして参照カウントをバンプし、作業者が受信側の所有権を共有できるようにします。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">With these changes, the code compiles!</span>これらの変更により、コードはコンパイルされます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;re getting there!</span>私たちはそこに着きます！</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Implementing the <code>execute</code> Method</span> <code>execute</code>メソッドの実装</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s finally implement the <code>execute</code> method on <code>ThreadPool</code> .</span>最後に、 <code>ThreadPool</code> <code>execute</code>メソッドを実装しましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll also change <code>Job</code> from a struct to a type alias for a trait object that holds the type of closure that <code>execute</code> receives.</span>また、構造体から受信を<code>execute</code>クロージャの型を保持する特性オブジェクトの型エイリアスに<code>Job</code>を変更します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As discussed in the “Creating Type Synonyms with Type Aliases” section of Chapter 19, type aliases allow us to make long types shorter.</span>第19章の「型エイリアスを持つ型シノニムを作成する」で説明したように、型のエイリアスを使用すると、long型を短くすることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Look at Listing 20-19.</span>リスト20-19を見てください。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/lib.rs</span></span> <span class=filename>ファイル名：src / lib.rs</span></span> </p><br><div data-lang=rust><div data-l="#// --snip--"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">--snip--</span> --snip--</span> </div><div data-l="# pub struct ThreadPool {"></div><div data-l="#     workers: Vec&lt;Worker&gt;,"></div><div data-l="#     sender: mpsc::Sender&lt;Job&gt;,"></div><div data-l="# }"></div><div data-l="# use std::sync::mpsc;"></div><div data-l="# struct Worker {}"></div><div data-l=""></div><div data-l="type Job = Box&lt;FnOnce() + Send + 'static&gt;;"></div><div data-l=""></div><div data-l="impl ThreadPool {"></div><div data-l="#    // --snip--"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">--snip--</span> --snip--</span> </div><div data-l=""></div><div data-l="    pub fn execute&lt;F&gt;(&amp;self, f: F)"></div><div data-l="        where"></div><div data-l="            F: FnOnce() + Send + 'static"></div><div data-l="    {"></div><div data-l="        let job = Box::new(f);"></div><div data-l=""></div><div data-l="        self.sender.send(job).unwrap();"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="#// --snip--"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">--snip--</span> --snip--</span> </div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 20-19: Creating a <code>Job</code> type alias for a <code>Box</code> that holds each closure and then sending the job down the channel</span></span> <span class=caption>リスト20-19：各クロージャを保持している<code>Box</code> <code>Job</code>タイプエイリアスを作成し、そのジョブをチャンネルの下に送る</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">After creating a new <code>Job</code> instance using the closure we get in <code>execute</code> , we send that job down the sending end of the channel.</span> <code>execute</code>れたクロージャを使用して新しい<code>Job</code>インスタンスを作成した後、そのジョブをチャネルの送信側に送ります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;re calling <code>unwrap</code> on <code>send</code> for the case that sending fails.</span>送信が失敗した場合、 <code>send</code>で<code>unwrap</code>を呼び出しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This might happen if, for example, we stop all our threads from executing, meaning the receiving end has stopped receiving new messages.</span>これは、たとえば、受信側が新しいメッセージの受信を停止したことを意味するスレッドの実行をすべて停止する場合に発生します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">At the moment, we can&#39;t stop our threads from executing: our threads continue executing as long as the pool exists.</span>現時点では、スレッドの実行を停止することはできません。プールが存在する限り、スレッドは実行を継続します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The reason we use <code>unwrap</code> is that we know the failure case won&#39;t happen, but the compiler doesn&#39;t know that.</span>私たちが<code>unwrap</code>を使う理由は、失敗事例は起こらないが、コンパイラはそれを知りません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But we&#39;re not quite done yet!</span>しかし、まだ完了していません！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In the worker, our closure being passed to <code>thread::spawn</code> still only <i>references</i> the receiving end of the channel.</span>作業者では、closureが<code>thread::spawn</code>に渡されても、チャネルの受信側のみが<i>参照され</i>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Instead, we need the closure to loop forever, asking the receiving end of the channel for a job and running the job when it gets one.</span>代わりに、私たちはクロージャーを永遠にループし、チャネルの受信側にジョブを要求し、ジョブが取得されたときにジョブを実行する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s make the change shown in Listing 20-20 to <code>Worker::new</code> .</span>リスト20-20に示す変更を<code>Worker::new</code>ましょう。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/lib.rs</span></span> <span class=filename>ファイル名：src / lib.rs</span></span> </p><br><div data-lang=rust,ignore><div data-l="#// --snip--"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">--snip--</span> --snip--</span> </div><div data-l=""></div><div data-l="impl Worker {"></div><div data-l="    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {"></div><div data-l="        let thread = thread::spawn(move || {"></div><div data-l="            loop {"></div><div data-l="                let job = receiver.lock().unwrap().recv().unwrap();"></div><div data-l=""></div><div data-l="                println!(&quot;Worker {} got a job; executing.&quot;, id);"></div><div data-l=""></div><div data-l="                (*job)();"></div><div data-l="            }"></div><div data-l="        });"></div><div data-l=""></div><div data-l="        Worker {"></div><div data-l="            id,"></div><div data-l="            thread,"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 20-20: Receiving and executing the jobs in the worker&#39;s thread</span></span> <span class=caption>リスト20-20：ワーカのスレッドでジョブを受け取って実行する</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here, we first call <code>lock</code> on the <code>receiver</code> to acquire the mutex, and then we call <code>unwrap</code> to panic on any errors.</span>ここでは、最初に<code>receiver</code> <code>lock</code>を呼び出してミューテックスを取得し、エラーが発生した場合に<code>unwrap</code>をパニックにします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Acquiring a lock might fail if the mutex is in a <i>poisoned</i> state, which can happen if some other thread panicked while holding the lock rather than releasing the lock.</span>ミューテックスが<i>被毒</i>状態にある場合、ロックを取得することは失敗する可能性があります。これは、ロックを解放するのではなく、ロックを保持している間に他のスレッドがパニックになった場合に発生します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this situation, calling <code>unwrap</code> to have this thread panic is the correct action to take.</span>この状況では、 <code>unwrap</code>を呼び出してこのスレッドパニックが発生するのは正しい処置です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Feel free to change this <code>unwrap</code> to an <code>expect</code> with an error message that is meaningful to you.</span>この<code>unwrap</code>を<code>expect</code>に変更<code>expect</code>て、意味のあるエラーメッセージを表示してください。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we get the lock on the mutex, we call <code>recv</code> to receive a <code>Job</code> from the channel.</span> mutexのロックを取得したら、 <code>recv</code>を呼び出してチャネルから<code>Job</code>を受け取ります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A final <code>unwrap</code> moves past any errors here as well, which might occur if the thread holding the sending side of the channel has shut down, similar to how the <code>send</code> method returns <code>Err</code> if the receiving side shuts down.</span>受信側がシャットダウンした場合に<code>send</code>メソッドが<code>Err</code>返す方法と同様に、チャネルの送信側を保持するスレッドがシャットダウンした場合に発生する可能性がある、ここでのすべてのエラーを最終的な<code>unwrap</code>します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The call to <code>recv</code> blocks, so if there is no job yet, the current thread will wait until a job becomes available.</span> <code>recv</code>の呼び出しはブロックされるので、まだジョブがない場合、現在のスレッドはジョブが利用可能になるまで待機します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Mutex&lt;T&gt;</code> ensures that only one <code>Worker</code> thread at a time is trying to request a job.</span> <code>Mutex&lt;T&gt;</code>は、一度に1つの<code>Worker</code>スレッドだけがジョブを要求しようとしていることを保証します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Theoretically, this code should compile.</span>理論的には、このコードはコンパイルする必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Unfortunately, the Rust compiler isn&#39;t perfect yet, and we get this error:</span>残念ながら、Rustコンパイラは完璧ではありません。このエラーが発生します：</span> </p><br><div data-lang=text><div data-l="error[E0161]: cannot move a value of type std::ops::FnOnce() +"></div><div data-l="std::marker::Send: the size of std::ops::FnOnce() + std::marker::Send cannot be"></div><div data-l="statically determined"></div><div data-l="  --&gt; src/lib.rs:63:17"></div><div data-l="   |"></div><div data-l="63 |                 (*job)();"></div><div data-l="   |                 ^^^^^^"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This error is fairly cryptic because the problem is fairly cryptic.</span>この問題はかなり謎めいているので、このエラーはかなり謎めいています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To call a <code>FnOnce</code> closure that is stored in a <code>Box&lt;T&gt;</code> (which is what our <code>Job</code> type alias is), the closure needs to move itself <i>out</i> of the <code>Box&lt;T&gt;</code> because the closure takes ownership of <code>self</code> when we call it.</span>呼び出すには<code>FnOnce</code>中に保存されている閉鎖<code>Box&lt;T&gt;</code>私達の何である<code>Job</code>タイプの別名がある）を、閉鎖の<i>外に</i>自分自身を移動する必要がある<code>Box&lt;T&gt;</code>の閉鎖がの所有権がかかるため<code>self</code> 、我々はそれを呼び出すとき。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In general, Rust doesn&#39;t allow us to move a value out of a <code>Box&lt;T&gt;</code> because Rust doesn&#39;t know how big the value inside the <code>Box&lt;T&gt;</code> will be: recall in Chapter 15 that we used <code>Box&lt;T&gt;</code> precisely because we had something of an unknown size that we wanted to store in a <code>Box&lt;T&gt;</code> to get a value of a known size.</span>一般的には、錆は、私たちは外の値を移動することはできません<code>Box&lt;T&gt;</code>錆が内部値どのように大きな認識していないので、 <code>Box&lt;T&gt;</code>次のようになります。私たちが使用し、第15章でリコール<code>Box&lt;T&gt;</code>正確には、既知のサイズの値を取得するために<code>Box&lt;T&gt;</code>に格納したい未知のサイズのものがあったからです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As you saw in Listing 17-15, we can write methods that use the syntax <code>self: Box&lt;Self&gt;</code> , which allows the method to take ownership of a <code>Self</code> value stored in a <code>Box&lt;T&gt;</code> .</span>リスト17-15で見たように、 <code>self: Box&lt;Self&gt;</code>という構文を使用するメソッドを記述することができます。これにより、メソッドは<code>Box&lt;T&gt;</code>格納されている<code>Self</code>値の所有権を取得できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That&#39;s exactly what we want to do here, but unfortunately Rust won&#39;t let us: the part of Rust that implements behavior when a closure is called isn&#39;t implemented using <code>self: Box&lt;Self&gt;</code> .</span>これはまさにここでやりたいことですが、残念ながらRustは私たちに言いません。クロストが呼び出されたときの動作を実装するRustの部分は、 <code>self: Box&lt;Self&gt;</code>を使って実装されていません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So Rust doesn&#39;t yet understand that it could use <code>self: Box&lt;Self&gt;</code> in this situation to take ownership of the closure and move the closure out of the <code>Box&lt;T&gt;</code> .</span>だから、Rustはまだ<code>self: Box&lt;Self&gt;</code>使うことができるということを理解していません。この状況では、 <code>self: Box&lt;Self&gt;</code>はClosureの所有権を持ち、Closureを<code>Box&lt;T&gt;</code>から移動することができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust is still a work in progress with places where the compiler could be improved, but in the future, the code in Listing 20-20 should work just fine.</span> Rustはまだコンパイラが改良される場所で進行中の作業ですが、将来はリスト20-20のコードはうまくいくはずです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">People just like you are working to fix this and other issues!</span>あなたと同じような人々は、この問題やその他の問題を解決するために取り組んでいます！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">After you&#39;ve finished this book, we would love for you to join in.</span>あなたがこの本を終えた後、我々はあなたが参加するのが大好きです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But for now, let&#39;s work around this problem using a handy trick.</span>しかし、今のところ、この問題を回避するために便利なテクニックを使って作業しましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can tell Rust explicitly that in this case we can take ownership of the value inside the <code>Box&lt;T&gt;</code> using <code>self: Box&lt;Self&gt;</code> ;</span>この場合、 <code>Box&lt;T&gt;</code>内の値の所有権を<code>self: Box&lt;Self&gt;</code>を使って取得することができることをRustに明示することができます<code>self: Box&lt;Self&gt;</code> ;</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">then, once we have ownership of the closure, we can call it.</span>その後、クロージャの所有権があれば、それを呼び出すことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This involves defining a new trait <code>FnBox</code> with the method <code>call_box</code> that will use <code>self: Box&lt;Self&gt;</code> in its signature, defining <code>FnBox</code> for any type that implements <code>FnOnce()</code> , changing our type alias to use the new trait, and changing <code>Worker</code> to use the <code>call_box</code> method.</span>これは、 <code>FnOnce()</code>を実装する任意の型に対して<code>FnBox</code>を定義し、新しい型を使用するために型名を変更し、使用する<code>Worker</code>を変更するために、 <code>self: Box&lt;Self&gt;</code>を使用する<code>call_box</code>メソッドで新しい特性<code>FnBox</code>を定義することを含む<code>call_box</code>メソッド。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These changes are shown in Listing 20-21.</span>これらの変更をリスト20-21に示します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/lib.rs</span></span> <span class=filename>ファイル名：src / lib.rs</span></span> </p><br><div data-lang=rust,ignore><div data-l="trait FnBox {"></div><div data-l="    fn call_box(self: Box&lt;Self&gt;);"></div><div data-l=}></div><div data-l=""></div><div data-l="impl&lt;F: FnOnce()&gt; FnBox for F {"></div><div data-l="    fn call_box(self: Box&lt;F&gt;) {"></div><div data-l="        (*self)()"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="type Job = Box&lt;FnBox + Send + 'static&gt;;"></div><div data-l=""></div><div data-l="#// --snip--"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">--snip--</span> --snip--</span> </div><div data-l=""></div><div data-l="impl Worker {"></div><div data-l="    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {"></div><div data-l="        let thread = thread::spawn(move || {"></div><div data-l="            loop {"></div><div data-l="                let job = receiver.lock().unwrap().recv().unwrap();"></div><div data-l=""></div><div data-l="                println!(&quot;Worker {} got a job; executing.&quot;, id);"></div><div data-l=""></div><div data-l="                job.call_box();"></div><div data-l="            }"></div><div data-l="        });"></div><div data-l=""></div><div data-l="        Worker {"></div><div data-l="            id,"></div><div data-l="            thread,"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 20-21: Adding a new trait <code>FnBox</code> to work around the current limitations of <code>Box&lt;FnOnce()&gt;</code></span></span> <span class=caption>リスト20-21： <code>Box&lt;FnOnce()&gt;</code>現在の制限を回避するための新しいtrait <code>FnBox</code>追加</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">First, we create a new trait named <code>FnBox</code> .</span>まず、 <code>FnBox</code>という名前の新しい形質を作成します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This trait has the one method <code>call_box</code> , which is similar to the <code>call</code> methods on the other <code>Fn*</code> traits except that it takes <code>self: Box&lt;Self&gt;</code> to take ownership of <code>self</code> and move the value out of the <code>Box&lt;T&gt;</code> .</span>この特性は<code>call_box</code>という1つのメソッドを<code>call_box</code> 。これは、他の<code>Fn*</code>特性の<code>call</code>メソッドに似てい<code>call</code> 、それは<code>self: Box&lt;Self&gt;</code>取ります<code>self: Box&lt;Self&gt;</code>は、 <code>self</code>所有権を持ち、 <code>Box&lt;T&gt;</code>から値を移動します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Next, we implement the <code>FnBox</code> trait for any type <code>F</code> that implements the <code>FnOnce()</code> trait.</span>次に、 <code>FnOnce()</code>特性を実装する任意のタイプ<code>F</code> <code>FnBox</code>特性を実装します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Effectively, this means that any <code>FnOnce()</code> closures can use our <code>call_box</code> method.</span>効果的には、これはすべての<code>FnOnce()</code>クロージャが<code>call_box</code>メソッドを使用できることを意味します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The implementation of <code>call_box</code> uses <code>(*self)()</code> to move the closure out of the <code>Box&lt;T&gt;</code> and call the closure.</span> <code>call_box</code>の実装は、 <code>(*self)()</code>を使用して<code>Box&lt;T&gt;</code>からクロージャを移動し、クロージャを呼び出します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We now need our <code>Job</code> type alias to be a <code>Box</code> of anything that implements our new trait <code>FnBox</code> .</span>私たちは今、私たちの新しい<code>FnBox</code>を実装するものの<code>Box</code>となるように、 <code>Job</code>タイプエイリアスが必要<code>FnBox</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This will allow us to use <code>call_box</code> in <code>Worker</code> when we get a <code>Job</code> value instead of invoking the closure directly.</span>これにより、クロージャを直接呼び出すのではなく、 <code>Job</code>値を取得したときに<code>Worker</code> <code>call_box</code>を使用することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Implementing the <code>FnBox</code> trait for any <code>FnOnce()</code> closure means we don&#39;t have to change anything about the actual values we&#39;re sending down the channel.</span>任意の<code>FnOnce()</code>クロージャの<code>FnBox</code>特性を実装することは、チャンネルを送信する実際の値について何も変更する必要がないことを意味します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now Rust is able to recognize that what we want to do is fine.</span>今、錆は私たちがしたいことがうまくいくことを認識することができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This trick is very sneaky and complicated.</span>このトリックは非常に卑劣で複雑です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Don&#39;t worry if it doesn&#39;t make perfect sense;</span>完璧な意味合いがないのであれば心配しないでください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">someday, it will be completely unnecessary.</span>いつかは、まったく必要ないでしょう。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">With the implementation of this trick, our thread pool is in a working state!</span>このトリックの実装では、私たちのスレッドプールは動作状態にあります！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Give it a <code>cargo run</code> and make some requests:</span>それに<code>cargo run</code>を与え、いくつかの要求をする：</span> </p><br><div data-lang=text><div data-l="$ cargo run"></div><div data-l="   Compiling hello v0.1.0 (file:///projects/hello)"></div><div data-l="warning: field is never used: `workers`"></div><div data-l=" --&gt; src/lib.rs:7:5"></div><div data-l="  |"></div><div data-l="7 |     workers: Vec&lt;Worker&gt;,"></div><div data-l="  |     ^^^^^^^^^^^^^^^^^^^^"></div><div data-l="  |"></div><div data-l="  = note: #[warn(dead_code)] on by default"></div><div data-l=""></div><div data-l="warning: field is never used: `id`"></div><div data-l="  --&gt; src/lib.rs:61:5"></div><div data-l="   |"></div><div data-l="61 |     id: usize,"></div><div data-l="   |     ^^^^^^^^^"></div><div data-l="   |"></div><div data-l="   = note: #[warn(dead_code)] on by default"></div><div data-l=""></div><div data-l="warning: field is never used: `thread`"></div><div data-l="  --&gt; src/lib.rs:62:5"></div><div data-l="   |"></div><div data-l="62 |     thread: thread::JoinHandle&lt;()&gt;,"></div><div data-l="   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"></div><div data-l="   |"></div><div data-l="   = note: #[warn(dead_code)] on by default"></div><div data-l=""></div><div data-l="    Finished dev [unoptimized + debuginfo] target(s) in 0.99 secs"></div><div data-l="     Running `target/debug/hello`"></div><div data-l="Worker 0 got a job; executing."></div><div data-l="Worker 2 got a job; executing."></div><div data-l="Worker 1 got a job; executing."></div><div data-l="Worker 3 got a job; executing."></div><div data-l="Worker 0 got a job; executing."></div><div data-l="Worker 2 got a job; executing."></div><div data-l="Worker 1 got a job; executing."></div><div data-l="Worker 3 got a job; executing."></div><div data-l="Worker 0 got a job; executing."></div><div data-l="Worker 2 got a job; executing."></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Success!</span>成功！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We now have a thread pool that executes connections asynchronously.</span>非同期に接続を実行するスレッドプールが用意されました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There are never more than four threads created, so our system won&#39;t get overloaded if the server receives a lot of requests.</span>決して4つ以上のスレッドが作成されることはありません。そのため、サーバーが多くの要求を受け取ると、システムが過負荷になることはありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we make a request to <i>/sleep</i> , the server will be able to serve other requests by having another thread run them.</span> <i>/ sleepを</i>要求すると、サーバーは別のスレッドに別のスレッドを実行させることで、他の要求を提供することができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">After learning about the <code>while let</code> loop in Chapter 18, you might be wondering why we didn&#39;t write the worker thread code as shown in Listing 20-22.</span>第18章でwhileループ<code>while let</code>学習した後、リスト20-22に示すようにワーカースレッドコードを記述しなかった理由が不思議に思えるかもしれません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/lib.rs</span></span> <span class=filename>ファイル名：src / lib.rs</span></span> </p><br><div data-lang=rust,ignore><div data-l="#// --snip--"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">--snip--</span> --snip--</span> </div><div data-l=""></div><div data-l="impl Worker {"></div><div data-l="    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {"></div><div data-l="        let thread = thread::spawn(move || {"></div><div data-l="            while let Ok(job) = receiver.lock().unwrap().recv() {"></div><div data-l="                println!(&quot;Worker {} got a job; executing.&quot;, id);"></div><div data-l=""></div><div data-l="                job.call_box();"></div><div data-l="            }"></div><div data-l="        });"></div><div data-l=""></div><div data-l="        Worker {"></div><div data-l="            id,"></div><div data-l="            thread,"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 20-22: An alternative implementation of <code>Worker::new</code> using <code>while let</code></span></span> <span class=caption>リスト20-22： <code>while let</code>を使用<code>while let</code> <code>Worker::new</code>の別の実装を使用<code>while let</code></span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This code compiles and runs but doesn&#39;t result in the desired threading behavior: a slow request will still cause other requests to wait to be processed.</span>このコードはコンパイルされ実行されますが、望ましいスレッド動作が行われません。低速の要求でも、他の要求が処理されるのを待ちます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The reason is somewhat subtle: the <code>Mutex</code> struct has no public <code>unlock</code> method because the ownership of the lock is based on the lifetime of the <code>MutexGuard&lt;T&gt;</code> within the <code>LockResult&lt;MutexGuard&lt;T&gt;&gt;</code> that the <code>lock</code> method returns.</span> <code>unlock</code>の所有権は、 <code>lock</code>メソッドが返す<code>LockResult&lt;MutexGuard&lt;T&gt;&gt;</code>内の<code>MutexGuard&lt;T&gt;</code>存続期間に基づいているため、 <code>Mutex</code>構造体には公開<code>unlock</code>メソッドがありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">At compile time, the borrow checker can then enforce the rule that a resource guarded by a <code>Mutex</code> cannot be accessed unless we hold the lock.</span>コンパイル時に、borrowチェッカーは、ロックを保持しない限り、 <code>Mutex</code>によって保護されているリソースにアクセスできないという規則を適用することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But this implementation can also result in the lock being held longer than intended if we don&#39;t think carefully about the lifetime of the <code>MutexGuard&lt;T&gt;</code> .</span>しかし、この実装は、 <code>MutexGuard&lt;T&gt;</code>存続期間を注意深く考えないと、ロックが意図したより長く保持される可能性もあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because the values in the <code>while</code> expression remain in scope for the duration of the block, the lock remains held for the duration of the call to <code>job.call_box()</code> , meaning other workers cannot receive jobs.</span> <code>while</code>式の値はブロックの持続時間の範囲内にとどまるため、ロックは<code>job.call_box()</code>呼び出しの間保持されたままであり、他のワーカーがジョブを受け取ることができないことを意味します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">By using <code>loop</code> instead and acquiring the lock and a job within the block rather than outside it, the <code>MutexGuard</code> returned from the <code>lock</code> method is dropped as soon as the <code>let job</code> statement ends.</span>代わりに<code>loop</code>を使用して、ロックとそれ以外のブロック内のジョブを取得することで、 <code>lock</code>メソッドから返された<code>MutexGuard</code>は、 <code>let job</code>ステートメントが終了するとすぐに削除されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This ensures that the lock is held during the call to <code>recv</code> , but it is released before the call to <code>job.call_box()</code> , allowing multiple requests to be serviced concurrently.</span>これにより、 <code>recv</code>の呼び出し中にロックが保持されますが、 <code>job.call_box()</code>呼び出す前にロックが解除され、複数の要求を同時に処理できるようになります。</span> </p><script>_addload(function(){_setupIW('com');_csi('en','ja','ch20-02-multithreaded.html');});</script><script type="text/javascript">function gtElInit() {var lib = new google.translate.TranslateService();lib.translatePage('en', 'ja', function () {});}</script><script type="text/javascript" src="https://translate.google.com/translate_a/element.js?cb=gtElInit&client=wt"></script>