<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180709_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=ch15-06-reference-cycles.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Reference Cycles Can Leak Memory</span>リファレンスサイクルがメモリをリークする可能性がある</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust&#39;s memory safety guarantees make it difficult, but not impossible, to accidentally create memory that is never cleaned up (known as a <i>memory leak</i> ).</span> Rustのメモリ安全性保証により、決して決して浄化されないメモリ（ <i>メモリリークと</i>呼ばれる）を誤って作成することは、不可能ではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Preventing memory leaks entirely is not one of Rust&#39;s guarantees in the same way that disallowing data races at compile time is, meaning memory leaks are memory safe in Rust.</span>メモリリークを完全に防ぐことは、コンパイル時にデータ競合を禁止するのと同じ方法で、Rustの保証の1つではなく、メモリリークがRustでメモリセーフであることを意味します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can see that Rust allows memory leaks by using <code>Rc&lt;T&gt;</code> and <code>RefCell&lt;T&gt;</code> : it&#39;s possible to create references where items refer to each other in a cycle.</span> Rustは<code>Rc&lt;T&gt;</code>と<code>RefCell&lt;T&gt;</code>を使用してメモリリークを許可することがわかります。アイテムがサイクル内で互いに参照する参照を作成することは可能です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This creates memory leaks because the reference count of each item in the cycle will never reach 0, and the values will never be dropped.</span>これにより、サイクル内の各アイテムの参照カウントが決して0にならず、値が決して破棄されないため、メモリリークが発生します。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Creating a Reference Cycle</span>参照サイクルの作成</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s look at how a reference cycle might happen and how to prevent it, starting with the definition of the <code>List</code> enum and a <code>tail</code> method in Listing 15-25:</span>リスト15-25の<code>List</code> enumと<code>tail</code>メソッドの定義から始めて、参照サイクルがどのように起こるか、そしてそれを防ぐ方法を見てみましょう：</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><p><!-- Hidden fn main is here to disable the automatic wrapping in fn main that
doc tests do; the `use List` fails if this listing is put within a main --></p><br><div data-lang=rust><div data-l="# fn main() {}"></div><div data-l="use std::rc::Rc;"></div><div data-l="use std::cell::RefCell;"></div><div data-l="use List::{Cons, Nil};"></div><div data-l=""></div><div data-l=#[derive(Debug)]></div><div data-l="enum List {"></div><div data-l="    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),"></div><div data-l="    Nil,"></div><div data-l=}></div><div data-l=""></div><div data-l="impl List {"></div><div data-l="    fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {"></div><div data-l="        match *self {"></div><div data-l="            Cons(_, ref item) =&gt; Some(item),"></div><div data-l="            Nil =&gt; None,"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 15-25: A cons list definition that holds a <code>RefCell&lt;T&gt;</code> so we can modify what a <code>Cons</code> variant is referring to</span></span> <span class=caption>15-25リスト：保持短所リスト定義<code>RefCell&lt;T&gt;</code>私たちは何を修正することができるように<code>Cons</code>バリアントが参照しています</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;re using another variation of the <code>List</code> definition in Listing 15-5.</span>リスト15-5の<code>List</code>定義の別のバリエーションを使用しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The second element in the <code>Cons</code> variant is now <code>RefCell&lt;Rc&lt;List&gt;&gt;</code> , meaning that instead of having the ability to modify the <code>i32</code> value as we did in Listing 15-24, we want to modify which <code>List</code> value a <code>Cons</code> variant is pointing to.</span> <code>Cons</code>バリアントの2番目の要素は<code>RefCell&lt;Rc&lt;List&gt;&gt;</code> 。つまり、リスト15-24のように<code>i32</code>値を変更するのではなく、 <code>Cons</code>バリアントが指している<code>List</code>値を変更する必要がありますに。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;re also adding a <code>tail</code> method to make it convenient for us to access the second item if we have a <code>Cons</code> variant.</span>また、 <code>Cons</code>バリアントがあれば、2番目のアイテムにアクセスするのに便利な<code>tail</code>メソッドを追加しています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In Listing 15-26, we&#39;re adding a <code>main</code> function that uses the definitions in Listing 15-25.</span>リスト15-26に、リスト15-25の定義を使用する<code>main</code>関数を追加します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This code creates a list in <code>a</code> and a list in <code>b</code> that points to the list in <code>a</code> .</span>このコードは、リスト作成と、リスト<code>a</code> <code>b</code>内のリストを指します。 <code>a</code></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then it modifies the list in <code>a</code> to point to <code>b</code> , creating a reference cycle.</span>次に、 <code>a</code>のリストを<code>b</code>を指すように変更して、参照サイクルを作成します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There are <code>println€</code> statements along the way to show what the reference counts are at various points in this process.</span>このプロセスのさまざまな時点で参照カウントが何であるかを示すために途中で<code>println€</code>文があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="# use List::{Cons, Nil};"></div><div data-l="# use std::rc::Rc;"></div><div data-l="# use std::cell::RefCell;"></div><div data-l="# #[derive(Debug)]"></div><div data-l="# enum List {"></div><div data-l="#     Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),"></div><div data-l="#     Nil,"></div><div data-l="# }"></div><div data-l=#></div><div data-l="# impl List {"></div><div data-l="#     fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {"></div><div data-l="#         match *self {"></div><div data-l="#             Cons(_, ref item) =&gt; Some(item),"></div><div data-l="#             Nil =&gt; None,"></div><div data-l="#         }"></div><div data-l="#     }"></div><div data-l="# }"></div><div data-l=#></div><div data-l="fn main() {"></div><div data-l="    let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));"></div><div data-l=""></div><div data-l="    println!(&quot;a initial rc count = {}&quot;, Rc::strong_count(&amp;a));"></div><div data-l="    println!(&quot;a next item = {:?}&quot;, a.tail());"></div><div data-l=""></div><div data-l="    let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&amp;a))));"></div><div data-l=""></div><div data-l="    println!(&quot;a rc count after b creation = {}&quot;, Rc::strong_count(&amp;a));"></div><div data-l="    println!(&quot;b initial rc count = {}&quot;, Rc::strong_count(&amp;b));"></div><div data-l="    println!(&quot;b next item = {:?}&quot;, b.tail());"></div><div data-l=""></div><div data-l="    if let Some(link) = a.tail() {"></div><div data-l="        *link.borrow_mut() = Rc::clone(&amp;b);"></div><div data-l="    }"></div><div data-l=""></div><div data-l="    println!(&quot;b rc count after changing a = {}&quot;, Rc::strong_count(&amp;b));"></div><div data-l="    println!(&quot;a rc count after changing a = {}&quot;, Rc::strong_count(&amp;a));"></div><div data-l=""></div><div data-l="#    // Uncomment the next line to see that we have a cycle;"></div><div data-l="#    // it will overflow the stack"></div><div data-l="#    // println!(&quot;a next item = {:?}&quot;, a.tail());"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Uncomment the next line to see that we have a cycle;</span>次の行のコメントを外して、サイクルがあることを確認します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">it will overflow the stack println!(&quot;a next item = {:?}&quot;, a.tail());</span>それはスタックprintln！（ &quot;次のアイテム= {：？}&quot;、a.tail（））をオーバーフローさせます。</span> </div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 15-26: Creating a reference cycle of two <code>List</code> values pointing to each other</span></span> <span class=caption>リスト15-26：互いに指し示す2つの<code>List</code>値の参照サイクルを作成する</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We create an <code>Rc&lt;List&gt;</code> instance holding a <code>List</code> value in the variable <code>a</code> with an initial list of <code>5, Nil</code> .</span>最初のリストが<code>5, Nil</code>変数<code>a</code> <code>List</code>値を保持する<code>Rc&lt;List&gt;</code>インスタンスを作成します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We then create an <code>Rc&lt;List&gt;</code> instance holding another <code>List</code> value in the variable <code>b</code> that contains the value 10 and points to the list in <code>a</code> .</span>私たちは、その後、作成<code>Rc&lt;List&gt;</code>別の保持のインスタンス<code>List</code>変数に値を<code>b</code>でリストに値10と点を含んでいます。 <code>a</code></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We modify <code>a</code> so it points to <code>b</code> instead of <code>Nil</code> , creating a cycle.</span>私は<code>a</code>を修正して<code>a</code> <code>Nil</code>代わりに<code>b</code>を指し、サイクルを作ります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We do that by using the <code>tail</code> method to get a reference to the <code>RefCell&lt;Rc&lt;List&gt;&gt;</code> in <code>a</code> , which we put in the variable <code>link</code> .</span>私たちは、使用していることを行う<code>tail</code>への参照を取得する方法を<code>RefCell&lt;Rc&lt;List&gt;&gt;</code>で、我々は変数に入れて、 <code>a</code> <code>link</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then we use the <code>borrow_mut</code> method on the <code>RefCell&lt;Rc&lt;List&gt;&gt;</code> to change the value inside from an <code>Rc&lt;List&gt;</code> that holds a <code>Nil</code> value to the <code>Rc&lt;List&gt;</code> in <code>b</code> .</span>次に<code>RefCell&lt;Rc&lt;List&gt;&gt;</code>の<code>borrow_mut</code>メソッドを使用して、 <code>Nil</code>値を保持する<code>Rc&lt;List&gt;</code>から内部の値を<code>b</code> <code>Rc&lt;List&gt;</code>します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When we run this code, keeping the last <code>println€</code> commented out for the moment, we&#39;ll get this output:</span>このコードを実行すると、最後の<code>println€</code>コメントアウトされたままになって<code>println€</code>ば、次の出力が得られます：</span> </p><br><div data-lang=text><div data-l="a initial rc count = 1"></div><div data-l="a next item = Some(RefCell { value: Nil })"></div><div data-l="a rc count after b creation = 2"></div><div data-l="b initial rc count = 1"></div><div data-l="b next item = Some(RefCell { value: Cons(5, RefCell { value: Nil }) })"></div><div data-l="b rc count after changing a = 2"></div><div data-l="a rc count after changing a = 2"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The reference count of the <code>Rc&lt;List&gt;</code> instances in both <code>a</code> and <code>b</code> are 2 after we change the list in <code>a</code> to point to <code>b</code> .</span>参照カウント<code>Rc&lt;List&gt;</code>の両方でインスタンス<code>a</code>と<code>b</code>我々はリストを変更した後、2ですを指すように<code>a</code> <code>b</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">At the end of <code>main</code> , Rust will try to drop <code>b</code> first, which will decrease the count in each of the <code>Rc&lt;List&gt;</code> instances in <code>a</code> and <code>b</code> by 1.</span> <code>main</code>の最後で、Rustは最初に<code>b</code>を落とそうとし、 <code>a</code>と<code>b</code>の<code>Rc&lt;List&gt;</code>インスタンスのそれぞれの数を1減らします。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, because <code>a</code> is still referencing the <code>Rc&lt;List&gt;</code> that was in <code>b</code> , that <code>Rc&lt;List&gt;</code> has a count of 1 rather than 0, so the memory the <code>Rc&lt;List&gt;</code> has on the heap won&#39;t be dropped.</span>しかし、まだ参照している<code>a</code> <code>Rc&lt;List&gt;</code>にあった<code>b</code>することを、 <code>Rc&lt;List&gt;</code> 1ではなく0の数を持っているので、メモリ<code>Rc&lt;List&gt;</code>ドロップされることはありませんヒープ上にあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The memory will just sit there with a count of 1, forever.</span>メモリは永遠に1のカウントでそこに座ります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To visualize this reference cycle, we&#39;ve created a diagram in Figure 15-4.</span>この参照サイクルを視覚化するために、図15-4の図を作成しました。</span> </p><br><p><img alt="リストの参照サイクル" src=img/trpl15-04.svg class=center /></p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Figure 15-4: A reference cycle of lists <code>a</code> and <code>b</code> pointing to each other</span></span> <span class=caption>図15-4：互いに指し示すリスト<code>a</code>と<code>b</code>参照サイクル</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you uncomment the last <code>println€</code> and run the program, Rust will try to print this cycle with <code>a</code> pointing to <code>b</code> pointing to <code>a</code> and so forth until it overflows the stack.</span>あなたが最後のコメントを解除した場合<code>println€</code> 、プログラムを実行し、錆がでこのサイクルを印刷しようとするポインティング<code>a</code> <code>b</code>を指して、それがスタックをオーバーフローするまで、などと。 <code>a</code></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this case, right after we create the reference cycle, the program ends.</span>この場合、参照サイクルを作成した直後に、プログラムは終了します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The consequences of this cycle aren&#39;t very dire.</span>このサイクルの結果はあまり悲惨ではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, if a more complex program allocated lots of memory in a cycle and held onto it for a long time, the program would use more memory than it needed and might overwhelm the system, causing it to run out of available memory.</span>しかし、より複雑なプログラムが1つのサイクルで大量のメモリを割り当てて長時間保持すると、プログラムは必要以上のメモリを使用し、システムを圧倒して使用可能なメモリが使い果たされる可能性があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Creating reference cycles is not easily done, but it&#39;s not impossible either.</span>参照サイクルの作成は簡単ではありませんが、不可能ではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you have <code>RefCell&lt;T&gt;</code> values that contain <code>Rc&lt;T&gt;</code> values or similar nested combinations of types with interior mutability and reference counting, you must ensure that you don&#39;t create cycles;</span> <code>Rc&lt;T&gt;</code>値または内部の変更可能性と参照カウントを持つタイプの同様のネストされた組み合わせを含む<code>RefCell&lt;T&gt;</code>値がある場合は、サイクルを作成しないようにする必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">you can&#39;t rely on Rust to catch them.</span>あなたはそれらを捕まえるために錆に頼ることはできません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Creating a reference cycle would be a logic bug in your program that you should use automated tests, code reviews, and other software development practices to minimize.</span>参照サイクルを作成することは、自動化されたテスト、コードレビュー、およびその他のソフトウェア開発の慣行を最小限に抑えるために、プログラムのロジックバグになります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Another solution for avoiding reference cycles is reorganizing your data structures so that some references express ownership and some references don&#39;t.</span>参照サイクルを回避するもう1つの方法は、データ構造を再編成して、一部の参照が所有権を表し、一部の参照が所有権を示さないようにすることです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As a result, you can have cycles made up of some ownership relationships and some non-ownership relationships, and only the ownership relationships affect whether or not a value can be dropped.</span>その結果、いくつかの所有関係といくつかの非所有関係からなるサイクルを持つことができ、所有関係だけが値を削除できるかどうかに影響します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In Listing 15-25, we always want <code>Cons</code> variants to own their list, so reorganizing the data structure isn&#39;t possible.</span>リスト15-25では、 <code>Cons</code>バリアントが常にリストを所有するようにしたいので、データ構造を再編成することはできません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s look at an example using graphs made up of parent nodes and child nodes to see when non-ownership relationships are an appropriate way to prevent reference cycles.</span>親ノードと子ノードで構成されるグラフを使用して、非所有関係が参照サイクルを防止する適切な方法であるかどうかを確認する例を見てみましょう。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Preventing Reference Cycles: Turning an <code>Rc&lt;T&gt;</code> into a <code>Weak&lt;T&gt;</code></span>リファレンスサイクルの防止： <code>Rc&lt;T&gt;</code>を<code>Weak&lt;T&gt;</code>変える</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So far, we&#39;ve demonstrated that calling <code>Rc::clone</code> increases the <code>strong_count</code> of an <code>Rc&lt;T&gt;</code> instance, and an <code>Rc&lt;T&gt;</code> instance is only cleaned up if its <code>strong_count</code> is 0. You can also create a <i>weak reference</i> to the value within an <code>Rc&lt;T&gt;</code> instance by calling <code>Rc::downgrade</code> and passing a reference to the <code>Rc&lt;T&gt;</code> .</span>これまで、 <code>Rc::clone</code>を呼び出すと<code>Rc::clone</code> <code>Rc&lt;T&gt;</code>インスタンスの<code>strong_count</code>が増加し、 <code>Rc&lt;T&gt;</code>インスタンスはその<code>strong_count</code>が0の場合にのみクリーンアップされることが<i>示さ</i>れています。 <code>Rc::downgrade</code>を呼び出して<code>Rc&lt;T&gt;</code>への参照を渡すことにより、 <code>Rc&lt;T&gt;</code>インスタンス内の値を取得します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When you call <code>Rc::downgrade</code> , you get a smart pointer of type <code>Weak&lt;T&gt;</code> .</span> <code>Rc::downgrade</code>を呼び出すと<code>Weak&lt;T&gt;</code>型のスマートポインタが得られます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Instead of increasing the <code>strong_count</code> in the <code>Rc&lt;T&gt;</code> instance by 1, calling <code>Rc::downgrade</code> increases the <code>weak_count</code> by 1. The <code>Rc&lt;T&gt;</code> type uses <code>weak_count</code> to keep track of how many <code>Weak&lt;T&gt;</code> references exist, similar to <code>strong_count</code> .</span>代わり増加の<code>strong_count</code>で<code>Rc&lt;T&gt;</code>を呼び出す、1インスタンスを<code>Rc::downgrade</code>増加<code>weak_count</code> 1だけ<code>Rc&lt;T&gt;</code>型が使用<code>weak_count</code>どのように多くのトラック維持する<code>Weak&lt;T&gt;</code>と同様、参照が存在し<code>strong_count</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The difference is the <code>weak_count</code> doesn&#39;t need to be 0 for the <code>Rc&lt;T&gt;</code> instance to be cleaned up.</span>違いは、 <code>Rc&lt;T&gt;</code>インスタンスをクリーンアップするには、 <code>weak_count</code> 0にする必要はないということです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Strong references are how you can share ownership of an <code>Rc&lt;T&gt;</code> instance.</span>強力な参照は、 <code>Rc&lt;T&gt;</code>インスタンスの所有権を共有する方法です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Weak references don&#39;t express an ownership relationship.</span>弱い参照は所有関係を表していません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">They won&#39;t cause a reference cycle because any cycle involving some weak references will be broken once the strong reference count of values involved is 0.</span>関連する値の強い参照カウントが0になると、弱い参照を含むサイクルが壊れるため、参照サイクルが発生しません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because the value that <code>Weak&lt;T&gt;</code> references might have been dropped, to do anything with the value that a <code>Weak&lt;T&gt;</code> is pointing to, you must make sure the value still exists.</span> <code>Weak&lt;T&gt;</code>参照している値が削除されている可能性があるため、 <code>Weak&lt;T&gt;</code>が指す値で何かを行うには、その値がまだ存在することを確認する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Do this by calling the <code>upgrade</code> method on a <code>Weak&lt;T&gt;</code> instance, which will return an <code>Option&lt;Rc&lt;T&gt;&gt;</code> .</span>これを行うには、 <code>Option&lt;Rc&lt;T&gt;&gt;</code>を返す<code>Weak&lt;T&gt;</code>インスタンスの<code>upgrade</code>メソッドを呼び出し<code>upgrade</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You&#39;ll get a result of <code>Some</code> if the <code>Rc&lt;T&gt;</code> value has not been dropped yet and a result of <code>None</code> if the <code>Rc&lt;T&gt;</code> value has been dropped.</span>あなたは結果を得るだろう<code>Some</code>場合<code>Rc&lt;T&gt;</code>値がまだ削除されていないとの結果<code>None</code>場合<code>Rc&lt;T&gt;</code>値が削除されました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because <code>upgrade</code> returns an <code>Option&lt;T&gt;</code> , Rust will ensure that the <code>Some</code> case and the <code>None</code> case are handled, and there won&#39;t be an invalid pointer.</span> <code>upgrade</code>は<code>Option&lt;T&gt;</code>返すので、Rustは<code>Some</code> caseと<code>None</code>ケースが処理され、無効なポインタが存在しないことを保証します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As an example, rather than using a list whose items know only about the next item, we&#39;ll create a tree whose items know about their children items <i>and</i> their parent items.</span>例として、アイテムが次のアイテムのみを知っているリストを使用するのではなく、アイテムが子アイテム<i>と</i>その親アイテムについて知っているツリーを作成します。</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Creating a Tree Data Structure: a <code>Node</code> with Child Nodes</span>ツリーデータ構造の作成： <code>Node</code>の子ノードとし</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To start, we&#39;ll build a tree with nodes that know about their child nodes.</span>まず、子ノードについて知っているノードを持つツリーを構築します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll create a struct named <code>Node</code> that holds its own <code>i32</code> value as well as references to its children <code>Node</code> values:</span>私たちは、構造体の名前の作成します<code>Node</code>自身の保持している<code>i32</code>その子への参照だけでなく、値を<code>Node</code>値を：</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="use std::rc::Rc;"></div><div data-l="use std::cell::RefCell;"></div><div data-l=""></div><div data-l=#[derive(Debug)]></div><div data-l="struct Node {"></div><div data-l="    value: i32,"></div><div data-l="    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We want a <code>Node</code> to own its children, and we want to share that ownership with variables so we can access each <code>Node</code> in the tree directly.</span> <code>Node</code>はその子を所有したいので、ツリー内の各<code>Node</code>に直接アクセスできるように、その所有権を変数と共有する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To do this, we define the <code>Vec&lt;T&gt;</code> items to be values of type <code>Rc&lt;Node&gt;</code> .</span>これを行うために、 <code>Vec&lt;T&gt;</code>項目を<code>Rc&lt;Node&gt;</code>型の値と定義します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We also want to modify which nodes are children of another node, so we have a <code>RefCell&lt;T&gt;</code> in <code>children</code> around the <code>Vec&lt;Rc&lt;Node&gt;&gt;</code> .</span>また、どのノードが別のノードの子ノードであるかを変更したいので、 <code>Vec&lt;Rc&lt;Node&gt;&gt;</code> <code>children</code>ノードに<code>RefCell&lt;T&gt;</code>があり<code>Vec&lt;Rc&lt;Node&gt;&gt;</code> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Next, we&#39;ll use our struct definition and create one <code>Node</code> instance named <code>leaf</code> with the value 3 and no children, and another instance named <code>branch</code> with the value 5 and <code>leaf</code> as one of its children, as shown in Listing 15-27:</span>次に、我々は我々の構造体定義を使用しますと、1つの作成<code>Node</code>インスタンスという名前の<code>leaf</code>値3と子供がいない、と別のインスタンスの名前で<code>branch</code>値5とで<code>leaf</code> 15-27リストに示すように、その子の1つとして：</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="# use std::rc::Rc;"></div><div data-l="# use std::cell::RefCell;"></div><div data-l=#></div><div data-l="# #[derive(Debug)]"></div><div data-l="# struct Node {"></div><div data-l="#     value: i32,"></div><div data-l="#    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,"></div><div data-l="# }"></div><div data-l=#></div><div data-l="fn main() {"></div><div data-l="    let leaf = Rc::new(Node {"></div><div data-l="        value: 3,"></div><div data-l="        children: RefCell::new(vec![]),"></div><div data-l="    });"></div><div data-l=""></div><div data-l="    let branch = Rc::new(Node {"></div><div data-l="        value: 5,"></div><div data-l="        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),"></div><div data-l="    });"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 15-27: Creating a <code>leaf</code> node with no children and a <code>branch</code> node with <code>leaf</code> as one of its children</span></span> <span class=caption>15-27リスト：作成<code>leaf</code>子を持たないノードと<code>branch</code>を持つノード<code>leaf</code>その子の1つとして、</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We clone the <code>Rc&lt;Node&gt;</code> in <code>leaf</code> and store that in <code>branch</code> , meaning the <code>Node</code> in <code>leaf</code> now has two owners: <code>leaf</code> and <code>branch</code> .</span>私たちは、クローン<code>Rc&lt;Node&gt;</code>に<code>leaf</code>とのそれを保存<code>branch</code>意味、 <code>Node</code>内<code>leaf</code>今2つのオーナーあり： <code>leaf</code>や<code>branch</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can get from <code>branch</code> to <code>leaf</code> through <code>branch.children</code> , but there&#39;s no way to get from <code>leaf</code> to <code>branch</code> .</span>私たちは<code>branch.children</code>を通して、 <code>branch</code>から<code>leaf</code>まで得ることができますが、 <code>leaf</code>から<code>branch</code>に到達する方法はありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The reason is that <code>leaf</code> has no reference to <code>branch</code> and doesn&#39;t know they&#39;re related.</span>その理由は、 <code>leaf</code>は<code>branch</code>への参照を持たず、それらが関連していることを知らないからです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We want <code>leaf</code> to know that <code>branch</code> is its parent.</span>私たちは、 <code>leaf</code>が<code>branch</code>がその親であることを知ることを望みます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll do that next.</span>私たちは次にそれを行います。</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Adding a Reference from a Child to Its Parent</span>子から親への参照の追加</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To make the child node aware of its parent, we need to add a <code>parent</code> field to our <code>Node</code> struct definition.</span>子ノードがその親を認識するようにするには、 <code>Node</code>構造体定義に<code>parent</code>フィールドを追加する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The trouble is in deciding what the type of <code>parent</code> should be.</span>問題は、 <code>parent</code>のタイプを決定することです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We know it can&#39;t contain an <code>Rc&lt;T&gt;</code> , because that would create a reference cycle with <code>leaf.parent</code> pointing to <code>branch</code> and <code>branch.children</code> pointing to <code>leaf</code> , which would cause their <code>strong_count</code> values to never be 0.</span>私たちは、それが含まれていないことを知って<code>Rc&lt;T&gt;</code>それがで基準周期を作成しますので、 <code>leaf.parent</code>指し<code>branch</code>と<code>branch.children</code>を指して<code>leaf</code>その原因と思われる、 <code>strong_count</code>値が0になることはありませんし。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Thinking about the relationships another way, a parent node should own its children: if a parent node is dropped, its child nodes should be dropped as well.</span>別の方法で関係を考えると、親ノードは子ノードを所有する必要があります。親ノードが削除された場合、その子ノードも削除する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, a child should not own its parent: if we drop a child node, the parent should still exist.</span>しかし、子は親を所有すべきではありません。子ノードを削除すると、親はまだ存在するはずです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is a case for weak references!</span>これは弱い参照の場合です！</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So instead of <code>Rc&lt;T&gt;</code> , we&#39;ll make the type of <code>parent</code> use <code>Weak&lt;T&gt;</code> , specifically a <code>RefCell&lt;Weak&lt;Node&gt;&gt;</code> .</span>したがって、 <code>Rc&lt;T&gt;</code>代わりに、 <code>Weak&lt;T&gt;</code> <code>parent</code>のタイプ、特に<code>RefCell&lt;Weak&lt;Node&gt;&gt;</code>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now our <code>Node</code> struct definition looks like this:</span>これで、 <code>Node</code>構造体の定義は次のようになります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="use std::rc::{Rc, Weak};"></div><div data-l="use std::cell::RefCell;"></div><div data-l=""></div><div data-l=#[derive(Debug)]></div><div data-l="struct Node {"></div><div data-l="    value: i32,"></div><div data-l="    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,"></div><div data-l="    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A node will be able to refer to its parent node but doesn&#39;t own its parent.</span>ノードはその親ノードを参照することができるが、その親を所有しない。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In Listing 15-28, we update <code>main</code> to use this new definition so the <code>leaf</code> node will have a way to refer to its parent, <code>branch</code> :</span>リスト15-28では、この新しい定義を使用するように<code>main</code>を更新して、 <code>leaf</code>ノードがその親の<code>branch</code>を参照する方法を持つようにします。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="# use std::rc::{Rc, Weak};"></div><div data-l="# use std::cell::RefCell;"></div><div data-l=#></div><div data-l="# #[derive(Debug)]"></div><div data-l="# struct Node {"></div><div data-l="#     value: i32,"></div><div data-l="#     parent: RefCell&lt;Weak&lt;Node&gt;&gt;,"></div><div data-l="#     children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,"></div><div data-l="# }"></div><div data-l=#></div><div data-l="fn main() {"></div><div data-l="    let leaf = Rc::new(Node {"></div><div data-l="        value: 3,"></div><div data-l="        parent: RefCell::new(Weak::new()),"></div><div data-l="        children: RefCell::new(vec![]),"></div><div data-l="    });"></div><div data-l=""></div><div data-l="    println!(&quot;leaf parent = {:?}&quot;, leaf.parent.borrow().upgrade());"></div><div data-l=""></div><div data-l="    let branch = Rc::new(Node {"></div><div data-l="        value: 5,"></div><div data-l="        parent: RefCell::new(Weak::new()),"></div><div data-l="        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),"></div><div data-l="    });"></div><div data-l=""></div><div data-l="    *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);"></div><div data-l=""></div><div data-l="    println!(&quot;leaf parent = {:?}&quot;, leaf.parent.borrow().upgrade());"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 15-28: A <code>leaf</code> node with a weak reference to its parent node <code>branch</code></span></span> <span class=caption>リスト15-28：親ノード<code>branch</code>への弱い参照を持つ<code>leaf</code>ノード</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Creating the <code>leaf</code> node looks similar to how creating the <code>leaf</code> node looked in Listing 15-27 with the exception of the <code>parent</code> field: <code>leaf</code> starts out without a parent, so we create a new, empty <code>Weak&lt;Node&gt;</code> reference instance.</span> <code>leaf</code>ノードの作成は、リスト15-27のように、 <code>leaf</code>ノードを作成する方法と似ていますが、 <code>parent</code>フィールドは例外です。 <code>leaf</code>は親なしで開始されるため、空の<code>Weak&lt;Node&gt;</code>参照インスタンスを作成します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">At this point, when we try to get a reference to the parent of <code>leaf</code> by using the <code>upgrade</code> method, we get a <code>None</code> value.</span>この時点で、 <code>upgrade</code>メソッドを使用して<code>leaf</code>の親への参照を取得しようとすると、 <code>None</code>値が返されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We see this in the output from the first <code>println€</code> statement:</span>これは最初の<code>println€</code>ステートメントの出力にあります。</span> </p><br><div data-lang=text><div data-l="leaf parent = None"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When we create the <code>branch</code> node, it will also have a new <code>Weak&lt;Node&gt;</code> reference in the <code>parent</code> field, because <code>branch</code> doesn&#39;t have a parent node.</span>私たちが作成した場合<code>branch</code>ノードを、それはまた、新しい必要があります<code>Weak&lt;Node&gt;</code>で参照<code>parent</code>ので、フィールドを<code>branch</code>親ノードを持ちません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We still have <code>leaf</code> as one of the children of <code>branch</code> .</span>私たちはまだ<code>branch</code>の子供の一人として<code>leaf</code>を持っています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Once we have the <code>Node</code> instance in <code>branch</code> , we can modify <code>leaf</code> to give it a <code>Weak&lt;Node&gt;</code> reference to its parent.</span> <code>branch</code>インスタンスに<code>Node</code>インスタンスを設定したら、 <code>leaf</code>を修正して親<code>Weak&lt;Node&gt;</code>への<code>Weak&lt;Node&gt;</code>参照を与えることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We use the <code>borrow_mut</code> method on the <code>RefCell&lt;Weak&lt;Node&gt;&gt;</code> in the <code>parent</code> field of <code>leaf</code> , and then we use the <code>Rc::downgrade</code> function to create a <code>Weak&lt;Node&gt;</code> reference to <code>branch</code> from the <code>Rc&lt;Node&gt;</code> in <code>branch.</code></span> <code>leaf</code>の<code>parent</code>フィールドの<code>RefCell&lt;Weak&lt;Node&gt;&gt;</code>で<code>borrow_mut</code>メソッドを使用し、 <code>Rc::downgrade</code>関数を使用して<code>branch</code>の<code>Rc&lt;Node&gt;</code>から<code>branch</code>する<code>Weak&lt;Node&gt;</code>参照を作成します<code>branch.</code></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When we print the parent of <code>leaf</code> again, this time we&#39;ll get a <code>Some</code> variant holding <code>branch</code> : now <code>leaf</code> can access its parent!</span>今度は<code>leaf</code>の親をもう一度印刷すると、今度は<code>branch</code>持つ<code>Some</code> variantを取得します：今、 <code>leaf</code>はその親にアクセスできます！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When we print <code>leaf</code> , we also avoid the cycle that eventually ended in a stack overflow like we had in Listing 15-26;</span> <code>leaf</code>を印刷するとき、リスト15-26のようにスタックのオーバーフローで終了するサイクルも回避します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">the <code>Weak&lt;Node&gt;</code> references are printed as <code>(Weak)</code> :</span> <code>Weak&lt;Node&gt;</code>参照は<code>(Weak)</code>として出力されます。</span> </p><br><div data-lang=text><div data-l="leaf parent = Some(Node { value: 5, parent: RefCell { value: (Weak) },"></div><div data-l="children: RefCell { value: [Node { value: 3, parent: RefCell { value: (Weak) },"></div><div data-l="children: RefCell { value: [] } }] } })"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The lack of infinite output indicates that this code didn&#39;t create a reference cycle.</span>無限の出力がないことは、このコードが参照サイクルを作成しなかったことを示します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can also tell this by looking at the values we get from calling <code>Rc::strong_count</code> and <code>Rc::weak_count</code> .</span>また、 <code>Rc::strong_count</code>と<code>Rc::weak_count</code>呼び出すことで得られる値を調べることで、これを知ることができます。</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Visualizing Changes to <code>strong_count</code> and <code>weak_count</code></span> <code>strong_count</code>と<code>weak_count</code>への変更の可視化</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s look at how the <code>strong_count</code> and <code>weak_count</code> values of the <code>Rc&lt;Node&gt;</code> instances change by creating a new inner scope and moving the creation of <code>branch</code> into that scope.</span>新しい内部スコープを作成し、そのスコープに<code>branch</code>の作成を移動することによって、 <code>Rc&lt;Node&gt;</code>インスタンスの<code>strong_count</code>と<code>weak_count</code>値がどのように<code>strong_count</code>するかを見てみましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">By doing so, we can see what happens when <code>branch</code> is created and then dropped when it goes out of scope.</span>そうすることで、 <code>branch</code>が作成され、スコープ外になったときに<code>branch</code>が作成されたときに何が起こるかを確認することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The modifications are shown in Listing 15-29:</span>リスト15-29にその変更を示します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="# use std::rc::{Rc, Weak};"></div><div data-l="# use std::cell::RefCell;"></div><div data-l=#></div><div data-l="# #[derive(Debug)]"></div><div data-l="# struct Node {"></div><div data-l="#     value: i32,"></div><div data-l="#     parent: RefCell&lt;Weak&lt;Node&gt;&gt;,"></div><div data-l="#     children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,"></div><div data-l="# }"></div><div data-l=#></div><div data-l="fn main() {"></div><div data-l="    let leaf = Rc::new(Node {"></div><div data-l="        value: 3,"></div><div data-l="        parent: RefCell::new(Weak::new()),"></div><div data-l="        children: RefCell::new(vec![]),"></div><div data-l="    });"></div><div data-l=""></div><div data-l="    println!("></div><div data-l="        &quot;leaf strong = {}, weak = {}&quot;,"></div><div data-l="        Rc::strong_count(&amp;leaf),"></div><div data-l="        Rc::weak_count(&amp;leaf),"></div><div data-l="    );"></div><div data-l=""></div><div data-l="    {"></div><div data-l="        let branch = Rc::new(Node {"></div><div data-l="            value: 5,"></div><div data-l="            parent: RefCell::new(Weak::new()),"></div><div data-l="            children: RefCell::new(vec![Rc::clone(&amp;leaf)]),"></div><div data-l="        });"></div><div data-l=""></div><div data-l="        *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);"></div><div data-l=""></div><div data-l="        println!("></div><div data-l="            &quot;branch strong = {}, weak = {}&quot;,"></div><div data-l="            Rc::strong_count(&amp;branch),"></div><div data-l="            Rc::weak_count(&amp;branch),"></div><div data-l="        );"></div><div data-l=""></div><div data-l="        println!("></div><div data-l="            &quot;leaf strong = {}, weak = {}&quot;,"></div><div data-l="            Rc::strong_count(&amp;leaf),"></div><div data-l="            Rc::weak_count(&amp;leaf),"></div><div data-l="        );"></div><div data-l="    }"></div><div data-l=""></div><div data-l="    println!(&quot;leaf parent = {:?}&quot;, leaf.parent.borrow().upgrade());"></div><div data-l="    println!("></div><div data-l="        &quot;leaf strong = {}, weak = {}&quot;,"></div><div data-l="        Rc::strong_count(&amp;leaf),"></div><div data-l="        Rc::weak_count(&amp;leaf),"></div><div data-l="    );"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 15-29: Creating <code>branch</code> in an inner scope and examining strong and weak reference counts</span></span> <span class=caption>リスト15-29：内部スコープ内に<code>branch</code>を作成し、強い参照カウントと弱い参照カウントを調べる</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">After <code>leaf</code> is created, its <code>Rc&lt;Node&gt;</code> has a strong count of 1 and a weak count of 0. In the inner scope, we create <code>branch</code> and associate it with <code>leaf</code> , at which point when we print the counts, the <code>Rc&lt;Node&gt;</code> in <code>branch</code> will have a strong count of 1 and a weak count of 1 (for <code>leaf.parent</code> pointing to <code>branch</code> with a <code>Weak&lt;Node&gt;</code> ).</span> <code>leaf</code>が作成された後、その<code>Rc&lt;Node&gt;</code>は1の強いカウントと0の弱いカウントを持ちます。内部スコープでは、 <code>branch</code>を作成し、それを<code>leaf</code>に関連付けます。カウントをプリントするとき、 <code>Rc&lt;Node&gt;</code> <code>branch</code>に1の強いカウントと1の弱いカウントがあります（ <code>Weak&lt;Node&gt;</code> <code>branch</code>を指す<code>leaf.parent</code>場合）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When we print the counts in <code>leaf</code> , we&#39;ll see it will have a strong count of 2, because <code>branch</code> now has a clone of the <code>Rc&lt;Node&gt;</code> of <code>leaf</code> stored in <code>branch.children</code> , but will still have a weak count of 0.</span>我々はカウントを印刷するとき<code>leaf</code> 、我々はので、それは、2の強力な数を持っています表示されます<code>branch</code>今のクローンがある<code>Rc&lt;Node&gt;</code>の<code>leaf</code>に保存されている<code>branch.children</code> 、まだ0の弱い数を持っています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When the inner scope ends, <code>branch</code> goes out of scope and the strong count of the <code>Rc&lt;Node&gt;</code> decreases to 0, so its <code>Node</code> is dropped.</span>内部スコープが終了すると、 <code>branch</code>が有効範囲外になり、 <code>Rc&lt;Node&gt;</code>強いカウントが0に減少し、その<code>Node</code>が削除されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The weak count of 1 from <code>leaf.parent</code> has no bearing on whether or not <code>Node</code> is dropped, so we don&#39;t get any memory leaks!</span> <code>leaf.parent</code>からの1の弱いカウントは、 <code>Node</code>がドロップされたかどうかに関係なく、メモリリークは発生しません！</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we try to access the parent of <code>leaf</code> after the end of the scope, we&#39;ll get <code>None</code> again.</span>スコープの終了後に<code>leaf</code>の親にアクセスしようとすると、再び<code>None</code>が<code>None</code>れます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">At the end of the program, the <code>Rc&lt;Node&gt;</code> in <code>leaf</code> has a strong count of 1 and a weak count of 0, because the variable <code>leaf</code> is now the only reference to the <code>Rc&lt;Node&gt;</code> again.</span>プログラムの終了時に、 <code>Rc&lt;Node&gt;</code>で<code>leaf</code>可変のため、1の強力な数と0の弱い数を持っている<code>leaf</code> 、今への参照のみである<code>Rc&lt;Node&gt;</code>もう一度。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">All of the logic that manages the counts and value dropping is built into <code>Rc&lt;T&gt;</code> and <code>Weak&lt;T&gt;</code> and their implementations of the <code>Drop</code> trait.</span>カウントと値の低下を管理するすべてのロジックは、 <code>Rc&lt;T&gt;</code>と<code>Weak&lt;T&gt;</code>と<code>Drop</code>特性の実装に組み込まれています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">By specifying that the relationship from a child to its parent should be a <code>Weak&lt;T&gt;</code> reference in the definition of <code>Node</code> , you&#39;re able to have parent nodes point to child nodes and vice versa without creating a reference cycle and memory leaks.</span>子ノードから親ノードへの関係が<code>Node</code>の定義における<code>Weak&lt;T&gt;</code>参照であることを指定することによって、親ノードが子ノードを指すようにすることができます。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Summary</span>概要</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This chapter covered how to use smart pointers to make different guarantees and trade-offs than those Rust makes by default with regular references.</span>この章では、スマートポインタを使用して、Rustがデフォルトで通常参照するものとは異なる保証とトレードオフを行う方法について説明しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Box&lt;T&gt;</code> type has a known size and points to data allocated on the heap.</span> <code>Box&lt;T&gt;</code>型は既知のサイズを持ち、ヒープに割り当てられたデータを指します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Rc&lt;T&gt;</code> type keeps track of the number of references to data on the heap so that data can have multiple owners.</span> <code>Rc&lt;T&gt;</code>型は、データが複数の所有者を持つことができるように、ヒープ上のデータへの参照の数を追跡します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>RefCell&lt;T&gt;</code> type with its interior mutability gives us a type that we can use when we need an immutable type but need to change an inner value of that type;</span>内部の<code>RefCell&lt;T&gt;</code>型は、不変型を必要とするが、その型の内部値を変更する必要があるときに使用できる型を与えます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">it also enforces the borrowing rules at runtime instead of at compile time.</span>コンパイル時ではなく、実行時に借用ルールを強制します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Also discussed were the <code>Deref</code> and <code>Drop</code> traits, which enable a lot of the functionality of smart pointers.</span>スマートポインタの多くの機能を有効にする<code>Deref</code>と<code>Drop</code>特徴についても説明しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We explored reference cycles that can cause memory leaks and how to prevent them using <code>Weak&lt;T&gt;</code> .</span> <code>Weak&lt;T&gt;</code>を使用してメモリリークを引き起こす可能性のあるリファレンスサイクルとその回避方法について調べました。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If this chapter has piqued your interest and you want to implement your own smart pointers, check out <a href=#3nomicon>“The Rustonomicon”</a> for more useful information.</span>この章で興味をそそられていて、独自のスマートポインタを実装したい場合は、 <a href=#3nomicon>「The Rustonomicon」</a>を参照してください。</span> </p><br> <a class=notranslate href=#1https://doc.rust-lang.org/stable/nomicon/>nomicon</a> <br> <p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Next, we&#39;ll talk about concurrency in Rust.</span>次に、Rustの並行処理について説明します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You&#39;ll even learn about a few new smart pointers.</span>いくつかの新しいスマートポインタについても学びます。</span> </p><script>_addload(function(){_setupIW('com');_csi('en','ja','ch15-06-reference-cycles.html');});</script>