<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180709_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=ch10-02-traits.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Traits: Defining Shared Behavior</span>特性：共有動作の定義</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A <i>trait</i> tells the Rust compiler about functionality a particular type has and can share with other types.</span> <i>特性</i>は、Rustコンパイラに特定のタイプが持つ機能について知らせ、他のタイプと共有することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can use traits to define shared behavior in an abstract way.</span>我々は、特性を使用して抽象的な方法で共有動作を定義することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can use trait bounds to specify that a generic can be any type that has certain behavior.</span>特性境界を使用して、ジェネリックが特定の動作を持つ任意のタイプであることを指定できます。</span> </p><br><blockquote><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note: Traits are similar to a feature often called <i>interfaces</i> in other languages, although with some differences.</span>注意：特性は、他の言語の<i>インターフェース</i>とよく似ていますが、いくつかの違いがあります。</span> </p></blockquote><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Defining a Trait</span>特性の定義</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A type&#39;s behavior consists of the methods we can call on that type.</span>型の動作は、その型で呼び出すことができるメソッドから構成されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Different types share the same behavior if we can call the same methods on all of those types.</span>これらのすべての型に対して同じメソッドを呼び出すことができる場合、異なる型は同じ動作を共有します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Trait definitions are a way to group method signatures together to define a set of behaviors necessary to accomplish some purpose.</span>特性定義は、メソッドシグネチャをグループ化して、目的を達成するために必要な一連の動作を定義する方法です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, let&#39;s say we have multiple structs that hold various kinds and amounts of text: a <code>NewsArticle</code> struct that holds a news story filed in a particular location and a <code>Tweet</code> that can have at most 280 characters along with metadata that indicates whether it was a new tweet, a retweet, or a reply to another tweet.</span>たとえば、さまざまな種類と量のテキストを保持する複数の構造体があるとしましょう。特定の場所に<code>NewsArticle</code>れているニュース記事を保持する<code>NewsArticle</code>構造体と、280文字以下のメタデータを持つことができる<code>Tweet</code>です。新しいツイート、リトウェット、または別のツイートへの返信。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We want to make a media aggregator library that can display summaries of data that might be stored in a <code>NewsArticle</code> or <code>Tweet</code> instance.</span> <code>NewsArticle</code>または<code>Tweet</code>インスタンスに保存されている可能性のあるデータの要約を表示できるメディアアグリゲータライブラリを作成する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To do this, we need a summary from each type, and we need to request that summary by calling a <code>summarize</code> method on an instance.</span>これを行うには、それぞれの型から要約が必要です。インスタンスに対して<code>summarize</code>メソッドを呼び出すことによって要約を要求する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 10-12 shows the definition of a <code>Summary</code> trait that expresses this behavior.</span>リスト10-12は、この振る舞いを表す<code>Summary</code>特性の定義を示しています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/lib.rs</span></span> <span class=filename>ファイル名：src / lib.rs</span></span> </p><br><div data-lang=rust><div data-l="pub trait Summary {"></div><div data-l="    fn summarize(&amp;self) -&gt; String;"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 10-12: A <code>Summary</code> trait that consists of the behavior provided by a <code>summarize</code> method</span></span> <span class=caption>リスト10-12： <code>summarize</code>メソッドによって提供される振る舞いで構成される<code>Summary</code>特性</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here, we declare a trait using the <code>trait</code> keyword and then the trait&#39;s name, which is <code>Summary</code> in this case.</span>ここでは、 <code>trait</code>キーワードを使用して<code>trait</code>を宣言し、次に特性の名前を指定します。この場合、 <code>Summary</code>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Inside the curly brackets, we declare the method signatures that describe the behaviors of the types that implement this trait, which in this case is <code>fn summarize(&amp;self) -&gt; String</code> .</span>中括弧の中で、この特性を実装する型の振る舞いを記述するメソッドのシグネチャを宣言します。この場合、 <code>fn summarize(&amp;self) -&gt; String</code>です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">After the method signature, instead of providing an implementation within curly brackets, we use a semicolon.</span>メソッドシグネチャの後に、中括弧で実装する代わりに、セミコロンを使用します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Each type implementing this trait must provide its own custom behavior for the body of the method.</span>この特性を実装する各タイプは、メソッドの本体に対して独自のカスタム動作を提供する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The compiler will enforce that any type that has the <code>Summary</code> trait will have the method <code>summarize</code> defined with this signature exactly.</span>コンパイラは、 <code>Summary</code>特性を持つすべてのタイプで、このシグネチャで定義されたメソッド<code>summarize</code>正確に実行するように強制します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A trait can have multiple methods in its body: the method signatures are listed one per line and each line ends in a semicolon.</span>形質は、本体に複数のメソッドを持つことができます。メソッドのシグネチャは1行に1つずつリストされ、各行はセミコロンで終わります。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Implementing a Trait on a Type</span>タイプ上の特性の実装</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now that we&#39;ve defined the desired behavior using the <code>Summary</code> trait, we can implement it on the types in our media aggregator.</span> <code>Summary</code>特性を使用して目的の動作を定義したので、これをメディアアグリゲータのタイプに実装できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 10-13 shows an implementation of the <code>Summary</code> trait on the <code>NewsArticle</code> struct that uses the headline, the author, and the location to create the return value of <code>summarize</code> .</span>リスト10-13は、見出し、作成者、および場所を使用して<code>summarize</code>戻り値を作成する<code>NewsArticle</code>構造体の<code>Summary</code>特性の実装を示しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For the <code>Tweet</code> struct, we define <code>summarize</code> as the username followed by the entire text of the tweet, assuming that tweet content is already limited to 280 characters.</span> <code>Tweet</code>構造体の場合、ツイートの内容がすでに280文字に制限されていると仮定して、 <code>summarize</code>をユーザー名とそれに続くツイートのテキスト全体として定義します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/lib.rs</span></span> <span class=filename>ファイル名：src / lib.rs</span></span> </p><br><div data-lang=rust><div data-l="# pub trait Summary {"></div><div data-l="#     fn summarize(&amp;self) -&gt; String;"></div><div data-l="# }"></div><div data-l=#></div><div data-l="pub struct NewsArticle {"></div><div data-l="    pub headline: String,"></div><div data-l="    pub location: String,"></div><div data-l="    pub author: String,"></div><div data-l="    pub content: String,"></div><div data-l=}></div><div data-l=""></div><div data-l="impl Summary for NewsArticle {"></div><div data-l="    fn summarize(&amp;self) -&gt; String {"></div><div data-l="        format!(&quot;{}, by {} ({})&quot;, self.headline, self.author, self.location)"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="pub struct Tweet {"></div><div data-l="    pub username: String,"></div><div data-l="    pub content: String,"></div><div data-l="    pub reply: bool,"></div><div data-l="    pub retweet: bool,"></div><div data-l=}></div><div data-l=""></div><div data-l="impl Summary for Tweet {"></div><div data-l="    fn summarize(&amp;self) -&gt; String {"></div><div data-l="        format!(&quot;{}: {}&quot;, self.username, self.content)"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 10-13: Implementing the <code>Summary</code> trait on the <code>NewsArticle</code> and <code>Tweet</code> types</span></span> <span class=caption>リスト10-13： <code>NewsArticle</code>と<code>Tweet</code>型に<code>Summary</code>特性を実装する</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Implementing a trait on a type is similar to implementing regular methods.</span>ある型の特性を実装することは、通常のメソッドを実装することと似ています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The difference is that after <code>impl</code> , we put the trait name that we want to implement, then use the <code>for</code> keyword, and then specify the name of the type we want to implement the trait for.</span>違いは、 <code>impl</code>後に実装する特性名を入れてから<code>for</code>キーワードを使い、その特性を実装するタイプの名前を指定することです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Within the <code>impl</code> block, we put the method signatures that the trait definition has defined.</span> <code>impl</code>ブロック内で、特性定義が定義したメソッドのシグネチャを入れます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Instead of adding a semicolon after each signature, we use curly brackets and fill in the method body with the specific behavior that we want the methods of the trait to have for the particular type.</span>各署名の後にセミコロンを追加する代わりに、中括弧を使用して、メソッド本体に、特定の型に対して特性のメソッドが持つ特定の動作を記入します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">After implementing the trait, we can call the methods on instances of <code>NewsArticle</code> and <code>Tweet</code> in the same way we call regular methods, like this:</span>この特性を実装した後、次のように、 <code>NewsArticle</code>と<code>Tweet</code>インスタンスのメソッドを、通常のメソッドと同じ方法で呼び出すことができます。</span> </p><br><div data-lang=rust,ignore><div data-l="let tweet = Tweet {"></div><div data-l="    username: String::from(&quot;horse_ebooks&quot;),"></div><div data-l="    content: String::from(&quot;of course, as you probably already know, people&quot;),"></div><div data-l="    reply: false,"></div><div data-l="    retweet: false,"></div><div data-l=};></div><div data-l=""></div><div data-l="println!(&quot;1 new tweet: {}&quot;, tweet.summarize());"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This code prints <code>1 new tweet: horse_ebooks: of course, as you probably already know, people</code> .</span>このコードは、 <code>1 new tweet: horse_ebooks: of course, as you probably already know, people</code> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that because we defined the <code>Summary</code> trait and the <code>NewsArticle</code> and <code>Tweet</code> types in the same <i>lib.rs</i> in Listing 10-13, they&#39;re all in the same scope.</span> <code>Summary</code> <code>NewsArticle</code>と<code>NewsArticle</code>と<code>Tweet</code>型はリスト10-13の同じ<i>lib.rs</i>に定義されているため、すべて同じスコープに入っています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s say this <i>lib.rs</i> is for a crate we&#39;ve called <code>aggregator</code> and someone else wants to use our crate&#39;s functionality to implement the <code>Summary</code> trait on a struct defined within their library&#39;s scope.</span>この<i>lib.rs</i>は、 <code>aggregator</code>と呼ばれていたもの<code>aggregator</code> 、他の誰かが、ライブラリのスコープ内で定義された構造体に<code>Summary</code>特性を実装するために、クレートの機能を使用したいとします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">They would need to import the trait into their scope first.</span>彼らは最初に形質をそのスコープにインポートする必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">They would do so by specifying <code>use aggregator::Summary;</code></span>彼らは<code>use aggregator::Summary;</code>指定<code>use aggregator::Summary;</code>ことでそうするだろう<code>use aggregator::Summary;</code></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">, which then would enable them to implement <code>Summary</code> for their type.</span>これにより、それらのタイプの<code>Summary</code>を実装することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Summary</code> trait would also need to be a public trait for another crate to implement it, which it is because we put the <code>pub</code> keyword before <code>trait</code> in Listing 10-12.</span>リスト10-12の<code>trait</code>前に<code>pub</code>キーワードを置くので、 <code>Summary</code>特性は、それを実装するための別のクレートの公的特性である必要があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">One restriction to note with trait implementations is that we can implement a trait on a type only if either the trait or the type is local to our crate.</span>形質の実装で注意すべき制限の1つは、形質またはタイプのいずれかが私たちの箱にローカルである場合にのみ、タイプに形質を実装できることです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, we can implement standard library traits like <code>Display</code> on a custom type like <code>Tweet</code> as part of our <code>aggregator</code> crate functionality, because the type <code>Tweet</code> is local to our <code>aggregator</code> crate.</span>例えば、我々のような標準ライブラリの特性を実装することができます<code>Display</code>のようなカスタム型の<code>Tweet</code>私たちの一環として、 <code>aggregator</code>タイプので、クレート機能<code>Tweet</code>私たちにローカルな<code>aggregator</code>クレート。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can also implement <code>Summary</code> on <code>Vec&lt;T&gt;</code> in our <code>aggregator</code> crate, because the trait <code>Summary</code> is local to our <code>aggregator</code> crate.</span>特性<code>Summary</code>は<code>aggregator</code>クレートのローカルなので、 <code>aggregator</code>クレートで<code>Summary</code> on <code>Vec&lt;T&gt;</code>を実装することもできます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But we can&#39;t implement external traits on external types.</span>しかし、我々は外部の型に外部の特性を実装することはできません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, we can&#39;t implement the <code>Display</code> trait on <code>Vec&lt;T&gt;</code> within our <code>aggregator</code> crate, because <code>Display</code> and <code>Vec&lt;T&gt;</code> are defined in the standard library and aren&#39;t local to our <code>aggregator</code> crate.</span>たとえば、 <code>Display</code>および<code>Vec&lt;T&gt;</code>は標準ライブラリで定義されており、 <code>aggregator</code> crateではローカルではないため、 <code>aggregator</code>クレート内で<code>Vec&lt;T&gt;</code> <code>Display</code>特性を実装することはできません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This restriction is part of a property of programs called <i>coherence</i> , and more specifically the <i>orphan rule</i> , so named because the parent type is not present.</span>この制限は、 <i>コヒーレンス</i>と呼ばれるプログラムのプロパティの一部であり、より具体的には、親タイプが存在しないために名前が付けられた<i>孤立ルール</i>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This rule ensures that other people&#39;s code can&#39;t break your code and vice versa.</span>このルールは、他の人のコードがあなたのコードを破ることができないようにします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Without the rule, two crates could implement the same trait for the same type, and Rust wouldn&#39;t know which implementation to use.</span>ルールがなければ、2つの箱が同じタイプの同じ特性を実装でき、Rustはどちらの実装を使用するかを知りません。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Default Implementations</span>デフォルトの実装</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Sometimes it&#39;s useful to have default behavior for some or all of the methods in a trait instead of requiring implementations for all methods on every type.</span>場合によっては、すべての型のすべてのメソッドの実装を要求するのではなく、特性の一部またはすべてに対してメソッドのデフォルト動作を持たせると便利です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then, as we implement the trait on a particular type, we can keep or override each method&#39;s default behavior.</span>次に、特定の型の特性を実装する際に、各メソッドのデフォルト動作を保持またはオーバーライドできます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 10-14 shows how to specify a default string for the <code>summarize</code> method of the <code>Summary</code> trait instead of only defining the method signature, as we did in Listing 10-12.</span>コードリスト10-14は、コードリスト10-12のように、メソッドシグネチャを定義するだけでなく、 <code>Summary</code>特性の<code>summarize</code>メソッドのデフォルト文字列を指定する方法を示しています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/lib.rs</span></span> <span class=filename>ファイル名：src / lib.rs</span></span> </p><br><div data-lang=rust><div data-l="pub trait Summary {"></div><div data-l="    fn summarize(&amp;self) -&gt; String {"></div><div data-l="        String::from(&quot;(Read more...)&quot;)"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 10-14: Definition of a <code>Summary</code> trait with a default implementation of the <code>summarize</code> method</span></span> <span class=caption>リスト10-14： <code>summarize</code>メソッドのデフォルト実装による<code>Summary</code>特性の定義</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To use a default implementation to summarize instances of <code>NewsArticle</code> instead of defining a custom implementation, we specify an empty <code>impl</code> block with <code>impl Summary for NewsArticle {}</code> .</span>デフォルトの実装を使用してカスタム実装を定義する代わりに<code>NewsArticle</code>インスタンスを<code>impl Summary for NewsArticle {}</code>して空の<code>impl</code>ブロックを指定します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Even though we&#39;re no longer defining the <code>summarize</code> method on <code>NewsArticle</code> directly, we&#39;ve provided a default implementation and specified that <code>NewsArticle</code> implements the <code>Summary</code> trait.</span>私たちはもはや定義しているにもかかわらず<code>summarize</code>でメソッドを<code>NewsArticle</code>直接、我々は、デフォルトの実装を提供していないとことを指定した<code>NewsArticle</code>実装<code>Summary</code>形質を。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As a result, we can still call the <code>summarize</code> method on an instance of <code>NewsArticle</code> , like this:</span>その結果、我々はまだ呼び出すことができ<code>summarize</code>のインスタンスでメソッドを<code>NewsArticle</code>このように、：</span> </p><br><div data-lang=rust,ignore><div data-l="let article = NewsArticle {"></div><div data-l="    headline: String::from(&quot;Penguins win the Stanley Cup Championship!&quot;),"></div><div data-l="    location: String::from(&quot;Pittsburgh, PA, USA&quot;),"></div><div data-l="    author: String::from(&quot;Iceburgh&quot;),"></div><div data-l="    content: String::from(&quot;The Pittsburgh Penguins once again are the best"></div><div data-l="    hockey team in the NHL.&quot;),"></div><div data-l=};></div><div data-l=""></div><div data-l="println!(&quot;New article available! {}&quot;, article.summarize());"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This code prints <code>New article available€ (Read more...)</code> .</span>このコードは<code>New article available€ (Read more...)</code>印刷し<code>New article available€ (Read more...)</code> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Creating a default implementation for <code>summarize</code> doesn&#39;t require us to change anything about the implementation of <code>Summary</code> on <code>Tweet</code> in Listing 10-13.</span> <code>summarize</code>ためのデフォルト実装を作成しても、リスト10-13の<code>Summary</code> on <code>Tweet</code>実装について何も変更する必要はありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The reason is that the syntax for overriding a default implementation is the same as the syntax for implementing a trait method that doesn&#39;t have a default implementation.</span>その理由は、既定の実装をオーバーライドする構文は、既定の実装を持たないtraitメソッドを実装するための構文と同じであるためです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Default implementations can call other methods in the same trait, even if those other methods don&#39;t have a default implementation.</span>既定の実装では、他のメソッドに既定の実装がない場合でも、既定の実装では同じ特性の他のメソッドを呼び出すことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this way, a trait can provide a lot of useful functionality and only require implementors to specify a small part of it.</span>このようにして、特性は多くの有用な機能を提供することができ、実装者がその一部を指定することだけを必要とします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, we could define the <code>Summary</code> trait to have a <code>summarize_author</code> method whose implementation is required, and then define a <code>summarize</code> method that has a default implementation that calls the <code>summarize_author</code> method:</span>例えば、我々は定義でき<code>Summary</code>持っている特性を<code>summarize_author</code>その実装が要求される方法を、次に定義<code>summarize</code>呼び出し、デフォルトの実装がある方法<code>summarize_author</code>方法を：</span> </p><br><div data-lang=rust><div data-l="pub trait Summary {"></div><div data-l="    fn summarize_author(&amp;self) -&gt; String;"></div><div data-l=""></div><div data-l="    fn summarize(&amp;self) -&gt; String {"></div><div data-l="        format!(&quot;(Read more from {}...)&quot;, self.summarize_author())"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To use this version of <code>Summary</code> , we only need to define <code>summarize_author</code> when we implement the trait on a type:</span>このバージョンの<code>Summary</code>を使用するに<code>summarize_author</code> 、ある型に対して特性を実装するときに<code>summarize_author</code>を定義するだけで済みます：</span> </p><br><div data-lang=rust,ignore><div data-l="impl Summary for Tweet {"></div><div data-l="    fn summarize_author(&amp;self) -&gt; String {"></div><div data-l="        format!(&quot;@{}&quot;, self.username)"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">After we define <code>summarize_author</code> , we can call <code>summarize</code> on instances of the <code>Tweet</code> struct, and the default implementation of <code>summarize</code> will call the definition of <code>summarize_author</code> that we&#39;ve provided.</span>我々が定義した後<code>summarize_author</code> 、我々は呼び出すことができます<code>summarize</code>のインスタンスに<code>Tweet</code>構造体、およびデフォルトの実装で<code>summarize</code>の定義を呼び出します<code>summarize_author</code>私たちが提供してきました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because we&#39;ve implemented <code>summarize_author</code> , the <code>Summary</code> trait has given us the behavior of the <code>summarize</code> method without requiring us to write any more code.</span> <code>summarize_author</code>を実装しているので、 <code>Summary</code>特性は、これ以上のコードを書く必要なしに<code>summarize</code>メソッドの動作を与えました。</span> </p><br><div data-lang=rust,ignore><div data-l="let tweet = Tweet {"></div><div data-l="    username: String::from(&quot;horse_ebooks&quot;),"></div><div data-l="    content: String::from(&quot;of course, as you probably already know, people&quot;),"></div><div data-l="    reply: false,"></div><div data-l="    retweet: false,"></div><div data-l=};></div><div data-l=""></div><div data-l="println!(&quot;1 new tweet: {}&quot;, tweet.summarize());"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This code prints <code>1 new tweet: (Read more from @horse_ebooks...)</code> .</span>このコードは、 <code>1 new tweet: (Read more from @horse_ebooks...)</code> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that it isn&#39;t possible to call the default implementation from an overriding implementation of that same method.</span>同じメソッドのオーバーライド実装からデフォルト実装を呼び出すことはできません。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Trait Bounds</span>特性限界</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now that you know how to define traits and implement those traits on types, we can explore how to use traits with generic type parameters.</span>今度は、形質を定義し、それらの型を型に実装する方法を知ったので、型をジェネリック型パラメータで使用する方法を探ることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can use <i>trait bounds</i> to constrain generic types to ensure the type will be limited to those that implement a particular trait and behavior.</span> <i>特性境界</i>を使用してジェネリック型を制約することで、その型が特定の特性や動作を実装するものに限定されるようにすることができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, in Listing 10-13, we implemented the <code>Summary</code> trait on the types <code>NewsArticle</code> and <code>Tweet</code> .</span>たとえば、リスト10-13では、 <code>NewsArticle</code>と<code>Tweet</code>型について<code>Summary</code> <code>NewsArticle</code>を実装しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can define a function <code>notify</code> that calls the <code>summarize</code> method on its parameter <code>item</code> , which is of the generic type <code>T</code> .</span> <code>summarize</code>メソッドを呼び出す関数<code>notify</code>を定義することができます。これは、汎用型<code>T</code>パラメータ<code>item</code>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To be able to call <code>summarize</code> on <code>item</code> without getting an error telling us that the generic type <code>T</code> doesn&#39;t implement the method <code>summarize</code> , we can use trait bounds on <code>T</code> to specify that <code>item</code> must be of a type that implements the <code>Summary</code> trait:</span>呼び出すことができるようにするに<code>summarize</code>上で<code>item</code>ジェネリック型ということを告げて、エラー得ることなく<code>T</code>メソッドが実装されていない<code>summarize</code> 、我々は上の形質境界を使用することができます<code>T</code>ように指定する<code>item</code>実装型でなければならない<code>Summary</code>形質を：</span> </p><br><div data-lang=rust,ignore><div data-l="pub fn notify&lt;T: Summary&gt;(item: T) {"></div><div data-l="    println!(&quot;Breaking news! {}&quot;, item.summarize());"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We place trait bounds with the declaration of the generic type parameter, after a colon and inside angle brackets.</span>コロンと内側の山括弧の後に、ジェネリック型パラメータの宣言で特性境界を配置します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because of the trait bound on <code>T</code> , we can call <code>notify</code> and pass in any instance of <code>NewsArticle</code> or <code>Tweet</code> .</span> <code>T</code>の特性に縛られているため、 <code>NewsArticle</code>や<code>Tweet</code>インスタンスを<code>notify</code>して渡すことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Code that calls the function with any other type, like a <code>String</code> or an <code>i32</code> , won&#39;t compile, because those types don&#39;t implement <code>Summary</code> .</span> <code>String</code>や<code>i32</code>ような他の型の関数を呼び出すコードは、それらの型が<code>Summary</code>実装していないため、コンパイルされません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can specify multiple trait bounds on a generic type using the <code>+</code> syntax.</span> <code>+</code>構文を使用してジェネリック型に複数の特性境界を指定することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, to use display formatting on the type <code>T</code> in a function as well as the <code>summarize</code> method, we can use <code>T: Summary + Display</code> to say <code>T</code> can be any type that implements <code>Summary</code> and <code>Display</code> .</span>例えば、関数の型<code>T</code>と<code>summarize</code>メソッドの表示書式を使用するには、 <code>T: Summary + Display</code>を使用します<code>T</code>は、 <code>Summary</code>と<code>Display</code>を実装する任意の型とすることができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, there are downsides to using too many trait bounds.</span>しかし、あまりにも多くの特性境界を使用することには欠点があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Each generic has its own trait bounds, so functions with multiple generic type parameters can have lots of trait bound information between a function&#39;s name and its parameter list, making the function signature hard to read.</span>各ジェネリックには独自の特性境界があるため、複数のジェネリック型パラメータを持つ関数は、関数名とそのパラメータリストの間に多くの特性バインド情報を持ち、関数シグネチャを読みにくくします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For this reason, Rust has alternate syntax for specifying trait bounds inside a <code>where</code> clause after the function signature.</span>この理由から、Rustは、関数シグネチャの後に<code>where</code>句の中で特性境界を指定するための代替構文を持っています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So instead of writing this:</span>だからこれを書くのではなく：</span> </p><br><div data-lang=rust,ignore><div data-l="fn some_function&lt;T: Display + Clone, U: Clone + Debug&gt;(t: T, u: U) -&gt; i32 {"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">we can use a <code>where</code> clause, like this:</span>次のように<code>where</code>句を使用できます。</span> </p><br><div data-lang=rust,ignore><div data-l="fn some_function&lt;T, U&gt;(t: T, u: U) -&gt; i32"></div><div data-l="    where T: Display + Clone,"></div><div data-l="          U: Clone + Debug"></div><div data-l={></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This function&#39;s signature is less cluttered in that the function name, parameter list, and return type are close together, similar to a function without lots of trait bounds.</span>この関数のシグネチャは、関数名、パラメータリスト、および戻り値の型が密接に接しているので、あまりうまく機能しません。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Fixing the <code>largest</code> Function with Trait Bounds</span>特性境界で<code>largest</code>機能を固定する</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now that you know how to specify the behavior you want to use using the generic type parameter&#39;s bounds, let&#39;s return to Listing 10-5 to fix the definition of the <code>largest</code> function that uses a generic type parameter!</span>ジェネリック型パラメータの境界を使用して使用する動作を指定する方法を知ったので、リスト10-5に戻り、ジェネリック型パラメータを使用する<code>largest</code>関数の定義を修正しましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Last time we tried to run that code, we received this error:</span>前回このコードを実行しようとしましたが、このエラーが発生しました：</span> </p><br><div data-lang=text><div data-l="error[E0369]: binary operation `&gt;` cannot be applied to type `T`"></div><div data-l=" --&gt; src/main.rs:5:12"></div><div data-l="  |"></div><div data-l="5 |         if item &gt; largest {"></div><div data-l="  |            ^^^^^^^^^^^^^^"></div><div data-l="  |"></div><div data-l="  = note: an implementation of `std::cmp::PartialOrd` might be missing for `T`"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In the body of <code>largest</code> we wanted to compare two values of type <code>T</code> using the greater than ( <code>&gt;</code> ) operator.</span> <code>largest</code>の本体では、より大きい（ <code>&gt;</code> ）演算子を使用して<code>T</code>型の2つの値を比較したいと考えました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because that operator is defined as a default method on the standard library trait <code>std::cmp::PartialOrd</code> , we need to specify <code>PartialOrd</code> in the trait bounds for <code>T</code> so the <code>largest</code> function can work on slices of any type that we can compare.</span>この演算子は標準ライブラリの特性<code>std::cmp::PartialOrd</code>デフォルトメソッドとして定義されているため、 <code>T</code>の特性境界に<code>PartialOrd</code>を指定する必要があります。そのため、 <code>largest</code>関数は比較可能なすべてのタイプのスライスを処理できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We don&#39;t need to bring <code>PartialOrd</code> into scope because it&#39;s in the prelude.</span> <code>PartialOrd</code>入れているので、 <code>PartialOrd</code>をスコープに入れる必要はありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Change the signature of <code>largest</code> to look like this:</span> <code>largest</code>の署名を次のように変更します。</span> </p><br><div data-lang=rust,ignore><div data-l="fn largest&lt;T: PartialOrd&gt;(list: &amp;[T]) -&gt; T {"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This time when we compile the code, we get a different set of errors:</span>今回は、コードをコンパイルするときに、異なる一連のエラーが発生します。</span> </p><br><div data-lang=text><div data-l="error[E0508]: cannot move out of type `[T]`, a non-copy slice"></div><div data-l=" --&gt; src/main.rs:2:23"></div><div data-l="  |"></div><div data-l="2 |     let mut largest = list[0];"></div><div data-l="  |                       ^^^^^^^"></div><div data-l="  |                       |"></div><div data-l="  |                       cannot move out of here"></div><div data-l="  |                       help: consider using a reference instead: `&amp;list[0]`"></div><div data-l=""></div><div data-l="error[E0507]: cannot move out of borrowed content"></div><div data-l=" --&gt; src/main.rs:4:9"></div><div data-l="  |"></div><div data-l="4 |     for &amp;item in list.iter() {"></div><div data-l="  |         ^----"></div><div data-l="  |         ||"></div><div data-l="  |         |hint: to prevent move, use `ref item` or `ref mut item`"></div><div data-l="  |         cannot move out of borrowed content"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The key line in this error is <code>cannot move out of type [T], a non-copy slice</code> .</span>このエラーのキー行は<code>cannot move out of type [T], a non-copy slice</code>は<code>cannot move out of type [T], a non-copy slice</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">With our non-generic versions of the <code>largest</code> function, we were only trying to find the largest <code>i32</code> or <code>char</code> .</span> <code>largest</code>関数の非ジェネリック版では、私たちは最大の<code>i32</code>または<code>char</code>を見つけようとしていました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As discussed in the “Stack-Only Data: Copy” section in Chapter 4, types like <code>i32</code> and <code>char</code> that have a known size can be stored on the stack, so they implement the <code>Copy</code> trait.</span>第4章の「スタック専用データ：コピー」の項で説明したように、既知のサイズの<code>i32</code>や<code>char</code>などの型をスタックに格納できるため、 <code>Copy</code>特性が実装されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But when we made the <code>largest</code> function generic, it became possible for the <code>list</code> parameter to have types in it that don&#39;t implement the <code>Copy</code> trait.</span>しかし、私たちが<code>largest</code>汎用関数を作成したとき、 <code>list</code>パラメータには<code>Copy</code>特性を実装しない型を持つことが可能になりました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Consequently, we wouldn&#39;t be able to move the value out of <code>list[0]</code> and into the <code>largest</code> variable, resulting in this error.</span>したがって、 <code>list[0]</code>から<code>largest</code>変数に値を移動することができず、このエラーが発生します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To call this code with only those types that implement the <code>Copy</code> trait, we can add <code>Copy</code> to the trait bounds of <code>T</code> !</span> <code>Copy</code>特性を実装する型だけでこのコードを呼び出すには、 <code>T</code> ！の特性境界に<code>Copy</code>を追加することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 10-15 shows the complete code of a generic <code>largest</code> function that will compile as long as the types of the values in the slice that we pass into the function implement the <code>PartialOrd</code> <i>and</i> <code>Copy</code> traits, like <code>i32</code> and <code>char</code> do.</span>リスト10-15は、私たちが関数に渡すスライス内の値の型が、 <code>PartialOrd</code> <i>と</i> <code>Copy</code>特性を実装している限り、コンパイルする一般的な<code>largest</code>関数の完全なコードを示しています（ <code>i32</code>や<code>char</code> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="fn largest&lt;T: PartialOrd + Copy&gt;(list: &amp;[T]) -&gt; T {"></div><div data-l="    let mut largest = list[0];"></div><div data-l=""></div><div data-l="    for &amp;item in list.iter() {"></div><div data-l="        if item &gt; largest {"></div><div data-l="            largest = item;"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=""></div><div data-l="    largest"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let number_list = vec![34, 50, 25, 100, 65];"></div><div data-l=""></div><div data-l="    let result = largest(&amp;number_list);"></div><div data-l="    println!(&quot;The largest number is {}&quot;, result);"></div><div data-l=""></div><div data-l="    let char_list = vec!['y', 'm', 'a', 'q'];"></div><div data-l=""></div><div data-l="    let result = largest(&amp;char_list);"></div><div data-l="    println!(&quot;The largest char is {}&quot;, result);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 10-15: A working definition of the <code>largest</code> function that works on any generic type that implements the <code>PartialOrd</code> and <code>Copy</code> traits</span></span> <span class=caption>リスト10-15： <code>PartialOrd</code>と<code>Copy</code>特性を実装するジェネリック型で動作する<code>largest</code>関数の動作定義</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we don&#39;t want to restrict the <code>largest</code> function to the types that implement the <code>Copy</code> trait, we could specify that <code>T</code> has the trait bound <code>Clone</code> instead of <code>Copy</code> .</span> <code>largest</code>関数を<code>Copy</code>特性を実装する型に制限したくない場合、 <code>T</code>は<code>Copy</code>代わりに<code>Clone</code>にバインドされた特性を持つと指定することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then we could clone each value in the slice when we want the <code>largest</code> function to have ownership.</span>次に、 <code>largest</code>関数に所有権を持たせたいときに、スライス内の各値を複製できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Using the <code>clone</code> function means we&#39;re potentially making more heap allocations in the case of types that own heap data like <code>String</code> , and heap allocations can be slow if we&#39;re working with large amounts of data.</span> <code>clone</code>関数を使用すると、 <code>String</code>ようなヒープデータを所有する型の場合にヒープ割り当てを増やす可能性があり、大量のデータを扱う場合はヒープ割り当てが遅くなる可能性があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Another way we could implement <code>largest</code> is for the function to return a reference to a <code>T</code> value in the slice.</span> <code>largest</code>実装できる別の方法は、関数がスライス内の<code>T</code>値への参照を返すことです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we change the return type to <code>&amp;T</code> instead of <code>T</code> , thereby changing the body of the function to return a reference, we wouldn&#39;t need the <code>Clone</code> or <code>Copy</code> trait bounds and we could avoid heap allocations.</span>私たちがして戻り値の型を変更した場合は<code>&amp;T</code>の代わりに、 <code>T</code> 、それによって参照を返すために、関数の本体を変更し、我々は必要はありません<code>Clone</code>または<code>Copy</code>形質境界を、私たちは、ヒープ割り当てを避けることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Try implementing these alternate solutions on your own!</span>これらの代替ソリューションを自分で実装してみてください！</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Using Trait Bounds to Conditionally Implement Methods</span>特性境界を使用して条件付きでメソッドを実装する</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">By using a trait bound with an <code>impl</code> block that uses generic type parameters, we can implement methods conditionally for types that implement the specified traits.</span>ジェネリック型パラメータを使用する<code>impl</code>ブロックでバインドされた特性を使用することによって、指定された特性を実装するタイプに対して条件付きでメソッドを実装できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, the type <code>Pair&lt;T&gt;</code> in Listing 10-16 always implements the <code>new</code> function.</span>たとえば、リスト10-16の<code>Pair&lt;T&gt;</code>型は常に<code>new</code>関数を実装します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But <code>Pair&lt;T&gt;</code> only implements the <code>cmp_display</code> method if its inner type <code>T</code> implements the <code>PartialOrd</code> trait that enables comparison <i>and</i> the <code>Display</code> trait that enables printing.</span>しかし、 <code>Pair&lt;T&gt;</code>のみを実装<code>cmp_display</code>そのインナータイプの場合、このメソッド<code>T</code>実装<code>PartialOrd</code> <i>比較</i>可能な形質<code>Display</code> 、印刷を可能に形質を。</span> </p><br><div data-lang=rust><div data-l="use std::fmt::Display;"></div><div data-l=""></div><div data-l="struct Pair&lt;T&gt; {"></div><div data-l="    x: T,"></div><div data-l="    y: T,"></div><div data-l=}></div><div data-l=""></div><div data-l="impl&lt;T&gt; Pair&lt;T&gt; {"></div><div data-l="    fn new(x: T, y: T) -&gt; Self {"></div><div data-l="        Self {"></div><div data-l="            x,"></div><div data-l="            y,"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="impl&lt;T: Display + PartialOrd&gt; Pair&lt;T&gt; {"></div><div data-l="    fn cmp_display(&amp;self) {"></div><div data-l="        if self.x &gt;= self.y {"></div><div data-l="            println!(&quot;The largest member is x = {}&quot;, self.x);"></div><div data-l="        } else {"></div><div data-l="            println!(&quot;The largest member is y = {}&quot;, self.y);"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 10-16: Conditionally implement methods on a generic type depending on trait bounds</span></span> <span class=caption>リスト10-16：特性境界に応じてジェネリック型のメソッドを条件付きで実装する</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can also conditionally implement a trait for any type that implements another trait.</span>また、別の形質を実装する任意の型のための条件を条件付きで実装することもできます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Implementations of a trait on any type that satisfies the trait bounds are called <i>blanket implementations</i> and are extensively used in the Rust standard library.</span>特性境界を満たす任意の型の形質の実装は<i>ブランケット実装</i>と呼ばれ、Rust標準ライブラリで広く使用されています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, the standard library implements the <code>ToString</code> trait on any type that implements the <code>Display</code> trait.</span>たとえば、標準ライブラリは、 <code>Display</code>特性を実装する任意の型の<code>ToString</code>特性を実装します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>impl</code> block in the standard library looks similar to this code:</span>標準ライブラリの<code>impl</code>ブロックは、次のコードに似ています。</span> </p><br><div data-lang=rust,ignore><div data-l="impl&lt;T: Display&gt; ToString for T {"></div><div data-l="#    // --snip--"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">--snip--</span> --snip--</span> </div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because the standard library has this blanket implementation, we can call the <code>to_string</code> method defined by the <code>ToString</code> trait on any type that implements the <code>Display</code> trait.</span>標準ライブラリにはこのブランケット実装があるため、 <code>Display</code>特性を実装するすべての型の<code>ToString</code>特性で定義された<code>to_string</code>メソッドを呼び出すことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, we can turn integers into their corresponding <code>String</code> values like this because integers implement <code>Display</code> :</span>たとえば、整数が<code>Display</code>実装するため、整数を対応する<code>String</code>値に変換できます。</span> </p><br><div data-lang=rust><div data-l="let s = 3.to_string();"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Blanket implementations appear in the documentation for the trait in the “Implementors” section.</span>ブランケット実装は、「実装者」セクションの特性に関するドキュメントに記載されています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Traits and trait bounds let us write code that uses generic type parameters to reduce duplication but also specify to the compiler that we want the generic type to have particular behavior.</span>特性と特性境界は、複製を減らすためにジェネリック型パラメータを使用するコードを書くだけでなく、ジェネリック型に特定の動作を持たせたいというコンパイラを指定します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The compiler can then use the trait bound information to check that all the concrete types used with our code provide the correct behavior.</span>コンパイラは、特性バインド情報を使用して、コードで使用されているすべての具体的な型が正しい動作を提供しているかどうかをチェックできます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In dynamically typed languages, we would get an error at runtime if we called a method on a type that the type didn&#39;t implement.</span>動的に型付けされた言語では、型が実装しなかった型に対してメソッドを呼び出すと、実行時にエラーが発生します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But Rust moves these errors to compile time so we&#39;re forced to fix the problems before our code is even able to run.</span>しかし、Rustはこれらのエラーをコンパイルするためにコンパイルするので、コードを実行する前に問題を修正する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Additionally, we don&#39;t have to write code that checks for behavior at runtime because we&#39;ve already checked at compile time.</span>さらに、コンパイル時にすでにチェックしているため、実行時に動作をチェックするコードを記述する必要はありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Doing so improves performance without having to give up the flexibility of generics.</span>そうすることで、ジェネリックの柔軟性を失うことなく、パフォーマンスが向上します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Another kind of generic that we&#39;ve already been using is called <i>lifetimes</i> .</span>すでに使用している別の種類のジェネリックを<i>ライフタイム</i>と呼びます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rather than ensuring that a type has the behavior we want, lifetimes ensure that references are valid as long as we need them to be.</span>タイプが私たちが望むふるまいを持つことを保証するのではなく、生涯は、参照が必要である限り有効であることを保証します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s look at how lifetimes do that.</span>生涯がどのようにそれをするかを見てみましょう。</span> </p><script>_addload(function(){_setupIW('com');_csi('en','ja','ch10-02-traits.html');});</script>