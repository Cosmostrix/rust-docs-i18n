<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180709_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=ch18-02-refutability.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Refutability: Whether a Pattern Might Fail to Match</span> Refutability：パターンが一致しないかどうか</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Patterns come in two forms: refutable and irrefutable.</span>パターンには、2つの形式があります：refutableとrefrefutableです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Patterns that will match for any possible value passed are <i>irrefutable</i> .</span>渡される可能性のある値と一致するパターンは<i>反駁不可能</i>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">An example would be <code>x</code> in the statement <code>let x = 5;</code></span>例は、 <code>let x = 5;</code>ステートメントの<code>x</code>となり<code>let x = 5;</code></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">because <code>x</code> matches anything and therefore cannot fail to match.</span> <code>x</code>何にもマッチするので、一致することができないからです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Patterns that can fail to match for some possible value are <i>refutable</i> .</span>可能な値と一致しないパターンは<i>再現</i>可能です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">An example would be <code>Some(x)</code> in the expression <code>if let Some(x) = a_value</code> because if the value in the <code>a_value</code> variable is <code>None</code> rather than <code>Some</code> , the <code>Some(x)</code> pattern will not match.</span>例は次のようになり<code>Some(x)</code>式中の<code>if let Some(x) = a_value</code>の値場合ため<code>a_value</code>変数はありません<code>None</code>ではなく、 <code>Some</code> 、 <code>Some(x)</code>パターンが一致しません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Function parameters, <code>let</code> statements, and <code>for</code> loops can only accept irrefutable patterns, because the program cannot do anything meaningful when values don&#39;t match.</span>関数のパラメータ、 <code>let</code>文、 <code>for</code>ループは反駁不能なパターンしか受け付けることができません。なぜなら、値が不一致のときにプログラムが何か意味のあることを行うことができないからです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>if let</code> and <code>while let</code> expressions only accept refutable patterns, because by definition they&#39;re intended to handle possible failure: the functionality of a conditional is in its ability to perform differently depending on success or failure.</span> <code>if let</code>および<code>while let</code>式は、定義可能なパターンのみを受け入れます。なぜなら、定義によって、失敗の可能性を処理することを意図しているからです。条件の機能は、成功または失敗に応じて異なる実行能力にあります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In general, you shouldn&#39;t have to worry about the distinction between refutable and irrefutable patterns;</span>一般的に、あなたは、反駁可能なパターンと反駁できないパターンとの区別について心配する必要はありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">however, you do need to be familiar with the concept of refutability so you can respond when you see it in an error message.</span>ただし、エラーメッセージに表示されたときに対応できるように、再互換性の概念に精通している必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In those cases, you&#39;ll need to change either the pattern or the construct you&#39;re using the pattern with, depending on the intended behavior of the code.</span>そのような場合は、意図したコードの動作に応じて、パターンを使用しているパターンまたは構造を変更する必要があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s look at an example of what happens when we try to use a refutable pattern where Rust requires an irrefutable pattern and vice versa.</span> Rustが反駁不可能なパターンを必要とし、逆もまた同様である反駁可能なパターンを使用しようとするとどうなるかの例を見てみましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 18-8 shows a <code>let</code> statement, but for the pattern we&#39;ve specified <code>Some(x)</code> , a refutable pattern.</span>リスト18-8は<code>let</code>文を示していますが、 <code>Some(x)</code>指定したパターンに対しては、改変可能なパターンです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As you might expect, this code will not compile.</span>期待どおり、このコードはコンパイルされません。</span> </p><br><div data-lang=rust,ignore><div data-l="let Some(x) = some_option_value;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 18-8: Attempting to use a refutable pattern with <code>let</code></span></span> <span class=caption>リスト18-8： <code>let</code>改ざん可能なパターンを使用しようとしています</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If <code>some_option_value</code> was a <code>None</code> value, it would fail to match the pattern <code>Some(x)</code> , meaning the pattern is refutable.</span> <code>some_option_value</code>が<code>None</code>値だった場合、パターン<code>Some(x)</code>と一致しないことになります。これはパターンが<code>some_option_value</code>であることを意味します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, the <code>let</code> statement can only accept an irrefutable pattern because there is nothing valid the code can do with a <code>None</code> value.</span>ただし、 <code>let</code>ステートメントは、コードが<code>None</code>値で実行できる有効なものがないため、反駁可能なパターンのみを受け入れることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">At compile time, Rust will complain that we&#39;ve tried to use a refutable pattern where an irrefutable pattern is required:</span>コンパイル時に、Rustは反駁可能なパターンが必要な場合には、再利用可能なパターンを使用しようとしていると不平を言うでしょう：</span> </p><br><div data-lang=text><div data-l="error[E0005]: refutable pattern in local binding: `None` not covered"></div><div data-l=" --&gt;"></div><div data-l="  |"></div><div data-l="3 | let Some(x) = some_option_value;"></div><div data-l="  |     ^^^^^^^ pattern `None` not covered"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because we didn&#39;t cover (and couldn&#39;t cover!) every valid value with the pattern <code>Some(x)</code> , Rust rightfully produces a compiler error.</span>我々はパターン<code>Some(x)</code>ですべての有効な値をカバーしなかったので、錆は正しくコンパイルエラーを生成します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To fix the problem where we have a refutable pattern where an irrefutable pattern is needed, we can change the code that uses the pattern: instead of using <code>let</code> , we can use <code>if let</code> .</span>反駁可能なパターンが必要な修正可能なパターンを持つ問題を修正するには、パターンを使用するコードを変更することができます。letを使用する代わりに<code>let</code>を使用<code>if let</code>ことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then if the pattern doesn&#39;t match, the code will just skip the code in the curly brackets, giving it a way to continue validly.</span>パターンが一致しない場合、コードは中括弧でコードをスキップし、有効に続行する方法を与えます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 18-9 shows how to fix the code in Listing 18-8.</span>コードリスト18-9はコードリスト18-8のコードを修正する方法を示しています。</span> </p><br><div data-lang=rust><div data-l="# let some_option_value: Option&lt;i32&gt; = None;"></div><div data-l="if let Some(x) = some_option_value {"></div><div data-l="    println!(&quot;{}&quot;, x);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 18-9: Using <code>if let</code> and a block with refutable patterns instead of <code>let</code></span></span> <span class=caption>リスト18-9： <code>if let</code>と<code>let</code>代わりにrefutableのパターンを持つブロックを使う</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ve given the code an out!</span>私たちはコードを出しました！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This code is perfectly valid, although it means we cannot use an irrefutable pattern without receiving an error.</span>このコードは完全に有効ですが、エラーを受け取らずに反駁可能なパターンを使用することはできません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we give <code>if let</code> a pattern that will always match, such as <code>x</code> , as shown in Listing 18-10, it will not compile.</span>リスト18-10に示すように、 <code>x</code>など、常に一致するパターンを指定した<code>if let</code>そのパターンはコンパイルされません。</span> </p><br><div data-lang=rust,ignore><div data-l="if let x = 5 {"></div><div data-l="    println!(&quot;{}&quot;, x);"></div><div data-l=};></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 18-10: Attempting to use an irrefutable pattern with <code>if let</code></span></span> <span class=caption>リスト18-10： <code>if let</code> ifreflectableパターンを使用しようとした<code>if let</code></span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust complains that it doesn&#39;t make sense to use <code>if let</code> with an irrefutable pattern:</span>錆は、反駁できないパターンで<code>if let</code>を使うと意味をなさないと訴える：</span> </p><br><div data-lang=text><div data-l="error[E0162]: irrefutable if-let pattern"></div><div data-l=" --&gt; &lt;anon&gt;:2:8"></div><div data-l="  |"></div><div data-l="2 | if let x = 5 {"></div><div data-l="  |        ^ irrefutable pattern"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For this reason, match arms must use refutable patterns, except for the last arm, which should match any remaining values with an irrefutable pattern.</span>このため、マッチアームは最後のアームを除いて、リフレクタブルパターンを使用しなければなりません。残りの値は反駁できないパターンと一致するはずです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust allows us to use an irrefutable pattern in a <code>match</code> with only one arm, but this syntax isn&#39;t particularly useful and could be replaced with a simpler <code>let</code> statement.</span> Rustでは、1つの腕との<code>match</code>で反駁不能なパターンを使用することができますが、この構文は特に有用ではなく、より簡単な<code>let</code>文で置き換えることができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now that you know where to use patterns and the difference between refutable and irrefutable patterns, let&#39;s cover all the syntax we can use to create patterns.</span>パターンを使用する場所と、改ざん可能なパターンと反駁できないパターンの違いを知ったので、パターンを作成するために使用できるすべての構文について説明しましょう。</span> </p><script>_addload(function(){_setupIW('com');_csi('en','ja','ch18-02-refutability.html');});</script>