<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180709_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "è‹±èªã®åŸæ–‡ãƒ†ã‚­ã‚¹ãƒˆ:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s ã« %2$s ã«ã‚ˆã‚Šç¿»è¨³ã•ã‚Œã¾ã—ãŸ";_intlStrings._unknown="ä¸æ˜";_intlStrings._suggestTranslation="ç¿»è¨³ã‚’æ”¹å–„ã™ã‚‹"  ;_intlStrings._submit="é€ä¿¡";_intlStrings._suggestThanks="Google ç¿»è¨³ã®æ”¹å–„ã«ã”å”åŠ›ã„ãŸã ãã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã—ãŸã€‚";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=ch03-02-data-types.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Data Types</span>ãƒ‡ãƒ¼ã‚¿å‹</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Every value in Rust is of a certain <i>data type</i> , which tells Rust what kind of data is being specified so it knows how to work with that data.</span> Rustã®å„å€¤ã¯ç‰¹å®šã®<i>ãƒ‡ãƒ¼ã‚¿å‹ã®ã‚‚ã®ã§</i> ã€æŒ‡å®šã•ã‚Œã¦ã„ã‚‹ãƒ‡ãƒ¼ã‚¿ã®ç¨®é¡ã‚’Rustã«çŸ¥ã‚‰ã›ã‚‹ã®ã§ã€ãã®ãƒ‡ãƒ¼ã‚¿ã®å‡¦ç†æ–¹æ³•ã‚’çŸ¥ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll look at two data type subsets: scalar and compound.</span>ã‚¹ã‚«ãƒ©ãƒ¼ã¨è¤‡åˆä½“ã®2ã¤ã®ãƒ‡ãƒ¼ã‚¿å‹ã‚µãƒ–ã‚»ãƒƒãƒˆã‚’è¦‹ã¦ã„ãã¾ã™ã€‚</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Keep in mind that Rust is a <i>statically typed</i> language, which means that it must know the types of all variables at compile time.</span> Rustã¯<i>é™çš„å‹ä»˜ã</i>è¨€èªã§ã‚ã‚Šã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«ã™ã¹ã¦ã®å¤‰æ•°ã®å‹ã‚’çŸ¥ã£ã¦ã„ã‚‹å¿…è¦ãŒã‚ã‚‹ã“ã¨ã‚’è¦šãˆã¦ãŠã„ã¦ãã ã•ã„ã€‚</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The compiler can usually infer what type we want to use based on the value and how we use it.</span>ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã¯ã€é€šå¸¸ã€å€¤ã¨ä½¿ç”¨æ–¹æ³•ã«åŸºã¥ã„ã¦ã€ä½¿ç”¨ã™ã‚‹å‹ã‚’æ¨è«–ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In cases when many types are possible, such as when we converted a <code>String</code> to a numeric type using <code>parse</code> in the â€œComparing the Guess to the Secret Numberâ€ section in Chapter 2, we must add a type annotation, like this:</span>ç¬¬2ç« ã®ã€Œæ¨æ¸¬å€¤ã¨ç§˜å¯†ç•ªå·ã®æ¯”è¼ƒã€ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã§<code>parse</code>ã‚’ä½¿ã£ã¦<code>String</code>ã‚’æ•°å€¤å‹ã«å¤‰æ›ã—ãŸã¨ããªã©ã€å¤šãã®å‹ãŒå¯èƒ½ãªå ´åˆã¯ã€æ¬¡ã®ã‚ˆã†ã«å‹ã®æ³¨é‡ˆã‚’è¿½åŠ ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚</span> </p><br><div data-lang=rust><div data-l="let guess: u32 = &quot;42&quot;.parse().expect(&quot;Not a number!&quot;);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we don&#39;t add the type annotation here, Rust will display the following error, which means the compiler needs more information from us to know which type we want to use:</span>ã‚¿ã‚¤ãƒ—æ³¨é‡ˆã‚’ã“ã“ã«è¿½åŠ ã—ãªã„ã¨ã€Rustã¯æ¬¡ã®ã‚¨ãƒ©ãƒ¼ã‚’è¡¨ç¤ºã—ã¾ã™ã€‚ã“ã‚Œã¯ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãŒä½¿ç”¨ã—ãŸã„ã‚¿ã‚¤ãƒ—ã‚’çŸ¥ã‚‹ãŸã‚ã«ç§ãŸã¡ã‹ã‚‰ã‚ˆã‚Šå¤šãã®æƒ…å ±ã‚’å¿…è¦ã¨ã™ã‚‹ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚</span> </p><br><div data-lang=text><div data-l="error[E0282]: type annotations needed"></div><div data-l=" --&gt; src/main.rs:2:9"></div><div data-l="  |"></div><div data-l="2 |     let guess = &quot;42&quot;.parse().expect(&quot;Not a number!&quot;);"></div><div data-l="  |         ^^^^^"></div><div data-l="  |         |"></div><div data-l="  |         cannot infer type for `_`"></div><div data-l="  |         consider giving `guess` a type"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You&#39;ll see different type annotations for other data types.</span>ä»–ã®ãƒ‡ãƒ¼ã‚¿å‹ã«ã¯ç•°ãªã‚‹ã‚¿ã‚¤ãƒ—ã®æ³¨é‡ˆãŒè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Scalar Types</span>ã‚¹ã‚«ãƒ©å‹</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A <i>scalar</i> type represents a single value.</span> <i>ã‚¹ã‚«ãƒ©</i>å‹ã¯å˜ä¸€ã®å€¤ã‚’è¡¨ã—ã¾ã™ã€‚</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust has four primary scalar types: integers, floating-point numbers, Booleans, and characters.</span> Rustã«ã¯ã€æ•´æ•°ã€æµ®å‹•å°æ•°ç‚¹æ•°ã€ãƒ–ãƒ¼ãƒ«å€¤ã€ãŠã‚ˆã³æ–‡å­—ã®4ã¤ã®ä¸»ãªã‚¹ã‚«ãƒ©å‹ãŒã‚ã‚Šã¾ã™ã€‚</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You may recognize these from other programming languages.</span>ã“ã‚Œã‚‰ã¯ä»–ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªã‹ã‚‰èªè­˜ã•ã‚Œã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s jump into how they work in Rust.</span>å½¼ã‚‰ãŒRustã§ã©ã®ã‚ˆã†ã«åƒã„ã¦ã„ã‚‹ã‹ã‚’è€ƒãˆã¦ã¿ã¾ã—ã‚‡ã†ã€‚</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Integer Types</span>æ•´æ•°å‹</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">An <i>integer</i> is a number without a fractional component.</span> <i>æ•´æ•°</i>ã¯å°æ•°æˆåˆ†ã®ãªã„æ•°å€¤ã§ã™ã€‚</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We used one integer type in Chapter 2, the <code>u32</code> type.</span>ç¬¬2ç« ã§ã¯ã€ <code>u32</code>å‹ã®1ã¤ã®æ•´æ•°å‹ã‚’ä½¿ç”¨ã—ã¾ã—ãŸã€‚</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This type declaration indicates that the value it&#39;s associated with should be an unsigned integer (signed integer types start with <code>i</code> , instead of <code>u</code> ) that takes up 32 bits of space.</span>ã“ã®å‹å®£è¨€ã¯ã€é–¢é€£ã™ã‚‹å€¤ãŒã€32ãƒ“ãƒƒãƒˆã®ç©ºé–“ã‚’å ã‚ã‚‹ç¬¦å·ãªã—æ•´æ•°ï¼ˆç¬¦å·ä»˜ãæ•´æ•°å‹ã¯ã€ <code>u</code>ä»£ã‚ã‚Šã«<code>i</code>ã§å§‹ã¾ã‚‹ï¼‰ã§ãªã‘ã‚Œã°ãªã‚‰ãªã„ã“ã¨ã‚’ç¤ºã—ã¾ã™ã€‚</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Table 3-1 shows the built-in integer types in Rust.</span>è¡¨3-1ã«ã€Rustã®çµ„ã¿è¾¼ã¿æ•´æ•°å‹ã‚’ç¤ºã—ã¾ã™ã€‚</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Each variant in the Signed and Unsigned columns (for example, <code>i16</code> ) can be used to declare the type of an integer value.</span> Signedåˆ—ã¨Unsignedåˆ—ã®å„ãƒãƒªã‚¢ãƒ³ãƒˆï¼ˆãŸã¨ãˆã°<code>i16</code> ï¼‰ã‚’ä½¿ç”¨ã—ã¦ã€æ•´æ•°å€¤ã®å‹ã‚’å®£è¨€ã§ãã¾ã™ã€‚</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Table 3-1: Integer Types in Rust</span></span> <span class=caption>è¡¨3-1ï¼šéŒ†ã®æ•´æ•°å‹</span></span> </p><br><div data-tbl><div> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Length</span>é•·ã•</span> </div><div> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Signed</span>ç½²åã•ã‚ŒãŸ</span> </div><div> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Unsigned</span>ç½²åãªã—</span> </div></div><div data-tbl><div> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">--------</span> --------</span> </div><div> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">---------</span> ---------</span> </div><div> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">----------</span> ----------</span> </div></div><div data-tbl><div> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">8-bit</span> 8ãƒ“ãƒƒãƒˆ</span> </div><div> <code>i8</code> </div> <div> <code>u8</code> </div> </div><div data-tbl><div> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">16-bit</span> 16ãƒ“ãƒƒãƒˆ</span> </div><div> <code>i16</code> </div> <div> <code>u16</code> </div> </div><div data-tbl><div> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">32-bit</span> 32ãƒ“ãƒƒãƒˆ</span> </div><div> <code>i32</code> </div> <div> <code>u32</code> </div> </div><div data-tbl><div> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">64-bit</span> 64ãƒ“ãƒƒãƒˆ</span> </div><div> <code>i64</code> </div> <div> <code>u64</code> </div> </div><div data-tbl><div> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">arch</span>ã‚¢ãƒ¼ãƒ</span> </div><div> <code>isize</code> </div> <div> <code>usize</code> </div> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Each variant can be either signed or unsigned and has an explicit size.</span>å„ãƒãƒªã‚¢ãƒ³ãƒˆã¯ã€ç¬¦å·ä»˜ãã¾ãŸã¯ç¬¦å·ãªã—ã®ã„ãšã‚Œã‹ã§ã‚ã‚Šã€æ˜ç¤ºçš„ãªã‚µã‚¤ã‚ºã‚’æŒã¡ã¾ã™ã€‚</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><i>Signed</i> and <i>unsigned</i> refer to whether it&#39;s possible for the number to be negative or positiveâ€”in other words, whether the number needs to have a sign with it (signed) or whether it will only ever be positive and can therefore be represented without a sign (unsigned).</span> <i>ç¬¦å·ä»˜ã</i>ã¨<i>ç¬¦å·ãªã—</i>ã¯ã€ãã®æ•°å€¤ãŒè² ã§ã‚ã‚‹ã‹æ­£ã§ã‚ã‚‹ã‹ã€ã¤ã¾ã‚Šãã®æ•°å€¤ã«ç¬¦å·ãŒä»˜ã„ã¦ã„ã‚‹å¿…è¦ãŒã‚ã‚‹ï¼ˆç¬¦å·ä»˜ãã§ã‚ã‚‹ï¼‰ã‹ã€æ­£ã§ã‚ã‚‹ã‹ã©ã†ã‹ã ã‘ã§ç¬¦å·ãªã—ã§è¡¨ã™ã“ã¨ãŒã§ãã‚‹ã‹ã©ã†ã‹ã‚’ç¤ºã—ã¾ã™ï¼ˆç¬¦å·ãªã—ï¼‰ã€‚</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It&#39;s like writing numbers on paper: when the sign matters, a number is shown with a plus sign or a minus sign;</span>ãã‚Œã¯ç´™ã«æ•°å­—ã‚’æ›¸ãã‚ˆã†ãªã‚‚ã®ã§ã™ã€‚è¨˜å·ãŒé‡è¦ãªã¨ãã¯ãƒ—ãƒ©ã‚¹è¨˜å·ã¾ãŸã¯ãƒã‚¤ãƒŠã‚¹è¨˜å·ã§æ•°å­—ãŒè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">however, when it&#39;s safe to assume the number is positive, it&#39;s shown with no sign.</span>ã—ã‹ã—ã€æ•°å­—ãŒæ­£ã§ã‚ã‚‹ã¨ä»®å®šã™ã‚‹ã“ã¨ã¯å®‰å…¨ã§ã™ãŒã€ãã‚Œã¯è¨˜å·ãªã—ã§ç¤ºã•ã‚Œã¾ã™ã€‚</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Signed numbers are stored using two&#39;s complement representation (if you&#39;re unsure what this is, you can search for it online; an explanation is outside the scope of this book).</span>ç¬¦å·ä»˜ãæ•°å€¤ã¯ã€2ã®è£œæ•°è¡¨ç¾ã‚’ä½¿ç”¨ã—ã¦æ ¼ç´ã•ã‚Œã¾ã™ï¼ˆã“ã‚ŒãŒä½•ã§ã‚ã‚‹ã‹ã‚ã‹ã‚‰ãªã„å ´åˆã¯ã€ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ã§æ¤œç´¢ã§ãã¾ã™ãŒèª¬æ˜ã¯æœ¬æ›¸ã®ç¯„å›²å¤–ã§ã™ï¼‰ã€‚</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Each signed variant can store numbers from -(2 <sup>n - 1</sup> ) to 2 <sup>n - 1</sup> - 1 inclusive, where <i>n</i> is the number of bits that variant uses.</span>å„ç¬¦å·ä»˜ããƒãƒªã‚¢ãƒ³ãƒˆã¯ - ï¼ˆ2 <sup>n-1</sup> ï¼‰ã‹ã‚‰2 <sup>n-1</sup> -1ã¾ã§ã®æ•°ã‚’æ ¼ç´ã§ãã¾ã™<i>.n</i>ã¯ãƒãƒªã‚¢ãƒ³ãƒˆãŒä½¿ç”¨ã™ã‚‹ãƒ“ãƒƒãƒˆæ•°ã§ã™ã€‚</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So an <code>i8</code> can store numbers from -(2 <sup>7</sup> ) to 2 <sup>7</sup> - 1, which equals -128 to 127. Unsigned variants can store numbers from 0 to 2 <sup>n</sup> - 1, so a <code>u8</code> can store numbers from 0 to 2 <sup>8</sup> - 1, which equals 0 to 255.</span>ã—ãŸãŒã£ã¦ã€ <code>i8</code>ã¯ - ï¼ˆ2 <sup>7</sup> ï¼‰ <code>u8</code> <sup>7</sup> -  1ã®æ•°å€¤ã‚’<code>u8</code>ã§ãã¾ã™ã€‚ç¬¦å·ãªã—å¤‰æ•°ã«ã¯0ã€œ2 <sup>n</sup> -  1ã®æ•°å€¤ã‚’æ ¼ç´ã§ãã‚‹ã®ã§ã€ <code>u8</code> <sup>8ã«</sup>ã¯0ã€œ2ã®æ•°å€¤ã‚’æ ¼ç´ã§ãã¾ã™<sup>8</sup> - 1ã€ã“ã‚Œã¯0ã€œ255ã§ã™ã€‚</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Additionally, the <code>isize</code> and <code>usize</code> types depend on the kind of computer your program is running on: 64 bits if you&#39;re on a 64-bit architecture and 32 bits if you&#39;re on a 32-bit architecture.</span>ã•ã‚‰ã«ã€ <code>isize</code>ã¨<code>usize</code>ç¨®é¡ã¯ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒå®Ÿè¡Œã•ã‚Œã¦ã„ã‚‹ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ã®ç¨®é¡ã«ã‚ˆã£ã¦ç•°ãªã‚Šã¾ã™.64ãƒ“ãƒƒãƒˆã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã®å ´åˆã¯64ãƒ“ãƒƒãƒˆã€32ãƒ“ãƒƒãƒˆã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã®å ´åˆã¯32ãƒ“ãƒƒãƒˆã§ã™ã€‚</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can write integer literals in any of the forms shown in Table 3-2.</span>è¡¨3-2ã«ç¤ºã™ã„ãšã‚Œã‹ã®å½¢å¼ã§æ•´æ•°ãƒªãƒ†ãƒ©ãƒ«ã‚’è¨˜è¿°ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that all number literals except the byte literal allow a type suffix, such as <code>57u8</code> , and <code>_</code> as a visual separator, such as <code>1_000</code> .</span>ãƒã‚¤ãƒˆãƒªãƒ†ãƒ©ãƒ«ä»¥å¤–ã®ã™ã¹ã¦ã®æ•°å­—ãƒªãƒ†ãƒ©ãƒ«ã¯ã€ <code>57u8</code>ãªã©ã®ã‚¿ã‚¤ãƒ—æ¥å°¾è¾ã€ãŠã‚ˆã³<code>1_000</code>ãªã©ã®è¦–è¦šçš„åŒºåˆ‡ã‚Šæ–‡å­—ã¨ã—ã¦ã®<code>_</code>ã‚’è¨±å¯ã™ã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Table 3-2: Integer Literals in Rust</span></span> <span class=caption>è¡¨3-2ï¼šéŒ†ã®æ•´æ•°ãƒªãƒ†ãƒ©ãƒ«</span></span> </p><br><div data-tbl><div> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Number literals</span>æ•°ãƒªãƒ†ãƒ©ãƒ«</span> </div><div> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Example</span>ä¾‹</span> </div></div><div data-tbl><div> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">------------------</span> ------------------</span> </div><div> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">---------------</span> ---------------</span> </div></div><div data-tbl><div> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Decimal</span>å°æ•°</span> </div><div> <code>98_222</code> </div> </div><div data-tbl><div> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Hex</span>ãƒ˜ã‚­ã‚µ</span> </div><div> <code>0xff</code> </div> </div><div data-tbl><div> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Octal</span>ã‚ªã‚¯ã‚¿ãƒ«</span> </div><div> <code>0o77</code> </div> </div><div data-tbl><div> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Binary</span>ãƒã‚¤ãƒŠãƒª</span> </div><div> <code>0b1111_0000</code> </div> </div><div data-tbl><div> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Byte ( <code>u8</code> only)</span>ãƒã‚¤ãƒˆï¼ˆ <code>u8</code>ã®ã¿ï¼‰</span> </div><div> <code>b&#39;A&#39;</code> </div> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So how do you know which type of integer to use?</span>ã ã‹ã‚‰ã©ã®ã‚ˆã†ãªã‚¿ã‚¤ãƒ—ã®æ•´æ•°ã‚’ä½¿ã†ã¹ãã‹ã€ã©ã®ã‚ˆã†ã«çŸ¥ã£ã¦ã„ã¾ã™ã‹ï¼Ÿ</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you&#39;re unsure, Rust&#39;s defaults are generally good choices, and integer types default to <code>i32</code> : this type is generally the fastest, even on 64-bit systems.</span>ã‚‚ã—ã‚ãªãŸãŒç¢ºä¿¡ãŒæŒã¦ãªã„ãªã‚‰ã€Rustã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãŒä¸€èˆ¬çš„ã«è‰¯ã„é¸æŠè‚¢ã§ã‚ã‚Šã€æ•´æ•°å‹ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§<code>i32</code>ã¾ã™ã€‚ã“ã®ã‚¿ã‚¤ãƒ—ã¯ã€64ãƒ“ãƒƒãƒˆã‚·ã‚¹ãƒ†ãƒ ã§ã•ãˆä¸€èˆ¬çš„ã«æœ€ã‚‚é«˜é€Ÿã§ã™ã€‚</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The primary situation in which you&#39;d use <code>isize</code> or <code>usize</code> is when indexing some sort of collection.</span> <code>isize</code>ã¾ãŸã¯<code>usize</code>ä½¿ç”¨ã™ã‚‹ä¸»ãªçŠ¶æ³ã¯ã€ä½•ã‚‰ã‹ã®ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ä½œæˆã™ã‚‹ã¨ãã§ã™ã€‚</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Floating-Point Types</span>æµ®å‹•å°æ•°ç‚¹å‹</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust also has two primitive types for <i>floating-point numbers</i> , which are numbers with decimal points.</span> Rustã«ã¯ã€ <i>å°æ•°ç‚¹ã®ã‚ã‚‹æµ®å‹•å°æ•°ç‚¹æ•°ã®</i> 2ã¤ã®ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–å‹ã‚‚ã‚ã‚Šã¾ã™ã€‚</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust&#39;s floating-point types are <code>f32</code> and <code>f64</code> , which are 32 bits and 64 bits in size, respectively.</span> Rustã®æµ®å‹•å°æ•°ç‚¹å‹ã¯ã€ãã‚Œãã‚Œ32ãƒ“ãƒƒãƒˆã¨64ãƒ“ãƒƒãƒˆã®<code>f32</code>ã¨<code>f64</code>ã§ã™ã€‚</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The default type is <code>f64</code> because on modern CPUs it&#39;s roughly the same speed as <code>f32</code> but is capable of more precision.</span>ç¾ä»£ã®CPUã§ã¯<code>f32</code>ã¨ã»ã¼åŒã˜é€Ÿåº¦ã§ã™ãŒã€ã‚ˆã‚Šç²¾åº¦ãŒé«˜ã„ã®ã§ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ã‚¿ã‚¤ãƒ—ã¯<code>f64</code>ã§ã™ã€‚</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here&#39;s an example that shows floating-point numbers in action:</span>å®Ÿéš›ã®æµ®å‹•å°æ•°ç‚¹æ•°ã‚’ç¤ºã™ä¾‹ã§ã™ï¼š</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ãƒ•ã‚¡ã‚¤ãƒ«åï¼šsrc / main.rs</span></span> </p><br><div data-lang=rust><div data-l="fn main() {"></div><div data-l="#//    let x = 2.0; // f64"></div><div data-l="    let x = 2.0; // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">f64</span> f64</span> </div><div data-l=""></div><div data-l="#//    let y: f32 = 3.0; // f32"></div><div data-l="    let y: f32 = 3.0; // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">f32</span> f32</span> </div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Floating-point numbers are represented according to the IEEE-754 standard.</span>æµ®å‹•å°æ•°ç‚¹æ•°ã¯ã€IEEE-754æ¨™æº–ã«å¾“ã£ã¦è¡¨ã•ã‚Œã¾ã™ã€‚</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>f32</code> type is a single-precision float, and <code>f64</code> has double precision.</span> <code>f32</code>å‹ã¯å˜ç²¾åº¦æµ®å‹•å°æ•°ç‚¹å‹ã§ã€ <code>f64</code>å‹ã¯å€ç²¾åº¦ã§ã™ã€‚</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Numeric Operations</span>æ•°å€¤æ¼”ç®—</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust supports the basic mathematical operations you&#39;d expect for all of the number types: addition, subtraction, multiplication, division, and remainder.</span> Rustã¯ã€åŠ ç®—ã€æ¸›ç®—ã€ä¹—ç®—ã€é™¤ç®—ã€ãŠã‚ˆã³å‰°ä½™ã®ã™ã¹ã¦ã®æ•°å€¤ã‚¿ã‚¤ãƒ—ã«æœŸå¾…ã•ã‚Œã‚‹åŸºæœ¬çš„ãªæ•°å­¦æ¼”ç®—ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ã€‚</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The following code shows how you&#39;d use each one in a <code>let</code> statement:</span>æ¬¡ã®ã‚³ãƒ¼ãƒ‰ã¯ã€ <code>let</code>ã‚¹ãƒ†ãƒ¼ãƒˆãƒ¡ãƒ³ãƒˆã§å„ã‚¹ãƒ†ãƒ¼ãƒˆãƒ¡ãƒ³ãƒˆã‚’ã©ã®ã‚ˆã†ã«ä½¿ç”¨ã™ã‚‹ã‹ã‚’ç¤ºã—ã¦ã„ã¾ã™ã€‚</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ãƒ•ã‚¡ã‚¤ãƒ«åï¼šsrc / main.rs</span></span> </p><br><div data-lang=rust><div data-l="fn main() {"></div><div data-l="#    // addition"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">addition</span>æ·»åŠ </span> </div><div data-l="    let sum = 5 + 10;"></div><div data-l=""></div><div data-l="#    // subtraction"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">subtraction</span>æ¸›ç®—</span> </div><div data-l="    let difference = 95.5 - 4.3;"></div><div data-l=""></div><div data-l="#    // multiplication"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">multiplication</span>ä¹—ç®—</span> </div><div data-l="    let product = 4 * 30;"></div><div data-l=""></div><div data-l="#    // division"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">division</span>åˆ†å‰²</span> </div><div data-l="    let quotient = 56.7 / 32.2;"></div><div data-l=""></div><div data-l="#    // remainder"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">remainder</span>æ®‹ä½™</span> </div><div data-l="    let remainder = 43 % 5;"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Each expression in these statements uses a mathematical operator and evaluates to a single value, which is then bound to a variable.</span>ã“ã‚Œã‚‰ã®ã‚¹ãƒ†ãƒ¼ãƒˆãƒ¡ãƒ³ãƒˆã®å„å¼ã¯ã€æ•°å­¦æ¼”ç®—å­ã‚’ä½¿ç”¨ã—ã¦å˜ä¸€ã®å€¤ã«è©•ä¾¡ã•ã‚Œã€å¤‰æ•°ã«ãƒã‚¤ãƒ³ãƒ‰ã•ã‚Œã¾ã™ã€‚</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Appendix B contains a list of all operators that Rust provides.</span>ä»˜éŒ²Bã«ã¯ã€RustãŒæä¾›ã™ã‚‹ã™ã¹ã¦ã®æ¼”ç®—å­ã®ãƒªã‚¹ãƒˆãŒå«ã¾ã‚Œã¦ã„ã¾ã™ã€‚</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The Boolean Type</span>ãƒ–ãƒ¼ãƒ«å‹</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As in most other programming languages, a Boolean type in Rust has two possible values: <code>true</code> and <code>false</code> .</span>ä»–ã®ã»ã¨ã‚“ã©ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªã¨åŒæ§˜ã«ã€Rustã®ãƒ–ãƒ¼ãƒ«å‹ã«ã¯ã€ <code>true</code>ã¨<code>false</code> 2ã¤ã®å€¤ãŒã‚ã‚Š<code>false</code> ã€‚</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The Boolean type in Rust is specified using <code>bool</code> .</span> Rustã®Booleanå‹ã¯ã€ <code>bool</code>ã‚’ä½¿ç”¨ã—ã¦æŒ‡å®šã—ã¾ã™ã€‚</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example:</span>ä¾‹ãˆã°ï¼š</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ãƒ•ã‚¡ã‚¤ãƒ«åï¼šsrc / main.rs</span></span> </p><br><div data-lang=rust><div data-l="fn main() {"></div><div data-l="    let t = true;"></div><div data-l=""></div><div data-l="#//    let f: bool = false; // with explicit type annotation"></div><div data-l="    let f: bool = false; // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">with explicit type annotation</span>æ˜ç¤ºçš„ãªå‹ã®æ³¨é‡ˆä»˜ã</span> </div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The main way to use Boolean values is through conditionals, such as an <code>if</code> expression.</span>ãƒ–ãƒ¼ãƒ«å€¤ã‚’ä½¿ç”¨ã™ã‚‹ä¸»ãªæ–¹æ³•ã¯ã€ <code>if</code>å¼ãªã©ã®æ¡ä»¶å¼ã«ã‚ˆã‚‹ã‚‚ã®ã§ã™ã€‚</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll cover how <code>if</code> expressions work in Rust in the â€œControl Flowâ€ section.</span>ç§ãŸã¡ã¯ã©ã®ã‚ˆã†ã«å–ã‚Šä¸Šã’ã‚‹<code>if</code>ã®å¼ã¯ã€ã€Œåˆ¶å¾¡ãƒ•ãƒ­ãƒ¼ã€ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã§éŒ†ã«åƒãã¾ã™ã€‚</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The Character Type</span>æ–‡å­—ã®ç¨®é¡</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So far we&#39;ve worked only with numbers, but Rust supports letters too.</span>ã“ã‚Œã¾ã§ã¯æ•°å­—ã ã‘ã§ä½œæ¥­ã—ã¦ã„ã¾ã—ãŸãŒã€Rustã‚‚æ‰‹ç´™ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ã€‚</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust&#39;s <code>char</code> type is the language&#39;s most primitive alphabetic type, and the following code shows one way to use it.</span> Rustã®<code>char</code>å‹ã¯ã€è¨€èªã®æœ€ã‚‚åŸºæœ¬çš„ãªã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒƒãƒˆå‹ã§ã™ã€‚æ¬¡ã®ã‚³ãƒ¼ãƒ‰ã¯ã€ãã‚Œã‚’ä½¿ç”¨ã™ã‚‹æ–¹æ³•ã®1ã¤ã‚’ç¤ºã—ã¦ã„ã¾ã™ã€‚</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">(Note that the <code>char</code> type is specified with single quotes, as opposed to strings, which use double quotes.)</span> ï¼ˆ <code>char</code>å‹ã¯äºŒé‡å¼•ç”¨ç¬¦ã‚’ä½¿ç”¨ã™ã‚‹æ–‡å­—åˆ—ã§ã¯ãªãã€ä¸€é‡å¼•ç”¨ç¬¦ã§æŒ‡å®šã•ã‚Œã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ï¼‰ã€‚</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ãƒ•ã‚¡ã‚¤ãƒ«åï¼šsrc / main.rs</span></span> </p><br><div data-lang=rust><div data-l="fn main() {"></div><div data-l="    let c = 'z';"></div><div data-l="    let z = 'â„¤';"></div><div data-l="    let heart_eyed_cat = 'ğŸ˜»';"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust&#39;s <code>char</code> type represents a Unicode Scalar Value, which means it can represent a lot more than just ASCII.</span> Rustã®<code>char</code>å‹ã¯Unicode Scalar Valueã‚’è¡¨ã—ã¦ã„ã¾ã™ã€‚ã¤ã¾ã‚Šã€ASCIIä»¥å¤–ã®å¤šãã®è¦ç´ ã‚’è¡¨ã™ã“ã¨ãŒã§ãã¾ã™ã€‚</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Accented letters;</span>ã‚¢ã‚¯ã‚»ãƒ³ãƒˆä»˜ãã®æ‰‹ç´™ã€‚</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Chinese, Japanese, and Korean characters;</span>ä¸­å›½èªã€æ—¥æœ¬èªã€éŸ“å›½èªã®æ–‡å­—ã€‚</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">emoji;</span>çµµæ–‡å­—;</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">and zero-width spaces are all valid <code>char</code> values in Rust.</span>ã‚¼ãƒ­å¹…ã®ã‚¹ãƒšãƒ¼ã‚¹ã¯ã™ã¹ã¦Rustã®æœ‰åŠ¹ãª<code>char</code>å€¤ã§ã™ã€‚</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Unicode Scalar Values range from <code>U+0000</code> to <code>U+D7FF</code> and <code>U+E000</code> to <code>U+10FFFF</code> inclusive.</span> Unicodeã®ã‚¹ã‚«ãƒ©å€¤ã¯ã€ç¯„å›²<code>U+0000</code>ã«<code>U+D7FF</code>ã¨<code>U+E000</code>ã«<code>U+10FFFF</code>è¾¼ã¿ã€‚</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, a â€œcharacterâ€ isn&#39;t really a concept in Unicode, so your human intuition for what a â€œcharacterâ€ is may not match up with what a <code>char</code> is in Rust.</span>ã—ã‹ã—ã€ã€Œæ–‡å­—ã€ã¯å®Ÿéš›ã«ã¯Unicodeã®æ¦‚å¿µã§ã¯ãªã„ãŸã‚ã€äººé–“ã®ã€Œæ–‡å­—ã€ã®ç›´æ„Ÿã¯ã€ <code>char</code>ãŒRustã®<code>char</code>ã¨ä¸€è‡´ã—ãªã„ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll discuss this topic in detail in â€œStringsâ€ in Chapter 8.</span>ã“ã®ãƒˆãƒ”ãƒƒã‚¯ã«ã¤ã„ã¦ã¯ã€ç¬¬8ç« ã®ã€Œæ–‡å­—åˆ—ã€ã§è©³ã—ãèª¬æ˜ã—ã¾ã™ã€‚</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Compound Types</span>åŒ–åˆç‰©ã‚¿ã‚¤ãƒ—</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><i>Compound types</i> can group multiple values into one type.</span> <i>è¤‡åˆå‹</i>ã¯ã€è¤‡æ•°ã®å€¤ã‚’1ã¤ã®å‹ã«ã‚°ãƒ«ãƒ¼ãƒ—åŒ–ã§ãã¾ã™ã€‚</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust has two primitive compound types: tuples and arrays.</span> Rustã«ã¯ã€ã‚¿ãƒ—ãƒ«ã¨é…åˆ—ã®2ã¤ã®åŸºæœ¬çš„ãªè¤‡åˆå‹ãŒã‚ã‚Šã¾ã™ã€‚</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The Tuple Type</span>ã‚¿ãƒ—ãƒ«ã‚¿ã‚¤ãƒ—</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A tuple is a general way of grouping together some number of other values with a variety of types into one compound type.</span>ã‚¿ãƒ—ãƒ«ã¯ã€ã•ã¾ã–ã¾ãªã‚¿ã‚¤ãƒ—ã®ã„ãã¤ã‹ã®å€¤ã‚’1ã¤ã®è¤‡åˆã‚¿ã‚¤ãƒ—ã«ã‚°ãƒ«ãƒ¼ãƒ—åŒ–ã™ã‚‹ä¸€èˆ¬çš„ãªæ–¹æ³•ã§ã™ã€‚</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We create a tuple by writing a comma-separated list of values inside parentheses.</span>ã‚¿ãƒ—ãƒ«ã¯ã€ã‚«ãƒƒã‚³ã§åŒºåˆ‡ã£ãŸå€¤ã®ãƒªã‚¹ãƒˆã‚’ã‚³ãƒ³ãƒã§åŒºåˆ‡ã£ã¦ä½œæˆã—ã¾ã™ã€‚</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Each position in the tuple has a type, and the types of the different values in the tuple don&#39;t have to be the same.</span>ã‚¿ãƒ—ãƒ«å†…ã®å„ä½ç½®ã¯å‹ã‚’æŒã¡ã€ã‚¿ãƒ—ãƒ«å†…ã®ç•°ãªã‚‹å€¤ã®å‹ã¯åŒã˜ã§ã‚ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ve added optional type annotations in this example:</span>ã“ã®ä¾‹ã§ã¯ã€ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®æ³¨é‡ˆã‚’è¿½åŠ ã—ã¾ã—ãŸï¼š</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ãƒ•ã‚¡ã‚¤ãƒ«åï¼šsrc / main.rs</span></span> </p><br><div data-lang=rust><div data-l="fn main() {"></div><div data-l="    let tup: (i32, f64, u8) = (500, 6.4, 1);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The variable <code>tup</code> binds to the entire tuple, because a tuple is considered a single compound element.</span>å¤‰æ•°<code>tup</code>ã¯ã€ã‚¿ãƒ—ãƒ«ãŒå˜ä¸€ã®è¤‡åˆè¦ç´ ã¨ã¿ãªã•ã‚Œã‚‹ãŸã‚ã€ã‚¿ãƒ—ãƒ«å…¨ä½“ã«ãƒã‚¤ãƒ³ãƒ‰ã•ã‚Œã¾ã™ã€‚</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To get the individual values out of a tuple, we can use pattern matching to destructure a tuple value, like this:</span>ã‚¿ãƒ—ãƒ«ã‹ã‚‰å€‹ã€…ã®å€¤ã‚’å–å¾—ã™ã‚‹ã«ã¯ã€ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒãƒ³ã‚°ã‚’ä½¿ç”¨ã—ã¦æ¬¡ã®ã‚ˆã†ã«ã‚¿ãƒ—ãƒ«å€¤ã‚’ç ´æ£„ã§ãã¾ã™ã€‚</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ãƒ•ã‚¡ã‚¤ãƒ«åï¼šsrc / main.rs</span></span> </p><br><div data-lang=rust><div data-l="fn main() {"></div><div data-l="    let tup = (500, 6.4, 1);"></div><div data-l=""></div><div data-l="    let (x, y, z) = tup;"></div><div data-l=""></div><div data-l="    println!(&quot;The value of y is: {}&quot;, y);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This program first creates a tuple and binds it to the variable <code>tup</code> .</span>ã“ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯æœ€åˆã«ã‚¿ãƒ—ãƒ«ã‚’ä½œæˆã—ã€ãã‚Œã‚’å¤‰æ•°<code>tup</code>ã¾ã™ã€‚</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It then uses a pattern with <code>let</code> to take <code>tup</code> and turn it into three separate variables, <code>x</code> , <code>y</code> , and <code>z</code> .</span> <code>let</code>ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ä½¿ç”¨ã—ã¦<code>tup</code>ã‚’ã¨ã‚Šã€ <code>x</code> ã€ <code>y</code> ã€ <code>z</code> 3ã¤ã®åˆ¥ã€…ã®å¤‰æ•°ã«å¤‰æ›ã—ã¾ã™ã€‚</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is called <i>destructuring</i> , because it breaks the single tuple into three parts.</span>ãã‚Œã¯ä¸‰ã¤ã®éƒ¨åˆ†ã«å˜ä¸€ã®ã‚¿ãƒ—ãƒ«ã‚’å£Šã™ã®ã§ã€ã“ã‚Œã¯ã€ <i>éæ§‹é€ </i>ã¨å‘¼ã°ã‚Œã¦ã„ã¾ã™ã€‚</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Finally, the program prints the value of <code>y</code> , which is <code>6.4</code> .</span>æœ€å¾Œã«ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯<code>y</code>ã®å€¤<code>6.4</code>å‡ºåŠ›ã—ã¾ã™ã€‚</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In addition to destructuring through pattern matching, we can access a tuple element directly by using a period ( <code>.</code> ) followed by the index of the value we want to access.</span>ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒãƒ³ã‚°ã«ã‚ˆã‚‹æ§‹é€ è§£é™¤ã«åŠ ãˆã¦ã€ãƒ”ãƒªã‚ªãƒ‰ï¼ˆ <code>.</code> ï¼‰ã¨ãã‚Œã«ç¶šãã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹å€¤ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ä½¿ç”¨ã—ã¦ã€ã‚¿ãƒ—ãƒ«è¦ç´ ã«ç›´æ¥ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example:</span>ä¾‹ãˆã°ï¼š</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ãƒ•ã‚¡ã‚¤ãƒ«åï¼šsrc / main.rs</span></span> </p><br><div data-lang=rust><div data-l="fn main() {"></div><div data-l="    let x: (i32, f64, u8) = (500, 6.4, 1);"></div><div data-l=""></div><div data-l="    let five_hundred = x.0;"></div><div data-l=""></div><div data-l="    let six_point_four = x.1;"></div><div data-l=""></div><div data-l="    let one = x.2;"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This program creates a tuple, <code>x</code> , and then makes new variables for each element by using their index.</span>ã“ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ã‚¿ãƒ—ãƒ«<code>x</code>ä½œæˆã—ã€å„è¦ç´ ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ä½¿ã£ã¦æ–°ã—ã„å¤‰æ•°ã‚’ä½œæˆã—ã¾ã™ã€‚</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As with most programming languages, the first index in a tuple is 0.</span>ã»ã¨ã‚“ã©ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªã¨åŒæ§˜ã«ã€ã‚¿ãƒ—ãƒ«ã®æœ€åˆã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã¯0ã§ã™ã€‚</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The Array Type</span>é…åˆ—å‹</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Another way to have a collection of multiple values is with an <i>array</i> .</span>è¤‡æ•°ã®å€¤ã®ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚’æŒã¤åˆ¥ã®æ–¹æ³•ã¯ã€ <i>é…åˆ—ã‚’ä½¿ç”¨ã™ã‚‹æ–¹æ³•</i>ã§ã™ã€‚</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Unlike a tuple, every element of an array must have the same type.</span>ã‚¿ãƒ—ãƒ«ã¨ã¯ç•°ãªã‚Šã€é…åˆ—ã®ã™ã¹ã¦ã®è¦ç´ ã¯åŒã˜å‹ã§ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Arrays in Rust are different from arrays in some other languages because arrays in Rust have a fixed length: once declared, they cannot grow or shrink in size.</span> Rustã®é…åˆ—ã¯ä»–ã®è¨€èªã®é…åˆ—ã¨ã¯ç•°ãªã‚Šã¾ã™ã€‚ãªãœãªã‚‰ã€Rustã®é…åˆ—ã¯å›ºå®šé•·ã§ã‚ã‚‹ãŸã‚ã§ã™ã€‚å®£è¨€ã•ã‚ŒãŸé…åˆ—ã¯ã€ã‚µã‚¤ã‚ºãŒæ‹¡å¤§ã¾ãŸã¯ç¸®å°ã§ãã¾ã›ã‚“ã€‚</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In Rust, the values going into an array are written as a comma-separated list inside square brackets:</span> Rustã§ã¯ã€é…åˆ—ã«å…¥ã‚‹å€¤ã¯è§’æ‹¬å¼§ã§å›²ã¾ã‚ŒãŸã‚³ãƒ³ãƒåŒºåˆ‡ã‚Šã®ãƒªã‚¹ãƒˆã¨ã—ã¦æ›¸ãå‡ºã•ã‚Œã¾ã™ã€‚</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ãƒ•ã‚¡ã‚¤ãƒ«åï¼šsrc / main.rs</span></span> </p><br><div data-lang=rust><div data-l="fn main() {"></div><div data-l="    let a = [1, 2, 3, 4, 5];"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Arrays are useful when you want your data allocated on the stack rather than the heap (we will discuss the stack and the heap more in Chapter 4) or when you want to ensure you always have a fixed number of elements.</span>é…åˆ—ã¯ã€ãƒ’ãƒ¼ãƒ—ã§ã¯ãªãã‚¹ã‚¿ãƒƒã‚¯ã«ãƒ‡ãƒ¼ã‚¿ã‚’å‰²ã‚Šå½“ã¦ãŸã„å ´åˆã«ä¾¿åˆ©ã§ã™ï¼ˆã‚¹ã‚¿ãƒƒã‚¯ã¨ãƒ’ãƒ¼ãƒ—ã«ã¤ã„ã¦ã¯ç¬¬4ç« ã§è©³ã—ãèª¬æ˜ã—ã¾ã™ï¼‰ã€‚ã¾ãŸã¯ã€å¸¸ã«å›ºå®šæ•°ã®è¦ç´ ã‚’ç¢ºä¿ã—ãŸã„å ´åˆã«ä¾¿åˆ©ã§ã™ã€‚</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">An array isn&#39;t as flexible as the vector type, though.</span>ã—ã‹ã—ã€é…åˆ—ã¯ãƒ™ã‚¯ãƒˆãƒ«å‹ã»ã©æŸ”è»Ÿã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A vector is a similar collection type provided by the standard library that <i>is</i> allowed to grow or shrink in size.</span>ãƒ™ã‚¯ãƒˆãƒ«ã¯æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã«ã‚ˆã£ã¦æä¾›ã•ã‚Œã‚‹åŒæ§˜ã®ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³å‹ã§ã€ã‚µã‚¤ã‚ºã®æ‹¡å¤§ã¾ãŸã¯ç¸®å°<i>ãŒ</i>å¯èƒ½ã§ã™ã€‚</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you&#39;re unsure whether to use an array or a vector, you should probably use a vector.</span>é…åˆ—ã‚„ãƒ™ã‚¯ãƒˆãƒ«ã‚’ä½¿ç”¨ã™ã‚‹ã‹ã©ã†ã‹ã‚ã‹ã‚‰ãªã„å ´åˆã¯ã€ãŠãã‚‰ããƒ™ã‚¯ãƒˆãƒ«ã‚’ä½¿ç”¨ã™ã‚‹ã¹ãã§ã™ã€‚</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Chapter 8 discusses vectors in more detail.</span>ç¬¬8ç« ã§ã¯ã€ãƒ™ã‚¯ãƒˆãƒ«ã«ã¤ã„ã¦è©³ã—ãèª¬æ˜ã—ã¾ã™ã€‚</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">An example of when you might want to use an array rather than a vector is in a program that needs to know the names of the months of the year.</span>ãƒ™ã‚¯ãƒˆãƒ«ã§ã¯ãªãé…åˆ—ã‚’ä½¿ç”¨ã™ã‚‹å ´åˆã®ä¾‹ã¯ã€å¹´ã®æœˆã®åå‰ã‚’çŸ¥ã‚‹å¿…è¦ãŒã‚ã‚‹ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã«ã‚ã‚Šã¾ã™ã€‚</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It&#39;s very unlikely that such a program will need to add or remove months, so you can use an array because you know it will always contain 12 items:</span>ã“ã®ã‚ˆã†ãªãƒ—ãƒ­ã‚°ãƒ©ãƒ ã§ã¯æœˆã‚’è¿½åŠ ã¾ãŸã¯å‰Šé™¤ã™ã‚‹å¿…è¦ã¯ã»ã¨ã‚“ã©ã‚ã‚Šã¾ã›ã‚“ã€‚ã—ãŸãŒã£ã¦ã€é…åˆ—ã«ã¯å¸¸ã«12å€‹ã®é …ç›®ãŒå«ã¾ã‚Œã¦ã„ã‚‹ã“ã¨ãŒã‚ã‹ã£ã¦ã„ã‚‹ã®ã§ã€é…åˆ—ã‚’ä½¿ç”¨ã§ãã¾ã™ã€‚</span> </p><br><div data-lang=rust><div data-l="let months = [&quot;January&quot;, &quot;February&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;, &quot;June&quot;, &quot;July&quot;,"></div><div data-l="              &quot;August&quot;, &quot;September&quot;, &quot;October&quot;, &quot;November&quot;, &quot;December&quot;];"></div></div><br><h5> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Accessing Array Elements</span>é…åˆ—è¦ç´ ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹</span> </h5><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">An array is a single chunk of memory allocated on the stack.</span>é…åˆ—ã¯ã€ã‚¹ã‚¿ãƒƒã‚¯ã«å‰²ã‚Šå½“ã¦ã‚‰ã‚ŒãŸãƒ¡ãƒ¢ãƒªã®å˜ä¸€ã®ãƒãƒ£ãƒ³ã‚¯ã§ã™ã€‚</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can access elements of an array using indexing, like this:</span>æ¬¡ã®ã‚ˆã†ã«ã€ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ä½¿ç”¨ã—ã¦é…åˆ—ã®è¦ç´ ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã¾ã™ã€‚</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ãƒ•ã‚¡ã‚¤ãƒ«åï¼šsrc / main.rs</span></span> </p><br><div data-lang=rust><div data-l="fn main() {"></div><div data-l="    let a = [1, 2, 3, 4, 5];"></div><div data-l=""></div><div data-l="    let first = a[0];"></div><div data-l="    let second = a[1];"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this example, the variable named <code>first</code> will get the value <code>1</code> , because that is the value at index <code>[0]</code> in the array.</span>ã“ã®ä¾‹ã§ã¯ã€ <code>first</code>ã¨ã„ã†åå‰ã®å¤‰æ•°ã¯é…åˆ—ã®index <code>[0]</code>å€¤ã§ã‚ã‚‹ãŸã‚ã€å€¤<code>1</code>ã‚’å–å¾—ã—ã¾ã™ã€‚</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The variable named <code>second</code> will get the value <code>2</code> from index <code>[1]</code> in the array.</span>å¤‰æ•°<code>second</code>ã¯é…åˆ—ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹<code>[1]</code>ã‹ã‚‰å€¤<code>2</code>ã‚’å–å¾—ã—ã¾ã™ã€‚</span> </p><br><h5> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Invalid Array Element Access</span>ç„¡åŠ¹ãªé…åˆ—è¦ç´ ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹</span> </h5><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">What happens if you try to access an element of an array that is past the end of the array?</span>é…åˆ—ã®æœ€å¾Œã‚’éããŸé…åˆ—ã®è¦ç´ ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ã‚ˆã†ã¨ã™ã‚‹ã¨ã©ã†ãªã‚Šã¾ã™ã‹ï¼Ÿ</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Say you change the example to the following code, which will compile but exit with an error when it runs:</span>ä¾‹ã‚’ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ã«å¤‰æ›´ã—ã¾ã™ã€‚ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã¯å®Ÿè¡Œã•ã‚Œã¾ã™ãŒã€å®Ÿè¡Œæ™‚ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¦çµ‚äº†ã—ã¾ã™ã€‚</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ãƒ•ã‚¡ã‚¤ãƒ«åï¼šsrc / main.rs</span></span> </p><br><div data-lang=rust,ignore><div data-l="fn main() {"></div><div data-l="    let a = [1, 2, 3, 4, 5];"></div><div data-l="    let index = 10;"></div><div data-l=""></div><div data-l="    let element = a[index];"></div><div data-l=""></div><div data-l="    println!(&quot;The value of element is: {}&quot;, element);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Running this code using <code>cargo run</code> produces the following result:</span> <code>cargo run</code>ã‚’ä½¿ç”¨ã—ã¦ã“ã®ã‚³ãƒ¼ãƒ‰ã‚’<code>cargo run</code>ã™ã‚‹ã¨ã€æ¬¡ã®çµæœãŒå¾—ã‚‰ã‚Œã¾ã™ã€‚</span> </p><br><div data-lang=text><div data-l="$ cargo run"></div><div data-l="   Compiling arrays v0.1.0 (file:///projects/arrays)"></div><div data-l="    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs"></div><div data-l="     Running `target/debug/arrays`"></div><div data-l="thread '&lt;main&gt;' panicked at 'index out of bounds: the len is 5 but the index is"></div><div data-l=" 10', src/main.rs:6"></div><div data-l="note: Run with `RUST_BACKTRACE=1` for a backtrace."></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The compilation didn&#39;t produce any errors, but the program resulted in a <i>runtime</i> error and didn&#39;t exit successfully.</span>ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã§ã¯ã‚¨ãƒ©ãƒ¼ã¯ç™ºç”Ÿã—ã¾ã›ã‚“ã§ã—ãŸãŒã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã§<i>ãƒ©ãƒ³ã‚¿ã‚¤ãƒ </i>ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã€æ­£å¸¸ã«çµ‚äº†ã—ã¾ã›ã‚“ã§ã—ãŸã€‚</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When you attempt to access an element using indexing, Rust will check that the index you&#39;ve specified is less than the array length.</span>ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ä½¿ç”¨ã—ã¦è¦ç´ ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ã‚ˆã†ã¨ã™ã‚‹ã¨ã€æŒ‡å®šã—ãŸã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãŒé…åˆ—ã®é•·ã•ã‚ˆã‚Šã‚‚å°ã•ã„ã‹ã©ã†ã‹ãŒç¢ºèªã•ã‚Œã¾ã™ã€‚</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If the index is greater than the length, Rust will <i>panic</i> , which is the term Rust uses when a program exits with an error.</span>ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãŒé•·ã•ã‚ˆã‚Šã‚‚é•·ã„å ´åˆã€Rustã¯<i>ãƒ‘ãƒ‹ãƒƒã‚¯</i>ã«ãªã‚Šã¾ã™ã€‚ã“ã‚Œã¯ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒã‚¨ãƒ©ãƒ¼ã§çµ‚äº†ã—ãŸã¨ãã«RustãŒä½¿ç”¨ã™ã‚‹ç”¨èªã§ã™ã€‚</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is the first example of Rust&#39;s safety principles in action.</span>ã“ã‚Œã¯ã€Rustã®å®‰å…¨åŸå‰‡ã®æœ€åˆã®å®Ÿä¾‹ã§ã™ã€‚</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In many low-level languages, this kind of check is not done, and when you provide an incorrect index, invalid memory can be accessed.</span>å¤šãã®ä½ãƒ¬ãƒ™ãƒ«è¨€èªã§ã¯ã€ã“ã®ã‚ˆã†ãªãƒã‚§ãƒƒã‚¯ã¯è¡Œã‚ã‚Œãšã€é–“é•ã£ãŸã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’æŒ‡å®šã™ã‚‹ã¨ç„¡åŠ¹ãªãƒ¡ãƒ¢ãƒªã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust protects you against this kind of error by immediately exiting instead of allowing the memory access and continuing.</span>éŒ†ã¯ã€ãƒ¡ãƒ¢ãƒªã‚¢ã‚¯ã‚»ã‚¹ã‚’è¨±å¯ã—ç¶šã‘ã‚‹ä»£ã‚ã‚Šã«ã™ãã«çµ‚äº†ã™ã‚‹ã“ã¨ã§ã€ã“ã®ç¨®ã®ã‚¨ãƒ©ãƒ¼ã‹ã‚‰ã‚ãªãŸã‚’å®ˆã‚Šã¾ã™ã€‚</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Chapter 9 discusses more of Rust&#39;s error handling.</span>ç¬¬9ç« ã§ã¯ã€Rustã®ã‚¨ãƒ©ãƒ¼å‡¦ç†ã®è©³ç´°ã«ã¤ã„ã¦èª¬æ˜ã—ã¾ã™ã€‚</span> </p><script>_addload(function(){_setupIW('com');_csi('en','ja','ch03-02-data-types.html');});</script>