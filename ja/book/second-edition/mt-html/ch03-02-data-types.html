<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180709_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=ch03-02-data-types.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Data Types</span>データ型</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Every value in Rust is of a certain <i>data type</i> , which tells Rust what kind of data is being specified so it knows how to work with that data.</span> Rustの各値は特定の<i>データ型のもので</i> 、指定されているデータの種類をRustに知らせるので、そのデータの処理方法を知ることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll look at two data type subsets: scalar and compound.</span>スカラーと複合体の2つのデータ型サブセットを見ていきます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Keep in mind that Rust is a <i>statically typed</i> language, which means that it must know the types of all variables at compile time.</span> Rustは<i>静的型付き</i>言語であり、コンパイル時にすべての変数の型を知っている必要があることを覚えておいてください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The compiler can usually infer what type we want to use based on the value and how we use it.</span>コンパイラは、通常、値と使用方法に基づいて、使用する型を推論することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In cases when many types are possible, such as when we converted a <code>String</code> to a numeric type using <code>parse</code> in the “Comparing the Guess to the Secret Number” section in Chapter 2, we must add a type annotation, like this:</span>第2章の「推測値と秘密番号の比較」のセクションで<code>parse</code>を使って<code>String</code>を数値型に変換したときなど、多くの型が可能な場合は、次のように型の注釈を追加する必要があります。</span> </p><br><div data-lang=rust><div data-l="let guess: u32 = &quot;42&quot;.parse().expect(&quot;Not a number!&quot;);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we don&#39;t add the type annotation here, Rust will display the following error, which means the compiler needs more information from us to know which type we want to use:</span>タイプ注釈をここに追加しないと、Rustは次のエラーを表示します。これは、コンパイラが使用したいタイプを知るために私たちからより多くの情報を必要とすることを意味します。</span> </p><br><div data-lang=text><div data-l="error[E0282]: type annotations needed"></div><div data-l=" --&gt; src/main.rs:2:9"></div><div data-l="  |"></div><div data-l="2 |     let guess = &quot;42&quot;.parse().expect(&quot;Not a number!&quot;);"></div><div data-l="  |         ^^^^^"></div><div data-l="  |         |"></div><div data-l="  |         cannot infer type for `_`"></div><div data-l="  |         consider giving `guess` a type"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You&#39;ll see different type annotations for other data types.</span>他のデータ型には異なるタイプの注釈が表示されます。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Scalar Types</span>スカラ型</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A <i>scalar</i> type represents a single value.</span> <i>スカラ</i>型は単一の値を表します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust has four primary scalar types: integers, floating-point numbers, Booleans, and characters.</span> Rustには、整数、浮動小数点数、ブール値、および文字の4つの主なスカラ型があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You may recognize these from other programming languages.</span>これらは他のプログラミング言語から認識されるかもしれません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s jump into how they work in Rust.</span>彼らがRustでどのように働いているかを考えてみましょう。</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Integer Types</span>整数型</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">An <i>integer</i> is a number without a fractional component.</span> <i>整数</i>は小数成分のない数値です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We used one integer type in Chapter 2, the <code>u32</code> type.</span>第2章では、 <code>u32</code>型の1つの整数型を使用しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This type declaration indicates that the value it&#39;s associated with should be an unsigned integer (signed integer types start with <code>i</code> , instead of <code>u</code> ) that takes up 32 bits of space.</span>この型宣言は、関連する値が、32ビットの空間を占める符号なし整数（符号付き整数型は、 <code>u</code>代わりに<code>i</code>で始まる）でなければならないことを示します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Table 3-1 shows the built-in integer types in Rust.</span>表3-1に、Rustの組み込み整数型を示します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Each variant in the Signed and Unsigned columns (for example, <code>i16</code> ) can be used to declare the type of an integer value.</span> Signed列とUnsigned列の各バリアント（たとえば<code>i16</code> ）を使用して、整数値の型を宣言できます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Table 3-1: Integer Types in Rust</span></span> <span class=caption>表3-1：錆の整数型</span></span> </p><br><div data-tbl><div> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Length</span>長さ</span> </div><div> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Signed</span>署名された</span> </div><div> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Unsigned</span>署名なし</span> </div></div><div data-tbl><div> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">--------</span> --------</span> </div><div> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">---------</span> ---------</span> </div><div> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">----------</span> ----------</span> </div></div><div data-tbl><div> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">8-bit</span> 8ビット</span> </div><div> <code>i8</code> </div> <div> <code>u8</code> </div> </div><div data-tbl><div> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">16-bit</span> 16ビット</span> </div><div> <code>i16</code> </div> <div> <code>u16</code> </div> </div><div data-tbl><div> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">32-bit</span> 32ビット</span> </div><div> <code>i32</code> </div> <div> <code>u32</code> </div> </div><div data-tbl><div> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">64-bit</span> 64ビット</span> </div><div> <code>i64</code> </div> <div> <code>u64</code> </div> </div><div data-tbl><div> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">arch</span>アーチ</span> </div><div> <code>isize</code> </div> <div> <code>usize</code> </div> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Each variant can be either signed or unsigned and has an explicit size.</span>各バリアントは、符号付きまたは符号なしのいずれかであり、明示的なサイズを持ちます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><i>Signed</i> and <i>unsigned</i> refer to whether it&#39;s possible for the number to be negative or positive—in other words, whether the number needs to have a sign with it (signed) or whether it will only ever be positive and can therefore be represented without a sign (unsigned).</span> <i>符号付き</i>と<i>符号なし</i>は、その数値が負であるか正であるか、つまりその数値に符号が付いている必要がある（符号付きである）か、正であるかどうかだけで符号なしで表すことができるかどうかを示します（符号なし）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It&#39;s like writing numbers on paper: when the sign matters, a number is shown with a plus sign or a minus sign;</span>それは紙に数字を書くようなものです。記号が重要なときはプラス記号またはマイナス記号で数字が表示されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">however, when it&#39;s safe to assume the number is positive, it&#39;s shown with no sign.</span>しかし、数字が正であると仮定することは安全ですが、それは記号なしで示されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Signed numbers are stored using two&#39;s complement representation (if you&#39;re unsure what this is, you can search for it online; an explanation is outside the scope of this book).</span>符号付き数値は、2の補数表現を使用して格納されます（これが何であるかわからない場合は、オンラインで検索できますが説明は本書の範囲外です）。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Each signed variant can store numbers from -(2 <sup>n - 1</sup> ) to 2 <sup>n - 1</sup> - 1 inclusive, where <i>n</i> is the number of bits that variant uses.</span>各符号付きバリアントは - （2 <sup>n-1</sup> ）から2 <sup>n-1</sup> -1までの数を格納できます<i>.n</i>はバリアントが使用するビット数です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So an <code>i8</code> can store numbers from -(2 <sup>7</sup> ) to 2 <sup>7</sup> - 1, which equals -128 to 127. Unsigned variants can store numbers from 0 to 2 <sup>n</sup> - 1, so a <code>u8</code> can store numbers from 0 to 2 <sup>8</sup> - 1, which equals 0 to 255.</span>したがって、 <code>i8</code>は - （2 <sup>7</sup> ） <code>u8</code> <sup>7</sup> -  1の数値を<code>u8</code>できます。符号なし変数には0〜2 <sup>n</sup> -  1の数値を格納できるので、 <code>u8</code> <sup>8に</sup>は0〜2の数値を格納できます<sup>8</sup> - 1、これは0〜255です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Additionally, the <code>isize</code> and <code>usize</code> types depend on the kind of computer your program is running on: 64 bits if you&#39;re on a 64-bit architecture and 32 bits if you&#39;re on a 32-bit architecture.</span>さらに、 <code>isize</code>と<code>usize</code>種類は、プログラムが実行されているコンピュータの種類によって異なります.64ビットアーキテクチャの場合は64ビット、32ビットアーキテクチャの場合は32ビットです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can write integer literals in any of the forms shown in Table 3-2.</span>表3-2に示すいずれかの形式で整数リテラルを記述することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that all number literals except the byte literal allow a type suffix, such as <code>57u8</code> , and <code>_</code> as a visual separator, such as <code>1_000</code> .</span>バイトリテラル以外のすべての数字リテラルは、 <code>57u8</code>などのタイプ接尾辞、および<code>1_000</code>などの視覚的区切り文字としての<code>_</code>を許可することに注意してください。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Table 3-2: Integer Literals in Rust</span></span> <span class=caption>表3-2：錆の整数リテラル</span></span> </p><br><div data-tbl><div> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Number literals</span>数リテラル</span> </div><div> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Example</span>例</span> </div></div><div data-tbl><div> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">------------------</span> ------------------</span> </div><div> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">---------------</span> ---------------</span> </div></div><div data-tbl><div> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Decimal</span>小数</span> </div><div> <code>98_222</code> </div> </div><div data-tbl><div> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Hex</span>ヘキサ</span> </div><div> <code>0xff</code> </div> </div><div data-tbl><div> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Octal</span>オクタル</span> </div><div> <code>0o77</code> </div> </div><div data-tbl><div> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Binary</span>バイナリ</span> </div><div> <code>0b1111_0000</code> </div> </div><div data-tbl><div> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Byte ( <code>u8</code> only)</span>バイト（ <code>u8</code>のみ）</span> </div><div> <code>b&#39;A&#39;</code> </div> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So how do you know which type of integer to use?</span>だからどのようなタイプの整数を使うべきか、どのように知っていますか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you&#39;re unsure, Rust&#39;s defaults are generally good choices, and integer types default to <code>i32</code> : this type is generally the fastest, even on 64-bit systems.</span>もしあなたが確信が持てないなら、Rustのデフォルトが一般的に良い選択肢であり、整数型はデフォルトで<code>i32</code>ます。このタイプは、64ビットシステムでさえ一般的に最も高速です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The primary situation in which you&#39;d use <code>isize</code> or <code>usize</code> is when indexing some sort of collection.</span> <code>isize</code>または<code>usize</code>使用する主な状況は、何らかのコレクションのインデックスを作成するときです。</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Floating-Point Types</span>浮動小数点型</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust also has two primitive types for <i>floating-point numbers</i> , which are numbers with decimal points.</span> Rustには、 <i>小数点のある浮動小数点数の</i> 2つのプリミティブ型もあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust&#39;s floating-point types are <code>f32</code> and <code>f64</code> , which are 32 bits and 64 bits in size, respectively.</span> Rustの浮動小数点型は、それぞれ32ビットと64ビットの<code>f32</code>と<code>f64</code>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The default type is <code>f64</code> because on modern CPUs it&#39;s roughly the same speed as <code>f32</code> but is capable of more precision.</span>現代のCPUでは<code>f32</code>とほぼ同じ速度ですが、より精度が高いので、デフォルトのタイプは<code>f64</code>です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here&#39;s an example that shows floating-point numbers in action:</span>実際の浮動小数点数を示す例です：</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="fn main() {"></div><div data-l="#//    let x = 2.0; // f64"></div><div data-l="    let x = 2.0; // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">f64</span> f64</span> </div><div data-l=""></div><div data-l="#//    let y: f32 = 3.0; // f32"></div><div data-l="    let y: f32 = 3.0; // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">f32</span> f32</span> </div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Floating-point numbers are represented according to the IEEE-754 standard.</span>浮動小数点数は、IEEE-754標準に従って表されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>f32</code> type is a single-precision float, and <code>f64</code> has double precision.</span> <code>f32</code>型は単精度浮動小数点型で、 <code>f64</code>型は倍精度です。</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Numeric Operations</span>数値演算</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust supports the basic mathematical operations you&#39;d expect for all of the number types: addition, subtraction, multiplication, division, and remainder.</span> Rustは、加算、減算、乗算、除算、および剰余のすべての数値タイプに期待される基本的な数学演算をサポートしています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The following code shows how you&#39;d use each one in a <code>let</code> statement:</span>次のコードは、 <code>let</code>ステートメントで各ステートメントをどのように使用するかを示しています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="fn main() {"></div><div data-l="#    // addition"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">addition</span>添加</span> </div><div data-l="    let sum = 5 + 10;"></div><div data-l=""></div><div data-l="#    // subtraction"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">subtraction</span>減算</span> </div><div data-l="    let difference = 95.5 - 4.3;"></div><div data-l=""></div><div data-l="#    // multiplication"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">multiplication</span>乗算</span> </div><div data-l="    let product = 4 * 30;"></div><div data-l=""></div><div data-l="#    // division"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">division</span>分割</span> </div><div data-l="    let quotient = 56.7 / 32.2;"></div><div data-l=""></div><div data-l="#    // remainder"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">remainder</span>残余</span> </div><div data-l="    let remainder = 43 % 5;"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Each expression in these statements uses a mathematical operator and evaluates to a single value, which is then bound to a variable.</span>これらのステートメントの各式は、数学演算子を使用して単一の値に評価され、変数にバインドされます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Appendix B contains a list of all operators that Rust provides.</span>付録Bには、Rustが提供するすべての演算子のリストが含まれています。</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The Boolean Type</span>ブール型</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As in most other programming languages, a Boolean type in Rust has two possible values: <code>true</code> and <code>false</code> .</span>他のほとんどのプログラミング言語と同様に、Rustのブール型には、 <code>true</code>と<code>false</code> 2つの値があり<code>false</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The Boolean type in Rust is specified using <code>bool</code> .</span> RustのBoolean型は、 <code>bool</code>を使用して指定します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example:</span>例えば：</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="fn main() {"></div><div data-l="    let t = true;"></div><div data-l=""></div><div data-l="#//    let f: bool = false; // with explicit type annotation"></div><div data-l="    let f: bool = false; // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">with explicit type annotation</span>明示的な型の注釈付き</span> </div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The main way to use Boolean values is through conditionals, such as an <code>if</code> expression.</span>ブール値を使用する主な方法は、 <code>if</code>式などの条件式によるものです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll cover how <code>if</code> expressions work in Rust in the “Control Flow” section.</span>私たちはどのように取り上げる<code>if</code>の式は、「制御フロー」のセクションで錆に働きます。</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The Character Type</span>文字の種類</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So far we&#39;ve worked only with numbers, but Rust supports letters too.</span>これまでは数字だけで作業していましたが、Rustも手紙をサポートしています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust&#39;s <code>char</code> type is the language&#39;s most primitive alphabetic type, and the following code shows one way to use it.</span> Rustの<code>char</code>型は、言語の最も基本的なアルファベット型です。次のコードは、それを使用する方法の1つを示しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">(Note that the <code>char</code> type is specified with single quotes, as opposed to strings, which use double quotes.)</span> （ <code>char</code>型は二重引用符を使用する文字列ではなく、一重引用符で指定されることに注意してください）。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="fn main() {"></div><div data-l="    let c = 'z';"></div><div data-l="    let z = 'ℤ';"></div><div data-l="    let heart_eyed_cat = '😻';"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust&#39;s <code>char</code> type represents a Unicode Scalar Value, which means it can represent a lot more than just ASCII.</span> Rustの<code>char</code>型はUnicode Scalar Valueを表しています。つまり、ASCII以外の多くの要素を表すことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Accented letters;</span>アクセント付きの手紙。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Chinese, Japanese, and Korean characters;</span>中国語、日本語、韓国語の文字。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">emoji;</span>絵文字;</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">and zero-width spaces are all valid <code>char</code> values in Rust.</span>ゼロ幅のスペースはすべてRustの有効な<code>char</code>値です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Unicode Scalar Values range from <code>U+0000</code> to <code>U+D7FF</code> and <code>U+E000</code> to <code>U+10FFFF</code> inclusive.</span> Unicodeのスカラ値は、範囲<code>U+0000</code>に<code>U+D7FF</code>と<code>U+E000</code>に<code>U+10FFFF</code>込み。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, a “character” isn&#39;t really a concept in Unicode, so your human intuition for what a “character” is may not match up with what a <code>char</code> is in Rust.</span>しかし、「文字」は実際にはUnicodeの概念ではないため、人間の「文字」の直感は、 <code>char</code>がRustの<code>char</code>と一致しないことがあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll discuss this topic in detail in “Strings” in Chapter 8.</span>このトピックについては、第8章の「文字列」で詳しく説明します。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Compound Types</span>化合物タイプ</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><i>Compound types</i> can group multiple values into one type.</span> <i>複合型</i>は、複数の値を1つの型にグループ化できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust has two primitive compound types: tuples and arrays.</span> Rustには、タプルと配列の2つの基本的な複合型があります。</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The Tuple Type</span>タプルタイプ</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A tuple is a general way of grouping together some number of other values with a variety of types into one compound type.</span>タプルは、さまざまなタイプのいくつかの値を1つの複合タイプにグループ化する一般的な方法です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We create a tuple by writing a comma-separated list of values inside parentheses.</span>タプルは、カッコで区切った値のリストをコンマで区切って作成します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Each position in the tuple has a type, and the types of the different values in the tuple don&#39;t have to be the same.</span>タプル内の各位置は型を持ち、タプル内の異なる値の型は同じである必要はありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ve added optional type annotations in this example:</span>この例では、オプションの注釈を追加しました：</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="fn main() {"></div><div data-l="    let tup: (i32, f64, u8) = (500, 6.4, 1);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The variable <code>tup</code> binds to the entire tuple, because a tuple is considered a single compound element.</span>変数<code>tup</code>は、タプルが単一の複合要素とみなされるため、タプル全体にバインドされます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To get the individual values out of a tuple, we can use pattern matching to destructure a tuple value, like this:</span>タプルから個々の値を取得するには、パターンマッチングを使用して次のようにタプル値を破棄できます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="fn main() {"></div><div data-l="    let tup = (500, 6.4, 1);"></div><div data-l=""></div><div data-l="    let (x, y, z) = tup;"></div><div data-l=""></div><div data-l="    println!(&quot;The value of y is: {}&quot;, y);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This program first creates a tuple and binds it to the variable <code>tup</code> .</span>このプログラムは最初にタプルを作成し、それを変数<code>tup</code>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It then uses a pattern with <code>let</code> to take <code>tup</code> and turn it into three separate variables, <code>x</code> , <code>y</code> , and <code>z</code> .</span> <code>let</code>パターンを使用して<code>tup</code>をとり、 <code>x</code> 、 <code>y</code> 、 <code>z</code> 3つの別々の変数に変換します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is called <i>destructuring</i> , because it breaks the single tuple into three parts.</span>それは三つの部分に単一のタプルを壊すので、これは、 <i>非構造</i>と呼ばれています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Finally, the program prints the value of <code>y</code> , which is <code>6.4</code> .</span>最後に、プログラムは<code>y</code>の値<code>6.4</code>出力します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In addition to destructuring through pattern matching, we can access a tuple element directly by using a period ( <code>.</code> ) followed by the index of the value we want to access.</span>パターンマッチングによる構造解除に加えて、ピリオド（ <code>.</code> ）とそれに続くアクセスする値のインデックスを使用して、タプル要素に直接アクセスすることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example:</span>例えば：</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="fn main() {"></div><div data-l="    let x: (i32, f64, u8) = (500, 6.4, 1);"></div><div data-l=""></div><div data-l="    let five_hundred = x.0;"></div><div data-l=""></div><div data-l="    let six_point_four = x.1;"></div><div data-l=""></div><div data-l="    let one = x.2;"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This program creates a tuple, <code>x</code> , and then makes new variables for each element by using their index.</span>このプログラムはタプル<code>x</code>作成し、各要素のインデックスを使って新しい変数を作成します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As with most programming languages, the first index in a tuple is 0.</span>ほとんどのプログラミング言語と同様に、タプルの最初のインデックスは0です。</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The Array Type</span>配列型</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Another way to have a collection of multiple values is with an <i>array</i> .</span>複数の値のコレクションを持つ別の方法は、 <i>配列を使用する方法</i>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Unlike a tuple, every element of an array must have the same type.</span>タプルとは異なり、配列のすべての要素は同じ型でなければなりません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Arrays in Rust are different from arrays in some other languages because arrays in Rust have a fixed length: once declared, they cannot grow or shrink in size.</span> Rustの配列は他の言語の配列とは異なります。なぜなら、Rustの配列は固定長であるためです。宣言された配列は、サイズが拡大または縮小できません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In Rust, the values going into an array are written as a comma-separated list inside square brackets:</span> Rustでは、配列に入る値は角括弧で囲まれたコンマ区切りのリストとして書き出されます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="fn main() {"></div><div data-l="    let a = [1, 2, 3, 4, 5];"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Arrays are useful when you want your data allocated on the stack rather than the heap (we will discuss the stack and the heap more in Chapter 4) or when you want to ensure you always have a fixed number of elements.</span>配列は、ヒープではなくスタックにデータを割り当てたい場合に便利です（スタックとヒープについては第4章で詳しく説明します）。または、常に固定数の要素を確保したい場合に便利です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">An array isn&#39;t as flexible as the vector type, though.</span>しかし、配列はベクトル型ほど柔軟ではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A vector is a similar collection type provided by the standard library that <i>is</i> allowed to grow or shrink in size.</span>ベクトルは標準ライブラリによって提供される同様のコレクション型で、サイズの拡大または縮小<i>が</i>可能です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you&#39;re unsure whether to use an array or a vector, you should probably use a vector.</span>配列やベクトルを使用するかどうかわからない場合は、おそらくベクトルを使用するべきです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Chapter 8 discusses vectors in more detail.</span>第8章では、ベクトルについて詳しく説明します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">An example of when you might want to use an array rather than a vector is in a program that needs to know the names of the months of the year.</span>ベクトルではなく配列を使用する場合の例は、年の月の名前を知る必要があるプログラムにあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It&#39;s very unlikely that such a program will need to add or remove months, so you can use an array because you know it will always contain 12 items:</span>このようなプログラムでは月を追加または削除する必要はほとんどありません。したがって、配列には常に12個の項目が含まれていることがわかっているので、配列を使用できます。</span> </p><br><div data-lang=rust><div data-l="let months = [&quot;January&quot;, &quot;February&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;, &quot;June&quot;, &quot;July&quot;,"></div><div data-l="              &quot;August&quot;, &quot;September&quot;, &quot;October&quot;, &quot;November&quot;, &quot;December&quot;];"></div></div><br><h5> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Accessing Array Elements</span>配列要素へのアクセス</span> </h5><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">An array is a single chunk of memory allocated on the stack.</span>配列は、スタックに割り当てられたメモリの単一のチャンクです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can access elements of an array using indexing, like this:</span>次のように、インデックスを使用して配列の要素にアクセスできます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="fn main() {"></div><div data-l="    let a = [1, 2, 3, 4, 5];"></div><div data-l=""></div><div data-l="    let first = a[0];"></div><div data-l="    let second = a[1];"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this example, the variable named <code>first</code> will get the value <code>1</code> , because that is the value at index <code>[0]</code> in the array.</span>この例では、 <code>first</code>という名前の変数は配列のindex <code>[0]</code>値であるため、値<code>1</code>を取得します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The variable named <code>second</code> will get the value <code>2</code> from index <code>[1]</code> in the array.</span>変数<code>second</code>は配列のインデックス<code>[1]</code>から値<code>2</code>を取得します。</span> </p><br><h5> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Invalid Array Element Access</span>無効な配列要素へのアクセス</span> </h5><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">What happens if you try to access an element of an array that is past the end of the array?</span>配列の最後を過ぎた配列の要素にアクセスしようとするとどうなりますか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Say you change the example to the following code, which will compile but exit with an error when it runs:</span>例を以下のコードに変更します。コンパイルは実行されますが、実行時にエラーが発生して終了します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust,ignore><div data-l="fn main() {"></div><div data-l="    let a = [1, 2, 3, 4, 5];"></div><div data-l="    let index = 10;"></div><div data-l=""></div><div data-l="    let element = a[index];"></div><div data-l=""></div><div data-l="    println!(&quot;The value of element is: {}&quot;, element);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Running this code using <code>cargo run</code> produces the following result:</span> <code>cargo run</code>を使用してこのコードを<code>cargo run</code>すると、次の結果が得られます。</span> </p><br><div data-lang=text><div data-l="$ cargo run"></div><div data-l="   Compiling arrays v0.1.0 (file:///projects/arrays)"></div><div data-l="    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs"></div><div data-l="     Running `target/debug/arrays`"></div><div data-l="thread '&lt;main&gt;' panicked at 'index out of bounds: the len is 5 but the index is"></div><div data-l=" 10', src/main.rs:6"></div><div data-l="note: Run with `RUST_BACKTRACE=1` for a backtrace."></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The compilation didn&#39;t produce any errors, but the program resulted in a <i>runtime</i> error and didn&#39;t exit successfully.</span>コンパイルではエラーは発生しませんでしたが、プログラムで<i>ランタイム</i>エラーが発生し、正常に終了しませんでした。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When you attempt to access an element using indexing, Rust will check that the index you&#39;ve specified is less than the array length.</span>インデックスを使用して要素にアクセスしようとすると、指定したインデックスが配列の長さよりも小さいかどうかが確認されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If the index is greater than the length, Rust will <i>panic</i> , which is the term Rust uses when a program exits with an error.</span>インデックスが長さよりも長い場合、Rustは<i>パニック</i>になります。これは、プログラムがエラーで終了したときにRustが使用する用語です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is the first example of Rust&#39;s safety principles in action.</span>これは、Rustの安全原則の最初の実例です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In many low-level languages, this kind of check is not done, and when you provide an incorrect index, invalid memory can be accessed.</span>多くの低レベル言語では、このようなチェックは行われず、間違ったインデックスを指定すると無効なメモリにアクセスすることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust protects you against this kind of error by immediately exiting instead of allowing the memory access and continuing.</span>錆は、メモリアクセスを許可し続ける代わりにすぐに終了することで、この種のエラーからあなたを守ります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Chapter 9 discusses more of Rust&#39;s error handling.</span>第9章では、Rustのエラー処理の詳細について説明します。</span> </p><script>_addload(function(){_setupIW('com');_csi('en','ja','ch03-02-data-types.html');});</script>