<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180709_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=ch18-01-all-the-places-for-patterns.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">All the Places Patterns Can Be Used</span>すべてのプレイスパターンを使用できます</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Patterns pop up in a number of places in Rust, and you&#39;ve been using them a lot without realizing it!</span>パターンはRustのいくつかの場所にポップアップし、あなたはそれを実現せずにたくさん使っています！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This section discusses all the places where patterns are valid.</span>このセクションでは、パターンが有効なすべての場所について説明します。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>match</code> Arms</span> <code>match</code>アーム</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As discussed in Chapter 6, we use patterns in the arms of <code>match</code> expressions.</span>第6章で説明したように、 <code>match</code>式の腕にパターンを使用します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Formally, <code>match</code> expressions are defined as the keyword <code>match</code> , a value to match on, and one or more match arms that consist of a pattern and an expression to run if the value matches that arm&#39;s pattern, like this:</span>形式的には、 <code>match</code>式はキーワード<code>match</code> 、 <code>match</code>する値、パターンとその値がその腕のパターンと一致する場合に実行される式からなる1つ以上の一致腕として定義されます。</span> </p><br><div data-lang=text><div data-l="match VALUE {"></div><div data-l="    PATTERN =&gt; EXPRESSION,"></div><div data-l="    PATTERN =&gt; EXPRESSION,"></div><div data-l="    PATTERN =&gt; EXPRESSION,"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">One requirement for <code>match</code> expressions is that they need to be <i>exhaustive</i> in the sense that all possibilities for the value in the <code>match</code> expression must be accounted for.</span> <code>match</code>式の要件の1つは、 <code>match</code>式の値のすべての可能性が考慮されなければならないという意味で<i>網羅的</i>である必要があるということです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">One way to ensure you&#39;ve covered every possibility is to have a catchall pattern for the last arm: for example, a variable name matching any value can never fail and thus covers every remaining case.</span>すべての可能性をカバーするための1つの方法は、最後の腕のためのキャッチオールパターンを作ることです。例えば、値にマッチする変数名が失敗することはなく、残りのすべてのケースをカバーします。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A particular pattern <code>_</code> will match anything, but it never binds to a variable, so it&#39;s often used in the last match arm.</span>特定のパターン<code>_</code>は何でも一致しますが、決して変数に束縛されないので、最終的なマッチ・アームでよく使われます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>_</code> pattern can be useful when you want to ignore any value not specified, for example.</span> <code>_</code>パターンは、たとえば、指定されていない値を無視する場合に便利です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll cover the <code>_</code> pattern in more detail in the “Ignoring Values in a Pattern” section later in this chapter.</span> <code>_</code>パターンについては、この章の「パターン内の値を無視する」のセクションで詳しく説明します。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Conditional <code>if let</code> Expressions</span>条件式<code>if let</code></span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In Chapter 6 we discussed how to use <code>if let</code> expressions mainly as a shorter way to write the equivalent of a <code>match</code> that only matches one case.</span>第6章では、使用方法を検討し<code>if let</code> 、主の同等書くための短い方法として、式を<code>match</code>一つだけの場合に一致します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Optionally, <code>if let</code> can have a corresponding <code>else</code> containing code to run if the pattern in the <code>if let</code> doesn&#39;t match.</span>必要に応じて、 <code>if let</code>のパターンが一致しない<code>if let</code>対応する<code>else</code>コードを含むコードを実行<code>if let</code>ことができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 18-1 shows that it&#39;s also possible to mix and match <code>if let</code> , <code>else if</code> , and <code>else if let</code> expressions.</span>リスト18-1は、 <code>if let</code> 、 <code>else if</code> 、 <code>else if let</code>式を混在<code>if let</code>ことも可能であることを示しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Doing so gives us more flexibility than a <code>match</code> expression in which we can express only one value to compare with the patterns.</span>そうすることで、パターンと比較する値を1つしか表現できない<code>match</code>表現よりも柔軟性が向上します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Also, the conditions in a series of <code>if let</code> , <code>else if</code> , <code>else if let</code> arms aren&#39;t required to relate to each other.</span>また、一連の<code>if let</code> 、 <code>else if</code> 、 <code>else if let</code>の条件は、互いに関連する必要はありません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The code in Listing 18-1 shows a series of checks for several conditions that decide what the background color should be.</span>リスト18-1のコードは、背景色を決定するいくつかの条件のチェックを示しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For this example, we&#39;ve created variables with hardcoded values that a real program might receive from user input.</span>この例では、実際のプログラムがユーザー入力から受け取る可能性のあるハードコードされた値を持つ変数を作成しました。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="fn main() {"></div><div data-l="    let favorite_color: Option&lt;&amp;str&gt; = None;"></div><div data-l="    let is_tuesday = false;"></div><div data-l="    let age: Result&lt;u8, _&gt; = &quot;34&quot;.parse();"></div><div data-l=""></div><div data-l="    if let Some(color) = favorite_color {"></div><div data-l="        println!(&quot;Using your favorite color, {}, as the background&quot;, color);"></div><div data-l="    } else if is_tuesday {"></div><div data-l="        println!(&quot;Tuesday is green day!&quot;);"></div><div data-l="    } else if let Ok(age) = age {"></div><div data-l="        if age &gt; 30 {"></div><div data-l="            println!(&quot;Using purple as the background color&quot;);"></div><div data-l="        } else {"></div><div data-l="            println!(&quot;Using orange as the background color&quot;);"></div><div data-l="        }"></div><div data-l="    } else {"></div><div data-l="        println!(&quot;Using blue as the background color&quot;);"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 18-1: Mixing <code>if let</code> , <code>else if</code> , <code>else if let</code> , and <code>else</code></span></span> <span class=caption>リスト18-1： <code>if let</code>混合、 <code>else if</code>は<code>else if let</code> <code>else if</code>は<code>else if let</code> 、 <code>else</code></span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If the user specifies a favorite color, that color is the background color.</span>ユーザが好きな色を指定すると、その色が背景色になります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If today is Tuesday, the background color is green.</span>今日が火曜日の場合、背景色は緑色です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If the user specifies their age as a string and we can parse it as a number successfully, the color is either purple or orange depending on the value of the number.</span>ユーザーが年齢を文字列として指定し、数値として正常に解析できる場合、数値は数値の値によって紫色またはオレンジ色になります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If none of these conditions apply, the background color is blue.</span>これらの条件のいずれも該当しない場合、背景色は青です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This conditional structure lets us support complex requirements.</span>この条件付き構造は複雑な要件をサポートします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">With the hardcoded values we have here, this example will print <code>Using purple as the background color</code> .</span>ここではハードコードされた値を使用して、この例では<code>Using purple as the background color</code>印刷<code>Using purple as the background color</code>ます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can see that <code>if let</code> can also introduce shadowed variables in the same way that <code>match</code> arms can: the line <code>if let Ok(age) = age</code> introduces a new shadowed <code>age</code> variable that contains the value inside the <code>Ok</code> variant.</span> <code>if let</code>が、 <code>match</code>武器と同じ方法でシャドウ変数を導入できる<code>if let Ok(age) = age</code>の行は、 <code>Ok</code>変形の中の値を含む新しいシャドウ化された<code>age</code>変数を導入します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This means we need to place the <code>if age &gt; 30</code> condition within that block: we can&#39;t combine these two conditions into <code>if let Ok(age) = age &amp;&amp; age &gt; 30</code> .</span>これは、そのブロック内に<code>if age &gt; 30</code>条件を配置する必要があることを意味します。つまり、これらの2つの条件を組み合わせて<code>if let Ok(age) = age &amp;&amp; age &gt; 30</code>することはできません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The shadowed <code>age</code> we want to compare to 30 isn&#39;t valid until the new scope starts with the curly bracket.</span>新しいスコープが中括弧で始まるまで、30と比較するシャドー<code>age</code>は有効ではありません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The downside of using <code>if let</code> expressions is that the compiler doesn&#39;t check exhaustiveness, whereas with <code>match</code> expressions it does.</span> <code>if let</code>式を使うことの欠点は、コンパイラが完全性をチェックするのではなく、 <code>match</code>式を使うことです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we omitted the last <code>else</code> block and therefore missed handling some cases, the compiler would not alert us to the possible logic bug.</span>最後の<code>else</code>ブロックを省略していくつかのケースを処理しなかった場合、コンパイラはロジックバグを警告しませんでした。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>while let</code> Conditional Loops</span>条件付きループ<code>while let</code></span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Similar in construction to <code>if let</code> , the <code>while let</code> conditional loop allows a <code>while</code> loop to run for as long as a pattern continues to match.</span> <code>if let</code>と同様の構成で<code>while let</code>条件付きループは、パターンが引き続き一致する限り<code>while</code>ループを実行<code>while let</code>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The example in Listing 18-2 shows a <code>while let</code> loop that uses a vector as a stack and prints the values in the vector in the opposite order in which they were pushed.</span>リスト18-2の例で示し<code>while let</code>スタックとしてベクターを使用し、それらがプッシュされた逆の順序でベクトルの値を印刷するループ。</span> </p><br><div data-lang=rust><div data-l="let mut stack = Vec::new();"></div><div data-l=""></div><div data-l=stack.push(1);></div><div data-l=stack.push(2);></div><div data-l=stack.push(3);></div><div data-l=""></div><div data-l="while let Some(top) = stack.pop() {"></div><div data-l="    println!(&quot;{}&quot;, top);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 18-2: Using a <code>while let</code> loop to print values for as long as <code>stack.pop()</code> returns <code>Some</code></span></span> <span class=caption>18-2リスト：使用して<code>while let</code>ループは限りの値を印刷する<code>stack.pop()</code>返す<code>Some</code></span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This example prints 3, 2, and then 1. The <code>pop</code> method takes the last element out of the vector and returns <code>Some(value)</code> .</span>この例では3、2、1を出力します<code>pop</code>メソッドは最後の要素をベクトルから取り出し、 <code>Some(value)</code>を返します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If the vector is empty, <code>pop</code> returns <code>None</code> .</span>ベクトルが空の場合、 <code>pop</code>は<code>None</code>返します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>while</code> loop continues running the code in its block as long as <code>pop</code> returns <code>Some</code> .</span> <code>while</code>ループは限り、そのブロック内のコードを実行し続け<code>pop</code>返さ<code>Some</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When <code>pop</code> returns <code>None</code> , the loop stops.</span> <code>pop</code>が<code>None</code>返すと、ループは停止します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can use <code>while let</code> to pop every element off our stack.</span>私たちはスタックのすべての要素をポップアップ<code>while let</code>使うことができます。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>for</code> Loops</span> <code>for</code>ループ</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In Chapter 3, we mentioned that the <code>for</code> loop is the most common loop construction in Rust code, but we haven&#39;t yet discussed the pattern that <code>for</code> takes.</span>第3章では、 <code>for</code>ループはRustコードの中で最も一般的なループ構造であると述べ<code>for</code>が<code>for</code>テイクのパターンについてはまだ説明していません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In a <code>for</code> loop, the pattern is the value that directly follows the keyword <code>for</code> , so in <code>for x in y</code> the <code>x</code> is the pattern.</span> <code>for</code>ループでは、パターンは<code>for</code>のキーワードの直後にある値なので、 <code>for x in y</code>では<code>x</code>がパターンです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 18-3 demonstrates how to use a pattern in a <code>for</code> loop to destructure, or break apart, a tuple as part of the <code>for</code> loop.</span>コードリスト18-3は<code>for</code>ループのパターンを使って、 <code>for</code>ループの一部としてタプルを分割または分割する方法を示し<code>for</code>ます。</span> </p><br><div data-lang=rust><div data-l="let v = vec!['a', 'b', 'c'];"></div><div data-l=""></div><div data-l="for (index, value) in v.iter().enumerate() {"></div><div data-l="    println!(&quot;{} is at index {}&quot;, value, index);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 18-3: Using a pattern in a <code>for</code> loop to destructure a tuple</span></span> <span class=caption>リスト18-3： <code>for</code>ループのパターンを使ってタプルを構造化する</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The code in Listing 18-3 will print the following:</span>コードリスト18-3のコードは次のように表示されます：</span> </p><br><div data-lang=text><div data-l="a is at index 0"></div><div data-l="b is at index 1"></div><div data-l="c is at index 2"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We use the <code>enumerate</code> method to adapt an iterator to produce a value and that value&#39;s index in the iterator, placed into a tuple.</span> <code>enumerate</code>メソッドを使用してイテレータを適用して値を生成し、イテレータ内のその値のインデックスをタプルに配置します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The first call to <code>enumerate</code> produces the tuple <code>(0, &#39;a&#39;)</code> .</span> <code>enumerate</code>最初の呼び出しは、タプル<code>(0, &#39;a&#39;)</code>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When this value is matched to the pattern <code>(index, value)</code> , <code>index</code> will be <code>0</code> and <code>value</code> will be <code>&#39;a&#39;</code> , printing the first line of the output.</span>この値がパターン<code>(index, value)</code>に一致すると、 <code>index</code>は<code>0</code>なり、 <code>value</code>は<code>&#39;a&#39;</code>になり、出力の最初の行が出力されます。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>let</code> Statements</span>ステートメントを<code>let</code></span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Prior to this chapter, we had only explicitly discussed using patterns with <code>match</code> and <code>if let</code> , but in fact, we&#39;ve used patterns in other places as well, including in <code>let</code> statements.</span>この章の前には、 <code>match</code>と<code>if let</code>でパターンを使用することについてのみ明示的に議論しましたが、実際には<code>let</code>ステートメントを含む他の場所でもパターンを使用しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, consider this straightforward variable assignment with <code>let</code> :</span>たとえば、 <code>let</code>使ってこのような簡単な変数代入を考えて<code>let</code> 。</span> </p><br><div data-lang=rust><div data-l="let x = 5;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Throughout this book, we&#39;ve used <code>let</code> like this hundreds of times, and although you might not have realized it, you were using patterns!</span>この本を通して、私たちは使用してきました<code>let</code>回のこの数百のように、そしてあなたがそれを実現していないかもしれないが、あなたはパターンを使用していました！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">More formally, a <code>let</code> statement looks like this:</span>より正式には、 <code>let</code>ステートメントは次のようになります。</span> </p><br><div data-lang=text><div data-l="let PATTERN = EXPRESSION;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In statements like <code>let x = 5;</code></span> <code>let x = 5;</code>ような文では<code>let x = 5;</code></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">with a variable name in the <code>PATTERN</code> slot, the variable name is just a particularly simple form of a pattern.</span> <code>PATTERN</code>スロットに変数名を付けると、変数名は単なるパターンの単純な形式に過ぎません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust compares the expression against the pattern and assigns any names it finds.</span> Rustは式とパターンを比較し、見つかった名前を割り当てます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So in the <code>let x = 5;</code></span>だから<code>let x = 5;</code></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">example, <code>x</code> is a pattern that means “bind what matches here to the variable <code>x</code> .” Because the name <code>x</code> is the whole pattern, this pattern effectively means “bind everything to the variable <code>x</code> , whatever the value is.”</span>たとえば、 <code>x</code>意味のパターンである「変数にここに合致するものを結合し<code>x</code> 。」名前なので<code>x</code> 、全体のパターンで、このパターンは、実質的に「変数にすべてをバインドする意味<code>x</code>値が何であれ、。」</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To see the pattern matching aspect of <code>let</code> more clearly, consider Listing 18-4, which uses a pattern with <code>let</code> to destructure a tuple.</span> <code>let</code>パターンマッチングの側面をより明確に見るために、リスト18-4を考えて<code>let</code> 。これは<code>let</code>パターンを使ってタプルを分解します。</span> </p><br><div data-lang=rust><div data-l="let (x, y, z) = (1, 2, 3);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 18-4: Using a pattern to destructure a tuple and create three variables at once</span></span> <span class=caption>リスト18-4：パターンを使ってタプルを分解し、一度に3つの変数を作成する</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here, we match a tuple against a pattern.</span>ここでは、タプルとパターンを照合します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust compares the value <code>(1, 2, 3)</code> to the pattern <code>(x, y, z)</code> and sees that the value matches the pattern, so Rust binds <code>1</code> to <code>x</code> , <code>2</code> to <code>y</code> , and <code>3</code> to <code>z</code> .</span> Rustは値<code>(1, 2, 3)</code>をパターン<code>(x, y, z)</code>と比較し、その値がパターンと一致することを確認するので、Rustは<code>1</code>を<code>x</code> 、 <code>2</code>を<code>y</code>に、 <code>3</code>を<code>z</code>バインドします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can think of this tuple pattern as nesting three individual variable patterns inside it.</span>このタプルパターンは、内部に3つの個別の変数パターンをネストしていると考えることができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If the number of elements in the pattern doesn&#39;t match the number of elements in the tuple, the overall type won&#39;t match and we&#39;ll get a compiler error.</span>パターンの要素の数がタプルの要素の数と一致しない場合は、全体の型が一致せず、コンパイラエラーが発生します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, Listing 18-5 shows an attempt to destructure a tuple with three elements into two variables, which won&#39;t work.</span>たとえば、リスト18-5は、3つの要素を持つタプルを2つの変数に分解しようとしていますが、これはうまくいきません。</span> </p><br><div data-lang=rust,ignore><div data-l="let (x, y) = (1, 2, 3);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 18-5: Incorrectly constructing a pattern whose variables don&#39;t match the number of elements in the tuple</span></span> <span class=caption>リスト18-5：変数がタプルの要素の数と一致しないパターンを間違って構築する</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Attempting to compile this code results in this type error:</span>このコードをコンパイルしようとすると、次のようなエラーが発生します。</span> </p><br><div data-lang=text><div data-l="error[E0308]: mismatched types"></div><div data-l=" --&gt; src/main.rs:2:9"></div><div data-l="  |"></div><div data-l="2 |     let (x, y) = (1, 2, 3);"></div><div data-l="  |         ^^^^^^ expected a tuple with 3 elements, found one with 2 elements"></div><div data-l="  |"></div><div data-l="  = note: expected type `({integer}, {integer}, {integer})`"></div><div data-l="             found type `(_, _)`"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we wanted to ignore one or more of the values in the tuple, we could use <code>_</code> or <code>..</code> , as you&#39;ll see in the “Ignoring Values in a Pattern” section.</span>タプルの中の1つ以上の値を無視したい場合は、「パターンの値を無視する」で説明するように<code>_</code>または<code>..</code>使用できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If the problem is that we have too many variables in the pattern, the solution is to make the types match by removing variables so the number of variables equals the number of elements in the tuple.</span>パターンに変数が多すぎる問題がある場合は、変数の数がタプルの要素の数と等しくなるように変数を削除して型を一致させることです。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Function Parameters</span>関数のパラメータ</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Function parameters can also be patterns.</span>機能パラメータはパターンであってもよい。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The code in Listing 18-6, which declares a function named <code>foo</code> that takes one parameter named <code>x</code> of type <code>i32</code> , should by now look familiar.</span>名前の関数を宣言し、リスト18-6のコード、 <code>foo</code>名前の一つのパラメータとる<code>x</code>型の<code>i32</code> 、今ではおなじみのはずです。</span> </p><br><div data-lang=rust><div data-l="fn foo(x: i32) {"></div><div data-l="#    // code goes here"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">code goes here</span>コードはここに行く</span> </div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 18-6: A function signature uses patterns in the parameters</span></span> <span class=caption>リスト18-6：関数シグネチャは、パラメータのパターンを使用します。</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>x</code> part is a pattern!</span> <code>x</code>部分はパターンです！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As we did with <code>let</code> , we could match a tuple in a function&#39;s arguments to the pattern.</span> <code>let</code>で行ったように、関数の引数のタプルをパターンにマッチ<code>let</code>ことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 18-7 splits the values in a tuple as we pass it to a function.</span>リスト18-7は、タプルの値を関数に渡す際に値を分割します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="fn print_coordinates(&amp;(x, y): &amp;(i32, i32)) {"></div><div data-l="    println!(&quot;Current location: ({}, {})&quot;, x, y);"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let point = (3, 5);"></div><div data-l="    print_coordinates(&amp;point);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 18-7: A function with parameters that destructure a tuple</span></span> <span class=caption>リスト18-7：タプルをデストラクションするパラメータを持つ関数</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This code prints <code>Current location: (3, 5)</code> .</span>このコードは<code>Current location: (3, 5)</code>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The values <code>&amp;(3, 5)</code> match the pattern <code>&amp;(x, y)</code> , so <code>x</code> is the value <code>3</code> and <code>y</code> is the value <code>5</code> .</span>値<code>&amp;(3, 5)</code>はパターン<code>&amp;(x, y)</code>と一致するので、 <code>x</code>は値<code>3</code> 、 <code>y</code>は値<code>5</code>です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can also use patterns in closure parameter lists in the same way as in function parameter lists, because closures are similar to functions, as discussed in Chapter 13.</span>第13章で説明したように、クロージャは関数と似ているので、関数パラメータリストと同じ方法でクロージャパラメータリストのパターンを使用することもできます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">At this point, you&#39;ve seen several ways of using patterns, but patterns don&#39;t work the same in every place we can use them.</span>この時点で、パターンを使用するいくつかの方法を見てきましたが、使用できるすべての場所でパターンが同じように機能しません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In some places, the patterns must be irrefutable;</span>いくつかの場所では、パターンは反駁不可能でなければならない。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">in other circumstances, they can be refutable.</span>他の状況では、それらは改訂することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll discuss these two concepts next.</span>次に、これらの2つの概念について説明します。</span> </p><script>_addload(function(){_setupIW('com');_csi('en','ja','ch18-01-all-the-places-for-patterns.html');});</script>