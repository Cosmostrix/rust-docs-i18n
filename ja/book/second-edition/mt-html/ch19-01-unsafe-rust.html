<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180709_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=ch19-01-unsafe-rust.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Unsafe Rust</span>安全でない錆</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">All the code we&#39;ve discussed so far has had Rust&#39;s memory safety guarantees enforced at compile time.</span>これまで説明したすべてのコードでは、コンパイル時にRustのメモリ安全性が保証されています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, Rust has a second language hidden inside it that doesn&#39;t enforce these memory safety guarantees: it&#39;s called <i>unsafe Rust</i> and works just like regular Rust, but gives us extra superpowers.</span>しかし、Rustは内部に隠された第2言語を持っています。これは、 <i>安全でないRust</i>と呼ばれ、通常のRustのように動作しますが、余分な超電力を与えます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Unsafe Rust exists because, by nature, static analysis is conservative.</span>事実、静的分析は保守的であるため、安全でない錆が存在する。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When the compiler tries to determine whether or not code upholds the guarantees, it&#39;s better for it to reject some valid programs rather than accept some invalid programs.</span>コンパイラがコードが保証を維持するかどうかを判断しようとすると、いくつかの無効なプログラムを受け入れるのではなく、有効なプログラムを拒否する方が良いでしょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Although the code might be okay, as far as Rust is able to tell, it&#39;s not!</span>コードは大丈夫かもしれませんが、Rustが言うことができる限り、そうではありません！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In these cases, you can use unsafe code to tell the compiler, “Trust me, I know what I&#39;m doing.” The downside is that you use it at your own risk: if you use unsafe code incorrectly, problems due to memory unsafety, such as null pointer dereferencing, can occur.</span>このような場合、安全でないコードを使用して、コンパイラに「信頼してください、私がやっていることを知っています。」ということを伝えることができます。危険なコードを使用することは危険です。安全でないコードを誤って使用すると、ヌル・ポインター逆参照などの安全でないものが発生する可能性があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Another reason Rust has an unsafe alter ego is that the underlying computer hardware is inherently unsafe.</span> Rustが危険な自我を持っているもう一つの理由は、基本的なコンピュータのハードウェアが本質的に危険であるということです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If Rust didn&#39;t let you do unsafe operations, you couldn&#39;t do certain tasks.</span> Rustが安全でない操作をさせなかった場合、あなたは特定の作業を行うことができませんでした。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust needs to allow you to do low-level systems programming, such as directly interacting with the operating system or even writing your own operating system.</span> Rustは、オペレーティングシステムと直接対話する、または独自のオペレーティングシステムを作成するなど、低レベルのシステムプログラミングを可能にする必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Working with low-level systems programming is one of the goals of the language.</span>低レベルのシステムプログラミングを使用することは、言語の目標の1つです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s explore what we can do with unsafe Rust and how to do it.</span>私たちが安全でない錆に何ができるのか、それをどうするかを探そう。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Unsafe Superpowers</span>安全でない超大国</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To switch to unsafe Rust, use the <code>unsafe</code> keyword and then start a new block that holds the unsafe code.</span>安全でない錆に切り替えるには、 <code>unsafe</code>キーワードを使用し、 <code>unsafe</code>ないコードを保持する新しいブロックを開始します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can take four actions in unsafe Rust, called <i>unsafe superpowers</i> , that you can&#39;t in safe Rust.</span>安全では<i>ないスーパーパワー</i>と呼ばれる<i>安全</i>でないルストでは、4つのアクションを取ることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Those superpowers include the ability to:</span>これらの超大国には以下の能力が含まれます：</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Dereference a raw pointer</span>未処理のポインタを参照解除する</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Call an unsafe function or method</span>安全でない関数またはメソッドを呼び出す</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Access or modify a mutable static variable</span>可変静的変数へのアクセスまたは変更</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Implement an unsafe trait</span>安全でない特性を実装する</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It&#39;s important to understand that <code>unsafe</code> doesn&#39;t turn off the borrow checker or disable any other of Rust&#39;s safety checks: if you use a reference in unsafe code, it will still be checked.</span> <code>unsafe</code>ないと借りチェッカーを無効にしたり、Rustの安全チェックを無効にしたりすることはないことを理解することが重要です。 <code>unsafe</code>でないコードで参照を使用してもチェックされます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>unsafe</code> keyword only gives you access to these four features that are then not checked by the compiler for memory safety.</span> <code>unsafe</code>キーワードは、メモリ安全性のためにコンパイラによってチェックされない4つの機能にのみアクセスできます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You&#39;ll still get some degree of safety inside of an unsafe block.</span>あなたはまだ安全でないブロックの中である程度の安全を得るでしょう。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In addition, <code>unsafe</code> does not mean the code inside the block is necessarily dangerous or that it will definitely have memory safety problems: the intent is that as the programmer, you&#39;ll ensure the code inside an <code>unsafe</code> block will access memory in a valid way.</span>さらに、 <code>unsafe</code>ないということは、ブロック内のコードが必然的に危険であるということ、またはメモリの安全上の問題があることを意味するわけではありません。プログラマーとして、 <code>unsafe</code>ブロック内のコードが、 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">People are fallible, and mistakes will happen, but by requiring these four unsafe operations to be inside blocks annotated with <code>unsafe</code> you&#39;ll know that any errors related to memory safety must be within an <code>unsafe</code> block.</span>人々は間違いがあり、間違いが起こりますが、これらの4つの安全でない操作に安全で<code>unsafe</code>ことが注釈されたブロックの内側にあることを要求することにより、メモリの安全性に関するエラーは<code>unsafe</code>ブロック内になければなりません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Keep <code>unsafe</code> blocks small;</span> <code>unsafe</code>ブロックは小さくしてください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">you&#39;ll be thankful later when you investigate memory bugs.</span>後でメモリバグを調べると感謝しています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To isolate unsafe code as much as possible, it&#39;s best to enclose unsafe code within a safe abstraction and provide a safe API, which we&#39;ll discuss later in the chapter when we examine unsafe functions and methods.</span>安全でないコードを可能な限り分離するには、安全でないコードを安全な抽象的に囲み、安全なAPIを提供することが最善です。これについては、安全でない関数やメソッドを調べるときの章で後述します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Parts of the standard library are implemented as safe abstractions over unsafe code that has been audited.</span>標準ライブラリの一部は、監査された安全でないコードに対して安全な抽象として実装されています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Wrapping unsafe code in a safe abstraction prevents uses of <code>unsafe</code> from leaking out into all the places that you or your users might want to use the functionality implemented with <code>unsafe</code> code, because using a safe abstraction is safe.</span>危険なコードを安全な抽象的にラップすることで、安全な抽象を使用することは<code>unsafe</code>であるため、安全で<code>unsafe</code>コードを実装する機能を使用したいと思うすべての場所に<code>unsafe</code>で<code>unsafe</code>ものが漏れるのを防ぎます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s look at each of the four unsafe superpowers in turn.</span>安全でない4つの超大国のそれぞれを順番に見てみましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll also look at some abstractions that provide a safe interface to unsafe code.</span>また、安全でないコードとの安全なインターフェイスを提供する抽象概念についても見ていきます。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Dereferencing a Raw Pointer</span>未処理のポインタを参照解除する</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In Chapter 4, in the “Dangling References” section, we mentioned that the compiler ensures references are always valid.</span>第4章の「Dangling References」セクションでは、コンパイラが参照が常に有効であることを保証していると述べました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Unsafe Rust has two new types called <i>raw pointers</i> that are similar to references.</span> Unsafe Rustには、参照に似ている<i>生ポインタ</i>という2つの新しいタイプがあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As with references, raw pointers can be immutable or mutable and are written as <code>*const T</code> and <code>*mut T</code> , respectively.</span>参照の場合と同様に、生ポインタは不変または変更可能であり、それぞれ<code>*const T</code>および<code>*mut T</code>として記述されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The asterisk isn&#39;t the dereference operator;</span>アスタリスクは逆参照演算子ではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">it&#39;s part of the type name.</span>それは型名の一部です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In the context of raw pointers, <i>immutable</i> means that the pointer can&#39;t be directly assigned to after being dereferenced.</span>生ポインタのコンテキストでは、 <i>immutable</i>は、逆参照された後にポインタを直接割り当てることができないことを意味します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Different from references and smart pointers, raw pointers:</span>リファレンスとスマートポインタとは異なり、生ポインタ：</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Are allowed to ignore the borrowing rules by having both immutable and mutable pointers or multiple mutable pointers to the same location</span>不変および変更可能なポインタまたは同じ場所への複数の変更可能なポインタの両方を持つことによって、借用ルールを無視することができます</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Aren&#39;t guaranteed to point to valid memory</span>有効なメモリを指すことが保証されていない</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Are allowed to be null</span> nullにできる</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Don&#39;t implement any automatic cleanup</span>自動クリーンアップを実装しないでください</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">By opting out of having Rust enforce these guarantees, you can give up guaranteed safety in exchange for greater performance or the ability to interface with another language or hardware where Rust&#39;s guarantees don&#39;t apply.</span> Rustにこれらの保証を適用することを拒否することにより、より高いパフォーマンスとRustの保証が適用されない別の言語またはハードウェアとのインターフェース機能と引き換えに保証された安全性を放棄することができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 19-1 shows how to create an immutable and a mutable raw pointer from references.</span>リスト19-1は、参照から不変および変更可能な生ポインタを作成する方法を示しています。</span> </p><br><div data-lang=rust><div data-l="let mut num = 5;"></div><div data-l=""></div><div data-l="let r1 = &amp;num as *const i32;"></div><div data-l="let r2 = &amp;mut num as *mut i32;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 19-1: Creating raw pointers from references</span></span> <span class=caption>リスト19-1：リファレンスからの生ポインタの作成</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Notice that we don&#39;t include the <code>unsafe</code> keyword in this code.</span>このコードに<code>unsafe</code>キーワードは含まれていないことに注意してください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can create raw pointers in safe code;</span>安全なコードで生ポインタを作成することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">we just can&#39;t dereference raw pointers outside an unsafe block, as you&#39;ll see in a bit.</span>安全でないブロックの外に生のポインタを逆参照することはできません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ve created raw pointers by using <code>as</code> to cast an immutable and a mutable reference into their corresponding raw pointer types.</span>私たちは、 <code>as</code>を使っ<code>as</code>不変の参照と変更可能な参照を対応する未処理のポインタ型にキャストすることで、未加工のポインタを作成しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because we created them directly from references guaranteed to be valid, we know these particular raw pointers are valid, but we can&#39;t make that assumption about just any raw pointer.</span>有効であることが保証されている参照から直接作成したため、これらの特定のローポインタが有効であることがわかりましたが、ローポインタについてはその仮定をすることはできません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Next, we&#39;ll create a raw pointer whose validity we can&#39;t be so certain of.</span>次に、有効性がそれほど高くない生のポインタを作成します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 19-2 shows how to create a raw pointer to an arbitrary location in memory.</span>リスト19-2は、メモリ内の任意の場所への生ポインタを作成する方法を示しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Trying to use arbitrary memory is undefined: there might be data at that address or there might not, the compiler might optimize the code so there is no memory access, or the program might error with a segmentation fault.</span>任意のメモリを使用しようとすると、そのアドレスにデータが存在する可能性があります。そうしないと、コンパイラはコードを最適化してメモリアクセスがないか、セグメンテーションフォルトでエラーが発生する可能性があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Usually, there is no good reason to write code like this, but it is possible.</span>通常、このようなコードを記述する正当な理由はありませんが、可能です。</span> </p><br><div data-lang=rust><div data-l="let address = 0x012345usize;"></div><div data-l="let r = address as *const i32;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 19-2: Creating a raw pointer to an arbitrary memory address</span></span> <span class=caption>リスト19-2：任意のメモリアドレスへの生ポインタの作成</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Recall that we can create raw pointers in safe code, but we can&#39;t <i>dereference</i> raw pointers and read the data being pointed to.</span>安全なコードで生ポインタを作成できることを思い出してください。しかし、生ポインタを<i>逆参照</i>したり、指し示されているデータを読み込んだりすることはできません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In Listing 19-3, we use the dereference operator <code>*</code> on a raw pointer that requires an <code>unsafe</code> block.</span>リスト19-3では、 <code>unsafe</code>ブロックを必要とする生ポインタに対して逆参照演算子<code>*</code>を使用しています。</span> </p><br><div data-lang=rust><div data-l="let mut num = 5;"></div><div data-l=""></div><div data-l="let r1 = &amp;num as *const i32;"></div><div data-l="let r2 = &amp;mut num as *mut i32;"></div><div data-l=""></div><div data-l="unsafe {"></div><div data-l="    println!(&quot;r1 is: {}&quot;, *r1);"></div><div data-l="    println!(&quot;r2 is: {}&quot;, *r2);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 19-3: Dereferencing raw pointers within an <code>unsafe</code> block</span></span> <span class=caption>リスト19-3： <code>unsafe</code>ブロック内で生ポインタを参照解除する</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Creating a pointer does no harm;</span>ポインタを作成することは問題ありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">it&#39;s only when we try to access the value that it points at that we might end up dealing with an invalid value.</span>私たちが無効な値を扱うことになるかもしれないと指摘している値にアクセスしようとするときだけです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note also that in Listing 19-1 and 19-3, we created <code>*const i32</code> and <code>*mut i32</code> raw pointers that both pointed to the same memory location, where <code>num</code> is stored.</span>リスト19-1と19-3では、 <code>num</code>が格納されている同じメモリ位置を指していた<code>*const i32</code>と<code>*mut i32</code>生ポインタを作成したことにも注意してください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we instead tried to create an immutable and a mutable reference to <code>num</code> , the code would not have compiled because Rust&#39;s ownership rules don&#39;t allow a mutable reference at the same time as any immutable references.</span>代わりに、不変で変更可能な<code>num</code>への参照を作成しようとした場合、Rustの所有権規則は不変参照と同時に変更可能な参照を許可しないため、コードはコンパイルされません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">With raw pointers, we can create a mutable pointer and an immutable pointer to the same location and change data through the mutable pointer, potentially creating a data race.</span>生のポインタでは、可変ポインタと不変のポインタを同じ場所に作成し、可変ポインタを介してデータを変更することができ、データ競合が発生する可能性があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Be careful!</span>注意してください！</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">With all of these dangers, why would you ever use raw pointers?</span>これらの危険性のすべてを理由に、なぜ生ポインタを使用するのですか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">One major use case is when interfacing with C code, as you&#39;ll see in the next section, “Calling an Unsafe Function or Method.” Another case is when building up safe abstractions that the borrow checker doesn&#39;t understand.</span>次のセクション「安全ではない関数またはメソッドを呼び出す」のように、Cコードとインターフェイスするときの主な使用例があります。もう1つのケースは、借用チェッカーが理解できない安全な抽象を構築する場合です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll introduce unsafe functions and then look at an example of a safe abstraction that uses unsafe code.</span>安全でない関数を導入し、安全でないコードを使用する安全な抽象の例を見ていきます。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Calling an Unsafe Function or Method</span>安全でない関数またはメソッドを呼び出す</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The second type of operation that requires an unsafe block is calls to unsafe functions.</span>安全でないブロックを必要とする第2のタイプの操作は、安全でない関数を呼び出すことです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Unsafe functions and methods look exactly like regular functions and methods, but they have an extra <code>unsafe</code> before the rest of the definition.</span>安全ではない関数やメソッドは、通常の関数やメソッドとまったく同じように見えますが、残りの定義よりも<code>unsafe</code>なります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>unsafe</code> keyword in this context indicates the function has requirements we need to uphold when we call this function, because Rust can&#39;t guarantee we&#39;ve met these requirements.</span>この文脈の<code>unsafe</code>キーワードは、関数がこの関数を呼び出すときに必要とする要件があることを示しています。なぜなら、Rustはこれらの要件を満たしているとは保証できないからです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">By calling an unsafe function within an <code>unsafe</code> block, we&#39;re saying that we&#39;ve read this function&#39;s documentation and take responsibility for upholding the function&#39;s contracts.</span> <code>unsafe</code>ブロック内で<code>unsafe</code>ない関数を呼び出すことによって、この関数のドキュメントを読み、その関数の契約を守る責任があると言います。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here is an unsafe function named <code>dangerous</code> that doesn&#39;t do anything in its body:</span>ここに<code>dangerous</code>名前の<code>dangerous</code>な機能があります。危険な機能は本体内に何もしません。</span> </p><br><div data-lang=rust><div data-l="unsafe fn dangerous() {}"></div><div data-l=""></div><div data-l="unsafe {"></div><div data-l="    dangerous();"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We must call the <code>dangerous</code> function within a separate <code>unsafe</code> block.</span> <code>unsafe</code>別のブロック内で<code>dangerous</code>機能を呼び出す必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we try to call <code>dangerous</code> without the <code>unsafe</code> block, we&#39;ll get an error:</span> <code>unsafe</code>ブロックなしで<code>dangerous</code>を呼び出そうとすると、エラーが発生します：</span> </p><br><div data-lang=text><div data-l="error[E0133]: call to unsafe function requires unsafe function or block"></div><div data-l=" --&gt;"></div><div data-l="  |"></div><div data-l="4 |     dangerous();"></div><div data-l="  |     ^^^^^^^^^^^ call to unsafe function"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">By inserting the <code>unsafe</code> block around our call to <code>dangerous</code> , we&#39;re asserting to Rust that we&#39;ve read the function&#39;s documentation, we understand how to use it properly, and we&#39;ve verified that we&#39;re fulfilling the contract of the function.</span> <code>unsafe</code>ブロックを<code>dangerous</code>呼び出しの周りに挿入することで、関数のドキュメントを読んだこと、正しく使用する方法を理解していること、そして関数の規約を満たしていることが確認されました。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Bodies of unsafe functions are effectively <code>unsafe</code> blocks, so to perform other unsafe operations within an unsafe function, we don&#39;t need to add another <code>unsafe</code> block.</span>危険な関数の本体が効果的です<code>unsafe</code>ブロック、とても危険な関数内で他の危険な操作を実行するために、我々は別の追加する必要はありません<code>unsafe</code>ブロックを。</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Creating a Safe Abstraction over Unsafe Code</span>安全でないコードに対する安全な抽象化の作成</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Just because a function contains unsafe code doesn&#39;t mean we need to mark the entire function as unsafe.</span>関数が安全でないコードを含んでいるからといって、関数全体を危険なものとしてマークする必要はありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In fact, wrapping unsafe code in a safe function is a common abstraction.</span>実際、安全でないコードを安全な関数にラップすることは一般的な抽象化です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As an example, let&#39;s study a function from the standard library, <code>split_at_mut</code> , that requires some unsafe code and explore how we might implement it.</span>一例として、標準ライブラリ<code>split_at_mut</code>から安全でないコードが必要な関数を調べて、実装する方法を調べてみましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This safe method is defined on mutable slices: it takes one slice and makes it two by splitting the slice at the index given as an argument.</span>この安全なメソッドは可変スライスで定義されています。スライスを1つ取り、引数として与えられたインデックスでスライスを分割して2つにします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 19-4 shows how to use <code>split_at_mut</code> .</span>リスト19-4は、 <code>split_at_mut</code>使い方を示しています。</span> </p><br><div data-lang=rust><div data-l="let mut v = vec![1, 2, 3, 4, 5, 6];"></div><div data-l=""></div><div data-l="let r = &amp;mut v[..];"></div><div data-l=""></div><div data-l="let (a, b) = r.split_at_mut(3);"></div><div data-l=""></div><div data-l="assert_eq!(a, &amp;mut [1, 2, 3]);"></div><div data-l="assert_eq!(b, &amp;mut [4, 5, 6]);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 19-4: Using the safe <code>split_at_mut</code> function</span></span> <span class=caption>リスト19-4：safe <code>split_at_mut</code>関数の使用</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can&#39;t implement this function using only safe Rust.</span>安全なRustだけを使用してこの機能を実装することはできません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">An attempt might look something like Listing 19-5, which won&#39;t compile.</span>リスト19-5のようなものがありますが、これはコンパイルされません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For simplicity, we&#39;ll implement <code>split_at_mut</code> as a function rather than a method and only for slices of <code>i32</code> values rather than for a generic type <code>T</code> .</span> <code>split_at_mut</code>ために、 <code>split_at_mut</code>をメソッドではなく関数として実装し、ジェネリック型<code>T</code>ではなく<code>i32</code>値のスライスに対してのみ実装します。</span> </p><br><div data-lang=rust,ignore><div data-l="fn split_at_mut(slice: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {"></div><div data-l="    let len = slice.len();"></div><div data-l=""></div><div data-l="    assert!(mid &lt;= len);"></div><div data-l=""></div><div data-l="    (&amp;mut slice[..mid],"></div><div data-l="     &amp;mut slice[mid..])"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 19-5: An attempted implementation of <code>split_at_mut</code> using only safe Rust</span></span> <span class=caption>リスト19-5： <code>split_at_mut</code>だけを使って<code>split_at_mut</code>を実装しようとした</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This function first gets the total length of the slice.</span>この関数は、最初にスライスの全長を取得します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then it asserts that the index given as a parameter is within the slice by checking whether it&#39;s less than or equal to the length.</span>次に、パラメータとして指定されたインデックスが長さ以下であるかどうかをチェックすることによってスライス内にあることを示します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The assertion means that if we pass an index that is greater than the index to split the slice at, the function will panic before it attempts to use that index.</span>アサーションとは、スライスを分割するインデックスよりも大きいインデックスを渡すと、そのインデックスを使用しようとする前に関数がパニックすることを意味します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then we return two mutable slices in a tuple: one from the start of the original slice to the <code>mid</code> index and another from <code>mid</code> to the end of the slice.</span>次に、元のスライスの始めから<code>mid</code>インデックスまで、スライスの<code>mid</code>から終わりまでの2つの可変スライスをタプルに返します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When we try to compile the code in Listing 19-5, we&#39;ll get an error.</span>リスト19-5のコードをコンパイルしようとすると、エラーが発生します。</span> </p><br><div data-lang=text><div data-l="error[E0499]: cannot borrow `*slice` as mutable more than once at a time"></div><div data-l=" --&gt;"></div><div data-l="  |"></div><div data-l="6 |     (&amp;mut slice[..mid],"></div><div data-l="  |           ----- first mutable borrow occurs here"></div><div data-l="7 |      &amp;mut slice[mid..])"></div><div data-l="  |           ^^^^^ second mutable borrow occurs here"></div><div data-l="8 | }"></div><div data-l="  | - first borrow ends here"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust&#39;s borrow checker can&#39;t understand that we&#39;re borrowing different parts of the slice;</span> Rustの貸借チェッカーは、スライスのさまざまな部分を借りていることを理解できません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">it only knows that we&#39;re borrowing from the same slice twice.</span>私たちが同じスライスから2回借りていることを知っているだけです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Borrowing different parts of a slice is fundamentally okay because the two slices aren&#39;t overlapping, but Rust isn&#39;t smart enough to know this.</span> 2つのスライスが重なっていないので、スライスの異なる部分を借用するのは基本的に問題ありませんが、Rustはこれを知るには十分スマートではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When we know code is okay, but Rust doesn&#39;t, it&#39;s time to reach for unsafe code.</span>コードは大丈夫だが、Rustはそうでないことが分かっているときは、安全でないコードに手を差し伸べるべき時です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 19-6 shows how to use an <code>unsafe</code> block, a raw pointer, and some calls to unsafe functions to make the implementation of <code>split_at_mut</code> work.</span>リスト19-6は、 <code>unsafe</code>ブロック、生ポインタ、および安全ではない関数への呼び出しを使用して<code>split_at_mut</code>の実装を<code>split_at_mut</code>させる方法を<code>split_at_mut</code>います。</span> </p><br><div data-lang=rust><div data-l="use std::slice;"></div><div data-l=""></div><div data-l="fn split_at_mut(slice: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {"></div><div data-l="    let len = slice.len();"></div><div data-l="    let ptr = slice.as_mut_ptr();"></div><div data-l=""></div><div data-l="    assert!(mid &lt;= len);"></div><div data-l=""></div><div data-l="    unsafe {"></div><div data-l="        (slice::from_raw_parts_mut(ptr, mid),"></div><div data-l="         slice::from_raw_parts_mut(ptr.offset(mid as isize), len - mid))"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 19-6: Using unsafe code in the implementation of the <code>split_at_mut</code> function</span></span> <span class=caption>コードリスト19-6： <code>split_at_mut</code>関数の実装で安全でないコードを使用する</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Recall from “The Slice Type” section in Chapter 4 that slices are a pointer to some data and the length of the slice.</span>第4章の「スライスタイプ」のセクションから、スライスはいくつかのデータへのポインタとスライスの長さを思い出してください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We use the <code>len</code> method to get the length of a slice and the <code>as_mut_ptr</code> method to access the raw pointer of a slice.</span> <code>len</code>メソッドを使用してスライスの長さを取得し、 <code>as_mut_ptr</code>メソッドを使用してスライスの生ポインタにアクセスします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this case, because we have a mutable slice to <code>i32</code> values, <code>as_mut_ptr</code> returns a raw pointer with the type <code>*mut i32</code> , which we&#39;ve stored in the variable <code>ptr</code> .</span>この場合、私たちは<code>i32</code>値に対する可変スライスを持っているので、 <code>as_mut_ptr</code>は変数<code>ptr</code>格納した<code>*mut i32</code>型の生ポインタを返します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We keep the assertion that the <code>mid</code> index is within the slice.</span> <code>mid</code>インデックスがスライス内にあるという主張を維持します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then we get to the unsafe code: the <code>slice::from_raw_parts_mut</code> function takes a raw pointer and a length, and it creates a slice.</span>次に安全でないコードに到達します： <code>slice::from_raw_parts_mut</code>関数は生ポインタと長さを取り、スライスを作成します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We use this function to create a slice that starts from <code>ptr</code> and is <code>mid</code> items long.</span>この関数を使用して、 <code>ptr</code>から始まり、長い<code>mid</code>アイテムのスライスを作成します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then we call the <code>offset</code> method on <code>ptr</code> with <code>mid</code> as an argument to get a raw pointer that starts at <code>mid</code> , and we create a slice using that pointer and the remaining number of items after <code>mid</code> as the length.</span>その後、我々は呼んで<code>offset</code>の方法<code>ptr</code>して<code>mid</code>から始まる生のポインタを取得するには、引数として<code>mid</code> 、私たちはそのポインタを使用してスライスし、後のアイテムの残り数作成<code>mid</code>の長さなどを。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The function <code>slice::from_raw_parts_mut</code> is unsafe because it takes a raw pointer and must trust that this pointer is valid.</span> <code>slice::from_raw_parts_mut</code>関数は、生ポインタを取り、このポインタが有効であると信頼する必要があるため、安全ではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>offset</code> method on raw pointers is also unsafe, because it must trust that the offset location is also a valid pointer.</span>未処理のポインタに対する<code>offset</code>メソッドも安全ではありません。なぜなら、オフセット位置も有効なポインタであると信頼する必要があるからです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Therefore, we had to put an <code>unsafe</code> block around our calls to <code>slice::from_raw_parts_mut</code> and <code>offset</code> so we could call them.</span>したがって、私たちは<code>slice::from_raw_parts_mut</code>と<code>offset</code>呼び出しのあちこちに<code>unsafe</code>ブロックを置く<code>slice::from_raw_parts_mut</code>ありました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">By looking at the code and by adding the assertion that <code>mid</code> must be less than or equal to <code>len</code> , we can tell that all the raw pointers used within the <code>unsafe</code> block will be valid pointers to data within the slice.</span>コードを見て、 <code>mid</code>が<code>len</code>以下でなければならないというアサーションを追加することで、 <code>unsafe</code>ブロック内で使用されるすべての生ポインタがスライス内のデータへの有効なポインタになることがわかります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is an acceptable and appropriate use of <code>unsafe</code> .</span>これは、 <code>unsafe</code>では<code>unsafe</code>許容され、適切に使用されます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that we don&#39;t need to mark the resulting <code>split_at_mut</code> function as <code>unsafe</code> , and we can call this function from safe Rust.</span>結果として生じる<code>split_at_mut</code>関数を<code>unsafe</code>ものとしてマークする必要はなく、この関数を安全なRustから呼び出すことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ve created a safe abstraction to the unsafe code with an implementation of the function that uses <code>unsafe</code> code in a safe way, because it creates only valid pointers from the data this function has access to.</span>私たちは、使用する機能の実装に危険なコードへの安全な抽象化を作成した<code>unsafe</code>ことは、この機能がアクセスできるデータから、唯一の有効なポインタを作成するので、安全な方法でコードを。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In contrast, the use of <code>slice::from_raw_parts_mut</code> in Listing 19-7 would likely crash when the slice is used.</span>対照的に、リスト19-7の<code>slice::from_raw_parts_mut</code>使用は、 <code>slice::from_raw_parts_mut</code>の使用時にクラッシュする可能性があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This code takes an arbitrary memory location and creates a slice 10,000 items long.</span>このコードは任意のメモリ位置をとり、10,000個のアイテムのスライスを作成します。</span> </p><br><div data-lang=rust><div data-l="use std::slice;"></div><div data-l=""></div><div data-l="let address = 0x012345usize;"></div><div data-l="let r = address as *mut i32;"></div><div data-l=""></div><div data-l="let slice = unsafe {"></div><div data-l="    slice::from_raw_parts_mut(r, 10000)"></div><div data-l=};></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 19-7: Creating a slice from an arbitrary memory location</span></span> <span class=caption>リスト19-7：任意のメモリ位置からスライスを作成する</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We don&#39;t own the memory at this arbitrary location, and there is no guarantee that the slice this code creates contains valid <code>i32</code> values.</span>私たちはこの任意の場所にメモリを所有しておらず、このコードが作成するスライスに有効な<code>i32</code>値が含まれているという保証はありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Attempting to use <code>slice</code> as though it&#39;s a valid slice results in undefined behavior.</span>有効なスライスであるかのように<code>slice</code>を使用しようとすると、未定義の動作が発生します。</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Using <code>extern</code> Functions to Call External Code</span> <code>extern</code>関数を使用した外部コードの呼び出し</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Sometimes, your Rust code might need to interact with code written in another language.</span>時々、あなたの錆のコードは、別の言語で書かれたコードと対話する必要があるかもしれません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For this, Rust has a keyword, <code>extern</code> , that facilitates the creation and use of a <i>Foreign Function Interface (FFI)</i> .</span>このため、Rustには<i>外部ファンクションインタフェース（FFI）</i>の作成と使用を容易にする<code>extern</code>というキーワードがあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">An FFI is a way for a programming language to define functions and enable a different (foreign) programming language to call those functions.</span> FFIは、プログラミング言語が関数を定義し、それらの関数を呼び出すために異なる（外部の）プログラミング言語を使用可能にする方法です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 19-8 demonstrates how to set up an integration with the <code>abs</code> function from the C standard library.</span>リスト19-8は、C標準ライブラリの<code>abs</code>関数との統合を設定する方法を示しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Functions declared within <code>extern</code> blocks are always unsafe to call from Rust code.</span> <code>extern</code>ブロック内で宣言された関数は、必ずしもRustコードから呼び出すのは安全ではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The reason is that other languages don&#39;t enforce Rust&#39;s rules and guarantees, and Rust can&#39;t check them, so responsibility falls on the programmer to ensure safety.</span>その理由は、他の言語はRustの規則と保証を強制せず、Rustはそれらを検査できないため、安全性を確保するためにプログラマが責任を負うからです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="extern &quot;C&quot; {"></div><div data-l="    fn abs(input: i32) -&gt; i32;"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    unsafe {"></div><div data-l="        println!(&quot;Absolute value of -3 according to C: {}&quot;, abs(-3));"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 19-8: Declaring and calling an <code>extern</code> function defined in another language</span></span> <span class=caption>リスト19-8：別の言語で定義された<code>extern</code>関数の宣言と呼び出し</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Within the <code>extern &quot;C&quot;</code> block, we list the names and signatures of external functions from another language we want to call.</span> <code>extern &quot;C&quot;</code>ブロック内では、外部関数の名前と署名を、別の言語から呼び出したいとします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>&quot;C&quot;</code> part defines which <i>application binary interface (ABI)</i> the external function uses: the ABI defines how to call the function at the assembly level.</span> <code>&quot;C&quot;</code>部分は、外部関数が使用する<i>アプリケーションバイナリインタフェース（ABI）を</i>定義します.ABIは、アセンブリレベルで関数を呼び出す方法を定義します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>&quot;C&quot;</code> ABI is the most common and follows the C programming language&#39;s ABI.</span> <code>&quot;C&quot;</code> ABIは最も一般的であり、Cプログラミング言語のABIに従います。</span> </p><br><blockquote><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Calling Rust Functions from Other Languages</span>他の言語から錆関数を呼び出す</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can also use <code>extern</code> to create an interface that allows other languages to call Rust functions.</span> <code>extern</code>を使用して、他の言語がRust関数を呼び出すことができるようにするインタフェースを作成することもできます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Instead of an <code>extern</code> block, we add the <code>extern</code> keyword and specify the ABI to use just before the <code>fn</code> keyword.</span>代わりに<code>extern</code>ブロック、我々は追加<code>extern</code>キーワードをし、直前に使用するABIを指定<code>fn</code>キーワード。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We also need to add a <code>#[no_mangle]</code> annotation to tell the Rust compiler not to mangle the name of this function.</span>また、 <code>#[no_mangle]</code>アノテーションを追加して、この関数の名前をmangleしないようにRustコンパイラに指示する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><i>Mangling</i> is when a compiler changes the name we&#39;ve given a function to a different name that contains more information for other parts of the compilation process to consume but is less human readable.</span> <i>Mangling</i>はコンパイラが私たちが関数を与えた名前を、コンパイルプロセスの他の部分が消費するが人間の読取り可能性は低いというより多くの情報を含む別の名前に変更するときです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Every programming language compiler mangles names slightly differently, so for a Rust function to be nameable by other languages, we must disable the Rust compiler&#39;s name mangling.</span>すべてのプログラミング言語コンパイラは名前を若干違うようにマングルするので、Rust関数が他の言語で名前を付けるためには、Rustコンパイラの名前マングリングを無効にする必要があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In the following example, we make the <code>call_from_c</code> function accessible from C code, after it&#39;s compiled to a shared library and linked from C:</span>次の例では、 <code>call_from_c</code>関数を共有ライブラリにコンパイルしてCコードからリンクした後で、Cコードからアクセスできるようにします。</span> </p><br><div data-lang=rust><div data-l=#[no_mangle]></div><div data-l="pub extern &quot;C&quot; fn call_from_c() {"></div><div data-l="    println!(&quot;Just called a Rust function from C!&quot;);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This usage of <code>extern</code> does not require <code>unsafe</code> .</span> <code>extern</code>この使用法は<code>unsafe</code>ないことを要求しませ<code>unsafe</code> 。</span> </p></blockquote><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Accessing or Modifying a Mutable Static Variable</span>可変静的変数へのアクセスまたは変更</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Until now, we&#39;ve not talked about <i>global variables</i> , which Rust does support but can be problematic with Rust&#39;s ownership rules.</span>今まで、Rustはサポートしていますが、Rustのオーナーシップルールでは問題になる可能性がある<i>グローバル変数</i>については説明していません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If two threads are accessing the same mutable global variable, it can cause a data race.</span> 2つのスレッドが同じ可変グローバル変数にアクセスしている場合、データ競合が発生する可能性があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In Rust, global variables are called <i>static</i> variables.</span> Rustでは、グローバル変数は<i>静的</i>変数と呼ばれます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 19-9 shows an example declaration and use of a static variable with a string slice as a value.</span>リスト19-9は、文字列sliceを値として持つ静的変数の宣言と使用例を示しています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="static HELLO_WORLD: &amp;str = &quot;Hello, world!&quot;;"></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    println!(&quot;name is: {}&quot;, HELLO_WORLD);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 19-9: Defining and using an immutable static variable</span></span> <span class=caption>リスト19-9：不変の静的変数の定義と使用</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Static variables are similar to constants, which we discussed in the “Differences Between Variables and Constants” section in Chapter 3. The names of static variables are in <code>SCREAMING_SNAKE_CASE</code> by convention, and we <i>must</i> annotate the variable&#39;s type, which is <code>&amp;&#39;static str</code> in this example.</span>静的変数は定数と似ています。これについては第3章の「変数と定数の違い」で説明しました。静的変数の名前は慣習的に<code>SCREAMING_SNAKE_CASE</code>に<i>あり</i> 、変数の型に注釈を付ける<i>必要があり</i> <code>&amp;&#39;static str</code> 。この例。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Static variables can only store references with the <code>&#39;static</code> lifetime, which means the Rust compiler can figure out the lifetime;</span>静的変数は<code>&#39;static</code>寿命を持つ参照のみを格納できます。これは、Rustコンパイラが寿命を把握できることを意味します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">we don&#39;t need to annotate it explicitly.</span>明示的に注釈を付ける必要はありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Accessing an immutable static variable is safe.</span>不変の静的変数へのアクセスは安全です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Constants and immutable static variables might seem similar, but a subtle difference is that values in a static variable have a fixed address in memory.</span>定数と不変の静的変数は同じように見えるかもしれませんが、微妙な違いは静的な変数の値がメモリ内の固定アドレスを持つことです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Using the value will always access the same data.</span>値を使用すると常に同じデータにアクセスします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Constants, on the other hand, are allowed to duplicate their data whenever they&#39;re used.</span>一方、定数は使用されるたびにデータを複製することができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Another difference between constants and static variables is that static variables can be mutable.</span>定数と静的変数の別の違いは、静的変数が変更可能であることです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Accessing and modifying mutable static variables is <i>unsafe</i> .</span>可変静的変数へのアクセスと変更は<i>安全で</i>はあり<i>ません</i> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 19-10 shows how to declare, access, and modify a mutable static variable named <code>COUNTER</code> .</span>リスト19-10は、 <code>COUNTER</code>という可変静的変数を宣言、アクセス、および変更する方法を示しています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="static mut COUNTER: u32 = 0;"></div><div data-l=""></div><div data-l="fn add_to_count(inc: u32) {"></div><div data-l="    unsafe {"></div><div data-l="        COUNTER += inc;"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    add_to_count(3);"></div><div data-l=""></div><div data-l="    unsafe {"></div><div data-l="        println!(&quot;COUNTER: {}&quot;, COUNTER);"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 19-10: Reading from or writing to a mutable static variable is unsafe</span></span> <span class=caption>リスト19-10：可変静的変数からの読み書きは安全ではありません</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As with regular variables, we specify mutability using the <code>mut</code> keyword.</span>通常の変数と同様に、 <code>mut</code>キーワードを使用してmutabilityを指定します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Any code that reads or writes from <code>COUNTER</code> must be within an <code>unsafe</code> block.</span> <code>COUNTER</code>から読み取りまたは書き込みを行うコードは、 <code>unsafe</code>ブロック内になければなりません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This code compiles and prints <code>COUNTER: 3</code> as we would expect because it&#39;s single threaded.</span>このコードは、シングルスレッドであるため、 <code>COUNTER: 3</code>をコンパイルして出力します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Having multiple threads access <code>COUNTER</code> would likely result in data races.</span>複数のスレッドが<code>COUNTER</code>アクセスすると、データ競合が発生する可能性があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">With mutable data that is globally accessible, it&#39;s difficult to ensure there are no data races, which is why Rust considers mutable static variables to be unsafe.</span>グローバルにアクセス可能な変更可能なデータでは、データの競合がないことを保証することは難しいため、Rustは変更可能な静的変数を安全でないとみなしています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Where possible, it&#39;s preferable to use the concurrency techniques and thread-safe smart pointers we discussed in Chapter 16 so the compiler checks that data accessed from different threads is done safely.</span>可能であれば、第16章で説明した並行処理手法とスレッドセーフスマートポインタを使用することが望ましいため、コンパイラは、異なるスレッドからアクセスされたデータが安全に実行されることをチェックします。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Implementing an Unsafe Trait</span>安全でない特性の実装</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The final action that works only with <code>unsafe</code> is implementing an unsafe trait.</span> <code>unsafe</code>で<code>unsafe</code>場合にのみ機能する最終的なアクションは、安全でない特性を実装することです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A trait is unsafe when at least one of its methods has some invariant that the compiler can&#39;t verify.</span>少なくとも1つのメソッドにコンパイラが検証できない不変量がある場合、形質は安全ではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can declare that a trait is <code>unsafe</code> by adding the <code>unsafe</code> keyword before <code>trait</code> and marking the implementation of the trait as <code>unsafe</code> too, as shown in Listing 19-11.</span>リスト19-11に示すように、形質の前に<code>unsafe</code>キーワードを追加し、 <code>trait</code>の実装を<code>unsafe</code>ものとしてマークすることで、形質が<code>unsafe</code>ことを宣言することができます。</span> </p><br><div data-lang=rust><div data-l="unsafe trait Foo {"></div><div data-l="#    // methods go here"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">methods go here</span>メソッドはここに行く</span> </div><div data-l=}></div><div data-l=""></div><div data-l="unsafe impl Foo for i32 {"></div><div data-l="#    // method implementations go here"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">method implementations go here</span>メソッド実装はここに</span> </div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 19-11: Defining and implementing an unsafe trait</span></span> <span class=caption>リスト19-11：危険な特性の定義と実装</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">By using <code>unsafe impl</code> , we&#39;re promising that we&#39;ll uphold the invariants that the compiler can&#39;t verify.</span> <code>unsafe impl</code>を使用することで、コンパイラが検証できないインバリアントを維持することを約束しています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As an example, recall the <code>Sync</code> and <code>Send</code> marker traits we discussed in the “Extensible Concurrency with the <code>Sync</code> and <code>Send</code> Traits” section in Chapter 16: the compiler implements these traits automatically if our types are composed entirely of <code>Send</code> and <code>Sync</code> types.</span>たとえば、第16章の「 <code>Sync</code>と<code>Send</code>特性による拡張可能な並行性」のセクションで説明した<code>Sync</code>と<code>Send</code>マーカーの特性を思い出して<code>Send</code>これらの特性は、すべてのタイプが<code>Send</code>型と<code>Sync</code>型で構成されていれば自動的に実装されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we implement a type that contains a type that is not <code>Send</code> or <code>Sync</code> , such as raw pointers, and we want to mark that type as <code>Send</code> or <code>Sync</code> , we must use <code>unsafe</code> .</span>未処理のポインタなど、 <code>Send</code>または<code>Sync</code>ではないタイプを実装している場合、そのタイプを<code>Send</code>または<code>Sync</code>としてマークするには、 <code>unsafe</code>ないものを使用する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust can&#39;t verify that our type upholds the guarantees that it can be safely sent across threads or accessed from multiple threads;</span> Rustは、私たちのタイプがスレッド間で安全に送信されたり、複数のスレッドからアクセスされたりする保証があることを検証することはできません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">therefore, we need to do those checks manually and indicate as such with <code>unsafe</code> .</span>したがって、これらのチェックを手動で行い、 <code>unsafe</code>で<code>unsafe</code>として指示する必要があります。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When to Use Unsafe Code</span>安全でないコードを使用する場合</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Using <code>unsafe</code> to take one of the four actions (superpowers) just discussed isn&#39;t wrong or even frowned upon.</span>今話題にされた4つの行動（超大国）のうちの1つを取るために<code>unsafe</code>を使用することは、間違っていないか、あるいは悩まされることさえありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But it is trickier to get <code>unsafe</code> code correct because the compiler can&#39;t help uphold memory safety.</span>しかし、コンパイラがメモリの安全性を支えることができないため、 <code>unsafe</code>コードを正しいものにするのは難しいです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When you have a reason to use <code>unsafe</code> code, you can do so, and having the explicit <code>unsafe</code> annotation makes it easier to track down the source of problems if they occur.</span> <code>unsafe</code>コードを使用する理由がある場合は、そうすることができます。明示的で<code>unsafe</code>注釈があれば、問題が発生した場合に問題の原因を追跡するのが簡単になります。</span> </p><script>_addload(function(){_setupIW('com');_csi('en','ja','ch19-01-unsafe-rust.html');});</script>