<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180709_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=ch08-03-hash-maps.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Storing Keys with Associated Values in Hash Maps</span>関連付けられた値を持つキーをハッシュマップに格納する</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The last of our common collections is the <i>hash map</i> .</span>最後の一般的なコレクションは<i>ハッシュマップ</i>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The type <code>HashMap&lt;K, V&gt;</code> stores a mapping of keys of type <code>K</code> to values of type <code>V</code> .</span>タイプ<code>HashMap&lt;K, V&gt;</code>型のキーのマッピングを格納する<code>K</code>型の値に<code>V</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It does this via a <i>hashing function</i> , which determines how it places these keys and values into memory.</span>これは、これらのキーと値をどのようにメモリに格納するかを決定する<i>ハッシュ関数</i>を介して行います。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Many programming languages support this kind of data structure, but they often use a different name, such as hash, map, object, hash table, or associative array, just to name a few.</span>多くのプログラミング言語はこの種のデータ構造をサポートしていますが、ハッシュ、マップ、オブジェクト、ハッシュテーブル、または連想配列などの異なる名前を使用することがよくあります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Hash maps are useful when you want to look up data not by using an index, as you can with vectors, but by using a key that can be of any type.</span>ハッシュマップは、ベクトルを使用する場合と同じように、インデックスを使用せずに任意のタイプのキーを使用してデータをルックアップする場合に便利です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, in a game, you could keep track of each team&#39;s score in a hash map in which each key is a team&#39;s name and the values are each team&#39;s score.</span>たとえば、ゲームでは、各キーがチームの名前で値が各チームのスコアであるハッシュマップで各チームのスコアを追跡できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Given a team name, you can retrieve its score.</span>チーム名を指定するとスコアを取得できます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll go over the basic API of hash maps in this section, but many more goodies are hiding in the functions defined on <code>HashMap&lt;K, V&gt;</code> by the standard library.</span>このセクションでは、ハッシュマップの基本APIについて説明しますが、標準ライブラリでは<code>HashMap&lt;K, V&gt;</code>定義されている関数にはさらに多くの機能が隠されています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As always, check the standard library documentation for more information.</span>詳細は、標準ライブラリのマニュアルを参照してください。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Creating a New Hash Map</span>新しいハッシュマップの作成</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can create an empty hash map with <code>new</code> and add elements with <code>insert</code> .</span> <code>new</code>を使って空のハッシュマップを作成し、 <code>insert</code>要素を追加することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In Listing 8-20, we&#39;re keeping track of the scores of two teams whose names are Blue and Yellow.</span>リスト8-20では、名前がBlueとYellowの2つのチームの得点を記録しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The Blue team starts with 10 points, and the Yellow team starts with 50.</span>ブルーチームは10ポイントでスタートし、イエローチームは50ポイントでスタートします。</span> </p><br><div data-lang=rust><div data-l="use std::collections::HashMap;"></div><div data-l=""></div><div data-l="let mut scores = HashMap::new();"></div><div data-l=""></div><div data-l="scores.insert(String::from(&quot;Blue&quot;), 10);"></div><div data-l="scores.insert(String::from(&quot;Yellow&quot;), 50);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 8-20: Creating a new hash map and inserting some keys and values</span></span> <span class=caption>リスト8-20：新しいハッシュマップを作成し、いくつかのキーと値を挿入する</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that we need to first <code>use</code> the <code>HashMap</code> from the collections portion of the standard library.</span>最初に、標準ライブラリのコレクション部分から<code>HashMap</code>を<code>use</code>する必要があることに注意してください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Of our three common collections, this one is the least often used, so it&#39;s not included in the features brought into scope automatically in the prelude.</span> 3つの一般的なコレクションのうち、これは最も頻繁に使用されるものではないため、プレリュードに自動的に適用される機能には含まれていません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Hash maps also have less support from the standard library;</span>ハッシュマップは、標準ライブラリからのサポートも少なくなっています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">there&#39;s no built-in macro to construct them, for example.</span>例えば、それらを構築するための組み込みマクロはありません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Just like vectors, hash maps store their data on the heap.</span>ベクトルと同様に、ハッシュマップはヒープ上にデータを格納します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This <code>HashMap</code> has keys of type <code>String</code> and values of type <code>i32</code> .</span>この<code>HashMap</code>は、型<code>String</code>キーと型<code>i32</code>値があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Like vectors, hash maps are homogeneous: all of the keys must have the same type, and all of the values must have the same type.</span>ベクトルと同様に、ハッシュマップは同種である：すべてのキーは同じタイプでなければならず、すべての値は同じタイプでなければならない。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Another way of constructing a hash map is by using the <code>collect</code> method on a vector of tuples, where each tuple consists of a key and its value.</span>ハッシュマップを構築するもう1つの方法は、タプルのベクトル上で<code>collect</code>メソッドを使用することです。ここで、各タプルはキーとその値で構成されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>collect</code> method gathers data into a number of collection types, including <code>HashMap</code> .</span> <code>collect</code>メソッドは、 <code>HashMap</code>を含む多くのコレクションタイプにデータを収集します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, if we had the team names and initial scores in two separate vectors, we could use the <code>zip</code> method to create a vector of tuples where “Blue” is paired with 10, and so forth.</span>たとえば、チーム名と初期スコアが2つの別々のベクトルにある場合、 <code>zip</code>メソッドを使用して、 &quot;Blue&quot;が10とペアになっているタプルのベクトルを作成することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then we could use the <code>collect</code> method to turn that vector of tuples into a hash map, as shown in Listing 8-21.</span>リスト8-21に示すように、 <code>collect</code>メソッドを使用してタプルのベクトルをハッシュマップに<code>collect</code>ことができます。</span> </p><br><div data-lang=rust><div data-l="use std::collections::HashMap;"></div><div data-l=""></div><div data-l="let teams  = vec![String::from(&quot;Blue&quot;), String::from(&quot;Yellow&quot;)];"></div><div data-l="let initial_scores = vec![10, 50];"></div><div data-l=""></div><div data-l="let scores: HashMap&lt;_, _&gt; = teams.iter().zip(initial_scores.iter()).collect();"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 8-21: Creating a hash map from a list of teams and a list of scores</span></span> <span class=caption>リスト8-21：チームのリストと得点のリストからハッシュマップを作成する</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The type annotation <code>HashMap&lt;_, _&gt;</code> is needed here because it&#39;s possible to <code>collect</code> into many different data structures and Rust doesn&#39;t know which you want unless you specify.</span> <code>HashMap&lt;_, _&gt;</code>型の注釈はここで必要です。なぜなら、指定しない限り、多くの異なるデータ構造に<code>collect</code>ことが可能であり、Rustは必要なものを知りません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For the parameters for the key and value types, however, we use underscores, and Rust can infer the types that the hash map contains based on the types of the data in the vectors.</span>ただし、キーと値の型のパラメータでは、アンダースコアを使用し、ハッシュマップに含まれるデータの型に基づいて型を推測できます。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Hash Maps and Ownership</span>ハッシュマップと所有権</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For types that implement the <code>Copy</code> trait, like <code>i32</code> , the values are copied into the hash map.</span> <code>i32</code>ように、 <code>Copy</code>特性を実装するタイプの場合、値はハッシュマップにコピーされます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For owned values like <code>String</code> , the values will be moved and the hash map will be the owner of those values, as demonstrated in Listing 8-22.</span>リスト8-22に示すように、 <code>String</code>ような所有値の場合、値は移動され、ハッシュマップはそれらの値の所有者になります。</span> </p><br><div data-lang=rust><div data-l="use std::collections::HashMap;"></div><div data-l=""></div><div data-l="let field_name = String::from(&quot;Favorite color&quot;);"></div><div data-l="let field_value = String::from(&quot;Blue&quot;);"></div><div data-l=""></div><div data-l="let mut map = HashMap::new();"></div><div data-l="map.insert(field_name, field_value);"></div><div data-l="#// field_name and field_value are invalid at this point, try using them and"></div><div data-l="#// see what compiler error you get!"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">field_name and field_value are invalid at this point, try using them and see what compiler error you get!</span> field_nameとfield_valueはこの時点で無効です。それらを使用してみて、どのコンパイラエラーが発生しているのかを確認してください！</span> </div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 8-22: Showing that keys and values are owned by the hash map once they&#39;re inserted</span></span> <span class=caption>リスト8-22：挿入されたハッシュマップが所有するキーと値の表示</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We aren&#39;t able to use the variables <code>field_name</code> and <code>field_value</code> after they&#39;ve been moved into the hash map with the call to <code>insert</code> .</span> <code>insert</code>の呼び出しでハッシュマップに移動された後、変数<code>field_name</code>と<code>field_value</code>を使用することはできません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we insert references to values into the hash map, the values won&#39;t be moved into the hash map.</span>値への参照をハッシュマップに挿入すると、値はハッシュマップに移動されません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The values that the references point to must be valid for at least as long as the hash map is valid.</span>参照が指す値は、少なくともハッシュマップが有効である限り有効でなければなりません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll talk more about these issues in the “Validating References with Lifetimes” section in Chapter 10.</span>これらの問題については、第10章の「ライフタイムを使用した参照の検証」のセクションで詳しく説明します。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Accessing Values in a Hash Map</span>ハッシュマップの値へのアクセス</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can get a value out of the hash map by providing its key to the <code>get</code> method, as shown in Listing 8-23.</span>リスト8-23に示すように、キーを<code>get</code>メソッドに渡すことで、ハッシュマップから値を取得できます。</span> </p><br><div data-lang=rust><div data-l="use std::collections::HashMap;"></div><div data-l=""></div><div data-l="let mut scores = HashMap::new();"></div><div data-l=""></div><div data-l="scores.insert(String::from(&quot;Blue&quot;), 10);"></div><div data-l="scores.insert(String::from(&quot;Yellow&quot;), 50);"></div><div data-l=""></div><div data-l="let team_name = String::from(&quot;Blue&quot;);"></div><div data-l="let score = scores.get(&amp;team_name);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 8-23: Accessing the score for the Blue team stored in the hash map</span></span> <span class=caption>リスト8-23：ハッシュマップに格納されているBlueチームのスコアにアクセスする</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here, <code>score</code> will have the value that&#39;s associated with the Blue team, and the result will be <code>Some(&amp;10)</code> .</span> <code>score</code>は青チームに関連付けられた値があり、結果は<code>Some(&amp;10)</code>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The result is wrapped in <code>Some</code> because <code>get</code> returns an <code>Option&lt;&amp;V&gt;</code> ;</span> <code>get</code>は<code>Option&lt;&amp;V&gt;</code>返すので、結果は<code>Some</code>でラップされます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">if there&#39;s no value for that key in the hash map, <code>get</code> will return <code>None</code> .</span>そのキーの値がハッシュマップにない場合、 <code>get</code>は<code>None</code>を返します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The program will need to handle the <code>Option</code> in one of the ways that we covered in Chapter 6.</span>プログラムは、第6章で取り上げた方法の1つで、 <code>Option</code>を処理する必要があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can iterate over each key/value pair in a hash map in a similar manner as we do with vectors, using a <code>for</code> loop:</span> <code>for</code>ループを使用して、ベクトルと同様の方法で、ハッシュマップ内の各キーと値のペアを繰り返し処理できます。</span> </p><br><div data-lang=rust><div data-l="use std::collections::HashMap;"></div><div data-l=""></div><div data-l="let mut scores = HashMap::new();"></div><div data-l=""></div><div data-l="scores.insert(String::from(&quot;Blue&quot;), 10);"></div><div data-l="scores.insert(String::from(&quot;Yellow&quot;), 50);"></div><div data-l=""></div><div data-l="for (key, value) in &amp;scores {"></div><div data-l="    println!(&quot;{}: {}&quot;, key, value);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This code will print each pair in an arbitrary order:</span>このコードは各ペアを任意の順序で出力します：</span> </p><br><div data-lang=text><div data-l="Yellow: 50"></div><div data-l="Blue: 10"></div></div><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Updating a Hash Map</span>ハッシュマップの更新</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Although the number of keys and values is growable, each key can only have one value associated with it at a time.</span>キーと値の数は増えますが、各キーは一度に1つの値しか関連付けられません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When you want to change the data in a hash map, you have to decide how to handle the case when a key already has a value assigned.</span>ハッシュマップ内のデータを変更する場合は、キーにすでに値が割り当てられている場合の処理​​方法を決定する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You could replace the old value with the new value, completely disregarding the old value.</span>古い値を新しい値に置き換えて、古い値を完全に無視することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You could keep the old value and ignore the new value, only adding the new value if the key <i>doesn&#39;t</i> already have a value.</span>古い値を保持して新しい値を無視し、キーにまだ値<i>がない</i>場合は新しい値を追加するだけです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Or you could combine the old value and the new value.</span>または、古い値と新しい値を組み合わせることもできます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s look at how to do each of these!</span>これらのそれぞれを行う方法を見てみましょう！</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Overwriting a Value</span>値を上書きする</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we insert a key and a value into a hash map and then insert that same key with a different value, the value associated with that key will be replaced.</span>ハッシュマップにキーと値を挿入し、同じキーに別の値を挿入すると、そのキーに関連付けられた値が置き換えられます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Even though the code in Listing 8-24 calls <code>insert</code> twice, the hash map will only contain one key/value pair because we&#39;re inserting the value for the Blue team&#39;s key both times.</span>リスト8-24のコードで<code>insert</code> 2回呼び出すとしても、Blueチームのキーの値を両方とも挿入するため、ハッシュマップには1つのキーと値のペアしか含まれません。</span> </p><br><div data-lang=rust><div data-l="use std::collections::HashMap;"></div><div data-l=""></div><div data-l="let mut scores = HashMap::new();"></div><div data-l=""></div><div data-l="scores.insert(String::from(&quot;Blue&quot;), 10);"></div><div data-l="scores.insert(String::from(&quot;Blue&quot;), 25);"></div><div data-l=""></div><div data-l="println!(&quot;{:?}&quot;, scores);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 8-24: Replacing a value stored with a particular key</span></span> <span class=caption>リスト8-24：特定のキーに格納されている値を置き換える</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This code will print <code>{&quot;Blue&quot;: 25}</code> .</span>このコードは<code>{&quot;Blue&quot;: 25}</code>を印刷します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The original value of <code>10</code> has been overwritten.</span>元の<code>10</code>値は上書きされています。</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Only Inserting a Value If the Key Has No Value</span>キーに値がない場合にのみ値を挿入する</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It&#39;s common to check whether a particular key has a value and, if it doesn&#39;t, insert a value for it.</span>特定のキーに値があるかどうかをチェックし、キーに値がない場合は値を挿入するのが一般的です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Hash maps have a special API for this called <code>entry</code> that takes the key you want to check as a parameter.</span>ハッシュマップには、パラメータとしてチェックしたいキーを取得する、この呼び出された<code>entry</code>用の特別なAPIがあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The return value of the <code>entry</code> method is an enum called <code>Entry</code> that represents a value that might or might not exist.</span> <code>entry</code>メソッドの戻り値は、 <code>Entry</code>と呼ばれる列挙型で、存在する場合と存在しない場合がある値を表します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s say we want to check whether the key for the Yellow team has a value associated with it.</span> Yellowチームのキーに関連する値があるかどうかを確認したいとします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If it doesn&#39;t, we want to insert the value 50, and the same for the Blue team.</span>そうでない場合は、値50を挿入し、Blueチームに同じ値を挿入します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Using the <code>entry</code> API, the code looks like Listing 8-25.</span> <code>entry</code> APIを使用すると、コードはリスト8-25のようになります。</span> </p><br><div data-lang=rust><div data-l="use std::collections::HashMap;"></div><div data-l=""></div><div data-l="let mut scores = HashMap::new();"></div><div data-l="scores.insert(String::from(&quot;Blue&quot;), 10);"></div><div data-l=""></div><div data-l=scores.entry(String::from(&quot;Yellow&quot;)).or_insert(50);></div><div data-l=scores.entry(String::from(&quot;Blue&quot;)).or_insert(50);></div><div data-l=""></div><div data-l="println!(&quot;{:?}&quot;, scores);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 8-25: Using the <code>entry</code> method to only insert if the key does not already have a value</span></span> <span class=caption>リスト8-25： <code>entry</code>メソッドを使って、キーにまだ値がない場合のみ挿入する</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>or_insert</code> method on <code>Entry</code> is defined to return a mutable reference to the value for the corresponding <code>Entry</code> key if that key exists, and if not, inserts the parameter as the new value for this key and returns a mutable reference to the new value.</span> <code>Entry</code>の<code>or_insert</code>メソッドは、対応する<code>Entry</code>キーが存在する場合はその値への変更可能な参照を返すように定義され、そうでない場合は、このキーの新しい値としてパラメータを挿入し、新しい値への変更可能な参照を返します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This technique is much cleaner than writing the logic ourselves and, in addition, plays more nicely with the borrow checker.</span>このテクニックは、ロジックを書くよりもはるかにクリーンで、さらに、借用チェッカーでうまくいく。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Running the code in Listing 8-25 will print <code>{&quot;Yellow&quot;: 50, &quot;Blue&quot;: 10}</code> .</span>リスト8-25のコードを実行すると<code>{&quot;Yellow&quot;: 50, &quot;Blue&quot;: 10}</code>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The first call to <code>entry</code> will insert the key for the Yellow team with the value 50 because the Yellow team doesn&#39;t have a value already.</span>黄色のチームには既に価値がないため、 <code>entry</code>の最初の呼び出しでは、値が50のイエローチームのキーが挿入されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The second call to <code>entry</code> will not change the hash map because the Blue team already has the value 10.</span> 2番目のコール<code>entry</code>ブルーチームはすでに値が10を持っているので、ハッシュマップを変更しません。</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Updating a Value Based on the Old Value</span>古い値に基づく値の更新</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Another common use case for hash maps is to look up a key&#39;s value and then update it based on the old value.</span>ハッシュマップの別の一般的な使用例は、キーの値をルックアップし、古い値に基づいてキーの値を更新することです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For instance, Listing 8-26 shows code that counts how many times each word appears in some text.</span>たとえば、リスト8-26は、各単語がテキストに何回出現するかを数えるコードを示しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We use a hash map with the words as keys and increment the value to keep track of how many times we&#39;ve seen that word.</span>単語をキーとしてハッシュマップを使用し、その単語を何回見たかを追跡するために値を増やします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If it&#39;s the first time we&#39;ve seen a word, we&#39;ll first insert the value 0.</span>単語を見たのが初めての場合は、最初に値0を挿入します。</span> </p><br><div data-lang=rust><div data-l="use std::collections::HashMap;"></div><div data-l=""></div><div data-l="let text = &quot;hello world wonderful world&quot;;"></div><div data-l=""></div><div data-l="let mut map = HashMap::new();"></div><div data-l=""></div><div data-l="for word in text.split_whitespace() {"></div><div data-l="    let count = map.entry(word).or_insert(0);"></div><div data-l="    *count += 1;"></div><div data-l=}></div><div data-l=""></div><div data-l="println!(&quot;{:?}&quot;, map);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 8-26: Counting occurrences of words using a hash map that stores words and counts</span></span> <span class=caption>リスト8-26：単語とカウントを格納するハッシュマップを使って単語の出現を数える</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This code will print <code>{&quot;world&quot;: 2, &quot;hello&quot;: 1, &quot;wonderful&quot;: 1}</code> .</span>このコードは<code>{&quot;world&quot;: 2, &quot;hello&quot;: 1, &quot;wonderful&quot;: 1}</code>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>or_insert</code> method actually returns a mutable reference ( <code>&amp;mut V</code> ) to the value for this key.</span> <code>or_insert</code>メソッドは実際にこのキーの値に変更可能な参照（ <code>&amp;mut V</code> ）を返します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here we store that mutable reference in the <code>count</code> variable, so in order to assign to that value, we must first dereference <code>count</code> using the asterisk ( <code>*</code> ).</span>ここでは、その中に変更可能な参照保存<code>count</code>その値に割り当てるために、我々は最初の間接参照しなければならないので、変数を<code>count</code>アスタリスク（使用して<code>*</code> ）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The mutable reference goes out of scope at the end of the <code>for</code> loop, so all of these changes are safe and allowed by the borrowing rules.</span>変更可能な参照は<code>for</code>ループの終了時に範囲外になるので、これらの変更はすべて安全であり、借用ルールによって許可されます。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Hashing Functions</span>ハッシュ関数</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">By default, <code>HashMap</code> uses a cryptographically secure hashing function that can provide resistance to Denial of Service (DoS) attacks.</span>デフォルトでは、 <code>HashMap</code>はサービス拒否（DoS）攻撃に抵抗することができる暗号的に安全なハッシュ関数を使用します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is not the fastest hashing algorithm available, but the trade-off for better security that comes with the drop in performance is worth it.</span>利用可能な最速のハッシングアルゴリズムではありませんが、パフォーマンスの低下に伴うより良いセキュリティのトレードオフが価値があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you profile your code and find that the default hash function is too slow for your purposes, you can switch to another function by specifying a different <i>hasher</i> .</span>コードを<i>プロファイリング</i>し、デフォルトのハッシュ関数が目的に応じて遅すぎると<i>わかっ</i>た場合は、別の<i>ハッシャを</i>指定して別の関数に切り替えることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A hasher is a type that implements the <code>BuildHasher</code> trait.</span>ハッシャーは、 <code>BuildHasher</code>特性を実装する型です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll talk about traits and how to implement them in Chapter 10. You don&#39;t necessarily have to implement your own hasher from scratch;</span>第10章では、特性とその実装方法について説明します。必ずしも独自のハッシャーをゼロから実装する必要はありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a class=notranslate href=#2https://crates.io>crates.io</a> has libraries shared by other Rust users that provide hashers implementing many common hashing algorithms.</span> <a class=notranslate href=#2https://crates.io>crates.io</a>は、多くの一般的なハッシングアルゴリズムを実装しているハッシャーを提供する他のRustユーザーが共有するライブラリがあります。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Summary</span>概要</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Vectors, strings, and hash maps will provide a large amount of functionality necessary in programs when you need to store, access, and modify data.</span>ベクトル、文字列、およびハッシュマップは、データを格納、アクセス、および変更する必要がある場合に、プログラムに必要な大量の機能を提供します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here are some exercises you should now be equipped to solve:</span>ここで解決する必要があるいくつかの演習があります：</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Given a list of integers, use a vector and return the mean (the average value), median (when sorted, the value in the middle position), and mode (the value that occurs most often; a hash map will be helpful here) of the list.</span>整数のリストが与えられたら、ベクトルを使用して平均値（平均値）、中央値（ソート時、中央の値）、およびモード（最も頻繁に発生する値;ハッシュマップはここで役立ちます）リストの</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Convert strings to pig latin.</span>文字列をブタのラテン語に変換します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The first consonant of each word is moved to the end of the word and “ay” is added, so “first” becomes “irst-fay.” Words that start with a vowel have “hay” added to the end instead (“apple” becomes “apple-hay”).</span>各単語の最初の子音が単語の最後に移動し、 &quot;ay&quot;が追加されるので、 &quot;最初&quot;は &quot;irst-fay&quot;になります。母音で始まる単語は、代わりに &quot;乾草&quot; &quot;は&quot;リンゴ - 干し草 &quot;となる）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Keep in mind the details about UTF-8 encoding!</span> UTF-8エンコーディングの詳細を覚えておいてください！</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Using a hash map and vectors, create a text interface to allow a user to add employee names to a department in a company.</span>ハッシュマップとベクトルを使用して、ユーザーが社内の部門に従業員名を追加できるようにするテキストインタフェースを作成します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, “Add Sally to Engineering” or “Add Amir to Sales.” Then let the user retrieve a list of all people in a department or all people in the company by department, sorted alphabetically.</span>たとえば、「Sallyをエンジニアリングに追加する」または「AmirをSalesに追加する」などとします。部門内の全員または部門内の全員のリストをアルファベット順に並べ替えることができます。</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The standard library API documentation describes methods that vectors, strings, and hash maps have that will be helpful for these exercises!</span>標準ライブラリのAPIドキュメントでは、これらの演習に役立つベクトル、文字列、およびハッシュマップのメソッドについて説明しています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;re getting into more complex programs in which operations can fail, so, it&#39;s a perfect time to discuss error handling.</span>操作が失敗するより複雑なプログラムになってきているので、エラー処理について議論するのに最適なタイミングです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll do that next!</span>私たちは次にそれをやります！</span> </p><script>_addload(function(){_setupIW('com');_csi('en','ja','ch08-03-hash-maps.html');});</script>