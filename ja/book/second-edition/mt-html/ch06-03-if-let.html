<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180709_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=ch06-03-if-let.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Concise Control Flow with <code>if let</code></span> <code>if let</code>簡潔な制御フロー</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>if let</code> syntax lets you combine <code>if</code> and <code>let</code> into a less verbose way to handle values that match one pattern while ignoring the rest.</span> <code>if let</code>構文を使用すると、 <code>if</code>と<code>let</code>をあまり控えめに組み合わせ<code>if</code> 、あるパターンに一致する値を処理し、残りのものは無視することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Consider the program in Listing 6-6 that matches on an <code>Option&lt;u8&gt;</code> value but only wants to execute code if the value is 3.</span>リスト6-6のプログラムを<code>Option&lt;u8&gt;</code>値と一致させるが、その値が3の場合にのみコードを実行したいと考えているプログラムを考えてみましょう。</span> </p><br><div data-lang=rust><div data-l="let some_u8_value = Some(0u8);"></div><div data-l="match some_u8_value {"></div><div data-l="    Some(3) =&gt; println!(&quot;three&quot;),"></div><div data-l="    _ =&gt; (),"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 6-6: A <code>match</code> that only cares about executing code when the value is <code>Some(3)</code></span></span> <span class=caption>コードリスト6-6：値が<code>Some(3)</code>ときにのみコードを実行することを気にする<code>match</code></span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We want to do something with the <code>Some(3)</code> match but do nothing with any other <code>Some&lt;u8&gt;</code> value or the <code>None</code> value.</span> <code>Some(3)</code>一致で何かをしたいが、他の<code>Some&lt;u8&gt;</code>値または<code>None</code>値で何もしない。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To satisfy the <code>match</code> expression, we have to add <code>_ =&gt; ()</code> after processing just one variant, which is a lot of boilerplate code to add.</span> <code>match</code>式を満たすために、追加する定型コードの多くである1つのバリアントを処理した後に<code>_ =&gt; ()</code>を追加する必要があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Instead, we could write this in a shorter way using <code>if let</code> .</span>代わりに<code>if let</code>を使ってこれをもっと短時間で書くことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The following code behaves the same as the <code>match</code> in Listing 6-6:</span>次のコードは、リスト6-6の<code>match</code>と同じように動作します。</span> </p><br><div data-lang=rust><div data-l="# let some_u8_value = Some(0u8);"></div><div data-l="if let Some(3) = some_u8_value {"></div><div data-l="    println!(&quot;three&quot;);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The syntax <code>if let</code> takes a pattern and an expression separated by an equal sign.</span>構文<code>if let</code>は、パターンと式を等号で区切って指定します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It works the same way as a <code>match</code> , where the expression is given to the <code>match</code> and the pattern is its first arm.</span>これは同じように動作<code>match</code>式をに与えられ、 <code>match</code>パターンは、その第一のアームです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Using <code>if let</code> means less typing, less indentation, and less boilerplate code.</span> <code>if let</code>を使用すると、入力が少なくなり、インデントが少なくなり、定型化されたコードが少なくなります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, you lose the exhaustive checking that <code>match</code> enforces.</span>ただし、強制的に強制的にチェックを<code>match</code>ことはできません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Choosing between <code>match</code> and <code>if let</code> depends on what you&#39;re doing in your particular situation and whether gaining conciseness is an appropriate trade-off for losing exhaustive checking.</span> <code>match</code>と<code>if let</code>選択は、特定の状況で何をしているのか、簡潔さを得ることが網羅的なチェックを失うための適切なトレードオフであるかによって異なります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In other words, you can think of <code>if let</code> as syntax sugar for a <code>match</code> that runs code when the value matches one pattern and then ignores all other values.</span>言い換えれば、あなたは考えることができます<code>if let</code>するための構文糖として<code>match</code>値が一つのパターンに一致したときにコードを実行して、他のすべての値を無視します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can include an <code>else</code> with an <code>if let</code> .</span>私たちは<code>if let</code>使って<code>else</code>を含めることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The block of code that goes with the <code>else</code> is the same as the block of code that would go with the <code>_</code> case in the <code>match</code> expression that is equivalent to the <code>if let</code> and <code>else</code> .</span>となったコードのブロック<code>else</code>となるだろうコードのブロックと同じである<code>_</code>中の場合<code>match</code>と等価である表現<code>if let</code>と<code>else</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Recall the <code>Coin</code> enum definition in Listing 6-4, where the <code>Quarter</code> variant also held a <code>UsState</code> value.</span>リスト6-4の<code>Coin</code>列挙型の定義を思い出してください。ここでは、 <code>Quarter</code>変種も<code>UsState</code>値を保持して<code>UsState</code>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we wanted to count all non-quarter coins we see while also announcing the state of the quarters, we could do that with a <code>match</code> expression like this:</span>四半期の状態を発表している間に表示された非四半期のコインをすべてカウントしたければ、次のような<code>match</code>式でそれを行うことができます：</span> </p><br><div data-lang=rust><div data-l="# #[derive(Debug)]"></div><div data-l="# enum UsState {"></div><div data-l="#    Alabama,"></div><div data-l="#    Alaska,"></div><div data-l="# }"></div><div data-l=#></div><div data-l="# enum Coin {"></div><div data-l="#    Penny,"></div><div data-l="#    Nickel,"></div><div data-l="#    Dime,"></div><div data-l="#    Quarter(UsState),"></div><div data-l="# }"></div><div data-l="# let coin = Coin::Penny;"></div><div data-l="let mut count = 0;"></div><div data-l="match coin {"></div><div data-l="    Coin::Quarter(state) =&gt; println!(&quot;State quarter from {:?}!&quot;, state),"></div><div data-l="    _ =&gt; count += 1,"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Or we could use an <code>if let</code> and <code>else</code> expression like this:</span>あるいは、 <code>if let</code>と<code>else</code>ような式を以下のように使うことができます：</span> </p><br><div data-lang=rust><div data-l="# #[derive(Debug)]"></div><div data-l="# enum UsState {"></div><div data-l="#    Alabama,"></div><div data-l="#    Alaska,"></div><div data-l="# }"></div><div data-l=#></div><div data-l="# enum Coin {"></div><div data-l="#    Penny,"></div><div data-l="#    Nickel,"></div><div data-l="#    Dime,"></div><div data-l="#    Quarter(UsState),"></div><div data-l="# }"></div><div data-l="# let coin = Coin::Penny;"></div><div data-l="let mut count = 0;"></div><div data-l="if let Coin::Quarter(state) = coin {"></div><div data-l="    println!(&quot;State quarter from {:?}!&quot;, state);"></div><div data-l="} else {"></div><div data-l="    count += 1;"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you have a situation in which your program has logic that is too verbose to express using a <code>match</code> , remember that <code>if let</code> is in your Rust toolbox as well.</span>あなたのプログラムに、 <code>match</code>を使って表現するのが冗長すぎるロジックがある状況がある<code>if let</code>は、 <code>if let</code>もあなたの錆のツールボックスにあることを忘れないでください。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Summary</span>概要</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ve now covered how to use enums to create custom types that can be one of a set of enumerated values.</span>ここでは、enumを使用して列挙値のセットの1つであるカスタムタイプを作成する方法について説明しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ve shown how the standard library&#39;s <code>Option&lt;T&gt;</code> type helps you use the type system to prevent errors.</span>標準ライブラリの<code>Option&lt;T&gt;</code>型がエラーを防ぐために型システムをどのように使うのかを示しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When enum values have data inside them, you can use <code>match</code> or <code>if let</code> to extract and use those values, depending on how many cases you need to handle.</span>列挙型の値にデータが含まれている場合、処理する必要があるケースの数に応じて、 <code>match</code>または<code>if let</code>を使用してこれらの値を抽出して使用できます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Your Rust programs can now express concepts in your domain using structs and enums.</span>あなたのRustプログラムは、構造体と列挙型を使用して、ドメイン内の概念を表現できるようになりました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Creating custom types to use in your API ensures type safety: the compiler will make certain your functions get only values of the type each function expects.</span> APIで使用するカスタム型を作成すると、型の安全性が保証されます。コンパイラは、各関数が期待する型の値のみを取得するようにします。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In order to provide a well-organized API to your users that is straightforward to use and only exposes exactly what your users will need, let&#39;s now turn to Rust&#39;s modules.</span>ユーザーに必要なものだけが公開されるように、使いやすいAPIをユーザーに提供するために、Rustのモジュールに目を向けるようにしましょう。</span> </p><script>_addload(function(){_setupIW('com');_csi('en','ja','ch06-03-if-let.html');});</script>