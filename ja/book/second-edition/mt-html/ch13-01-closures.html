<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180709_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=ch13-01-closures.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Closures: Anonymous Functions that Can Capture Their Environment</span>クロージャ：環境を捕捉できる匿名関数</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust&#39;s closures are anonymous functions you can save in a variable or pass as arguments to other functions.</span> Rustのクロージャは、変数に保存するか、他の関数に引数として渡すことができる無名関数です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can create the closure in one place and then call the closure to evaluate it in a different context.</span> 1つの場所にクロージャを作成してから別のコンテキストでクロージャを評価することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Unlike functions, closures can capture values from the scope in which they&#39;re called.</span>関数とは異なり、クロージャは呼び出されたスコープから値を取得できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll demonstrate how these closure features allow for code reuse and behavior customization.</span>これらのクロージャー機能がコードの再利用と動作のカスタマイズを可能にする方法を示します。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Creating an Abstraction of Behavior with Closures</span>クロージャを使用した動作の抽象化の作成</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s work on an example of a situation in which it&#39;s useful to store a closure to be executed later.</span>後で実行されるクロージャを保存すると便利な状況の例を取り上げてみましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Along the way, we&#39;ll talk about the syntax of closures, type inference, and traits.</span>途中で、クロージャー、型推論、および特性の構文について説明します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Consider this hypothetical situation: we work at a startup that&#39;s making an app to generate custom exercise workout plans.</span>この仮説的な状況を考えてみましょう。私たちはスタートアップ時に、カスタム運動トレーニング計画を作成するアプリを作っています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The backend is written in Rust, and the algorithm that generates the workout plan takes into account many factors, such as the app user&#39;s age, body mass index, exercise preferences, recent workouts, and an intensity number they specify.</span>バックエンドはRustで書かれており、トレーニングプランを生成するアルゴリズムは、アプリユーザーの年齢、体格指数、運動の好み、最近のトレーニング、彼らが指定した強度番号など、多くの要因を考慮しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The actual algorithm used isn&#39;t important in this example;</span>使用される実際のアルゴリズムは、この例では重要ではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">what&#39;s important is that this calculation takes a few seconds.</span>重要なのは、この計算に数秒かかるということです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We want to call this algorithm only when we need to and only call it once so we don&#39;t make the user wait more than necessary.</span>このアルゴリズムを呼び出す必要があるときにのみ呼び出し、一度呼び出すだけで、ユーザーが必要以上に待たされることはありません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll simulate calling this hypothetical algorithm with the function <code>simulated_expensive_calculation</code> shown in Listing 13-1, which will print <code>calculating slowly...</code> , wait for two seconds, and then return whatever number we passed in.</span>リスト13-1に示す関数<code>simulated_expensive_calculation</code>使って、この仮説的なアルゴリズムを呼び出すことをシミュレートします。これは、 <code>calculating slowly...</code> 2秒間待ってから渡した数を返します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="use std::thread;"></div><div data-l="use std::time::Duration;"></div><div data-l=""></div><div data-l="fn simulated_expensive_calculation(intensity: u32) -&gt; u32 {"></div><div data-l="    println!(&quot;calculating slowly...&quot;);"></div><div data-l="    thread::sleep(Duration::from_secs(2));"></div><div data-l="    intensity"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 13-1: A function to stand in for a hypothetical calculation that takes about 2 seconds to run</span></span> <span class=caption>コードリスト13-1：実行に約2秒かかっている仮説計算を待つ関数</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Next is the <code>main</code> function, which contains the parts of the workout app important for this example.</span>次に、 <code>main</code>機能は、この例で重要なトレーニングアプリの部分を含んでいます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This function represents the code that the app will call when a user asks for a workout plan.</span>この関数は、ユーザーがワークアウトプランを要求したときにアプリケーションが呼び出すコードを表します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because the interaction with the app&#39;s frontend isn&#39;t relevant to the use of closures, we&#39;ll hardcode values representing inputs to our program and print the outputs.</span>アプリケーションのフロントエンドとのやりとりはクロージャの使用に関係しないので、プログラムへの入力を表す値をハードコードし、出力を出力します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The required inputs are these:</span>必要な入力は次のとおりです。</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">An intensity number from the user, which is specified when they request a workout to indicate whether they want a low-intensity workout or a high-intensity workout</span>ユーザーからの強度番号。低強度のトレーニングや高強度のトレーニングを希望するかどうかを示すためにトレーニングをリクエストしたときに指定されます。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A random number that will generate some variety in the workout plans</span>運動計画に多種多様な乱数を生成する</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The output will be the recommended workout plan.</span>出力は、推奨されるワークアウト計画になります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 13-2 shows the <code>main</code> function we&#39;ll use.</span>コードリスト13-2は、使用する<code>main</code>機能を示しています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="fn main() {"></div><div data-l="    let simulated_user_specified_value = 10;"></div><div data-l="    let simulated_random_number = 7;"></div><div data-l=""></div><div data-l="    generate_workout("></div><div data-l="        simulated_user_specified_value,"></div><div data-l="        simulated_random_number"></div><div data-l="    );"></div><div data-l=}></div><div data-l="# fn generate_workout(intensity: u32, random_number: u32) {}"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 13-2: A <code>main</code> function with hardcoded values to simulate user input and random number generation</span></span> <span class=caption>リスト13-2：ユーザ入力と乱数生成をシミュレートするハードコードされた値を持つ<code>main</code>関数</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ve hardcoded the variable <code>simulated_user_specified_value</code> as 10 and the variable <code>simulated_random_number</code> as 7 for simplicity&#39;s sake;</span>わかりやすくするために、変数<code>simulated_user_specified_value</code>を10、変数<code>simulated_random_number</code>を7にハードコーディングしました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">in an actual program, we&#39;d get the intensity number from the app frontend, and we&#39;d use the <code>rand</code> crate to generate a random number, as we did in the Guessing Game example in Chapter 2. The <code>main</code> function calls a <code>generate_workout</code> function with the simulated input values.</span>実際のプログラムでは、我々は、アプリのフロントエンドからの強度番号を取得したい、と私たちは、使用したい<code>rand</code>我々は、第2章で推測ゲームの例で行ったように、乱数を生成するためのクレートを<code>main</code>関数呼び出し<code>generate_workout</code>機能をシミュレートされた入力値と比較します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now that we have the context, let&#39;s get to the algorithm.</span>コンテキストがあるので、アルゴリズムに着きましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The function <code>generate_workout</code> in Listing 13-3 contains the business logic of the app that we&#39;re most concerned with in this example.</span>リスト13-3の関数<code>generate_workout</code>には、この例で最も関心のあるアプリケーションのビジネスロジックが含まれています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The rest of the code changes in this example will be made to this function.</span>この例のコード変更の残りの部分がこの関数に適用されます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="# use std::thread;"></div><div data-l="# use std::time::Duration;"></div><div data-l=#></div><div data-l="# fn simulated_expensive_calculation(num: u32) -&gt; u32 {"></div><div data-l="#     println!(&quot;calculating slowly...&quot;);"></div><div data-l="#     thread::sleep(Duration::from_secs(2));"></div><div data-l="#     num"></div><div data-l="# }"></div><div data-l=#></div><div data-l="fn generate_workout(intensity: u32, random_number: u32) {"></div><div data-l="    if intensity &lt; 25 {"></div><div data-l="        println!("></div><div data-l="            &quot;Today, do {} pushups!&quot;,"></div><div data-l="            simulated_expensive_calculation(intensity)"></div><div data-l="        );"></div><div data-l="        println!("></div><div data-l="            &quot;Next, do {} situps!&quot;,"></div><div data-l="            simulated_expensive_calculation(intensity)"></div><div data-l="        );"></div><div data-l="    } else {"></div><div data-l="        if random_number == 3 {"></div><div data-l="            println!(&quot;Take a break today! Remember to stay hydrated!&quot;);"></div><div data-l="        } else {"></div><div data-l="            println!("></div><div data-l="                &quot;Today, run for {} minutes!&quot;,"></div><div data-l="                simulated_expensive_calculation(intensity)"></div><div data-l="            );"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 13-3: The business logic that prints the workout plans based on the inputs and calls to the <code>simulated_expensive_calculation</code> function</span></span> <span class=caption>リスト13-3： <code>simulated_expensive_calculation</code>関数への入力と呼び出しに基づいてワークアウトプランを出力するビジネスロジック</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The code in Listing 13-3 has multiple calls to the slow calculation function.</span>コードリスト13-3のコードでは、低速計算機能が複数呼び出されています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The first <code>if</code> block calls <code>simulated_expensive_calculation</code> twice, the <code>if</code> inside the outer <code>else</code> doesn&#39;t call it at all, and the code inside the second <code>else</code> case calls it once.</span>最初の<code>if</code>ブロックの呼び出しは<code>simulated_expensive_calculation</code>二回、 <code>if</code>外側内側の<code>else</code>全くそれを呼び出すことはありません、第二の内部コード<code>else</code>場合は、一度それを呼び出します。</span> </p><br><p><!-- NEXT PARAGRAPH WRAPPED WEIRD INTENTIONALLY SEE #199 --></p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The desired behavior of the <code>generate_workout</code> function is to first check whether the user wants a low-intensity workout (indicated by a number less than 25) or a high-intensity workout (a number of 25 or greater).</span> <code>generate_workout</code>関数の望ましい挙動は、ユーザが低強度トレーニング（25未満の数字で示される）または高強度トレーニング（25以上の数）を望むかどうかを最初に確認することである。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Low-intensity workout plans will recommend a number of push-ups and sit-ups based on the complex algorithm we&#39;re simulating.</span>低強度トレーニング計画では、私たちがシミュレーションしている複雑なアルゴリズムに基づいて、いくつかのプッシュアップと腹筋を推奨します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If the user wants a high-intensity workout, there&#39;s some additional logic: if the value of the random number generated by the app happens to be 3, the app will recommend a break and hydration.</span>ユーザーが高輝度のトレーニングをしたい場合は、追加のロジックがあります。アプリによって生成された乱数の値が3になると、アプリは休憩と水分をおすすめします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If not, the user will get a number of minutes of running based on the complex algorithm.</span>そうでない場合、ユーザーは複雑なアルゴリズムに基づいて実行するまでに数分かかるでしょう。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This code works the way the business wants it to now, but let&#39;s say the data science team decides that we need to make some changes to the way we call the <code>simulated_expensive_calculation</code> function in the future.</span>このコードは今のところビジネスが望んでいるように機能しますが、データサイエンスチームは、将来<code>simulated_expensive_calculation</code>関数を呼び出す方法をいくつか変更する必要があると判断したとしましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To simplify the update when those changes happen, we want to refactor this code so it calls the <code>simulated_expensive_calculation</code> function only once.</span>これらの変更が発生したときに更新を簡素化するため、このコードをリファクタリングして、 <code>simulated_expensive_calculation</code>関数を1回だけ呼び出すようにします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We also want to cut the place where we&#39;re currently unnecessarily calling the function twice without adding any other calls to that function in the process.</span>また、現在、不必要に関数を2回呼び出す場所を、その関数の他の呼び出しをプロセスに追加することなく切り詰める必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That is, we don&#39;t want to call it if the result isn&#39;t needed, and we still want to call it only once.</span>つまり、結果が必要でない場合は呼びたくないのですが、それを一度だけ呼びたいと思っています。</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Refactoring Using Functions</span>関数を使用したリファクタリング</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We could restructure the workout program in many ways.</span>私たちは様々な方法でワークアウトプログラムを再構成することができました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">First, we&#39;ll try extracting the duplicated call to the <code>simulated_expensive_calculation</code> function into a variable, as shown in Listing 13-4.</span>まず、 <code>simulated_expensive_calculation</code>関数の重複呼び出しを変数に抽出してみましょう（リスト13-4を参照）。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="# use std::thread;"></div><div data-l="# use std::time::Duration;"></div><div data-l=#></div><div data-l="# fn simulated_expensive_calculation(num: u32) -&gt; u32 {"></div><div data-l="#     println!(&quot;calculating slowly...&quot;);"></div><div data-l="#     thread::sleep(Duration::from_secs(2));"></div><div data-l="#     num"></div><div data-l="# }"></div><div data-l=#></div><div data-l="fn generate_workout(intensity: u32, random_number: u32) {"></div><div data-l="    let expensive_result ="></div><div data-l="        simulated_expensive_calculation(intensity);"></div><div data-l=""></div><div data-l="    if intensity &lt; 25 {"></div><div data-l="        println!("></div><div data-l="            &quot;Today, do {} pushups!&quot;,"></div><div data-l="            expensive_result"></div><div data-l="        );"></div><div data-l="        println!("></div><div data-l="            &quot;Next, do {} situps!&quot;,"></div><div data-l="            expensive_result"></div><div data-l="        );"></div><div data-l="    } else {"></div><div data-l="        if random_number == 3 {"></div><div data-l="            println!(&quot;Take a break today! Remember to stay hydrated!&quot;);"></div><div data-l="        } else {"></div><div data-l="            println!("></div><div data-l="                &quot;Today, run for {} minutes!&quot;,"></div><div data-l="                expensive_result"></div><div data-l="            );"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 13-4: Extracting the calls to <code>simulated_expensive_calculation</code> to one place and storing the result in the <code>expensive_result</code> variable</span></span> <span class=caption>コードリスト13-4： <code>simulated_expensive_calculation</code>への呼び出しを1つの場所に抽出し、その結果を<code>expensive_result</code>変数に格納する</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This change unifies all the calls to <code>simulated_expensive_calculation</code> and solves the problem of the first <code>if</code> block unnecessarily calling the function twice.</span>この変更により、 <code>simulated_expensive_calculation</code>へのすべての呼び出しが統一され、最初の<code>if</code>ブロックが不必要に関数を2回呼び出すという問題が解決されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Unfortunately, we&#39;re now calling this function and waiting for the result in all cases, which includes the inner <code>if</code> block that doesn&#39;t use the result value at all.</span>残念ながら、この関数を呼び出して、結果値をまったく使用しない内部の<code>if</code>ブロックを含むすべての場合の結果を待っています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We want to define code in one place in our program, but only <i>execute</i> that code where we actually need the result.</span>私たちは、プログラム内のある場所にコードを定義したいが、実際に結果が必要な場所でコードを<i>実行する</i>だけです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is a use case for closures!</span>これはクロージャの使用例です！</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Refactoring with Closures to Store Code</span>コードを格納するためのクロージャによるリファクタリング</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Instead of always calling the <code>simulated_expensive_calculation</code> function before the <code>if</code> blocks, we can define a closure and store the <i>closure</i> in a variable rather than storing the result of the function call, as shown in Listing 13-5.</span>代わりに、常に呼び出しの<code>simulated_expensive_calculation</code>前に機能を<code>if</code>ブロック、我々はクロージャを定義し、むしろリスト13-5に示すように、関数呼び出しの結果を格納するよりも、変数に<i>閉鎖を</i>保存することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can actually move the whole body of <code>simulated_expensive_calculation</code> within the closure we&#39;re introducing here.</span>実際には、ここで紹介しているclosure内で<code>simulated_expensive_calculation</code>の全身を動かすことができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="# use std::thread;"></div><div data-l="# use std::time::Duration;"></div><div data-l=#></div><div data-l="let expensive_closure = |num| {"></div><div data-l="    println!(&quot;calculating slowly...&quot;);"></div><div data-l="    thread::sleep(Duration::from_secs(2));"></div><div data-l="    num"></div><div data-l=};></div><div data-l="# expensive_closure(5);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 13-5: Defining a closure and storing it in the <code>expensive_closure</code> variable</span></span> <span class=caption>リスト13-5：closureを定義してこれを<code>expensive_closure</code>変数に格納する</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The closure definition comes after the <code>=</code> to assign it to the variable <code>expensive_closure</code> .</span>クロージャの定義は、 <code>=</code>後に来て、それを変数<code>expensive_closure</code>に代入します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To define a closure, we start with a pair of vertical pipes ( <code>|</code> ), inside which we specify the parameters to the closure;</span>クロージャを定義するには、クロージャのパラメータを指定する一対の垂直パイプ（ <code>|</code> ）から始めます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">this syntax was chosen because of its similarity to closure definitions in Smalltalk and Ruby.</span>この構文は、SmalltalkとRubyにおけるクロージャ定義との類似性のために選択されました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This closure has one parameter named <code>num</code> : if we had more than one parameter, we would separate them with commas, like <code>|param1, param2|</code></span>このクロージャーには<code>num</code>という名前のパラメーターが1つあります。複数のパラメーターがある場合は、 <code>|param1, param2|</code>ようにカンマで区切ります<code>|param1, param2|</code></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">.</span> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">After the parameters, we place curly brackets that hold the body of the closure—these are optional if the closure body is a single expression.</span>パラメータの後ろに、クロージャの本体を保持する中括弧を配置します。これらは、クロージャ本体が単一の式であればオプションです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The end of the closure, after the curly brackets, needs a semicolon to complete the <code>let</code> statement.</span>中括弧の後ろには、 <code>let</code>ステートメントを完了するためにセミコロンが必要です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The value returned from the last line in the closure body ( <code>num</code> ) will be the value returned from the closure when it&#39;s called, because that line doesn&#39;t end in a semicolon;</span>クロージャ本体（ <code>num</code> ）の最後の行から返される値は、クロージャが呼び出されるときに返される値です。その行はセミコロンで終わらないためです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">just as in function bodies.</span>関数本体の場合とまったく同じです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that this <code>let</code> statement means <code>expensive_closure</code> contains the <i>definition</i> of an anonymous function, not the <i>resulting value</i> of calling the anonymous function.</span>この<code>let</code>文は、 <code>expensive_closure</code>には無名関数の<i>定義</i>が含まれており、無名関数を呼び出す<i>結果の値</i>は含まれないことに注意してください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Recall that we&#39;re using a closure because we want to define the code to call at one point, store that code, and call it at a later point;</span>ある時点で呼び出すコードを定義し、そのコードを格納し、後で呼び出したいので、クロージャを使用していることを思い出してください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">the code we want to call is now stored in <code>expensive_closure</code> .</span>呼び出したいコードが<code>expensive_closure</code>格納されます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">With the closure defined, we can change the code in the <code>if</code> blocks to call the closure to execute the code and get the resulting value.</span>クロージャが定義されている<code>if</code> 、 <code>if</code>ブロックのコードを変更して、クロージャを呼び出してコードを実行し、結果の値を取得することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We call a closure like we do a function: we specify the variable name that holds the closure definition and follow it with parentheses containing the argument values we want to use, as shown in Listing 13-6.</span>リスト13-6に示すように、クロージャ定義を保持する変数名を指定し、使用する引数値を含む括弧で囲みます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="# use std::thread;"></div><div data-l="# use std::time::Duration;"></div><div data-l=#></div><div data-l="fn generate_workout(intensity: u32, random_number: u32) {"></div><div data-l="    let expensive_closure = |num| {"></div><div data-l="        println!(&quot;calculating slowly...&quot;);"></div><div data-l="        thread::sleep(Duration::from_secs(2));"></div><div data-l="        num"></div><div data-l="    };"></div><div data-l=""></div><div data-l="    if intensity &lt; 25 {"></div><div data-l="        println!("></div><div data-l="            &quot;Today, do {} pushups!&quot;,"></div><div data-l="            expensive_closure(intensity)"></div><div data-l="        );"></div><div data-l="        println!("></div><div data-l="            &quot;Next, do {} situps!&quot;,"></div><div data-l="            expensive_closure(intensity)"></div><div data-l="        );"></div><div data-l="    } else {"></div><div data-l="        if random_number == 3 {"></div><div data-l="            println!(&quot;Take a break today! Remember to stay hydrated!&quot;);"></div><div data-l="        } else {"></div><div data-l="            println!("></div><div data-l="                &quot;Today, run for {} minutes!&quot;,"></div><div data-l="                expensive_closure(intensity)"></div><div data-l="            );"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 13-6: Calling the <code>expensive_closure</code> we&#39;ve defined</span></span> <span class=caption>リスト13-6：定義済みの<code>expensive_closure</code>を呼び出す</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now the expensive calculation is called in only one place, and we&#39;re only executing that code where we need the results.</span>高価な計算は1つの場所でのみ呼び出され、結果を必要とするところでそのコードを実行しています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, we&#39;ve reintroduced one of the problems from Listing 13-3: we&#39;re still calling the closure twice in the first <code>if</code> block, which will call the expensive code twice and make the user wait twice as long as they need to.</span>しかし、リスト13-3の問題の1つを再導入しました。最初の<code>if</code>ブロックでクロージャを2回呼び出します。これは高価なコードを2回呼び出し、必要なだけ長くユーザーを待機させます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We could fix this problem by creating a variable local to that <code>if</code> block to hold the result of calling the closure, but closures provide us with another solution.</span>クロージャを呼び出した結果を保持するブロックで<code>if</code>ローカル変数を作成することでこの問題を解決できますが、クロージャは別の解決策を提供します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll talk about that solution in a bit.</span>我々はその解決策について少し話します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But first let&#39;s talk about why there aren&#39;t type annotations in the closure definition and the traits involved with closures.</span>しかし、最初に、クロージャーの定義に型の注釈がなく、クロージャーに関連する特性がない理由について話しましょう。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Closure Type Inference and Annotation</span>閉鎖型推論と注釈</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Closures don&#39;t require you to annotate the types of the parameters or the return value like <code>fn</code> functions do.</span>クロージャでは、パラメータの型や<code>fn</code>関数のような戻り値に注釈を付ける必要はありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Type annotations are required on functions because they&#39;re part of an explicit interface exposed to your users.</span>型アノテーションは、ユーザーに公開されている明示的なインタフェースの一部であるため、関数に必要です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Defining this interface rigidly is important for ensuring that everyone agrees on what types of values a function uses and returns.</span>このインターフェイスを厳密に定義することは、関数が使用して返した値のタイプに誰もが同意することを確実にするために重要です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But closures aren&#39;t used in an exposed interface like this: they&#39;re stored in variables and used without naming them and exposing them to users of our library.</span>しかし、クロージャは、公開されたインターフェイスではこのように使用されません。変数は変数に格納され、名前を付けずにライブラリのユーザーに公開します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Closures are usually short and relevant only within a narrow context rather than in any arbitrary scenario.</span>クロージャは通常、短く、任意のシナリオではなく狭いコンテキスト内でのみ関連します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Within these limited contexts, the compiler is reliably able to infer the types of the parameters and the return type, similar to how it&#39;s able to infer the types of most variables.</span>これらの制限された文脈の中で、コンパイラは、ほとんどの変数の型を推論する方法と同様に、パラメータの型と戻り型を確実に推論することができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Making programmers annotate the types in these small, anonymous functions would be annoying and largely redundant with the information the compiler already has available.</span>プログラマーがこれらの小さな、無名関数の型に注釈を付けることは、コンパイラーがすでに利用可能な情報を迷惑にし、ほとんど冗長になります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As with variables, we can add type annotations if we want to increase explicitness and clarity at the cost of being more verbose than is strictly necessary.</span>変数の場合と同様に、厳密に必要以上に冗長であることを犠牲にして、明示と明快さを増やしたい場合は、型注釈を追加できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Annotating the types for the closure we defined in Listing 13-5 would look like the definition shown in Listing 13-7.</span>リスト13-5で定義したクロージャの型に注釈を付けると、リスト13-7のようになります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="# use std::thread;"></div><div data-l="# use std::time::Duration;"></div><div data-l=#></div><div data-l="let expensive_closure = |num: u32| -&gt; u32 {"></div><div data-l="    println!(&quot;calculating slowly...&quot;);"></div><div data-l="    thread::sleep(Duration::from_secs(2));"></div><div data-l="    num"></div><div data-l=};></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 13-7: Adding optional type annotations of the parameter and return value types in the closure</span></span> <span class=caption>リスト13-7：クロージャ内のパラメータと戻り値の型のオプションの型の注釈の追加</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">With type annotations added, the syntax of closures looks more similar to the syntax of functions.</span>型の注釈が追加されると、クロージャの構文は関数の構文に似ています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The following is a vertical comparison of the syntax for the definition of a function that adds 1 to its parameter and a closure that has the same behavior.</span>以下は、パラメータに1を加えた関数の定義と、同じ振る舞いを持つクロージャの構文の垂直比較です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ve added some spaces to line up the relevant parts.</span>関連する部分を整理するためのスペースを追加しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This illustrates how closure syntax is similar to function syntax except for the use of pipes and the amount of syntax that is optional:</span>これは、パイプの使用とオプションの構文の量を除いて、クロージャ構文が関数構文とどのように似ているかを示しています。</span> </p><br><div data-lang=rust,ignore><div data-l="fn  add_one_v1   (x: u32) -&gt; u32 { x + 1 }"></div><div data-l="let add_one_v2 = |x: u32| -&gt; u32 { x + 1 };"></div><div data-l="let add_one_v3 = |x|             { x + 1 };"></div><div data-l="let add_one_v4 = |x|               x + 1  ;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The first line shows a function definition, and the second line shows a fully annotated closure definition.</span>最初の行は関数定義を示し、2行目は完全に注釈付きのクロージャ定義を示します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The third line removes the type annotations from the closure definition, and the fourth line removes the brackets, which are optional because the closure body has only one expression.</span> 3行目は型定義をクロージャー定義から削除し、4行目は括弧を削除します。これはオプションです。クロージャー本体には1つの式しかないためです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These are all valid definitions that will produce the same behavior when they&#39;re called.</span>これらはすべて、呼び出し時に同じ動作を生成する有効な定義です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Closure definitions will have one concrete type inferred for each of their parameters and for their return value.</span>クロージャ定義では、それぞれのパラメータとその戻り値に対して推定される1つの具体的な型があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For instance, Listing 13-8 shows the definition of a short closure that just returns the value it receives as a parameter.</span>例えば、リスト13-8は、パラメータとして受け取った値を返すshort closureの定義を示しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This closure isn&#39;t very useful except for the purposes of this example.</span>このクロージャは、この例の目的を除いてあまり有用ではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that we haven&#39;t added any type annotations to the definition: if we then try to call the closure twice, using a <code>String</code> as an argument the first time and a <code>u32</code> the second time, we&#39;ll get an error.</span>型の注釈を定義に追加していないことに注意してください。最初に<code>String</code>を引数として、2回目に<code>u32</code>を使用してクロージャを2回呼び出すと、エラーが発生します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust,ignore><div data-l="let example_closure = |x| x;"></div><div data-l=""></div><div data-l="let s = example_closure(String::from(&quot;hello&quot;));"></div><div data-l="let n = example_closure(5);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 13-8: Attempting to call a closure whose types are inferred with two different types</span></span> <span class=caption>リスト13-8：型が2つの異なる型で推論されるクロージャを呼び出そうとする</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The compiler gives us this error:</span>コンパイラはこのエラーを返します：</span> </p><br><div data-lang=text><div data-l="error[E0308]: mismatched types"></div><div data-l=" --&gt; src/main.rs"></div><div data-l="  |"></div><div data-l="  | let n = example_closure(5);"></div><div data-l="  |                         ^ expected struct `std::string::String`, found"></div><div data-l="  integral variable"></div><div data-l="  |"></div><div data-l="  = note: expected type `std::string::String`"></div><div data-l="             found type `{integer}`"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The first time we call <code>example_closure</code> with the <code>String</code> value, the compiler infers the type of <code>x</code> and the return type of the closure to be <code>String</code> .</span>最初に<code>example_closure</code>を<code>String</code>値で呼び出すと、コンパイラは<code>x</code>型とクロージャの戻り型を<code>String</code>推論します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Those types are then locked in to the closure in <code>example_closure</code> , and we get a type error if we try to use a different type with the same closure.</span>これらの型は<code>example_closure</code>のクロージャーにロックインされ、同じクロージャーで別の型を使用しようとすると型エラーが発生します。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Storing Closures Using Generic Parameters and the <code>Fn</code> Traits</span>汎用パラメータと<code>Fn</code>特性を使用したクロージャの格納</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s return to our workout generation app.</span>私たちのワークアウト生成アプリに戻りましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In Listing 13-6, our code was still calling the expensive calculation closure more times than it needed to.</span>コードリスト13-6では、私たちのコードでは、必要以上に高価な計算クロージャを呼び出していました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">One option to solve this issue is to save the result of the expensive closure in a variable for reuse and use the variable in each place we need the result, instead of calling the closure again.</span>この問題を解決する1つの方法は、高価なクロージャの結果を変数に保存して再利用し、クロージャを再度呼び出すのではなく、結果が必要な各場所で変数を使用することです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, this method could result in a lot of repeated code.</span>ただし、この方法は繰り返しコードが多く発生する可能性があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Fortunately, another solution is available to us.</span>幸いにも、私たちにはもう一つの解決策があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can create a struct that will hold the closure and the resulting value of calling the closure.</span>クロージャを保持する構造体とクロージャを呼び出す結果の値を作成できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The struct will execute the closure only if we need the resulting value, and it will cache the resulting value so the rest of our code doesn&#39;t have to be responsible for saving and reusing the result.</span>構造体は、結果の値が必要な場合にのみクロージャを実行し、残りのコードは結果を保存して再利用する必要がないように結果の値をキャッシュします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You may know this pattern as <i>memoization</i> or <i>lazy evaluation</i> .</span>あなたはこのパターンを<i>メモ</i>や<i>怠惰な評価</i>として知っているかもしれません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To make a struct that holds a closure, we need to specify the type of the closure, because a struct definition needs to know the types of each of its fields.</span>クロージャを保持する構造体を作成するには、クロージャの型を指定する必要があります。構造体の定義では、各フィールドの型を知る必要があるからです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Each closure instance has its own unique anonymous type: that is, even if two closures have the same signature, their types are still considered different.</span>各クロージャインスタンスには、独自の一意の匿名型があります。つまり、2つのクロージャが同じシグネチャを持っていても、それらの型はまだ異なるとみなされます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To define structs, enums, or function parameters that use closures, we use generics and trait bounds, as we discussed in Chapter 10.</span>クロージャを使用する構造体、列挙型、または関数パラメータを定義するには、第10章で説明したようにジェネリックと特性境界を使用します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Fn</code> traits are provided by the standard library.</span> <code>Fn</code>形質は、標準ライブラリーによって提供される。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">All closures implement at least one of the traits: <code>Fn</code> , <code>FnMut</code> , or <code>FnOnce</code> .</span>すべてのクロージャは、 <code>Fn</code> 、 <code>FnMut</code> 、または<code>FnOnce</code>うちの少なくとも1つの特性を実装し<code>Fn</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll discuss the difference between these traits in the “Capturing the Environment with Closures” section;</span>これらの特性の違いについては、「環境をクローズで取り込む」セクションで説明します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">in this example, we can use the <code>Fn</code> trait.</span>この例では、 <code>Fn</code>特性を使用することができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We add types to the <code>Fn</code> trait bound to represent the types of the parameters and return values the closures must have to match this trait bound.</span> <code>Fn</code>特性バインドに型を追加して、パラメータの型を表現し、クロージャがこの特性境界に一致する必要がある戻り値を追加します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this case, our closure has a parameter of type <code>u32</code> and returns a <code>u32</code> , so the trait bound we specify is <code>Fn(u32) -&gt; u32</code> .</span>この場合、私たちの閉鎖は、型のパラメータがある<code>u32</code>して返す<code>u32</code> 、私たちが指定したバインド特徴はある<code>Fn(u32) -&gt; u32</code> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 13-9 shows the definition of the <code>Cacher</code> struct that holds a closure and an optional result value.</span>リスト13-9は、クロージャとオプションの結果値を保持する<code>Cacher</code>構造体の定義を示しています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="struct Cacher&lt;T&gt;"></div><div data-l="    where T: Fn(u32) -&gt; u32"></div><div data-l={></div><div data-l="    calculation: T,"></div><div data-l="    value: Option&lt;u32&gt;,"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 13-9: Defining a <code>Cacher</code> struct that holds a closure in <code>calculation</code> and an optional result in <code>value</code></span></span> <span class=caption>リスト13-9： <code>calculation</code>クロージャと<code>value</code>任意の結果を保持する<code>Cacher</code>構造体の定義</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Cacher</code> struct has a <code>calculation</code> field of the generic type <code>T</code> .</span> <code>Cacher</code>構造体には、ジェネリック型<code>T</code> <code>calculation</code>フィールドがあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The trait bounds on <code>T</code> specify that it&#39;s a closure by using the <code>Fn</code> trait.</span> <code>T</code>の特性境界は、 <code>Fn</code>特性を使用してクロージャであることを指定します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Any closure we want to store in the <code>calculation</code> field must have one <code>u32</code> parameter (specified within the parentheses after <code>Fn</code> ) and must return a <code>u32</code> (specified after the <code>-&gt;</code> ).</span> <code>calculation</code>フィールドに格納するクロージャは、1つの<code>u32</code>パラメータ（ <code>Fn</code>後の括弧内に指定）を持つ必要があり、 <code>u32</code> （ <code>-&gt;</code> ）の後に指定する必要があります。</span> </p><br><blockquote><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note: Functions implement all three of the <code>Fn</code> traits too.</span>注：関数は3つの<code>Fn</code>特性もすべて実装してい<code>Fn</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If what we want to do doesn&#39;t require capturing a value from the environment, we can use a function rather than a closure where we need something that implements an <code>Fn</code> trait.</span>私たちがやりたいことが環境からの価値を取り込む必要がなければ、 <code>Fn</code>特性を実装するものが必要なクロージャではなく関数を使うことができます。</span> </p></blockquote><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>value</code> field is of type <code>Option&lt;u32&gt;</code> .</span> <code>value</code>フィールドのタイプは<code>Option&lt;u32&gt;</code>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Before we execute the closure, <code>value</code> will be <code>None</code> .</span>クロージャを実行する前に、 <code>value</code>は<code>None</code>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When code using a <code>Cacher</code> asks for the <i>result</i> of the closure, the <code>Cacher</code> will execute the closure at that time and store the result within a <code>Some</code> variant in the <code>value</code> field.</span> <code>Cacher</code>を使用しているコードがクロージャの<i>結果</i>を要求すると、 <code>Cacher</code>はその時点でクロージャを実行し、その結果を<code>value</code>フィールドの<code>Some</code>バリアントに格納します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then if the code asks for the result of the closure again, instead of executing the closure again, the <code>Cacher</code> will return the result held in the <code>Some</code> variant.</span>次に、コードが再びクロージャの結果を求める場合、クロージャを再度実行する代わりに、 <code>Cacher</code>は<code>Some</code>バリアントに保持されている結果を返します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The logic around the <code>value</code> field we&#39;ve just described is defined in Listing 13-10.</span>上で説明した<code>value</code>フィールドの周りのロジックは、リスト13-10で定義されています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="# struct Cacher&lt;T&gt;"></div><div data-l="#     where T: Fn(u32) -&gt; u32"></div><div data-l="# {"></div><div data-l="#     calculation: T,"></div><div data-l="#     value: Option&lt;u32&gt;,"></div><div data-l="# }"></div><div data-l=#></div><div data-l="impl&lt;T&gt; Cacher&lt;T&gt;"></div><div data-l="    where T: Fn(u32) -&gt; u32"></div><div data-l={></div><div data-l="    fn new(calculation: T) -&gt; Cacher&lt;T&gt; {"></div><div data-l="        Cacher {"></div><div data-l="            calculation,"></div><div data-l="            value: None,"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=""></div><div data-l="    fn value(&amp;mut self, arg: u32) -&gt; u32 {"></div><div data-l="        match self.value {"></div><div data-l="            Some(v) =&gt; v,"></div><div data-l="            None =&gt; {"></div><div data-l="                let v = (self.calculation)(arg);"></div><div data-l="                self.value = Some(v);"></div><div data-l="                v"></div><div data-l="            },"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 13-10: The caching logic of <code>Cacher</code></span></span> <span class=caption>リスト13-10：のキャッシュロジック<code>Cacher</code></span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We want <code>Cacher</code> to manage the struct fields&#39; values rather than letting the calling code potentially change the values in these fields directly, so these fields are private.</span> <code>Cacher</code>は、呼び出し元コードがこれらのフィールドの値を直接変更できるようにするのではなく、構造体フィールドの値を管理したいので、これらのフィールドは非公開です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Cacher::new</code> function takes a generic parameter <code>T</code> , which we&#39;ve defined as having the same trait bound as the <code>Cacher</code> struct.</span> <code>Cacher::new</code>関数は、ジェネリックパラメータ<code>T</code>とります。これは、 <code>Cacher</code>構造体と同じ特性を持つと定義しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then <code>Cacher::new</code> returns a <code>Cacher</code> instance that holds the closure specified in the <code>calculation</code> field and a <code>None</code> value in the <code>value</code> field, because we haven&#39;t executed the closure yet.</span>次に、 <code>Cacher::new</code>は、 <code>calculation</code>フィールドで指定されたクロージャを保持する<code>Cacher</code>インスタンスと、まだクロージャを実行していないため、 <code>value</code>フィールドに<code>None</code>値を返します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When the calling code needs the result of evaluating the closure, instead of calling the closure directly, it will call the <code>value</code> method.</span>呼び出し元コードがクロージャを評価する結果を必要とする場合、クロージャを直接呼び出すのではなく、 <code>value</code>メソッドを呼び出し<code>value</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This method checks whether we already have a resulting value in <code>self.value</code> in a <code>Some</code> ;</span>このメソッドは、 <code>Some</code> <code>self.value</code>に結果の値がすでにあるかどうかをチェックします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">if we do, it returns the value within the <code>Some</code> without executing the closure again.</span>もしそうであれば、Closureを再度実行せずに<code>Some</code>内の値を返します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If <code>self.value</code> is <code>None</code> , the code calls the closure stored in <code>self.calculation</code> , saves the result in <code>self.value</code> for future use, and returns the value as well.</span> <code>self.value</code>が<code>None</code>場合、コードは<code>self.calculation</code>に格納されているクロージャを呼び出し、将来の使用のために<code>self.value</code>に結果を保存し、値も返します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 13-11 shows how we can use this <code>Cacher</code> struct in the function <code>generate_workout</code> from Listing 13-6.</span>リスト13-11は、リスト13-6の<code>generate_workout</code>関数でこの<code>Cacher</code>構造体を使用する方法を示しています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="# use std::thread;"></div><div data-l="# use std::time::Duration;"></div><div data-l=#></div><div data-l="# struct Cacher&lt;T&gt;"></div><div data-l="#     where T: Fn(u32) -&gt; u32"></div><div data-l="# {"></div><div data-l="#     calculation: T,"></div><div data-l="#     value: Option&lt;u32&gt;,"></div><div data-l="# }"></div><div data-l=#></div><div data-l="# impl&lt;T&gt; Cacher&lt;T&gt;"></div><div data-l="#     where T: Fn(u32) -&gt; u32"></div><div data-l="# {"></div><div data-l="#     fn new(calculation: T) -&gt; Cacher&lt;T&gt; {"></div><div data-l="#         Cacher {"></div><div data-l="#             calculation,"></div><div data-l="#             value: None,"></div><div data-l="#         }"></div><div data-l="#     }"></div><div data-l=#></div><div data-l="#     fn value(&amp;mut self, arg: u32) -&gt; u32 {"></div><div data-l="#         match self.value {"></div><div data-l="#             Some(v) =&gt; v,"></div><div data-l="#             None =&gt; {"></div><div data-l="#                 let v = (self.calculation)(arg);"></div><div data-l="#                 self.value = Some(v);"></div><div data-l="#                 v"></div><div data-l="#             },"></div><div data-l="#         }"></div><div data-l="#     }"></div><div data-l="# }"></div><div data-l=#></div><div data-l="fn generate_workout(intensity: u32, random_number: u32) {"></div><div data-l="    let mut expensive_result = Cacher::new(|num| {"></div><div data-l="        println!(&quot;calculating slowly...&quot;);"></div><div data-l="        thread::sleep(Duration::from_secs(2));"></div><div data-l="        num"></div><div data-l="    });"></div><div data-l=""></div><div data-l="    if intensity &lt; 25 {"></div><div data-l="        println!("></div><div data-l="            &quot;Today, do {} pushups!&quot;,"></div><div data-l="            expensive_result.value(intensity)"></div><div data-l="        );"></div><div data-l="        println!("></div><div data-l="            &quot;Next, do {} situps!&quot;,"></div><div data-l="            expensive_result.value(intensity)"></div><div data-l="        );"></div><div data-l="    } else {"></div><div data-l="        if random_number == 3 {"></div><div data-l="            println!(&quot;Take a break today! Remember to stay hydrated!&quot;);"></div><div data-l="        } else {"></div><div data-l="            println!("></div><div data-l="                &quot;Today, run for {} minutes!&quot;,"></div><div data-l="                expensive_result.value(intensity)"></div><div data-l="            );"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 13-11: Using <code>Cacher</code> in the <code>generate_workout</code> function to abstract away the caching logic</span></span> <span class=caption>リスト13-11：キャッシュロジックを抽象化<code>generate_workout</code>ために<code>generate_workout</code>関数で<code>Cacher</code>を使う</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Instead of saving the closure in a variable directly, we save a new instance of <code>Cacher</code> that holds the closure.</span>クロージャを変数に直接保存する代わりに、クロージャを保持する<code>Cacher</code>新しいインスタンスを保存します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then, in each place we want the result, we call the <code>value</code> method on the <code>Cacher</code> instance.</span>次に、結果が必要な各場所で、 <code>Cacher</code>インスタンスの<code>value</code>メソッドを呼び出します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can call the <code>value</code> method as many times as we want, or not call it at all, and the expensive calculation will be run a maximum of once.</span>私たちは、 <code>value</code>メソッドを何度でも呼び出すこともできますし、呼び出さないこともできます。高価な計算は最大1回実行されます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Try running this program with the <code>main</code> function from Listing 13-2.</span>リスト13-2の<code>main</code>関数でこのプログラムを実行してみてください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Change the values in the <code>simulated_user_specified_value</code> and <code>simulated_random_number</code> variables to verify that in all the cases in the various <code>if</code> and <code>else</code> blocks, <code>calculating slowly...</code> appears only once and only when needed.</span>内の値に変更<code>simulated_user_specified_value</code>と<code>simulated_random_number</code>様々で、すべての場合にそのことを確認するために、変数<code>if</code>と<code>else</code> 、ブロックを<code>calculating slowly...</code>必要なときに一度だけしか表示されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Cacher</code> takes care of the logic necessary to ensure we aren&#39;t calling the expensive calculation more than we need to so <code>generate_workout</code> can focus on the business logic.</span> <code>Cacher</code>は、必要以上に高価な計算を呼び出さないようにするために必要なロジックを処理し、 <code>generate_workout</code>はビジネスロジックに集中<code>generate_workout</code>ことができます。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Limitations of the <code>Cacher</code> Implementation</span> <code>Cacher</code>実装の制限</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Caching values is a generally useful behavior that we might want to use in other parts of our code with different closures.</span>値をキャッシュすることは、異なるクロージャを使用してコードの他の部分で使用したい場合がある一般的に有用な動作です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, there are two problems with the current implementation of <code>Cacher</code> that would make reusing it in different contexts difficult.</span>しかし、 <code>Cacher</code>の現在の実装には、異なる状況での再利用を困難にする2つの問題があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The first problem is that a <code>Cacher</code> instance assumes it will always get the same value for the parameter <code>arg</code> to the <code>value</code> method.</span>最初の問題は、 <code>Cacher</code>インスタンスは、 <code>value</code>メソッドへの<code>arg</code>に対して常に同じ値を取得すると仮定しているということです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That is, this test of <code>Cacher</code> will fail:</span>つまり、この<code>Cacher</code>テストは失敗します。</span> </p><br><div data-lang=rust,ignore><div data-l=#[test]></div><div data-l="fn call_with_different_values() {"></div><div data-l="    let mut c = Cacher::new(|a| a);"></div><div data-l=""></div><div data-l="    let v1 = c.value(1);"></div><div data-l="    let v2 = c.value(2);"></div><div data-l=""></div><div data-l="    assert_eq!(v2, 2);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This test creates a new <code>Cacher</code> instance with a closure that returns the value passed into it.</span>このテストでは、渡された値を返すクロージャ付きの新しい<code>Cacher</code>インスタンスを作成します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We call the <code>value</code> method on this <code>Cacher</code> instance with an <code>arg</code> value of 1 and then an <code>arg</code> value of 2, and we expect the call to <code>value</code> with the <code>arg</code> value of 2 to return 2.</span>この<code>Cacher</code>インスタンスの<code>value</code>メソッドを<code>arg</code>値1と<code>arg</code>値2で呼び出すと、 <code>arg</code>値2で<code>value</code>を呼び出すと2が返されます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Run this test with the <code>Cacher</code> implementation in Listing 13-9 and Listing 13-10, and the test will fail on the <code>assert_eq€</code> with this message:</span>で、このテストを実行します<code>Cacher</code> 13-9とリスト13-10のリストの実装、およびテストが上で失敗します<code>assert_eq€</code>このメッセージで：</span> </p><br><div data-lang=text><div data-l="thread 'call_with_different_values' panicked at 'assertion failed: `(left == right)`"></div><div data-l="  left: `1`,"></div><div data-l=" right: `2`', src/main.rs"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The problem is that the first time we called <code>c.value</code> with 1, the <code>Cacher</code> instance saved <code>Some(1)</code> in <code>self.value</code> .</span>問題は、私たちが呼ば初めてということである<code>c.value</code> 1とは、 <code>Cacher</code>インスタンスが保存された<code>Some(1)</code>に<code>self.value</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Thereafter, no matter what we pass in to the <code>value</code> method, it will always return 1.</span>その後、 <code>value</code>メソッドに何を渡しても、常に1が返されます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Try modifying <code>Cacher</code> to hold a hash map rather than a single value.</span>単一の値ではなくハッシュマップを保持するように<code>Cacher</code>を修正してみてください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The keys of the hash map will be the <code>arg</code> values that are passed in, and the values of the hash map will be the result of calling the closure on that key.</span>ハッシュマップのキーは渡される<code>arg</code>値になり、ハッシュマップの値はそのキーのクロージャを呼び出した結果になります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Instead of looking at whether <code>self.value</code> directly has a <code>Some</code> or a <code>None</code> value, the <code>value</code> function will look up the <code>arg</code> in the hash map and return the value if it&#39;s present.</span> <code>self.value</code>が<code>Some</code>または<code>None</code>値を直接持っているかどうかを調べる代わりに、 <code>value</code>関数はハッシュマップ内の<code>arg</code>をルックアップし、値が存在すればそれを返します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If it&#39;s not present, the <code>Cacher</code> will call the closure and save the resulting value in the hash map associated with its <code>arg</code> value.</span>それが存在しない場合、 <code>Cacher</code>はクロージャを呼び出し、結果値を<code>arg</code>値に関連付けられたハッシュマップに保存します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The second problem with the current <code>Cacher</code> implementation is that it only accepts closures that take one parameter of type <code>u32</code> and return a <code>u32</code> .</span>現在の第2の問題<code>Cacher</code>実装は、それが唯一のタイプの一つのパラメータ取る閉鎖受け入れるということです<code>u32</code>して返す<code>u32</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We might want to cache the results of closures that take a string slice and return <code>usize</code> values, for example.</span>たとえば、文字列スライスを使用して<code>usize</code>値を返すクロージャの結果をキャッシュすることが<code>usize</code>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To fix this issue, try introducing more generic parameters to increase the flexibility of the <code>Cacher</code> functionality.</span>この問題を解決するには、より一般的なパラメータを導入して、 <code>Cacher</code>機能の柔軟性を高めてください。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Capturing the Environment with Closures</span>閉鎖による環境の捉え方</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In the workout generator example, we only used closures as inline anonymous functions.</span>ワークアウトジェネレータの例では、インラインの匿名関数としてのみクロージャを使用しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, closures have an additional capability that functions don&#39;t have: they can capture their environment and access variables from the scope in which they&#39;re defined.</span>しかし、クロージャには、機能にはない追加の機能があります。つまり、環境をキャプチャし、定義されているスコープから変数にアクセスできます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 13-12 has an example of a closure stored in the <code>equal_to_x</code> variable that uses the <code>x</code> variable from the closure&#39;s surrounding environment.</span> <code>equal_to_x</code>リスト13-12には、クロージャの周囲環境からの<code>x</code>変数を使用する<code>equal_to_x</code>変数に格納されたクロージャの例があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="fn main() {"></div><div data-l="    let x = 4;"></div><div data-l=""></div><div data-l="    let equal_to_x = |z| z == x;"></div><div data-l=""></div><div data-l="    let y = 4;"></div><div data-l=""></div><div data-l="    assert!(equal_to_x(y));"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 13-12: Example of a closure that refers to a variable in its enclosing scope</span></span> <span class=caption>コードリスト13-12：囲みスコープ内の変数を参照するクロージャの例</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here, even though <code>x</code> is not one of the parameters of <code>equal_to_x</code> , the <code>equal_to_x</code> closure is allowed to use the <code>x</code> variable that&#39;s defined in the same scope that <code>equal_to_x</code> is defined in.</span>ここでは、にもかかわらず、 <code>x</code>のパラメータの一つではありません<code>equal_to_x</code> 、 <code>equal_to_x</code>閉鎖は使用を許可されている<code>x</code>同じスコープで定義されています変数<code>equal_to_x</code>に定義されているが。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can&#39;t do the same with functions;</span>関数でも同じことをすることはできません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">if we try with the following example, our code won&#39;t compile:</span>次の例で試してみると、コードはコンパイルされません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust,ignore><div data-l="fn main() {"></div><div data-l="    let x = 4;"></div><div data-l=""></div><div data-l="    fn equal_to_x(z: i32) -&gt; bool { z == x }"></div><div data-l=""></div><div data-l="    let y = 4;"></div><div data-l=""></div><div data-l="    assert!(equal_to_x(y));"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We get an error:</span>エラーが表示されます。</span> </p><br><div data-lang=text><div data-l="error[E0434]: can't capture dynamic environment in a fn item; use the || { ..."></div><div data-l="} closure form instead"></div><div data-l=" --&gt; src/main.rs"></div><div data-l="  |"></div><div data-l="4 |     fn equal_to_x(z: i32) -&gt; bool { z == x }"></div><div data-l="  |                                          ^"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The compiler even reminds us that this only works with closures!</span>コンパイラは、これがクロージャでのみ動作することを私たちに思い出させる！</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When a closure captures a value from its environment, it uses memory to store the values for use in the closure body.</span>クロージャがその環境から値を取得すると、メモリを使用してクロージャー本体で使用する値が格納されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This use of memory is overhead that we don&#39;t want to pay in more common cases where we want to execute code that doesn&#39;t capture its environment.</span>このメモリの使用は、環境を捕捉しないコードを実行する、より一般的なケースでは支払う必要のないオーバーヘッドです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because functions are never allowed to capture their environment, defining and using functions will never incur this overhead.</span>関数は決して環境を捕捉することができないので、関数を定義して使用することは決してこのオーバーヘッドを招くことはありません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Closures can capture values from their environment in three ways, which directly map to the three ways a function can take a parameter: taking ownership, borrowing mutably, and borrowing immutably.</span>クロージャは、環境から3つの方法で値を取り込むことができます。これは、関数がパラメータをとる3つの方法、つまり所有権の取得、可変的な借用、および不変の借用の3つの方法に直接対応します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These are encoded in the three <code>Fn</code> traits as follows:</span>これらは、以下のように3つの<code>Fn</code>形質でコードされる：</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>FnOnce</code> consumes the variables it captures from its enclosing scope, known as the closure&#39;s <i>environment</i> .</span> <code>FnOnce</code>は、クロージャの<i>環境</i>として知られる囲みスコープからキャプチャする変数を消費します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To consume the captured variables, the closure must take ownership of these variables and move them into the closure when it is defined.</span>キャプチャされた変数を消費するには、クロージャはこれらの変数の所有権を取得し、クロージャが定義されたときにクロージャに移動する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Once</code> part of the name represents the fact that the closure can&#39;t take ownership of the same variables more than once, so it can be called only once.</span>名前の<code>Once</code>部分は、クロージャが同じ変数の所有権を複数回取ることができないという事実を表しているため、一度しかコールすることはできません。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>FnMut</code> can change the environment because it mutably borrows values.</span> <code>FnMut</code>は、値を可変的に借りるので環境を変更することができます。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>Fn</code> borrows values from the environment immutably.</span> <code>Fn</code>は環境から価値を借りています。</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When you create a closure, Rust infers which trait to use based on how the closure uses the values from the environment.</span>クロージャを作成すると、Rustはクロージャが環境からの値をどのように使用するかに基づいてどの特性を使用するかを推測します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">All closures implement <code>FnOnce</code> because they can all be called at least once.</span>すべてのクロージャは少なくとも1回は<code>FnOnce</code>ことができるため、 <code>FnOnce</code>実装しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Closures that don&#39;t move the captured variables also implement <code>FnMut</code> , and closures that don&#39;t need mutable access to the captured variables also implement <code>Fn</code> .</span>キャプチャされた変数を移動しないクロージャも<code>FnMut</code>実装し、キャプチャされた変数への変更可能なアクセスを必要としないクロージャも<code>Fn</code>実装し<code>Fn</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In Listing 13-12, the <code>equal_to_x</code> closure borrows <code>x</code> immutably (so <code>equal_to_x</code> has the <code>Fn</code> trait) because the body of the closure only needs to read the value in <code>x</code> .</span>リスト13-12では、closureの本体が<code>x</code>の値を読み取るだけで<code>equal_to_x</code>ため、 <code>equal_to_x</code>クロージャは<code>x</code>不変に借り<code>Fn</code> （ <code>equal_to_x</code>は<code>Fn</code>特性を持ち<code>Fn</code> ）。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you want to force the closure to take ownership of the values it uses in the environment, you can use the <code>move</code> keyword before the parameter list.</span>クロージャが強制的に環境内で使用する値の所有権を取得するように<code>move</code>には、パラメータリストの前に<code>move</code>キーワードを使用します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This technique is mostly useful when passing a closure to a new thread to move the data so it&#39;s owned by the new thread.</span>この技法は、データを移動して新しいスレッドが所有するようにクロージャを新しいスレッドに渡すときに最も役立ちます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll have more examples of <code>move</code> closures in Chapter 16 when we talk about concurrency.</span>並行処理については、第16章で<code>move</code> closureの例をさらに紹介します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For now, here&#39;s the code from Listing 13-12 with the <code>move</code> keyword added to the closure definition and using vectors instead of integers, because integers can be copied rather than moved;</span>今のところ、リスト13-12のコードでは、 <code>move</code>キーワードをクロージャ定義に追加し、整数の代わりにベクトルを使用します。これは、整数を移動するのではなくコピーすることができるためです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">note that this code will not yet compile.</span>このコードはまだコンパイルされません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust,ignore><div data-l="fn main() {"></div><div data-l="    let x = vec![1, 2, 3];"></div><div data-l=""></div><div data-l="    let equal_to_x = move |z| z == x;"></div><div data-l=""></div><div data-l="    println!(&quot;can't use x here: {:?}&quot;, x);"></div><div data-l=""></div><div data-l="    let y = vec![1, 2, 3];"></div><div data-l=""></div><div data-l="    assert!(equal_to_x(y));"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We receive the following error:</span>次のエラーが表示されます。</span> </p><br><div data-lang=text><div data-l="error[E0382]: use of moved value: `x`"></div><div data-l=" --&gt; src/main.rs:6:40"></div><div data-l="  |"></div><div data-l="4 |     let equal_to_x = move |z| z == x;"></div><div data-l="  |                      -------- value moved (into closure) here"></div><div data-l="5 |"></div><div data-l="6 |     println!(&quot;can't use x here: {:?}&quot;, x);"></div><div data-l="  |                                        ^ value used here after move"></div><div data-l="  |"></div><div data-l="  = note: move occurs because `x` has type `std::vec::Vec&lt;i32&gt;`, which does not"></div><div data-l="  implement the `Copy` trait"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>x</code> value is moved into the closure when the closure is defined, because we added the <code>move</code> keyword.</span> <code>x</code>値はクロージャが定義されたときにクロージャに<code>move</code>されます。これは<code>move</code>キーワードが追加されたためです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The closure then has ownership of <code>x</code> , and <code>main</code> isn&#39;t allowed to use <code>x</code> anymore in the <code>println€</code> statement.</span>次に、クロージャは<code>x</code>所有権を持ち、 <code>main</code>は<code>println€</code>ステートメントで<code>x</code>もう使用することはできません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Removing <code>println€</code> will fix this example.</span> <code>println€</code>削除すると、この例が修正されます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Most of the time when specifying one of the <code>Fn</code> trait bounds, you can start with <code>Fn</code> and the compiler will tell you if you need <code>FnMut</code> or <code>FnOnce</code> based on what happens in the closure body.</span>一つを指定する時間のほとんど<code>Fn</code>形質境界は、あなたが始めることができる<code>Fn</code>とあなたが必要な場合、コンパイラはあなたを教えてくれます<code>FnMut</code>または<code>FnOnce</code>閉鎖体に何が起こるかに基づきます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To illustrate situations where closures that can capture their environment are useful as function parameters, let&#39;s move on to our next topic: iterators.</span>環境をキャプチャできるクロージャが関数パラメータとして有用な状況を説明するために、次のトピック、イテレータに移りましょう。</span> </p><script>_addload(function(){_setupIW('com');_csi('en','ja','ch13-01-closures.html');});</script>