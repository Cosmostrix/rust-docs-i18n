<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180709_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=ch16-00-concurrency.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Fearless Concurrency</span>恐れのない並行性</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Handling concurrent programming safely and efficiently is another of Rust&#39;s major goals.</span>並列プログラミングを安全かつ効率的に処理することは、Rustの主な目標の1つです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><i>Concurrent programming</i> , where different parts of a program execute independently, and <i>parallel programming</i> , where different parts of a program execute at the same time, are becoming increasingly important as more computers take advantage of their multiple processors.</span> <i>プログラムの</i>異なる部分が独立して実行される<i>並行プログラミング</i> 、および<i>プログラムの</i>異なる部分が同時に実行される<i>並列プログラミングは</i> 、より多くのコンピュータが複数のプロセッサを利用するにつれてますます重要になってきている。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Historically, programming in these contexts has been difficult and error prone: Rust hopes to change that.</span>歴史的に、これらのコンテキストでのプログラミングは難しく、エラーが発生しやすくなりました.Rustはそれを変えたいと考えています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Initially, the Rust team thought that ensuring memory safety and preventing concurrency problems were two separate challenges to be solved with different methods.</span>当初、Rustチームはメモリの安全性を保証し、並行性の問題を防ぐことは、異なる方法で解決する2つの別々の課題であると考えていました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Over time, the team discovered that the ownership and type systems are a powerful set of tools to help manage memory safety <i>and</i> concurrency problems!</span>時間の経過とともに、チームは、所有権とタイプのシステムが、メモリの安全性<i>と</i>同時実行性の問題を管理するための強力なツール群であることを発見しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">By leveraging ownership and type checking, many concurrency errors are compile-time errors in Rust rather than runtime errors.</span>所有権と型チェックを利用することで、多くの同時実行エラーは、実行時エラーではなく、Rustのコンパイル時エラーです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Therefore, rather than making you spend lots of time trying to reproduce the exact circumstances under which a runtime concurrency bug occurs, incorrect code will refuse to compile and present an error explaining the problem.</span>したがって、実行時の並行性のバグが発生する正確な状況を再現しようと多くの時間を費やすのではなく、誤ったコードがコンパイルを拒否し、問題を説明するエラーを表示します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As a result, you can fix your code while you&#39;re working on it rather than potentially after it has been shipped to production.</span>その結果、コードを実際に運用に移した後ではなく、作業中にコードを修正することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ve nicknamed this aspect of Rust <i>fearless</i> <i>concurrency</i> .</span>我々はRustの<i>恐怖のない</i> <i>並行性の</i>この側面にニックネームをつけた。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Fearless concurrency allows you to write code that is free of subtle bugs and is easy to refactor without introducing new bugs.</span>恐怖のない並行処理により、微妙なバグのないコードを書くことができ、新しいバグを導入することなくリファクタリングが容易になります。</span> </p><br><blockquote><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note: For simplicity&#39;s sake, we&#39;ll refer to many of the problems as <i>concurrent</i> rather than being more precise by saying <i>concurrent and/or parallel</i> .</span>注：わかりやすくするために、 <i>同時および/または並行と</i>言って、より正確なものではなく、 <i>同時の</i>ものとして多くの問題を参照します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If this book were about concurrency and/or parallelism, we&#39;d be more specific.</span>この本が並行性や並列性に関するものであれば、より具体的なものになります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For this chapter, please mentally substitute <i>concurrent and/or parallel</i> whenever we use <i>concurrent</i> .</span>この章では、我々は<i>同時に</i>精神的に代替<i>同時および/または並列</i>に使用してくださいいつでも。</span> </p></blockquote><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Many languages are dogmatic about the solutions they offer for handling concurrent problems.</span>多くの言語は、並列問題を処理するために提供するソリューションについて独断的です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, Erlang has elegant functionality for message-passing concurrency but has only obscure ways to share state between threads.</span>たとえば、Erlangはメッセージパッシングの並行処理のための洗練された機能を持っていますが、スレッド間で状態を共有するためのあいまいな方法しかありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Supporting only a subset of possible solutions is a reasonable strategy for higher-level languages, because a higher-level language promises benefits from giving up some control to gain abstractions.</span>可能なソリューションのサブセットのみをサポートすることは、より高水準の言語のための合理的な戦略です。なぜなら、より高いレベルの言語は、抽象化を得るために何らかの制御を放棄することによる利益を約束するからです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, lower-level languages are expected to provide the solution with the best performance in any given situation and have fewer abstractions over the hardware.</span>しかし、下位レベルの言語は、特定の状況で最高のパフォーマンスをソリューションに提供し、ハードウェア上の抽象度が低下することが予想されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Therefore, Rust offers a variety of tools for modeling problems in whatever way is appropriate for your situation and requirements.</span>したがって、Rustは、状況や要件に適した方法で問題をモデル化するためのさまざまなツールを提供しています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here are the topics we&#39;ll cover in this chapter:</span>この章で説明するトピックは次のとおりです。</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">How to create threads to run multiple pieces of code at the same time</span>複数のコードを同時に実行するスレッドを作成する方法</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><i>Message-passing</i> concurrency, where channels send messages between threads</span>チャネルがスレッド間でメッセージを送信するメッセージ<i>パッシング</i>同時実行性</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><i>Shared-state</i> concurrency, where multiple threads have access to some piece of data</span>複数のスレッドがあるデータにアクセスできる、 <i>共有状態の</i>同時実行性</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Sync</code> and <code>Send</code> traits, which extend Rust&#39;s concurrency guarantees to user-defined types as well as types provided by the standard library</span> Rustの並行性を保証する<code>Sync</code>および<code>Send</code>特性は、標準ライブラリによって提供される型だけでなく、ユーザー定義型にも保証されます</span> </div><script>_addload(function(){_setupIW('com');_csi('en','ja','ch16-00-concurrency.html');});</script>