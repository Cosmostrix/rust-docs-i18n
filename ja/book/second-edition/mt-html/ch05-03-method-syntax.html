<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180709_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=ch05-03-method-syntax.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Method Syntax</span>メソッドの構文</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><i>Methods</i> are similar to functions: they&#39;re declared with the <code>fn</code> keyword and their name, they can have parameters and a return value, and they contain some code that is run when they&#39;re called from somewhere else.</span> <i>メソッド</i>は関数と似ています： <code>fn</code>キーワードとその名前で宣言されています。パラメータと戻り値を持つことができ、他の場所から呼び出されたときに実行されるコードが含まれています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, methods are different from functions in that they&#39;re defined within the context of a struct (or an enum or a trait object, which we cover in Chapters 6 and 17, respectively), and their first parameter is always <code>self</code> , which represents the instance of the struct the method is being called on.</span>しかし、メソッドは構造体（またはそれぞれ第6章と第17章で説明するenumまたはtraitオブジェクト）のコンテキスト内で定義されている点で関数と異なり、最初のパラメータは常に<code>self</code>であり、メソッドが呼び出されている構造体のインスタンス</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Defining Methods</span>メソッドの定義</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s change the <code>area</code> function that has a <code>Rectangle</code> instance as a parameter and instead make an <code>area</code> method defined on the <code>Rectangle</code> struct, as shown in Listing 5-13.</span>リスト5-13に示すように、 <code>Rectangle</code>インスタンスを持つ<code>area</code>関数をパラメータとして変更し、代わりに<code>Rectangle</code>構造体に定義された<code>area</code>メソッドを作ってみましょう。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l=#[derive(Debug)]></div><div data-l="struct Rectangle {"></div><div data-l="    width: u32,"></div><div data-l="    height: u32,"></div><div data-l=}></div><div data-l=""></div><div data-l="impl Rectangle {"></div><div data-l="    fn area(&amp;self) -&gt; u32 {"></div><div data-l="        self.width * self.height"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let rect1 = Rectangle { width: 30, height: 50 };"></div><div data-l=""></div><div data-l="    println!("></div><div data-l="        &quot;The area of the rectangle is {} square pixels.&quot;,"></div><div data-l="        rect1.area()"></div><div data-l="    );"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 5-13: Defining an <code>area</code> method on the <code>Rectangle</code> struct</span></span> <span class=caption>リスト5-13： <code>Rectangle</code> <code>area</code>メソッドを定義するstruct</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To define the function within the context of <code>Rectangle</code> , we start an <code>impl</code> (implementation) block.</span> <code>Rectangle</code>のコンテキスト内で関数を定義するには、 <code>impl</code> （実装）ブロックを開始します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then we move the <code>area</code> function within the <code>impl</code> curly brackets and change the first (and in this case, only) parameter to be <code>self</code> in the signature and everywhere within the body.</span>その後、我々は、移動<code>area</code>内の関数<code>impl</code>中括弧を最初に変更し（この場合、唯一の）パラメータがあると<code>self</code>署名で、どこでも体内で。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In <code>main</code> , where we called the <code>area</code> function and passed <code>rect1</code> as an argument, we can instead use <i>method syntax</i> to call the <code>area</code> method on our <code>Rectangle</code> instance.</span>では<code>main</code> 、我々はと呼ばれる場所、 <code>area</code>機能を渡された<code>rect1</code>引数として、我々は代わりに呼び出す<i>メソッドの構文を</i>使用することができる<code>area</code>私たちの上のメソッド<code>Rectangle</code>インスタンスを。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The method syntax goes after an instance: we add a dot followed by the method name, parentheses, and any arguments.</span>メソッドの構文は、インスタンスの後に続きます。メソッド名、括弧、および引数の後にドットを追加します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In the signature for <code>area</code> , we use <code>&amp;self</code> instead of <code>rectangle: &amp;Rectangle</code> because Rust knows the type of <code>self</code> is <code>Rectangle</code> due to this method&#39;s being inside the <code>impl Rectangle</code> context.</span> <code>area</code>のシグネチャでは、 <code>impl Rectangle</code>コンテキスト内にあるため、Rustは<code>self</code>の型が<code>Rectangle</code>ことを知っているため、 <code>rectangle: &amp;Rectangle</code>代わりに<code>&amp;self</code>を使用します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that we still need to use the <code>&amp;</code> before <code>self</code> , just as we did in <code>&amp;Rectangle</code> .</span>私たちは<code>&amp;Rectangle</code>ように<code>&amp;</code>前に<code>self</code>を使う必要があることに注意してください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Methods can take ownership of <code>self</code> , borrow <code>self</code> immutably as we&#39;ve done here, or borrow <code>self</code> mutably, just as they can any other parameter.</span>メソッドは、 <code>self</code>所有権を取ることができ、ここでやったように<code>self</code>不変<code>self</code>に借りたり、他のパラメータと同じように<code>self</code>可変的に借りることができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ve chosen <code>&amp;self</code> here for the same reason we used <code>&amp;Rectangle</code> in the function version: we don&#39;t want to take ownership, and we just want to read the data in the struct, not write to it.</span>関数バージョンで<code>&amp;Rectangle</code>を使用したのと同じ理由で、ここで<code>&amp;self</code>を選択しました。所有権を奪いたくないので、構造体のデータを読み込み、書き込みしないだけです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we wanted to change the instance that we&#39;ve called the method on as part of what the method does, we&#39;d use <code>&amp;mut self</code> as the first parameter.</span>メソッドを呼び出すインスタンスをメソッドの一部として変更したい場合は、 <code>&amp;mut self</code>を最初のパラメータとして使用します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Having a method that takes ownership of the instance by using just <code>self</code> as the first parameter is rare;</span>最初のパラメータとして<code>self</code>だけを使用してインスタンスの所有権を取得するメソッドを持つことはまれです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">this technique is usually used when the method transforms <code>self</code> into something else and you want to prevent the caller from using the original instance after the transformation.</span>このメソッドは、通常、メソッドが<code>self</code>を何かに変換し、呼び出し元が変換後に元のインスタンスを使用しないようにしたい場合に使用されます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The main benefit of using methods instead of functions, in addition to using method syntax and not having to repeat the type of <code>self</code> in every method&#39;s signature, is for organization.</span>関数の代わりにメソッドを使用する主な利点は、メソッド構文を使用することに加えて、すべてのメソッドのシグネチャで<code>self</code>のタイプを繰り返す必要がないことです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ve put all the things we can do with an instance of a type in one <code>impl</code> block rather than making future users of our code search for capabilities of <code>Rectangle</code> in various places in the library we provide.</span>私たちは、私たちが提供するライブラリのさまざまな場所で<code>Rectangle</code>機能をコード検索する将来のユーザを作るのではなく、1つの<code>impl</code>ブロックでタイプのインスタンスを使ってできることをすべて<code>impl</code>ました。</span> </p><br><blockquote><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Where&#39;s the <code>-&gt;</code> Operator?</span> <code>-&gt;</code>演算子はどこですか？</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In C and C++, two different operators are used for calling methods: you use <code>.</code></span> CおよびC ++では、メソッドを呼び出すために2つの異なる演算子が使用されます<code>.</code></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">if you&#39;re calling a method on the object directly and <code>-&gt;</code> if you&#39;re calling the method on a pointer to the object and need to dereference the pointer first.</span>あなたは直接オブジェクトのメソッドを呼び出すとしている場合<code>-&gt;</code>あなたはオブジェクトへのポインタでメソッドを呼び出すと、最初のポインタを間接参照する必要がしている場合。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In other words, if <code>object</code> is a pointer, <code>object-&gt;something()</code> is similar to <code>(*object).something()</code> .</span>つまり、 <code>object</code>がポインタの場合、 <code>object-&gt;something()</code>は<code>(*object).something()</code>と似てい<code>(*object).something()</code> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust doesn&#39;t have an equivalent to the <code>-&gt;</code> operator;</span> Rustには、 <code>-&gt;</code>演算子と同等のものはありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">instead, Rust has a feature called <i>automatic referencing and dereferencing</i> .</span>代わりに、Rustには<i>自動参照と参照解除</i>と呼ばれる機能があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Calling methods is one of the few places in Rust that has this behavior.</span>メソッドを呼び出すことは、この動作を持つRustの数少ない場所の1つです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here&#39;s how it works: when you call a method with <code>object.something()</code> , Rust automatically adds in <code>&amp;</code> , <code>&amp;mut</code> , or <code>*</code> so <code>object</code> matches the signature of the method.</span>これはどのように動作するのですか： <code>object.something()</code>でメソッドを呼び出すと、Rustは<code>&amp;</code> 、 <code>&amp;mut</code> 、または<code>*</code>自動的に追加し<code>object</code>はメソッドのシグネチャに一致します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In other words, the following are the same:</span>言い換えれば、以下は同じです：</span> </p><br><div data-lang=rust><div data-l="# #[derive(Debug,Copy,Clone)]"></div><div data-l="# struct Point {"></div><div data-l="#     x: f64,"></div><div data-l="#     y: f64,"></div><div data-l="# }"></div><div data-l=#></div><div data-l="# impl Point {"></div><div data-l="#    fn distance(&amp;self, other: &amp;Point) -&gt; f64 {"></div><div data-l="#        let x_squared = f64::powi(other.x - self.x, 2);"></div><div data-l="#        let y_squared = f64::powi(other.y - self.y, 2);"></div><div data-l=#></div><div data-l="#        f64::sqrt(x_squared + y_squared)"></div><div data-l="#    }"></div><div data-l="# }"></div><div data-l="# let p1 = Point { x: 0.0, y: 0.0 };"></div><div data-l="# let p2 = Point { x: 5.0, y: 6.5 };"></div><div data-l=p1.distance(&amp;p2);></div><div data-l=(&amp;p1).distance(&amp;p2);></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The first one looks much cleaner.</span>最初のものははるかにきれいに見えます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This automatic referencing behavior works because methods have a clear receiver—the type of <code>self</code> .</span>方法は明確な受信機の種類があるので、この自動参照の挙動が働く<code>self</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Given the receiver and name of a method, Rust can figure out definitively whether the method is reading ( <code>&amp;self</code> ), mutating ( <code>&amp;mut self</code> ), or consuming ( <code>self</code> ).</span>レシーバとメソッドの名前が与えられた場合、Rustはメソッドが読み込み（ <code>&amp;self</code> ）、変異（ <code>&amp;mut self</code> ）、または消費（ <code>self</code> ）のいずれであるかを決定することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The fact that Rust makes borrowing implicit for method receivers is a big part of making ownership ergonomic in practice.</span> Rustがメソッド受信者に暗黙的に借り入れるという事実は、実際に人間工学に基づいて所有することの大きな部分です。</span> </p></blockquote><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Methods with More Parameters</span>より多くのパラメータを持つメソッド</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s practice using methods by implementing a second method on the <code>Rectangle</code> struct.</span> <code>Rectangle</code>構造体に2番目のメソッドを実装して、メソッドを使用して練習しましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This time, we want an instance of <code>Rectangle</code> to take another instance of <code>Rectangle</code> and return <code>true</code> if the second <code>Rectangle</code> can fit completely within <code>self</code> ;</span>今回は、のインスタンスたい<code>Rectangle</code>の別のインスタンス取るために<code>Rectangle</code>して返す<code>true</code>二場合<code>Rectangle</code>内に完全に適合することができ<code>self</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">otherwise it should return <code>false</code> .</span>それ以外の場合は<code>false</code>を返す必要があり<code>false</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That is, we want to be able to write the program shown in Listing 5-14, once we&#39;ve defined the <code>can_hold</code> method.</span>つまり、 <code>can_hold</code>メソッドを定義すると、リスト5-14に示すプログラムを作成できます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust,ignore><div data-l="fn main() {"></div><div data-l="    let rect1 = Rectangle { width: 30, height: 50 };"></div><div data-l="    let rect2 = Rectangle { width: 10, height: 40 };"></div><div data-l="    let rect3 = Rectangle { width: 60, height: 45 };"></div><div data-l=""></div><div data-l="    println!(&quot;Can rect1 hold rect2? {}&quot;, rect1.can_hold(&amp;rect2));"></div><div data-l="    println!(&quot;Can rect1 hold rect3? {}&quot;, rect1.can_hold(&amp;rect3));"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 5-14: Using the as-yet-unwritten <code>can_hold</code> method</span></span> <span class=caption>リスト5-14： <code>can_hold</code> -yet- <code>can_hold</code> - <code>can_hold</code>メソッドの使用</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">And the expected output would look like the following, because both dimensions of <code>rect2</code> are smaller than the dimensions of <code>rect1</code> but <code>rect3</code> is wider than <code>rect1</code> :</span>両方の寸法いるためと予想される出力は、次のようになり<code>rect2</code>の寸法よりも小さい<code>rect1</code>が、 <code>rect3</code>よりも広くなっている<code>rect1</code> ：</span> </p><br><div data-lang=text><div data-l="Can rect1 hold rect2? true"></div><div data-l="Can rect1 hold rect3? false"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We know we want to define a method, so it will be within the <code>impl Rectangle</code> block.</span>私たちは、メソッドを定義したいので、 <code>impl Rectangle</code>ブロック内にあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The method name will be <code>can_hold</code> , and it will take an immutable borrow of another <code>Rectangle</code> as a parameter.</span>メソッド名は<code>can_hold</code>になり、パラメータとして別の<code>Rectangle</code>不変な借用を取ります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can tell what the type of the parameter will be by looking at the code that calls the method: <code>rect1.can_hold(&amp;rect2)</code> passes in <code>&amp;rect2</code> , which is an immutable borrow to <code>rect2</code> , an instance of <code>Rectangle</code> .</span> <code>rect1.can_hold(&amp;rect2)</code>は<code>&amp;rect2</code> 。これは、 <code>Rectangle</code>インスタンスである<code>rect2</code>への不変の借りです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This makes sense because we only need to read <code>rect2</code> (rather than write, which would mean we&#39;d need a mutable borrow), and we want <code>main</code> to retain ownership of <code>rect2</code> so we can use it again after calling the <code>can_hold</code> method.</span>我々は唯一の読む必要があるので、これは理にかなって<code>rect2</code> （むしろ書くよりも、私たちは可変ボローが必要があると思います意味している）、そして我々はしたい<code>main</code>の所有権を保持する<code>rect2</code>我々が呼び出した後に再使用できるよう<code>can_hold</code>方法を。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The return value of <code>can_hold</code> will be a Boolean, and the implementation will check whether the width and height of <code>self</code> are both greater than the width and height of the other <code>Rectangle</code> , respectively.</span> <code>can_hold</code>の戻り値はブール値になり、実装は<code>self</code>幅と高さの両方がそれぞれ他の<code>Rectangle</code>幅と高さよりも大きいかどうかをチェックします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s add the new <code>can_hold</code> method to the <code>impl</code> block from Listing 5-13, shown in Listing 5-15.</span>リスト5-13の<code>impl</code>ブロックに新しい<code>can_hold</code>メソッドを追加しましょう（リスト5-15を参照）。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="# #[derive(Debug)]"></div><div data-l="# struct Rectangle {"></div><div data-l="#     width: u32,"></div><div data-l="#     height: u32,"></div><div data-l="# }"></div><div data-l=#></div><div data-l="impl Rectangle {"></div><div data-l="    fn area(&amp;self) -&gt; u32 {"></div><div data-l="        self.width * self.height"></div><div data-l="    }"></div><div data-l=""></div><div data-l="    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {"></div><div data-l="        self.width &gt; other.width &amp;&amp; self.height &gt; other.height"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 5-15: Implementing the <code>can_hold</code> method on <code>Rectangle</code> that takes another <code>Rectangle</code> instance as a parameter</span></span> <span class=caption>リスト5-15：別の<code>Rectangle</code>インスタンスをパラメータとして取る<code>Rectangle</code>で<code>can_hold</code>メソッドを実装する</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When we run this code with the <code>main</code> function in Listing 5-14, we&#39;ll get our desired output.</span>リスト5-14の<code>main</code>関数でこのコードを実行すると、望ましい出力が得られます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Methods can take multiple parameters that we add to the signature after the <code>self</code> parameter, and those parameters work just like parameters in functions.</span>メソッドは、 <code>self</code>パラメータの後にシグネチャに追加する複数のパラメータを取ることができ、これらのパラメータは関数のパラメータと同様に機能します。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Associated Functions</span>関連する関数</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Another useful feature of <code>impl</code> blocks is that we&#39;re allowed to define functions within <code>impl</code> blocks that <i>don&#39;t</i> take <code>self</code> as a parameter.</span> <code>impl</code>ブロックのもう一つの有用な機能は、 <code>self</code>をパラメータとして取ら<i>ない</i> <code>impl</code>ブロック内の関数を定義することが許されていることです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These are called <i>associated functions</i> because they&#39;re associated with the struct.</span>これらは<i>関連する関数</i>と呼ばれ、構造体に関連付けられているためです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">They&#39;re still functions, not methods, because they don&#39;t have an instance of the struct to work with.</span>それらは機能するものであり、メソッドではありません。構造体のインスタンスがないからです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You&#39;ve already used the <code>String::from</code> associated function.</span>関連する関数<code>String::from</code>既に<code>String::from</code>使用しています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Associated functions are often used for constructors that will return a new instance of the struct.</span>関連する関数は、構造体の新しいインスタンスを返すコンストラクタでよく使用されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, we could provide an associated function that would have one dimension parameter and use that as both width and height, thus making it easier to create a square <code>Rectangle</code> rather than having to specify the same value twice:</span>たとえば、次元パラメータを1つ持ち、幅と高さの両方として使用する関連する関数を提供すると、同じ値を2回指定するのではなく正方形の<code>Rectangle</code>簡単に作成できます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="# #[derive(Debug)]"></div><div data-l="# struct Rectangle {"></div><div data-l="#     width: u32,"></div><div data-l="#     height: u32,"></div><div data-l="# }"></div><div data-l=#></div><div data-l="impl Rectangle {"></div><div data-l="    fn square(size: u32) -&gt; Rectangle {"></div><div data-l="        Rectangle { width: size, height: size }"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To call this associated function, we use the <code>::</code> syntax with the struct name;</span>この関連する関数を呼び出すには、 <code>::</code>構文に構造体名を使用します。</span> <code>let sq = Rectangle::square(3);</code> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">is an example.</span>例です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This function is namespaced by the struct: the <code>::</code> syntax is used for both associated functions and namespaces created by modules.</span>この関数は構造体によって名前空間を持ちます。 <code>::</code>構文は、モジュールによって作成された関連する関数と名前空間の両方に使用されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll discuss modules in Chapter 7.</span>モジュールについては第7章で説明します。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Multiple <code>impl</code> Blocks</span>多重<code>impl</code>ブロック</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Each struct is allowed to have multiple <code>impl</code> blocks.</span>各構造体は複数の<code>impl</code>ブロックを持つことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, Listing 5-15 is equivalent to the code shown in Listing 5-16, which has each method in its own <code>impl</code> block.</span>たとえば、コードリスト5-15はコードリスト5-16のコードと同じです。リスト5-16では、各メソッドが独自の<code>impl</code>ブロックにあります。</span> </p><br><div data-lang=rust><div data-l="# #[derive(Debug)]"></div><div data-l="# struct Rectangle {"></div><div data-l="#     width: u32,"></div><div data-l="#     height: u32,"></div><div data-l="# }"></div><div data-l=#></div><div data-l="impl Rectangle {"></div><div data-l="    fn area(&amp;self) -&gt; u32 {"></div><div data-l="        self.width * self.height"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="impl Rectangle {"></div><div data-l="    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {"></div><div data-l="        self.width &gt; other.width &amp;&amp; self.height &gt; other.height"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 5-16: Rewriting Listing 5-15 using multiple <code>impl</code> blocks</span></span> <span class=caption>リスト5-16：複数の<code>impl</code>ブロックを使用したリスティングリスト5-15</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There&#39;s no reason to separate these methods into multiple <code>impl</code> blocks here, but this is valid syntax.</span>これらのメソッドを複数の<code>impl</code>ブロックに分割する理由はありませんが、これは有効な構文です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll see a case in which multiple <code>impl</code> blocks are useful in Chapter 10, where we discuss generic types and traits.</span>第10章では、複数の<code>impl</code>ブロックが有用な場合があります。第10章では、ジェネリック型と特性について説明します。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Summary</span>概要</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Structs let you create custom types that are meaningful for your domain.</span>構造体を使用すると、ドメインにとって意味のあるカスタムタイプを作成できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">By using structs, you can keep associated pieces of data connected to each other and name each piece to make your code clear.</span>構造体を使用することにより、関連するデータを相互に接続し、各部分に名前を付けてコードを明確にすることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Methods let you specify the behavior that instances of your structs have, and associated functions let you namespace functionality that is particular to your struct without having an instance available.</span>メソッドを使用すると、構造体のインスタンスが持つ動作を指定できます。また、関連する関数を使用すると、インスタンスを使用せずに構造体に固有の名前空間機能を使用できます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But structs aren&#39;t the only way you can create custom types: let&#39;s turn to Rust&#39;s enum feature to add another tool to your toolbox.</span>しかし、構造体はカスタムタイプを作成する唯一の方法ではありません：あなたのツールボックスに別のツールを追加するために、Rustのenum機能に切り替えましょう。</span> </p><script>_addload(function(){_setupIW('com');_csi('en','ja','ch05-03-method-syntax.html');});</script>