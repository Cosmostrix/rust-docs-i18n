<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180709_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=ch04-02-references-and-borrowing.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">References and Borrowing</span>参照と借用</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The issue with the tuple code in Listing 4-5 is that we have to return the <code>String</code> to the calling function so we can still use the <code>String</code> after the call to <code>calculate_length</code> , because the <code>String</code> was moved into <code>calculate_length</code> .</span>リスト4-5のタプルコードの問題は、私たちが返す必要があることである<code>String</code> 、我々はまだ使用できるように、呼び出し元の関数に<code>String</code>呼び出した後<code>calculate_length</code>ので、 <code>String</code>に移された<code>calculate_length</code> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here is how you would define and use a <code>calculate_length</code> function that has a reference to an object as a parameter instead of taking ownership of the value:</span>ここでは、値の所有権を取得するのではなく、オブジェクトへの参照をパラメータとして持つ<code>calculate_length</code>関数を定義して使用する方法を示します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="fn main() {"></div><div data-l="    let s1 = String::from(&quot;hello&quot;);"></div><div data-l=""></div><div data-l="    let len = calculate_length(&amp;s1);"></div><div data-l=""></div><div data-l="    println!(&quot;The length of '{}' is {}.&quot;, s1, len);"></div><div data-l=}></div><div data-l=""></div><div data-l="fn calculate_length(s: &amp;String) -&gt; usize {"></div><div data-l="    s.len()"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">First, notice that all the tuple code in the variable declaration and the function return value is gone.</span>最初に、変数宣言内のすべてのタプルコードと関数の戻り値がなくなったことに注目してください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Second, note that we pass <code>&amp;s1</code> into <code>calculate_length</code> and, in its definition, we take <code>&amp;String</code> rather than <code>String</code> .</span>第二に、我々は合格ことに注意してください<code>&amp;s1</code>に<code>calculate_length</code>と、その定義では、我々が取る<code>&amp;String</code>ではなく<code>String</code> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These ampersands are <i>references</i> , and they allow you to refer to some value without taking ownership of it.</span>これらのアンパサンドは<i>参照</i>であり、所有権を取らずに値を参照することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Figure 4-5 shows a diagram.</span>図4-5にダイアグラムを示します。</span> </p><br><p><img alt="＆s Stringを指すString s" src=img/trpl04-05.svg class=center /></p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Figure 4-5: A diagram of <code>&amp;String s</code> pointing at <code>String s1</code></span></span> <span class=caption>図4-5： <code>String s1</code>指す<code>&amp;String s</code>図</span></span> </p><br><blockquote><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note: The opposite of referencing by using <code>&amp;</code> is <i>dereferencing</i> , which is accomplished with the dereference operator, <code>*</code> .</span>注：使用して、参照の反対<code>&amp;</code>逆参照演算子を用いて達成される<i>間接参照</i>され、 <code>*</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll see some uses of the dereference operator in Chapter 8 and discuss details of dereferencing in Chapter 15.</span>第8章では逆参照演算子をいくつか使用し、第15章では逆参照の詳細について説明します。</span> </p></blockquote><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s take a closer look at the function call here:</span>ここで関数呼び出しを詳しく見てみましょう：</span> </p><br><div data-lang=rust><div data-l="# fn calculate_length(s: &amp;String) -&gt; usize {"></div><div data-l="#     s.len()"></div><div data-l="# }"></div><div data-l="let s1 = String::from(&quot;hello&quot;);"></div><div data-l=""></div><div data-l="let len = calculate_length(&amp;s1);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>&amp;s1</code> syntax lets us create a reference that <i>refers</i> to the value of <code>s1</code> but does not own it.</span> <code>&amp;s1</code>構文は、私たちがの値を<i>参照する</i>参照作成することができます<code>s1</code>が、それを所有していませんが。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because it does not own it, the value it points to will not be dropped when the reference goes out of scope.</span>それが所有していないので、参照先が範囲外になると、その参照元が指している値は削除されません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Likewise, the signature of the function uses <code>&amp;</code> to indicate that the type of the parameter <code>s</code> is a reference.</span>同様に、関数のシグネチャは<code>&amp;</code>を使用して、パラメータ<code>s</code>型が参照であることを示します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s add some explanatory annotations:</span>説明的な注釈を追加しましょう：</span> </p><br><div data-lang=rust><div data-l="#//fn calculate_length(s: &amp;String) -&gt; usize { // s is a reference to a String"></div><div data-l="fn calculate_length(s: &amp;String) -&gt; usize { // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">s is a reference to a String</span> sは文字列への参照です</span> </div><div data-l="    s.len()"></div><div data-l="#//} // Here, s goes out of scope. But because it does not have ownership of what"></div><div data-l="#  // it refers to, nothing happens."></div><div data-l="} // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here, s goes out of scope.</span>ここで、sは範囲外になる。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But because it does not have ownership of what it refers to, nothing happens.</span>しかし、それが何を指しているの所有権がないため、何も起こりません。</span> </div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The scope in which the variable <code>s</code> is valid is the same as any function parameter&#39;s scope, but we don&#39;t drop what the reference points to when it goes out of scope because we don&#39;t have ownership.</span>変数<code>s</code>が有効であるスコープは、関数パラメータのスコープと同じですが、所有権を持たないためスコープから外れるときに参照が指すものを削除しません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When functions have references as parameters instead of the actual values, we won&#39;t need to return the values in order to give back ownership, because we never had ownership.</span>関数が実際の値ではなくパラメータとして参照を持つ場合、所有権を持たないため、所有権を返すために値を返す必要はありません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We call having references as function parameters <i>borrowing</i> .</span>我々は関数パラメータの<i>借用</i>として参照を持つことを呼ぶ。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As in real life, if a person owns something, you can borrow it from them.</span>実際の人生の場合と同様に、人が何かを所有していれば、その人からそれを借りることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When you&#39;re done, you have to give it back.</span>あなたが終わったら、あなたはそれを返さなければなりません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So what happens if we try to modify something we&#39;re borrowing?</span>借りているものを変更しようとするとどうなりますか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Try the code in Listing 4-6.</span>リスト4-6のコードを試してみてください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Spoiler alert: it doesn&#39;t work!</span>スポイラー警告：それは動作しません！</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust,ignore><div data-l="fn main() {"></div><div data-l="    let s = String::from(&quot;hello&quot;);"></div><div data-l=""></div><div data-l="    change(&amp;s);"></div><div data-l=}></div><div data-l=""></div><div data-l="fn change(some_string: &amp;String) {"></div><div data-l="    some_string.push_str(&quot;, world&quot;);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 4-6: Attempting to modify a borrowed value</span></span> <span class=caption>コードリスト4-6：借用した値を変更しようとしています</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here&#39;s the error:</span>ここにエラーがあります：</span> </p><br><div data-lang=text><div data-l="error[E0596]: cannot borrow immutable borrowed content `*some_string` as mutable"></div><div data-l=" --&gt; error.rs:8:5"></div><div data-l="  |"></div><div data-l="7 | fn change(some_string: &amp;String) {"></div><div data-l="  |                        ------- use `&amp;mut String` here to make mutable"></div><div data-l="8 |     some_string.push_str(&quot;, world&quot;);"></div><div data-l="  |     ^^^^^^^^^^^ cannot borrow as mutable"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Just as variables are immutable by default, so are references.</span>デフォルトで変数が不変であるのと同じように、参照もそうです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;re not allowed to modify something we have a reference to.</span>私たちは参照しているものを変更することはできません。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Mutable References</span>変更可能な参照</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can fix the error in the code from Listing 4-6 with just a small tweak:</span>リスト4-6のコードのエラーをわずかに微調整して修正できます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="fn main() {"></div><div data-l="    let mut s = String::from(&quot;hello&quot;);"></div><div data-l=""></div><div data-l="    change(&amp;mut s);"></div><div data-l=}></div><div data-l=""></div><div data-l="fn change(some_string: &amp;mut String) {"></div><div data-l="    some_string.push_str(&quot;, world&quot;);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">First, we had to change <code>s</code> to be <code>mut</code> .</span>まず、 <code>s</code>を<code>mut</code>に変更する必要がありました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then we had to create a mutable reference with <code>&amp;mut s</code> and accept a mutable reference with <code>some_string: &amp;mut String</code> .</span>次に、 <code>&amp;mut s</code>を使って可変参照を作成し、 <code>some_string: &amp;mut String</code>を使用して可変参照を受け入れる必要がありました。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But mutable references have one big restriction: you can have only one mutable reference to a particular piece of data in a particular scope.</span>ただし、変更可能な参照には大きな制限があります。特定のスコープ内の特定のデータに対して1つの可変参照のみを持つことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This code will fail:</span>このコードは失敗します：</span> </p><br><div data-lang=rust,ignore><div data-l="let mut s = String::from(&quot;hello&quot;);"></div><div data-l=""></div><div data-l="let r1 = &amp;mut s;"></div><div data-l="let r2 = &amp;mut s;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here&#39;s the error:</span>ここにエラーがあります：</span> </p><br><div data-lang=text><div data-l="error[E0499]: cannot borrow `s` as mutable more than once at a time"></div><div data-l=" --&gt; borrow_twice.rs:5:19"></div><div data-l="  |"></div><div data-l="4 |     let r1 = &amp;mut s;"></div><div data-l="  |                   - first mutable borrow occurs here"></div><div data-l="5 |     let r2 = &amp;mut s;"></div><div data-l="  |                   ^ second mutable borrow occurs here"></div><div data-l="6 | }"></div><div data-l="  | - first borrow ends here"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This restriction allows for mutation but in a very controlled fashion.</span>この制限は突然変異を可能にするが、非常に制御された様式である。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It&#39;s something that new Rustaceans struggle with, because most languages let you mutate whenever you&#39;d like.</span>それは、ほとんどの言語があなたが好きなときにあなたが突然変異させるので、新しい錆びた人が苦労しているものです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The benefit of having this restriction is that Rust can prevent data races at compile time.</span>この制限を受ける利点は、Rustがコンパイル時にデータ競合を防止できることです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A <i>data race</i> is similar to a race condition and happens when these three behaviors occur:</span> <i>データレース</i>はレースコンディションに似ており、次の3つの動作が発生すると発生します。</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Two or more pointers access the same data at the same time.</span> 2つ以上のポインターが同じデータに同時にアクセスします。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">At least one of the pointers is being used to write to the data.</span>少なくとも1つのポインタがデータの書き込みに使用されています。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There&#39;s no mechanism being used to synchronize access to the data.</span>データへのアクセスを同期させるためのメカニズムはありません。</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Data races cause undefined behavior and can be difficult to diagnose and fix when you&#39;re trying to track them down at runtime;</span>データ競合は未定義の動作を引き起こし、実行時にそれらを追跡しようとしているときに診断して修正するのが難しい場合があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust prevents this problem from happening because it won&#39;t even compile code with data races!</span>錆は、データレースでコードをコンパイルしないので、この問題が起こらないようにします！</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As always, we can use curly brackets to create a new scope, allowing for multiple mutable references, just not <i>simultaneous</i> ones:</span>いつものように、我々は、複数の可変の参照のためだけに<i>同時</i>ではないものを許可する、新しいスコープを作成するために、中括弧を使用することができます。</span> </p><br><div data-lang=rust><div data-l="let mut s = String::from(&quot;hello&quot;);"></div><div data-l=""></div><div data-l={></div><div data-l="    let r1 = &amp;mut s;"></div><div data-l=""></div><div data-l="#//} // r1 goes out of scope here, so we can make a new reference with no problems."></div><div data-l="} // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">r1 goes out of scope here, so we can make a new reference with no problems.</span> r1はここで範囲外になるので、問題なく新しい参照を作成できます。</span> </div><div data-l=""></div><div data-l="let r2 = &amp;mut s;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A similar rule exists for combining mutable and immutable references.</span>可変と不変の参照を組み合わせるための同様の規則が存在する。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This code results in an error:</span>このコードはエラーになります：</span> </p><br><div data-lang=rust,ignore><div data-l="let mut s = String::from(&quot;hello&quot;);"></div><div data-l=""></div><div data-l="#//let r1 = &amp;s; // no problem"></div><div data-l="let r1 = &amp;s; // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">no problem</span>問題ない</span> </div><div data-l="#//let r2 = &amp;s; // no problem"></div><div data-l="let r2 = &amp;s; // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">no problem</span>問題ない</span> </div><div data-l="#//let r3 = &amp;mut s; // BIG PROBLEM"></div><div data-l="let r3 = &amp;mut s; // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">BIG PROBLEM</span>大問題</span> </div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here&#39;s the error:</span>ここにエラーがあります：</span> </p><br><div data-lang=text><div data-l="error[E0502]: cannot borrow `s` as mutable because it is also borrowed as"></div><div data-l=immutable></div><div data-l=" --&gt; borrow_thrice.rs:6:19"></div><div data-l="  |"></div><div data-l="#//4 |     let r1 = &amp;s; // no problem"></div><div data-l="4 |     let r1 = &amp;s; // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">no problem</span>問題ない</span> </div><div data-l="  |               - immutable borrow occurs here"></div><div data-l="#//5 |     let r2 = &amp;s; // no problem"></div><div data-l="5 |     let r2 = &amp;s; // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">no problem</span>問題ない</span> </div><div data-l="#//6 |     let r3 = &amp;mut s; // BIG PROBLEM"></div><div data-l="6 |     let r3 = &amp;mut s; // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">BIG PROBLEM</span>大問題</span> </div><div data-l="  |                   ^ mutable borrow occurs here"></div><div data-l="7 | }"></div><div data-l="  | - immutable borrow ends here"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Whew!</span>すごい！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We <i>also</i> cannot have a mutable reference while we have an immutable one.</span>不変のものがある間は、変更可能な参照を持つこと<i>も</i>できません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Users of an immutable reference don&#39;t expect the values to suddenly change out from under them!</span>不変参照のユーザーは、値が突然下から変更されることを期待しません！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, multiple immutable references are okay because no one who is just reading the data has the ability to affect anyone else&#39;s reading of the data.</span>しかし、複数の不変参照は大丈夫です。ただデータを読み込んでいる誰も他の人のデータの読書に影響を与えることはできないからです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Even though these errors may be frustrating at times, remember that it&#39;s the Rust compiler pointing out a potential bug early (at compile time rather than at runtime) and showing you exactly where the problem is.</span>これらのエラーは時には苛立つかもしれませんが、Rustコンパイラは潜在的なバグを早期に（実行時ではなくコンパイル時に）指摘し、問題のある場所を正確に示しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then you don&#39;t have to track down why your data isn&#39;t what you thought it was.</span>次に、あなたのデータがあなたが思っていたものではない理由を追跡する必要はありません。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Dangling References</span>ダングリングリファレンス</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In languages with pointers, it&#39;s easy to erroneously create a <i>dangling pointer</i> , a pointer that references a location in memory that may have been given to someone else, by freeing some memory while preserving a pointer to that memory.</span>ポインタを持つ言語では、 <i>ダングリングポインタ</i> 、つまり他の人に与えられた可能性のあるメモリ内の場所を参照するポインタを間違って作成することは簡単です。そのメモリへのポインタを保持しながらメモリを解放します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In Rust, by contrast, the compiler guarantees that references will never be dangling references: if you have a reference to some data, the compiler will ensure that the data will not go out of scope before the reference to the data does.</span>対照的に、Rustでは、コンパイラは参照がまったく参照を抱かないことを保証します。データへの参照がある場合、コンパイラはデータへの参照の前にデータが有効範囲外にならないようにします。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s try to create a dangling reference, which Rust will prevent with a compile-time error:</span> Rustがコンパイル時のエラーで防ぐことのできない、手間のかかる参照を作成しようとしましょう：</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust,ignore><div data-l="fn main() {"></div><div data-l="    let reference_to_nothing = dangle();"></div><div data-l=}></div><div data-l=""></div><div data-l="fn dangle() -&gt; &amp;String {"></div><div data-l="    let s = String::from(&quot;hello&quot;);"></div><div data-l=""></div><div data-l="    &amp;s"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here&#39;s the error:</span>ここにエラーがあります：</span> </p><br><div data-lang=text><div data-l="error[E0106]: missing lifetime specifier"></div><div data-l=" --&gt; main.rs:5:16"></div><div data-l="  |"></div><div data-l="5 | fn dangle() -&gt; &amp;String {"></div><div data-l="  |                ^ expected lifetime parameter"></div><div data-l="  |"></div><div data-l="  = help: this function's return type contains a borrowed value, but there is"></div><div data-l="  no value for it to be borrowed from"></div><div data-l="  = help: consider giving it a 'static lifetime"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This error message refers to a feature we haven&#39;t covered yet: lifetimes.</span>このエラーメッセージには、まだ説明していない機能、つまりライフタイムが含まれています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll discuss lifetimes in detail in Chapter 10. But, if you disregard the parts about lifetimes, the message does contain the key to why this code is a problem:</span>第10章では生涯について詳しく説明します。しかし、生涯についての部分を無視すると、メッセージにはなぜこのコードが問題であるかの鍵が含まれています。</span> </p><br><div data-lang=text><div data-l="this function's return type contains a borrowed value, but there is no value"></div><div data-l="for it to be borrowed from."></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s take a closer look at exactly what&#39;s happening at each stage of our <code>dangle</code> code:</span> <code>dangle</code>コードの各段階で何が起きているのかを詳しく見てみましょう。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust,ignore><div data-l="#//fn dangle() -&gt; &amp;String { // dangle returns a reference to a String"></div><div data-l="fn dangle() -&gt; &amp;String { // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">dangle returns a reference to a String</span> dangleはStringへの参照を返します</span> </div><div data-l=""></div><div data-l="#//    let s = String::from(&quot;hello&quot;); // s is a new String"></div><div data-l="    let s = String::from(&quot;hello&quot;); // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">s is a new String</span> sは新しいStringです</span> </div><div data-l=""></div><div data-l="#//    &amp;s // we return a reference to the String, s"></div><div data-l="    &amp;s // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">we return a reference to the String, s</span> Stringへの参照を返します。</span> </div><div data-l="#//} // Here, s goes out of scope, and is dropped. Its memory goes away."></div><div data-l="#  // Danger!"></div><div data-l="} // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here, s goes out of scope, and is dropped.</span>ここでは、範囲外になり、削除されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Its memory goes away.</span>その記憶は消え去る。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Danger!</span>危険！</span> </div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because <code>s</code> is created inside <code>dangle</code> , when the code of <code>dangle</code> is finished, <code>s</code> will be deallocated.</span> <code>s</code>は<code>dangle</code>中に作成されるため、 <code>dangle</code>のコードが終了すると、 <code>s</code>は割り当て解除されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But we tried to return a reference to it.</span>しかし、私たちはそれへの参照を返そうとしました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That means this reference would be pointing to an invalid <code>String</code> That&#39;s no good!</span>これは、この参照が無効な<code>String</code>指していることを意味します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust won&#39;t let us do this.</span>錆は私たちにこれをさせません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The solution here is to return the <code>String</code> directly:</span>ここでの解決方法は、 <code>String</code>直接返すことです。</span> </p><br><div data-lang=rust><div data-l="fn no_dangle() -&gt; String {"></div><div data-l="    let s = String::from(&quot;hello&quot;);"></div><div data-l=""></div><div data-l="    s"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This works without any problems.</span>これは問題なく動作します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Ownership is moved out, and nothing is deallocated.</span>所有権が移動され、割り当てが解除されることはありません。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The Rules of References</span>参照ルール</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s recap what we&#39;ve discussed about references:</span>参考文献について議論した内容を要約しましょう。</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">At any given time, you can have <i>either</i> one mutable reference <i>or</i> any number of immutable references.</span>任意の時点で、あなたは、1つの不定参照<i>または</i>不変の参照、任意の数の<i>いずれかを</i>持つことができます。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">References must always be valid.</span>参照は常に有効でなければなりません。</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Next, we&#39;ll look at a different kind of reference: slices.</span>次に、異なる種類の参照：スライスを見てみましょう。</span> </p><script>_addload(function(){_setupIW('com');_csi('en','ja','ch04-02-references-and-borrowing.html');});</script>