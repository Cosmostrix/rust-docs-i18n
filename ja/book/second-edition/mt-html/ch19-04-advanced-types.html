<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180709_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=ch19-04-advanced-types.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Advanced Types</span>高度なタイプ</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The Rust type system has some features that we&#39;ve mentioned in this book but haven&#39;t yet discussed.</span> Rustタイプのシステムには、本書で述べたいくつかの機能がありますが、まだ説明はしていません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll start by discussing newtypes in general as we examine why newtypes are useful as types.</span>新しい型の一般的な議論から始めることから、newtypeが型として有益な理由を調べます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then we&#39;ll move on to type aliases, a feature similar to newtypes but with slightly different semantics.</span>次に、newtypesに似ているが少し意味が異なるエイリアスを入力します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll also discuss the <code>€</code> type and dynamically sized types.</span>また<code>€</code>タイプと動的なサイズのタイプについても説明します。</span> </p><br><blockquote><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note: The next section assumes you&#39;ve read the earlier section “The Newtype Pattern to Implement External Traits on External Types.”</span>注：次のセクションでは、前のセクション「外部型に外部特性を実装するためのNewtypeパターン」を読んだことを前提としています。</span> </p></blockquote><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Using the Newtype Pattern for Type Safety and Abstraction</span>型の安全性と抽象化のためのNewtypeパターンの使用</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The newtype pattern is useful for tasks beyond those we&#39;ve discussed so far, including statically enforcing that values are never confused and indicating the units of a value.</span> newtypeパターンは、値が混乱することがなく、値の単位を示すことを静的に強制するなど、これまで説明したこと以外のタスクに役立ちます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You saw an example of using newtypes to indicate units in Listing 19-23: recall that the <code>Millimeters</code> and <code>Meters</code> structs wrapped <code>u32</code> values in a newtype.</span>リスト19-23のユニットを示すためにnewtypesを使用する例を見てきました： <code>Millimeters</code>と<code>Meters</code>構造体が<code>u32</code>値をラップしたことを思い出してください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we wrote a function with a parameter of type <code>Millimeters</code> , we couldn&#39;t compile a program that accidentally tried to call that function with a value of type <code>Meters</code> or a plain <code>u32</code> .</span> <code>Millimeters</code>型のパラメータを持つ関数を書いた場合、誤ってその関数を<code>Meters</code>型の値または普通の<code>u32</code>型の値で呼び出そうとしたプログラムをコンパイルできませんでした。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Another use of the newtype pattern is in abstracting away some implementation details of a type: the new type can expose a public API that is different from the API of the private inner type if we used the new type directly to restrict the available functionality, for example.</span> newtypeパターンのもう1つの使用法は、型の実装の詳細を抽象化することです。新しい型は、新しい型を直接使用して使用可能な機能を制限すると、private型のAPIとは異なるpublic APIを公開することができます。例。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Newtypes can also hide internal implementation.</span>ニュータイプは、内部実装を隠すこともできます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, we could provide a <code>People</code> type to wrap a <code>HashMap&lt;i32, String&gt;</code> that stores a person&#39;s ID associated with their name.</span>たとえば、名前に関連付けられた人のIDを格納する<code>HashMap&lt;i32, String&gt;</code>をラップする<code>People</code>型を提供できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Code using <code>People</code> would only interact with the public API we provide, such as a method to add a name string to the <code>People</code> collection;</span> <code>People</code>を使用するコードは、 <code>People</code>コレクションに名前文字列を追加するメソッドなど、私たちが提供する公開APIとのみ対話します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">that code wouldn&#39;t need to know that we assign an <code>i32</code> ID to names internally.</span>そのコードは内部的に名前に<code>i32</code> IDを割り当てることを知る必要はありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The newtype pattern is a lightweight way to achieve encapsulation to hide implementation details, which we discussed in the “Encapsulation that Hides Implementation Details” section of Chapter 17.</span> newtypeパターンは、実装の詳細を隠すためのカプセル化を実現するための軽量な方法です。これについては、第17章の「実装の詳細を隠すカプセル化」のセクションで説明しました。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Creating Type Synonyms with Type Aliases</span>タイプエイリアスを持つタイプシノニムの作成</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Along with the newtype pattern, Rust provides the ability to declare a <i>type alias</i> to give an existing type another name.</span> newtypeパターンに加えて、Rustは<i>型エイリアス</i>を宣言して既存の型に別の名前を与える機能を提供します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For this we use the <code>type</code> keyword.</span>このためには、 <code>type</code>キーワードを使用します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, we can create the alias <code>Kilometers</code> to <code>i32</code> like so:</span>たとえば、次のように<code>i32</code>エイリアス<code>Kilometers</code>を作成できます。</span> </p><br><div data-lang=rust><div data-l="type Kilometers = i32;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now, the alias <code>Kilometers</code> is a <i>synonym</i> for <code>i32</code> ;</span>さて、 <code>Kilometers</code>の別名は<code>i32</code> <i>同義語</i>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">unlike the <code>Millimeters</code> and <code>Meters</code> types we created in Listing 19-23, <code>Kilometers</code> is not a separate, new type.</span>異なり<code>Millimeters</code>と<code>Meters</code>我々は、リスト19-23で作成したタイプ、 <code>Kilometers</code>別の、新しいタイプではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Values that have the type <code>Kilometers</code> will be treated the same as values of type <code>i32</code> :</span> <code>Kilometers</code>タイプの値は、タイプ<code>i32</code>値と同じように扱われます。</span> </p><br><div data-lang=rust><div data-l="type Kilometers = i32;"></div><div data-l=""></div><div data-l="let x: i32 = 5;"></div><div data-l="let y: Kilometers = 5;"></div><div data-l=""></div><div data-l="println!(&quot;x + y = {}&quot;, x + y);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because <code>Kilometers</code> and <code>i32</code> are the same type, we can add values of both types and we can pass <code>Kilometers</code> values to functions that take <code>i32</code> parameters.</span> <code>Kilometers</code>と<code>i32</code>は同じタイプなので、両方のタイプの値を追加することができ、 <code>i32</code>パラメーターを取る関数に<code>Kilometers</code>値を渡すことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, using this method, we don&#39;t get the type checking benefits that we get from the newtype pattern discussed earlier.</span>ただし、このメソッドを使用すると、前に説明したnewtypeパターンから得られる型チェックの利点は得られません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The main use case for type synonyms is to reduce repetition.</span>型シノニムの主な使用例は、繰り返しを減らすことです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, we might have a lengthy type like this:</span>たとえば、次のような長い型があるとします。</span> </p><br><div data-lang=rust,ignore><div data-l="Box&lt;Fn() + Send + 'static&gt;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Writing this lengthy type in function signatures and as type annotations all over the code can be tiresome and error prone.</span>この長い型を関数シグネチャと型アノテーションとしてコード全体に記述すると、面倒でエラーが発生する可能性があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Imagine having a project full of code like that in Listing 19-32.</span>リスト19-32のようなコードで完全なプロジェクトを持っていると想像してください。</span> </p><br><div data-lang=rust><div data-l="let f: Box&lt;Fn() + Send + 'static&gt; = Box::new(|| println!(&quot;hi&quot;));"></div><div data-l=""></div><div data-l="fn takes_long_type(f: Box&lt;Fn() + Send + 'static&gt;) {"></div><div data-l="#    // --snip--"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">--snip--</span> --snip--</span> </div><div data-l=}></div><div data-l=""></div><div data-l="fn returns_long_type() -&gt; Box&lt;Fn() + Send + 'static&gt; {"></div><div data-l="#    // --snip--"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">--snip--</span> --snip--</span> </div><div data-l="#     Box::new(|| ())"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 19-32: Using a long type in many places</span></span> <span class=caption>リスト19-32：多くの場所で長い型を使う</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A type alias makes this code more manageable by reducing the repetition.</span>型エイリアスは、繰り返しを減らすことによって、このコードをより管理しやすくします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In Listing 19-33, we&#39;ve introduced an alias named <code>Thunk</code> for the verbose type and can replace all uses of the type with the shorter alias <code>Thunk</code> .</span>リスト19-33では、冗長型の<code>Thunk</code>という別名を導入し、その型のすべての使用をより短い別名<code>Thunk</code>置き換えることができます。</span> </p><br><div data-lang=rust><div data-l="type Thunk = Box&lt;Fn() + Send + 'static&gt;;"></div><div data-l=""></div><div data-l="let f: Thunk = Box::new(|| println!(&quot;hi&quot;));"></div><div data-l=""></div><div data-l="fn takes_long_type(f: Thunk) {"></div><div data-l="#    // --snip--"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">--snip--</span> --snip--</span> </div><div data-l=}></div><div data-l=""></div><div data-l="fn returns_long_type() -&gt; Thunk {"></div><div data-l="#    // --snip--"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">--snip--</span> --snip--</span> </div><div data-l="#     Box::new(|| ())"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 19-33: Introducing a type alias <code>Thunk</code> to reduce repetition</span></span> <span class=caption>リスト19-33：タイプエイリアスの紹介<code>Thunk</code>繰り返しを減らすために</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This code is much easier to read and write!</span>このコードは読み書きがはるかに簡単です！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Choosing a meaningful name for a type alias can help communicate your intent as well ( <i>thunk</i> is a word for code to be evaluated at a later time, so it&#39;s an appropriate name for a closure that gets stored).</span>タイプエイリアスの意味のある名前を選択することで、あなたの意図を伝えるのに役立ちます（ <i>サンク</i>は後で評価されるコードのため、保存されるクロージャの適切な名前です）。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Type aliases are also commonly used with the <code>Result&lt;T, E&gt;</code> type for reducing repetition.</span>型エイリアスは<code>Result&lt;T, E&gt;</code>繰り返しを減らすために<code>Result&lt;T, E&gt;</code>型でもよく使用されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Consider the <code>std::io</code> module in the standard library.</span>標準ライブラリの<code>std::io</code>モジュールを考えてみましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">I/O operations often return a <code>Result&lt;T, E&gt;</code> to handle situations when operations fail to work.</span> I / O操作は、操作が失敗した場合の状況を処理するために<code>Result&lt;T, E&gt;</code>を返すことがよくあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This library has a <code>std::io::Error</code> struct that represents all possible I/O errors.</span>このライブラリには、すべての可能な入出力エラーを表す<code>std::io::Error</code>構造体があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Many of the functions in <code>std::io</code> will be returning <code>Result&lt;T, E&gt;</code> where the <code>E</code> is <code>std::io::Error</code> , such as these functions in the <code>Write</code> trait:</span> <code>std::io</code>関数の多くは、 <code>E</code>が<code>std::io::Error</code>である<code>Result&lt;T, E&gt;</code>返します。これらの関数は、 <code>Write</code> trait：</span> </p><br><div data-lang=rust><div data-l="use std::io::Error;"></div><div data-l="use std::fmt;"></div><div data-l=""></div><div data-l="pub trait Write {"></div><div data-l="    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize, Error&gt;;"></div><div data-l="    fn flush(&amp;mut self) -&gt; Result&lt;(), Error&gt;;"></div><div data-l=""></div><div data-l="    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;(), Error&gt;;"></div><div data-l="    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;(), Error&gt;;"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Result&lt;..., Error&gt;</code> is repeated a lot.</span> <code>Result&lt;..., Error&gt;</code>は頻繁に繰り返されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As such, <code>std::io</code> has this type of alias declaration:</span>したがって、 <code>std::io</code>は、このタイプのエイリアス宣言があります。</span> </p><br><div data-lang=rust,ignore><div data-l="type Result&lt;T&gt; = Result&lt;T, std::io::Error&gt;;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because this declaration is in the <code>std::io</code> module, we can use the fully qualified alias <code>std::io::Result&lt;T&gt;</code> —that is, a <code>Result&lt;T, E&gt;</code> with the <code>E</code> filled in as <code>std::io::Error</code> .</span>この宣言は<code>std::io</code>モジュールにあるので、完全修飾エイリアス<code>std::io::Result&lt;T&gt;</code>を使用することができます。つまり、 <code>Result&lt;T, E&gt;</code>は<code>E</code>を<code>std::io::Error</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Write</code> trait function signatures end up looking like this:</span> <code>Write</code> trait関数のシグネチャは次のようになります。</span> </p><br><div data-lang=rust,ignore><div data-l="pub trait Write {"></div><div data-l="    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;"></div><div data-l="    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;"></div><div data-l=""></div><div data-l="    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt;;"></div><div data-l="    fn write_fmt(&amp;mut self, fmt: Arguments) -&gt; Result&lt;()&gt;;"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The type alias helps in two ways: it makes code easier to write <i>and</i> it gives us a consistent interface across all of <code>std::io</code> .</span>タイプの別名は、2つの方法で役立ちます。それは書くのコードが容易になり<i>、</i>それが私たちのすべてにわたって一貫したインターフェース与え<code>std::io</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because it&#39;s an alias, it&#39;s just another <code>Result&lt;T, E&gt;</code> , which means we can use any methods that work on <code>Result&lt;T, E&gt;</code> with it, as well as special syntax like the <code>?</code></span>それはエイリアスなので、別の<code>Result&lt;T, E&gt;</code> 。これは<code>Result&lt;T, E&gt;</code>で動作するメソッドを使用できることを意味し<code>?</code></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">operator.</span>オペレーター。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The Never Type that Never Returns</span>決して戻らない絶対的なタイプ</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust has a special type named <code>€</code> that&#39;s known in type theory lingo as the <i>empty type</i> because it has no values.</span> Rustには、型理論lingoで<i>空の型</i>として知られている、値がないので、特別な型の<code>€</code>があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We prefer to call it the <i>never type</i> because it stands in the place of the return type when a function will never return.</span>関数が決して返ってこないときは、戻り型の代わりに立つので、 <i>これをnever型</i>と呼んでいます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here is an example:</span>次に例を示します。</span> </p><br><div data-lang=rust,ignore><div data-l="fn bar() -&gt; ! {"></div><div data-l="#    // --snip--"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">--snip--</span> --snip--</span> </div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This code is read as “the function <code>bar</code> returns never.” Functions that return never are called <i>diverging functions</i> .</span>このコードは、「関数<code>bar</code>は決して返さない」と解釈されます。決して返されない関数は<i>分岐関数</i>と呼ばれ<i>ます</i> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can&#39;t create values of the type <code>€</code> so <code>bar</code> can never possibly return.</span>我々は<code>bar</code>が決して戻ってこないように、タイプ<code>€</code>値を作成することはできません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But what use is a type you can never create values for?</span>しかし、あなたは価値を創造することができないタイプは何ですか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Recall the code from Listing 2-5;</span>リスト2-5のコードを思い出してください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">we&#39;ve reproduced part of it here in Listing 19-34.</span>リスト19-34にその一部を再現しました。</span> </p><br><div data-lang=rust><div data-l="# let guess = &quot;3&quot;;"></div><div data-l="# loop {"></div><div data-l="let guess: u32 = match guess.trim().parse() {"></div><div data-l="    Ok(num) =&gt; num,"></div><div data-l="    Err(_) =&gt; continue,"></div><div data-l=};></div><div data-l="# break;"></div><div data-l="# }"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 19-34: A <code>match</code> with an arm that ends in <code>continue</code></span></span> <span class=caption>リスト19-34： <code>continue</code>で終わるアームとの<code>match</code></span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">At the time, we skipped over some details in this code.</span>当時、このコードでいくつかの詳細をスキップしました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In Chapter 6 in “The <code>match</code> Control Flow Operator” section, we discussed that <code>match</code> arms must all return the same type.</span>第6章「 <code>match</code>コントロールフロー演算子」のセクションでは、 <code>match</code>アームはすべて同じ型を返さなければならないと説明しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So, for example, the following code doesn&#39;t work:</span>たとえば、次のコードは機能しません。</span> </p><br><div data-lang=rust,ignore><div data-l="let guess = match guess.trim().parse() {"></div><div data-l="    Ok(_) =&gt; 5,"></div><div data-l="    Err(_) =&gt; &quot;hello&quot;,"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The type of <code>guess</code> in this code would have to be an integer <i>and</i> a string, and Rust requires that <code>guess</code> have only one type.</span>このコードの<code>guess</code>のタイプは整数<i>と</i>文字列でなければならず、Rustは<code>guess</code>は1つのタイプしか持たないことが必要<code>guess</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So what does <code>continue</code> return?</span>だから何をし<code>continue</code>リターンを？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">How were we allowed to return a <code>u32</code> from one arm and have another arm that ends with <code>continue</code> in Listing 19-34?</span>どのようにして、1つのアームから<code>u32</code>を返すことを許されたのでしょうか？そしてリスト19-34に<code>continue</code>ます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As you might have guessed, <code>continue</code> has a <code>€</code> value.</span>あなたが推測したように、 <code>continue</code>は<code>€</code>値を持っています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That is, when Rust computes the type of <code>guess</code> , it looks at both match arms, the former with a value of <code>u32</code> and the latter with a <code>€</code> value.</span>つまり、Rustが<code>guess</code>のタイプを計算するとき、両方のマッチ・アームを調べます。前者は<code>u32</code>値を、後者は<code>€</code>値を持ちます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because <code>€</code> can never have a value, Rust decides that the type of <code>guess</code> is <code>u32</code> .</span> <code>€</code>は決して値を持つことができないので、Rustは<code>guess</code>のタイプを<code>u32</code>と決定します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The formal way of describing this behavior is that expressions of type <code>€</code> can be coerced into any other type.</span>この振る舞いを記述する正式な方法は、型<code>€</code>式を他の型に強制することができるということです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;re allowed to end this <code>match</code> arm with <code>continue</code> because <code>continue</code> doesn&#39;t return a value;</span> <code>continue</code>は値を返さないので、この<code>match</code>アームを<code>continue</code>終了することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">instead, it moves control back to the top of the loop, so in the <code>Err</code> case, we never assign a value to <code>guess</code> .</span>代わりに、制御をループの先頭に戻します。したがって、 <code>Err</code>場合、 <code>guess</code>する値を決して割り当てません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The never type is useful with the <code>panic€</code> macro as well.</span> never型は<code>panic€</code>マクロにも便利です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Remember the <code>unwrap</code> function that we call on <code>Option&lt;T&gt;</code> values to produce a value or panic?</span> <code>Option&lt;T&gt;</code>値を呼び出して値またはパニックを生成する<code>unwrap</code>関数を覚えていますか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here is its definition:</span>ここにその定義があります：</span> </p><br><div data-lang=rust,ignore><div data-l="impl&lt;T&gt; Option&lt;T&gt; {"></div><div data-l="    pub fn unwrap(self) -&gt; T {"></div><div data-l="        match self {"></div><div data-l="            Some(val) =&gt; val,"></div><div data-l="            None =&gt; panic!(&quot;called `Option::unwrap()` on a `None` value&quot;),"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this code, the same thing happens as in the <code>match</code> in Listing 19-34: Rust sees that <code>val</code> has the type <code>T</code> and <code>panic€</code> has the type <code>€</code> , so the result of the overall <code>match</code> expression is <code>T</code> .</span>このコードでは、同じことが起こるのように<code>match</code>リスト19-34で：錆がいることを見ている<code>val</code>型がある<code>T</code>と<code>panic€</code>タイプがある<code>€</code> 、その全体的な結果<code>match</code>式がある<code>T</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This code works because <code>panic€</code> doesn&#39;t produce a value;</span>このコードは<code>panic€</code>が値を生成しないために機能します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">it ends the program.</span>プログラムを終了します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In the <code>None</code> case, we won&#39;t be returning a value from <code>unwrap</code> , so this code is valid.</span> <code>None</code>場合、 <code>unwrap</code>から値を返さないので、このコードは有効です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">One final expression that has the type <code>€</code> is a <code>loop</code> :</span> <code>€</code>を持つ最後の式の1つは<code>loop</code>です。</span> </p><br><div data-lang=rust,ignore><div data-l="print!(&quot;forever &quot;);"></div><div data-l=""></div><div data-l="loop {"></div><div data-l="    print!(&quot;and ever &quot;);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here, the loop never ends, so <code>€</code> is the value of the expression.</span>ここで、ループは終了しないので、 <code>€</code>は式の値です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, this wouldn&#39;t be true if we included a <code>break</code> , because the loop would terminate when it got to the <code>break</code> .</span>私たちが含まれている場合しかし、これは真実ではないでしょう<code>break</code>それに着いたとき、ループが終了してしまうため、 <code>break</code> 。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Dynamically Sized Types and the <code>Sized</code> Trait</span>動的なサイズのタイプと<code>Sized</code>特性</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Due to Rust&#39;s need to know certain details, such as how much space to allocate for a value of a particular type, there is a corner of its type system that can be confusing: the concept of <i>dynamically sized types</i> .</span>特定のタイプの値にどれくらいのスペースを割り当てるかなど、細部を知る必要があるため、混乱を招く可能性のある型システムの一角があり<i>ます</i> 。 <i>動的なサイズのタイプの</i>概念です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Sometimes referred to as <i>DSTs</i> or <i>unsized types</i> , these types let us write code using values whose size we can know only at runtime.</span> <i>DST</i>または<i>unsized型</i>と呼ばれることもあり<i>ますが</i> 、これらの型では、実行時にしか認識できないサイズの値を使用してコードを記述できます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s dig into the details of a dynamically sized type called <code>str</code> , which we&#39;ve been using throughout the book.</span> <code>str</code>と呼ばれる動的なサイズの型の詳細を掘り下げてみましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That&#39;s right, not <code>&amp;str</code> , but <code>str</code> on its own, is a DST.</span>それは正しいです、 <code>&amp;str</code>ではなく、 <code>str</code>は単独で、DSTです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can&#39;t know how long the string is until runtime, meaning we can&#39;t create a variable of type <code>str</code> , nor can we take an argument of type <code>str</code> .</span>実行時までの文字列の長さはわかりません。つまり、 <code>str</code>型の変数を作成することはできません。また、 <code>str</code>型の引数を取ることもできません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Consider the following code, which does not work:</span>動作しない次のコードを考えてみましょう：</span> </p><br><div data-lang=rust,ignore><div data-l="let s1: str = &quot;Hello there!&quot;;"></div><div data-l="let s2: str = &quot;How's it going?&quot;;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust needs to know how much memory to allocate for any value of a particular type, and all values of a type must use the same amount of memory.</span> Rustは、特定の型の値に割り当てられるメモリの量を知る必要があり、ある型のすべての値は同じ量のメモリを使用する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If Rust allowed us to write this code, these two <code>str</code> values would need to take up the same amount of space.</span> Rustがこのコードを書くことを許可した場合、これらの2つの<code>str</code>値は同じ量のスペースを占める必要があり<code>str</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But they have different lengths: <code>s1</code> needs 12 bytes of storage and <code>s2</code> needs 15. This is why it&#39;s not possible to create a variable holding a dynamically sized type.</span>しかし、それらの長さは異なります<code>s1</code>は12バイトのストレージが必要であり、 <code>s2</code>は15が必要です。これは、動的にサイズの変更されたタイプを保持する変数を作成できない理由です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So what do we do?</span>どうしようか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this case, you already know the answer: we make the types of <code>s1</code> and <code>s2</code> a <code>&amp;str</code> rather than a <code>str</code> .</span>この場合、あなたはすでに答えを知っています。つまり、 <code>s1</code>と<code>s2</code>型を<code>&amp;str</code>ではなくa <code>&amp;str</code>し<code>str</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Recall that in the “String Slices” section of Chapter 4, we said the slice data structure stores the starting position and the length of the slice.</span>第4章の「文字列スライス」のセクションでは、スライスデータ構造にスライスの開始位置と長さが格納されていることを思い出してください。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So although a <code>&amp;T</code> is a single value that stores the memory address of where the <code>T</code> is located, a <code>&amp;str</code> is <i>two</i> values: the address of the <code>str</code> and its length.</span>がそう<code>&amp;T</code>ここでのメモリアドレス格納する単一の値であり、 <code>T</code>配置されているが、A <code>&amp;str</code>のアドレス： <i>二つの</i>値である<code>str</code>とその長さ。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As such, we can know the size of a <code>&amp;str</code> value at compile time: it&#39;s twice the length of a <code>usize</code> .</span>したがって、コンパイル時の<code>&amp;str</code>値のサイズはわかり<code>&amp;str</code> <code>usize</code>長さの2倍<code>usize</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That is, we always know the size of a <code>&amp;str</code> , no matter how long the string it refers to is.</span>つまり、文字列の長さに関係なく、 <code>&amp;str</code>サイズは常にわかり<code>&amp;str</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In general, this is the way in which dynamically sized types are used in Rust: they have an extra bit of metadata that stores the size of the dynamic information.</span>一般に、これはRustで動的に使用されるサイズのタイプが使用される方法です。動的情報のサイズを格納する余分なビットのメタデータがあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The golden rule of dynamically sized types is that we must always put values of dynamically sized types behind a pointer of some kind.</span>動的なサイズの型のゴールデンルールは、ある種のポインタの後ろに常に動的に大きさを持つ型の値を置かなければならないということです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can combine <code>str</code> with all kinds of pointers: for example, <code>Box&lt;str&gt;</code> or <code>Rc&lt;str&gt;</code> .</span>たとえば、 <code>Box&lt;str&gt;</code>や<code>Rc&lt;str&gt;</code>ように、 <code>str</code>とあらゆる種類のポインタを組み合わせることができ<code>Rc&lt;str&gt;</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In fact, you&#39;ve seen this before but with a different dynamically sized type: traits.</span>実際には、以前はこれを見たことがありますが、タイプが異なる動的なサイズの特性があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Every trait is a dynamically sized type we can refer to by using the name of the trait.</span>すべての形質は、形質の名前を使って参照できる動的なサイズのタイプです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In Chapter 17 in the “Using Trait Objects that Allow for Values of Different Types” section, we mentioned that to use traits as trait objects, we must put them behind a pointer, such as <code>&amp;Trait</code> or <code>Box&lt;Trait&gt;</code> ( <code>Rc&lt;Trait&gt;</code> would work too).</span>第17章「異なる型の値を許容する型オブジェクトの使用」のセクションでは、型をTraitオブジェクトとして使用するには、 <code>&amp;Trait</code>または<code>Box&lt;Trait&gt;</code> （ <code>Rc&lt;Trait&gt;</code>うまくいくだろう）。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To work with DSTs, Rust has a particular trait called the <code>Sized</code> trait to determine whether or not a type&#39;s size is known at compile time.</span> DSTで作業するために、Rustには<code>Sized</code>特性と呼ばれる特定の特性があり、コンパイル時に型のサイズが分かっているかどうかを判断します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This trait is automatically implemented for everything whose size is known at compile time.</span>この特性は、コンパイル時にサイズがわかっているすべてのものに対して自動的に実装されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In addition, Rust implicitly adds a bound on <code>Sized</code> to every generic function.</span>さらに、Rustは、 <code>Sized</code>束縛を暗黙的にすべての汎用関数に追加します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That is, a generic function definition like this:</span>つまり、次のような汎用関数の定義です。</span> </p><br><div data-lang=rust,ignore><div data-l="fn generic&lt;T&gt;(t: T) {"></div><div data-l="#    // --snip--"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">--snip--</span> --snip--</span> </div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">is actually treated as though we had written this:</span>実際にはこれを書いたかのように扱われます：</span> </p><br><div data-lang=rust,ignore><div data-l="fn generic&lt;T: Sized&gt;(t: T) {"></div><div data-l="#    // --snip--"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">--snip--</span> --snip--</span> </div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">By default, generic functions will work only on types that have a known size at compile time.</span>デフォルトでは、汎用関数はコンパイル時に既知のサイズを持つ型に対してのみ機能します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, you can use the following special syntax to relax this restriction:</span>ただし、次の特殊構文を使用してこの制限を緩和することができます。</span> </p><br><div data-lang=rust,ignore><div data-l="fn generic&lt;T: ?Sized&gt;(t: &amp;T) {"></div><div data-l="#    // --snip--"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">--snip--</span> --snip--</span> </div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A trait bound on <code>?Sized</code> is the opposite of a trait bound on <code>Sized</code> : we would read this as “ <code>T</code> may or may not be <code>Sized</code> .” This syntax is only available for <code>Sized</code> , not any other traits.</span>形質は上のバインド<code>?Sized</code>上に結合特性の反対で<code>Sized</code> ：「我々はこれを読んでいました<code>T</code>たりしてもしなくてもよい<code>Sized</code> 。」この構文はのためにのみ利用可能です<code>Sized</code>ではなく、任意の他の形質。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Also note that we switched the type of the <code>t</code> parameter from <code>T</code> to <code>&amp;T</code> .</span>また、 <code>t</code>パラメータのタイプを<code>T</code>から<code>&amp;T</code>に変更したことにも注意してください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because the type might not be <code>Sized</code> , we need to use it behind some kind of pointer.</span>型は<code>Sized</code>ではない可能性があるため、ある種のポインタの後ろで使用する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this case, we&#39;ve chosen a reference.</span>この場合、参照を選択しました。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Next, we&#39;ll talk about functions and closures!</span>次に、関数とクロージャについて説明します。</span> </p><script>_addload(function(){_setupIW('com');_csi('en','ja','ch19-04-advanced-types.html');});</script>