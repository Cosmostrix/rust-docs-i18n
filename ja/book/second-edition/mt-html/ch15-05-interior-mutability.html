<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180709_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=ch15-05-interior-mutability.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>RefCell&lt;T&gt;</code> and the Interior Mutability Pattern</span> <code>RefCell&lt;T&gt;</code>とInterior Mutability Pattern</span> </h2><br><p><!-- NEXT PARAGRAPH WRAPPED WEIRD INTENTIONALLY SEE #199 --></p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><i>Interior mutability</i> is a design pattern in Rust that allows you to mutate data even when there are immutable references to that data;</span> <i>インテリアの変更</i>は、そのデータへの不変な参照があってもデータを変更できるようにする、Rustのデザインパターンです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">normally, this action is disallowed by the borrowing rules.</span>通常、この措置は借入ルールによって禁止されています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To mutate data, the pattern uses <code>unsafe</code> code inside a data structure to bend Rust&#39;s usual rules that govern mutation and borrowing.</span>データを変更するために、パターンはデータ構造内の<code>unsafe</code>コードを使用して、突然変異と借用を管理するRustの通常の規則を曲げます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We haven&#39;t yet covered unsafe code;</span>安全でないコードはまだ扱っていません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">we will in Chapter 19. We can use types that use the interior mutability pattern when we can ensure that the borrowing rules will be followed at runtime, even though the compiler can&#39;t guarantee that.</span>たとえコンパイラがそれを保証できないとしても、実行時に借用規則を確実に守ることができる場合には、内部の可変パターンを使用する型を使用することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>unsafe</code> code involved is then wrapped in a safe API, and the outer type is still immutable.</span> <code>unsafe</code>コードは安全なAPIでラップされ、外側の型は変わりません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s explore this concept by looking at the <code>RefCell&lt;T&gt;</code> type that follows the interior mutability pattern.</span>内部の変異パターンに続く<code>RefCell&lt;T&gt;</code>型を見て、このコンセプトを探ってみましょう。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Enforcing Borrowing Rules at Runtime with <code>RefCell&lt;T&gt;</code></span> <code>RefCell&lt;T&gt;</code>を<code>RefCell&lt;T&gt;</code>して実行時に借用ルールを強制する</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Unlike <code>Rc&lt;T&gt;</code> , the <code>RefCell&lt;T&gt;</code> type represents single ownership over the data it holds.</span> <code>Rc&lt;T&gt;</code>とは異なり、 <code>RefCell&lt;T&gt;</code>型は、保持しているデータに対する単一の所有権を表します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So, what makes <code>RefCell&lt;T&gt;</code> different from a type like <code>Box&lt;T&gt;</code> ?</span>だから、 <code>RefCell&lt;T&gt;</code> <code>Box&lt;T&gt;</code>ような型と何が違うのですか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Recall the borrowing rules you learned in Chapter 4:</span>第4章で学んだ借用規則を思い出してください。</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">At any given time, you can have <i>either</i> (but not both of) one mutable reference or any number of immutable references.</span>任意の時点で、1つの可変参照または任意の数の不変参照を持つことができ<i>ます</i> （ただし両方ではありません）。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">References must always be valid.</span>参照は常に有効でなければなりません。</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">With references and <code>Box&lt;T&gt;</code> , the borrowing rules&#39; invariants are enforced at compile time.</span>参照と<code>Box&lt;T&gt;</code>では、借用ルールの不変式はコンパイル時に強制されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">With <code>RefCell&lt;T&gt;</code> , these invariants are enforced <i>at runtime</i> .</span> <code>RefCell&lt;T&gt;</code>では、これらの不変式は<i>実行時に</i>強制さ<i>れます</i> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">With references, if you break these rules, you&#39;ll get a compiler error.</span>参考文献を参照して、これらの規則を破ると、コンパイラエラーが発生します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">With <code>RefCell&lt;T&gt;</code> , if you break these rules, your program will panic and exit.</span> <code>RefCell&lt;T&gt;</code> 、これらのルールを破ると、プログラムがパニックして終了します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The advantages of checking the borrowing rules at compile time are that errors will be caught sooner in the development process, and there is no impact on runtime performance because all the analysis is completed beforehand.</span>コンパイル時に借用ルールをチェックする利点は、開発プロセスでエラーがより早く検出され、すべての分析があらかじめ完了しているため実行時のパフォーマンスに影響がないことです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For those reasons, checking the borrowing rules at compile time is the best choice in the majority of cases, which is why this is Rust&#39;s default.</span>こうした理由から、コンパイル時に借用ルールをチェックするのが大半のケースで最良の選択です。これがRustのデフォルトです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The advantage of checking the borrowing rules at runtime instead is that certain memory-safe scenarios are then allowed, whereas they are disallowed by the compile-time checks.</span>ランタイム時に借用ルールをチェックする利点は、コンパイル時のチェックでは許可されないものの、一定のメモリセーフシナリオが許可されることです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Static analysis, like the Rust compiler, is inherently conservative.</span> Rustコンパイラのような静的解析は、本質的に保守的です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Some properties of code are impossible to detect by analyzing the code: the most famous example is the Halting Problem, which is beyond the scope of this book but is an interesting topic to research.</span>コードのいくつかの特性は、コードを分析することで検出することは不可能です：最も有名な例はHalting Problemですが、この本の範囲を超えていますが、研究の興味深いトピックです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because some analysis is impossible, if the Rust compiler can&#39;t be sure the code complies with the ownership rules, it might reject a correct program;</span>分析が不可能なため、Rustコンパイラがコードが所有権ルールに準拠しているかどうかを確かめることができない場合、正しいプログラムを拒否することがあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">in this way, it&#39;s conservative.</span>このように、それは保守的です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If Rust accepted an incorrect program, users wouldn&#39;t be able to trust in the guarantees Rust makes.</span> Rustが間違ったプログラムを受け入れると、ユーザーはRustが行う保証を信頼することができなくなります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, if Rust rejects a correct program, the programmer will be inconvenienced, but nothing catastrophic can occur.</span>しかし、Rustが正しいプログラムを拒否した場合、プログラマは不便になるが、致命的なことは起こりません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>RefCell&lt;T&gt;</code> type is useful when you&#39;re sure your code follows the borrowing rules but the compiler is unable to understand and guarantee that.</span> <code>RefCell&lt;T&gt;</code>型は、コードが借用ルールに従っていることを確認しているのにコンパイラがそれを理解して保証することができない場合に便利です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Similar to <code>Rc&lt;T&gt;</code> , <code>RefCell&lt;T&gt;</code> is only for use in single-threaded scenarios and will give you a compile-time error if you try using it in a multithreaded context.</span> <code>Rc&lt;T&gt;</code>と同様、 <code>RefCell&lt;T&gt;</code>はシングルスレッドのシナリオでのみ使用でき、マルチスレッド環境で使用するとコンパイル時エラーが発生します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll talk about how to get the functionality of <code>RefCell&lt;T&gt;</code> in a multithreaded program in Chapter 16.</span>第16章のマルチスレッドプログラムで<code>RefCell&lt;T&gt;</code>機能を取得する方法について説明します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here is a recap of the reasons to choose <code>Box&lt;T&gt;</code> , <code>Rc&lt;T&gt;</code> , or <code>RefCell&lt;T&gt;</code> :</span> <code>Box&lt;T&gt;</code> 、 <code>Rc&lt;T&gt;</code> 、または<code>RefCell&lt;T&gt;</code>を選択する理由を要約すると次のようになります。</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>Rc&lt;T&gt;</code> enables multiple owners of the same data;</span> <code>Rc&lt;T&gt;</code>は同じデータの複数の所有者を可能にする。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>Box&lt;T&gt;</code> and <code>RefCell&lt;T&gt;</code> have single owners.</span> <code>Box&lt;T&gt;</code>と<code>RefCell&lt;T&gt;</code>は1人の所有者がいます。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>Box&lt;T&gt;</code> allows immutable or mutable borrows checked at compile time;</span> <code>Box&lt;T&gt;</code>は、コンパイル時に不変または変更可能な借用をチェックします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>Rc&lt;T&gt;</code> allows only immutable borrows checked at compile time;</span> <code>Rc&lt;T&gt;</code>は、コンパイル時にチェックされた不変のBorrowsのみを許可します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>RefCell&lt;T&gt;</code> allows immutable or mutable borrows checked at runtime.</span> <code>RefCell&lt;T&gt;</code>は、実行時に不変または変更可能な借用をチェックできます。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because <code>RefCell&lt;T&gt;</code> allows mutable borrows checked at runtime, you can mutate the value inside the <code>RefCell&lt;T&gt;</code> even when the <code>RefCell&lt;T&gt;</code> is immutable.</span> <code>RefCell&lt;T&gt;</code>は実行時に変更可能な借用をチェックできるため、 <code>RefCell&lt;T&gt;</code>が不変の場合でも<code>RefCell&lt;T&gt;</code>内の値を変更することができます。</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Mutating the value inside an immutable value is the <i>interior mutability</i> pattern.</span>不変値内の値を突然変異する<i>内部可変性パターン</i>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s look at a situation in which interior mutability is useful and examine how it&#39;s possible.</span>内部の可変性が有用であり、それが可能である方法を調べる状況を見てみましょう。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Interior Mutability: A Mutable Borrow to an Immutable Value</span>内部の変更：不変の値への変更可能な借用</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A consequence of the borrowing rules is that when you have an immutable value, you can&#39;t borrow it mutably.</span>借り入れルールの結果、あなたが不変の価値を持っているときは、それを変更することはできません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, this code won&#39;t compile:</span>たとえば、このコードはコンパイルされません。</span> </p><br><div data-lang=rust,ignore><div data-l="fn main() {"></div><div data-l="    let x = 5;"></div><div data-l="    let y = &amp;mut x;"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you tried to compile this code, you&#39;d get the following error:</span>このコードをコンパイルしようとすると、次のエラーが発生します。</span> </p><br><div data-lang=text><div data-l="error[E0596]: cannot borrow immutable local variable `x` as mutable"></div><div data-l=" --&gt; src/main.rs:3:18"></div><div data-l="  |"></div><div data-l="2 |     let x = 5;"></div><div data-l="  |         - consider changing this to `mut x`"></div><div data-l="3 |     let y = &amp;mut x;"></div><div data-l="  |                  ^ cannot borrow mutably"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, there are situations in which it would be useful for a value to mutate itself in its methods but appear immutable to other code.</span>しかし、値がそのメソッドでそれ自身を突然変異させるが、他のコードには不変であるように見えることが有益である状況がある。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Code outside the value&#39;s methods would not be able to mutate the value.</span>値のメソッド以外のコードでは、値を変更することはできません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Using <code>RefCell&lt;T&gt;</code> is one way to get the ability to have interior mutability.</span> <code>RefCell&lt;T&gt;</code>を使用することは、内部の変更を可能にする方法の1つです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But <code>RefCell&lt;T&gt;</code> doesn&#39;t get around the borrowing rules completely: the borrow checker in the compiler allows this interior mutability, and the borrowing rules are checked at runtime instead.</span>しかし<code>RefCell&lt;T&gt;</code>は借用ルールを完全に回避しません。コンパイラの貸借チェッカーはこの内部の変更を許可し、代わりに実行時に借用ルールがチェックされます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you violate the rules, you&#39;ll get a <code>panic€</code> instead of a compiler error.</span>ルールに違反すると、コンパイラエラーではなく<code>panic€</code>発生します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s work through a practical example where we can use <code>RefCell&lt;T&gt;</code> to mutate an immutable value and see why that is useful.</span> <code>RefCell&lt;T&gt;</code>を使用して不変の値を変更し、それがなぜ有用であるかを実例で見てみましょう。</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A Use Case for Interior Mutability: Mock Objects</span>インテリア・ミュータビリティのためのユースケース：モック・オブジェクト</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A <i>test double</i> is the general programming concept for a type used in place of another type during testing.</span> <i>テストダブル</i>は、 <i>テスト</i>中に別のタイプの代わりに使用されるタイプの一般的なプログラミングコンセプトです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><i>Mock objects</i> are specific types of test doubles that record what happens during a test so you can assert that the correct actions took place.</span> <i>モックオブジェクト</i>は、テスト中に何が起こったかを記録する特定のタイプのテストダブルです。そのため、正しいアクションが発生したと主張できます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust doesn&#39;t have objects in the same sense as other languages have objects, and Rust doesn&#39;t have mock object functionality built into the standard library as some other languages do.</span> Rustには他の言語のオブジェクトと同じ意味のオブジェクトはなく、Rustは他の言語のように標準ライブラリにモックオブジェクト機能を組み込んでいません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, you can definitely create a struct that will serve the same purposes as a mock object.</span>しかし、モックオブジェクトと同じ目的を果たす構造体を作成することは間違いありません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here&#39;s the scenario we&#39;ll test: we&#39;ll create a library that tracks a value against a maximum value and sends messages based on how close to the maximum value the current value is.</span>ここではテストするシナリオを示します。最大値に対する値を追跡し、現在の値がどれくらい近いかに基づいてメッセージを送信するライブラリを作成します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This library could be used to keep track of a user&#39;s quota for the number of API calls they&#39;re allowed to make, for example.</span>このライブラリは、たとえば、許可されているAPI呼び出しの数に対するユーザーのクォータを追跡するために使用できます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Our library will only provide the functionality of tracking how close to the maximum a value is and what the messages should be at what times.</span>私たちの図書館は、最大値にどれくらい近づき、何時にメッセージを表示するのかを追跡する機能しか提供しません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Applications that use our library will be expected to provide the mechanism for sending the messages: the application could put a message in the application, send an email, send a text message, or something else.</span>ライブラリを使用するアプリケーションは、メッセージを送信するためのメカニズムを提供することが期待されます。つまり、アプリケーションにメッセージを挿入したり、電子メールを送信したり、テキストメッセージを送信したりすることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The library doesn&#39;t need to know that detail.</span>ライブラリはその詳細を知る必要はありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">All it needs is something that implements a trait we&#39;ll provide called <code>Messenger</code> .</span>必要なのは、 <code>Messenger</code>と呼ばれる特質を実装するものです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 15-20 shows the library code:</span>コードリスト15-20にライブラリコードを示します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/lib.rs</span></span> <span class=filename>ファイル名：src / lib.rs</span></span> </p><br><div data-lang=rust><div data-l="pub trait Messenger {"></div><div data-l="    fn send(&amp;self, msg: &amp;str);"></div><div data-l=}></div><div data-l=""></div><div data-l="pub struct LimitTracker&lt;'a, T: 'a + Messenger&gt; {"></div><div data-l="    messenger: &amp;'a T,"></div><div data-l="    value: usize,"></div><div data-l="    max: usize,"></div><div data-l=}></div><div data-l=""></div><div data-l="impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;"></div><div data-l="    where T: Messenger {"></div><div data-l="    pub fn new(messenger: &amp;T, max: usize) -&gt; LimitTracker&lt;T&gt; {"></div><div data-l="        LimitTracker {"></div><div data-l="            messenger,"></div><div data-l="            value: 0,"></div><div data-l="            max,"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=""></div><div data-l="    pub fn set_value(&amp;mut self, value: usize) {"></div><div data-l="        self.value = value;"></div><div data-l=""></div><div data-l="        let percentage_of_max = self.value as f64 / self.max as f64;"></div><div data-l=""></div><div data-l="        if percentage_of_max &gt;= 0.75 &amp;&amp; percentage_of_max &lt; 0.9 {"></div><div data-l="            self.messenger.send(&quot;Warning: You've used up over 75% of your quota!&quot;);"></div><div data-l="        } else if percentage_of_max &gt;= 0.9 &amp;&amp; percentage_of_max &lt; 1.0 {"></div><div data-l="            self.messenger.send(&quot;Urgent warning: You've used up over 90% of your quota!&quot;);"></div><div data-l="        } else if percentage_of_max &gt;= 1.0 {"></div><div data-l="            self.messenger.send(&quot;Error: You are over your quota!&quot;);"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 15-20: A library to keep track of how close a value is to a maximum value and warn when the value is at certain levels</span></span> <span class=caption>リスト15-20：値が最大値にどのくらい近いかを追跡し、値が特定のレベルにあるときに警告するライブラリ</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">One important part of this code is that the <code>Messenger</code> trait has one method called <code>send</code> that takes an immutable reference to <code>self</code> and the text of the message.</span>このコードの重要な部分の1つは、 <code>Messenger</code>特性に、 <code>self</code>とメッセージのテキストに対する不変の参照をとる<code>send</code>という1つのメソッドがあることです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is the interface our mock object needs to have.</span>これは私たちのモックオブジェクトが必要とするインターフェースです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The other important part is that we want to test the behavior of the <code>set_value</code> method on the <code>LimitTracker</code> .</span>他の重要な部分は、私たちが行動のテストすることです<code>set_value</code>の方法<code>LimitTracker</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can change what we pass in for the <code>value</code> parameter, but <code>set_value</code> doesn&#39;t return anything for us to make assertions on.</span>渡した<code>value</code>パラメータで変更することはできますが、 <code>set_value</code>はアサーションを行うために何も返しません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We want to be able to say that if we create a <code>LimitTracker</code> with something that implements the <code>Messenger</code> trait and a particular value for <code>max</code> , when we pass different numbers for <code>value</code> , the messenger is told to send the appropriate messages.</span>私たちは、私たちが作成した場合と言うことができるようにしたい<code>LimitTracker</code>実装して何かを<code>Messenger</code>特性とのための特定の値<code>max</code>我々は異なる番号を渡すとき、 <code>value</code> 、メッセンジャーは、適切なメッセージを送信するように言われています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We need a mock object that, instead of sending an email or text message when we call <code>send</code> , will only keep track of the messages it&#39;s told to send.</span> <code>send</code>を呼び出すときに電子メールまたはテキストメッセージを送信する代わりに、送信するように指示されたメッセージのみを追跡するモックオブジェクトが必要です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can create a new instance of the mock object, create a <code>LimitTracker</code> that uses the mock object, call the <code>set_value</code> method on <code>LimitTracker</code> , and then check that the mock object has the messages we expect.</span>私たちは、作成、モックオブジェクトの新しいインスタンスを作成することができます<code>LimitTracker</code> 、モックオブジェクトを使用して呼び出す<code>set_value</code>に方法を<code>LimitTracker</code> 、その後、モックオブジェクトは、我々が期待するメッセージを持っていることを確認してください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 15-21 shows an attempt to implement a mock object to do just that, but the borrow checker won&#39;t allow it:</span>リスト15-21は、それを行うための模擬オブジェクトを実装する試みを示していますが、貸借チェッカーは許可しません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/lib.rs</span></span> <span class=filename>ファイル名：src / lib.rs</span></span> </p><br><div data-lang=rust><div data-l=#[cfg(test)]></div><div data-l="mod tests {"></div><div data-l="    use super::*;"></div><div data-l=""></div><div data-l="    struct MockMessenger {"></div><div data-l="        sent_messages: Vec&lt;String&gt;,"></div><div data-l="    }"></div><div data-l=""></div><div data-l="    impl MockMessenger {"></div><div data-l="        fn new() -&gt; MockMessenger {"></div><div data-l="            MockMessenger { sent_messages: vec![] }"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=""></div><div data-l="    impl Messenger for MockMessenger {"></div><div data-l="        fn send(&amp;self, message: &amp;str) {"></div><div data-l="            self.sent_messages.push(String::from(message));"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=""></div><div data-l="    #[test]"></div><div data-l="    fn it_sends_an_over_75_percent_warning_message() {"></div><div data-l="        let mock_messenger = MockMessenger::new();"></div><div data-l="        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);"></div><div data-l=""></div><div data-l="        limit_tracker.set_value(80);"></div><div data-l=""></div><div data-l="        assert_eq!(mock_messenger.sent_messages.len(), 1);"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 15-21: An attempt to implement a <code>MockMessenger</code> that isn&#39;t allowed by the borrow checker</span></span> <span class=caption>リスト15-21： <code>MockMessenger</code>チェッカーで許可されていない<code>MockMessenger</code>を実装しようとする試み</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This test code defines a <code>MockMessenger</code> struct that has a <code>sent_messages</code> field with a <code>Vec</code> of <code>String</code> values to keep track of the messages it&#39;s told to send.</span>このテストコードは、送信するように指示されたメッセージを追跡するために、 <code>Vec</code>の<code>String</code>値を持つ<code>sent_messages</code>フィールドを持つ<code>MockMessenger</code>構造体を定義します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We also define an associated function <code>new</code> to make it convenient to create new <code>MockMessenger</code> values that start with an empty list of messages.</span>空のメッセージリストから始まる新しい<code>MockMessenger</code>値を作成するのに便利<code>new</code>ように、関連する関数<code>new</code>を定義します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We then implement the <code>Messenger</code> trait for <code>MockMessenger</code> so we can give a <code>MockMessenger</code> to a <code>LimitTracker</code> .</span>私たちは、その後、実装<code>Messenger</code>のための形質を<code>MockMessenger</code>我々が与えることができるよう<code>MockMessenger</code>する<code>LimitTracker</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In the definition of the <code>send</code> method, we take the message passed in as a parameter and store it in the <code>MockMessenger</code> list of <code>sent_messages</code> .</span> <code>send</code>メソッドの定義では、渡されたメッセージをパラメータとして<code>MockMessenger</code> 、 <code>MockMessenger</code>リストに<code>sent_messages</code>ます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In the test, we&#39;re testing what happens when the <code>LimitTracker</code> is told to set <code>value</code> to something that is more than 75 percent of the <code>max</code> value.</span>テストでは、 <code>LimitTracker</code>が<code>max</code>値の75％を超える<code>value</code>を設定するように指示されたときに何が起こるかをテストしています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">First, we create a new <code>MockMessenger</code> , which will start with an empty list of messages.</span>まず、新しい<code>MockMessenger</code>を作成します<code>MockMessenger</code>は空のメッセージリストから始まります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then we create a new <code>LimitTracker</code> and give it a reference to the new <code>MockMessenger</code> and a <code>max</code> value of 100. We call the <code>set_value</code> method on the <code>LimitTracker</code> with a value of 80, which is more than 75 percent of 100. Then we assert that the list of messages that the <code>MockMessenger</code> is keeping track of should now have one message in it.</span>その後、我々は新しい作成<code>LimitTracker</code>し、それを新しい参照与える<code>MockMessenger</code>と<code>max</code>我々は呼ん100の値<code>set_value</code>の方法<code>LimitTracker</code>その後、我々が主張100の75％以上である80の値とを、 <code>MockMessenger</code>が追跡しているメッセージのリストに、メッセージが1つあるはずです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, there&#39;s one problem with this test, as shown here:</span>ただし、ここに示すように、このテストには1つの問題があります。</span> </p><br><div data-lang=text><div data-l="error[E0596]: cannot borrow immutable field `self.sent_messages` as mutable"></div><div data-l="  --&gt; src/lib.rs:52:13"></div><div data-l="   |"></div><div data-l="51 |         fn send(&amp;self, message: &amp;str) {"></div><div data-l="   |                 ----- use `&amp;mut self` here to make mutable"></div><div data-l="52 |             self.sent_messages.push(String::from(message));"></div><div data-l="   |             ^^^^^^^^^^^^^^^^^^ cannot mutably borrow immutable field"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can&#39;t modify the <code>MockMessenger</code> to keep track of the messages, because the <code>send</code> method takes an immutable reference to <code>self</code> .</span> <code>send</code>メソッドは<code>self</code>への不変の参照を取るので、メッセージを追跡するために<code>MockMessenger</code>を変更することはできません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We also can&#39;t take the suggestion from the error text to use <code>&amp;mut self</code> instead, because then the signature of <code>send</code> wouldn&#39;t match the signature in the <code>Messenger</code> trait definition (feel free to try and see what error message you get).</span>また、 <code>send</code>のシグネチャが<code>Messenger</code> trait定義のシグネチャと一致しないため、エラーテキストから<code>&amp;mut self</code>代わりに使用する<code>send</code>はできません（どのようなエラーメッセージが表示されるか気軽に試してみてください）。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is a situation in which interior mutability can help!</span>これは、内部の変更が助けになる状況です！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll store the <code>sent_messages</code> within a <code>RefCell&lt;T&gt;</code> , and then the <code>send</code> message will be able to modify <code>sent_messages</code> to store the messages we&#39;ve seen.</span>私たちは、保存します<code>sent_messages</code>内<code>RefCell&lt;T&gt;</code>その後、 <code>send</code>メッセージは、変更することができるようになります<code>sent_messages</code>私たちが見てきたメッセージを格納します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 15-22 shows what that looks like:</span>リスト15-22は、それがどのように見えるかを示しています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/lib.rs</span></span> <span class=filename>ファイル名：src / lib.rs</span></span> </p><br><div data-lang=rust><div data-l=#[cfg(test)]></div><div data-l="mod tests {"></div><div data-l="    use super::*;"></div><div data-l="    use std::cell::RefCell;"></div><div data-l=""></div><div data-l="    struct MockMessenger {"></div><div data-l="        sent_messages: RefCell&lt;Vec&lt;String&gt;&gt;,"></div><div data-l="    }"></div><div data-l=""></div><div data-l="    impl MockMessenger {"></div><div data-l="        fn new() -&gt; MockMessenger {"></div><div data-l="            MockMessenger { sent_messages: RefCell::new(vec![]) }"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=""></div><div data-l="    impl Messenger for MockMessenger {"></div><div data-l="        fn send(&amp;self, message: &amp;str) {"></div><div data-l="            self.sent_messages.borrow_mut().push(String::from(message));"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=""></div><div data-l="    #[test]"></div><div data-l="    fn it_sends_an_over_75_percent_warning_message() {"></div><div data-l="#        // --snip--"></div><div data-l="        // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">--snip--</span> --snip--</span> </div><div data-l="#         let mock_messenger = MockMessenger::new();"></div><div data-l="#         let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);"></div><div data-l="#         limit_tracker.set_value(75);"></div><div data-l=""></div><div data-l="        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 15-22: Using <code>RefCell&lt;T&gt;</code> to mutate an inner value while the outer value is considered immutable</span></span> <span class=caption>リスト15-22： <code>RefCell&lt;T&gt;</code>を使って内部値を変更し、外側の値が不変であると見なす</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>sent_messages</code> field is now of type <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> instead of <code>Vec&lt;String&gt;</code> .</span> <code>sent_messages</code>フィールドは、 <code>Vec&lt;String&gt;</code>ではなく<code>RefCell&lt;Vec&lt;String&gt;&gt;</code>型に<code>RefCell&lt;Vec&lt;String&gt;&gt;</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In the <code>new</code> function, we create a new <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> instance around the empty vector.</span> <code>new</code>関数では、空のベクトルの周りに新しい<code>RefCell&lt;Vec&lt;String&gt;&gt;</code>インスタンスを作成します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For the implementation of the <code>send</code> method, the first parameter is still an immutable borrow of <code>self</code> , which matches the trait definition.</span> <code>send</code>メソッドの実装では、最初のパラメータはまだ<code>self</code>不変の借用であり、これは特性定義に一致します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We call <code>borrow_mut</code> on the <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> in <code>self.sent_messages</code> to get a mutable reference to the value inside the <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> , which is the vector.</span>私たちは呼んで<code>borrow_mut</code>に<code>RefCell&lt;Vec&lt;String&gt;&gt;</code>に<code>self.sent_messages</code>内の値を変更可能な参照を取得するために<code>RefCell&lt;Vec&lt;String&gt;&gt;</code>ベクトルです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then we can call <code>push</code> on the mutable reference to the vector to keep track of the messages sent during the test.</span>次に、テスト中に送信されたメッセージを追跡するために、ベクトルへの変更可能な参照を<code>push</code>を呼び出すことができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The last change we have to make is in the assertion: to see how many items are in the inner vector, we call <code>borrow</code> on the <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> to get an immutable reference to the vector.</span>私たちが行う必要があり、最後の変更が主張している：我々は呼んで、内側のベクトルであるどのように多くの項目を参照するために<code>borrow</code>に<code>RefCell&lt;Vec&lt;String&gt;&gt;</code>ベクトルへの不変の参照を取得します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now that you&#39;ve seen how to use <code>RefCell&lt;T&gt;</code> , let&#39;s dig into how it works!</span> <code>RefCell&lt;T&gt;</code>使い方を見てきたので、どのように動作するかを見てみましょう。</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Keeping Track of Borrows at Runtime with <code>RefCell&lt;T&gt;</code></span> <code>RefCell&lt;T&gt;</code>を<code>RefCell&lt;T&gt;</code>して実行時に借用を追跡する</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When creating immutable and mutable references, we use the <code>&amp;</code> and <code>&amp;mut</code> syntax, respectively.</span>不変で変更可能な参照を作成するときは、それぞれ<code>&amp;</code>と<code>&amp;mut</code>構文を使用します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">With <code>RefCell&lt;T&gt;</code> , we use the <code>borrow</code> and <code>borrow_mut</code> methods, which are part of the safe API that belongs to <code>RefCell&lt;T&gt;</code> .</span> <code>RefCell&lt;T&gt;</code>我々は使用<code>borrow</code>と<code>borrow_mut</code>に属する安全なAPIの一部である方法、 <code>RefCell&lt;T&gt;</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>borrow</code> method returns the smart pointer type <code>Ref&lt;T&gt;</code> , and <code>borrow_mut</code> returns the smart pointer type <code>RefMut&lt;T&gt;</code> .</span> <code>borrow</code>方法は、スマートポインタ型返し<code>Ref&lt;T&gt;</code> 、そして<code>borrow_mut</code>スマートポインタ型返し<code>RefMut&lt;T&gt;</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Both types implement <code>Deref</code> , so we can treat them like regular references.</span>どちらの型も<code>Deref</code>実装しているので、正規表現のように扱うことができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>RefCell&lt;T&gt;</code> keeps track of how many <code>Ref&lt;T&gt;</code> and <code>RefMut&lt;T&gt;</code> smart pointers are currently active.</span> <code>RefCell&lt;T&gt;</code>は、現在アクティブな<code>Ref&lt;T&gt;</code>と<code>RefMut&lt;T&gt;</code>スマートポインタの数を<code>RefMut&lt;T&gt;</code>します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Every time we call <code>borrow</code> , the <code>RefCell&lt;T&gt;</code> increases its count of how many immutable borrows are active.</span> <code>RefCell&lt;T&gt;</code>は、 <code>borrow</code>を呼び出すたびに、不変の借用がいくつあるかをカウントします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When a <code>Ref&lt;T&gt;</code> value goes out of scope, the count of immutable borrows goes down by one.</span> <code>Ref&lt;T&gt;</code>値が範囲外になると、不変の借りの数が1つ減ります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Just like the compile-time borrowing rules, <code>RefCell&lt;T&gt;</code> lets us have many immutable borrows or one mutable borrow at any point in time.</span> <code>RefCell&lt;T&gt;</code>は、コンパイル時の借用規則と同じように、いつでも不変の借用または可変の借用が可能です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we try to violate these rules, rather than getting a compiler error as we would with references, the implementation of <code>RefCell&lt;T&gt;</code> will panic at runtime.</span>これらのルールに違反しようとすると、参照と同じようにコンパイラエラーが発生するのではなく、実行時に<code>RefCell&lt;T&gt;</code>実装がパニックに陥ります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 15-23 shows a modification of the implementation of <code>send</code> in Listing 15-22.</span>リスト15-23は、リスト15-22の<code>send</code>の実装の変更を示しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;re deliberately trying to create two mutable borrows active for the same scope to illustrate that <code>RefCell&lt;T&gt;</code> prevents us from doing this at runtime.</span>我々は、 <code>RefCell&lt;T&gt;</code>が実行時にこれを<code>RefCell&lt;T&gt;</code>ないようにするために、同じスコープに対してアクティブな2つの可変の借用を意図的に作成しようとしています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/lib.rs</span></span> <span class=filename>ファイル名：src / lib.rs</span></span> </p><br><div data-lang=rust,ignore><div data-l="impl Messenger for MockMessenger {"></div><div data-l="    fn send(&amp;self, message: &amp;str) {"></div><div data-l="        let mut one_borrow = self.sent_messages.borrow_mut();"></div><div data-l="        let mut two_borrow = self.sent_messages.borrow_mut();"></div><div data-l=""></div><div data-l="        one_borrow.push(String::from(message));"></div><div data-l="        two_borrow.push(String::from(message));"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 15-23: Creating two mutable references in the same scope to see that <code>RefCell&lt;T&gt;</code> will panic</span></span> <span class=caption>リスト15-23： <code>RefCell&lt;T&gt;</code>がパニックすることを<code>RefCell&lt;T&gt;</code>ために同じスコープ内に2つの可変参照を作成する</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We create a variable <code>one_borrow</code> for the <code>RefMut&lt;T&gt;</code> smart pointer returned from <code>borrow_mut</code> .</span>私たちは、変数を作成<code>one_borrow</code>ため<code>RefMut&lt;T&gt;</code>から返されたスマートポインタ<code>borrow_mut</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then we create another mutable borrow in the same way in the variable <code>two_borrow</code> .</span>次に変数<code>two_borrow</code>同様の方法で別の可変ボローを作成します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This makes two mutable references in the same scope, which isn&#39;t allowed.</span>これにより、2つの可変参照が同じスコープ内に作成されますが、これは許可されません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When we run the tests for our library, the code in Listing 15-23 will compile without any errors, but the test will fail:</span>ライブラリのテストを実行すると、リスト15-23のコードはエラーなくコンパイルされますが、テストは失敗します。</span> </p><br><div data-lang=text><div data-l="---- tests::it_sends_an_over_75_percent_warning_message stdout ----"></div><div data-l="	thread 'tests::it_sends_an_over_75_percent_warning_message' panicked at"></div><div data-l="'already borrowed: BorrowMutError', src/libcore/result.rs:906:4"></div><div data-l="note: Run with `RUST_BACKTRACE=1` for a backtrace."></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Notice that the code panicked with the message <code>already borrowed: BorrowMutError</code> .</span> <code>already borrowed: BorrowMutError</code>ているメッセージで慌てたコード<code>already borrowed: BorrowMutError</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is how <code>RefCell&lt;T&gt;</code> handles violations of the borrowing rules at runtime.</span>これは<code>RefCell&lt;T&gt;</code>が実行時に借用ルールの違反を処理する方法<code>RefCell&lt;T&gt;</code> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Catching borrowing errors at runtime rather than compile time means that you would find a mistake in your code later in the development process and possibly not until your code was deployed to production.</span>コンパイル時ではなく実行時に借用エラーをキャッチすることは、開発プロセスの後半でコードに間違いがあり、コードが本番環境に配備されるまで間違いを見つけることを意味します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Also, your code would incur a small runtime performance penalty as a result of keeping track of the borrows at runtime rather than compile time.</span>また、コンパイル時ではなく実行時に借用を追跡した結果、実行時のパフォーマンスが低下する可能性があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, using <code>RefCell&lt;T&gt;</code> makes it possible to write a mock object that can modify itself to keep track of the messages it has seen while you&#39;re using it in a context where only immutable values are allowed.</span>しかし、 <code>RefCell&lt;T&gt;</code>を使うと、変更可能なモックオブジェクトを書くことが可能になります。モックオブジェクトは、変更可能な値だけが許されているコンテキストで使用している間に見たメッセージを追跡することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can use <code>RefCell&lt;T&gt;</code> despite its trade-offs to get more functionality than regular references provide.</span> <code>RefCell&lt;T&gt;</code>使用することで、通常の参照よりも多くの機能を得ることができます。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Having Multiple Owners of Mutable Data by Combining <code>Rc&lt;T&gt;</code> and <code>RefCell&lt;T&gt;</code></span> <code>Rc&lt;T&gt;</code>と<code>RefCell&lt;T&gt;</code>組み合わせて変更可能なデータの複数の所有者を持つ</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A common way to use <code>RefCell&lt;T&gt;</code> is in combination with <code>Rc&lt;T&gt;</code> .</span> <code>RefCell&lt;T&gt;</code>を使用する一般的な方法は<code>Rc&lt;T&gt;</code>と組み合わせて使用​​されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Recall that <code>Rc&lt;T&gt;</code> lets you have multiple owners of some data, but it only gives immutable access to that data.</span> <code>Rc&lt;T&gt;</code>はいくつかのデータの複数の所有者を持つことができますが、そのデータへの不変のアクセスしか与えないことを思い出してください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you have an <code>Rc&lt;T&gt;</code> that holds a <code>RefCell&lt;T&gt;</code> , you can get a value that can have multiple owners <i>and</i> that you can mutate!</span> <code>RefCell&lt;T&gt;</code> <code>Rc&lt;T&gt;</code>を保持する<code>Rc&lt;T&gt;</code>を持っている場合は、複数の所有者<i>を</i>持つことができる値を得ることができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, recall the cons list example in Listing 15-18 where we used <code>Rc&lt;T&gt;</code> to allow multiple lists to share ownership of another list.</span>たとえば、リスト15-18のconsリストの例を思い出してください。ここでは、複数のリストが別のリストの所有権を共有できるように<code>Rc&lt;T&gt;</code>を使用しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because <code>Rc&lt;T&gt;</code> holds only immutable values, we can&#39;t change any of the values in the list once we&#39;ve created them.</span> <code>Rc&lt;T&gt;</code>は不変の値しか保持しないため、作成した後はリストの値を変更することはできません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s add in <code>RefCell&lt;T&gt;</code> to gain the ability to change the values in the lists.</span> <code>RefCell&lt;T&gt;</code>を追加して、リスト内の値を変更できるようにしましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 15-24 shows that by using a <code>RefCell&lt;T&gt;</code> in the <code>Cons</code> definition, we can modify the value stored in all the lists:</span>リスト15-24は、 <code>Cons</code>定義で<code>RefCell&lt;T&gt;</code>を使用することによって、すべてのリストに格納されている値を変更できることを示しています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l=#[derive(Debug)]></div><div data-l="enum List {"></div><div data-l="    Cons(Rc&lt;RefCell&lt;i32&gt;&gt;, Rc&lt;List&gt;),"></div><div data-l="    Nil,"></div><div data-l=}></div><div data-l=""></div><div data-l="use List::{Cons, Nil};"></div><div data-l="use std::rc::Rc;"></div><div data-l="use std::cell::RefCell;"></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let value = Rc::new(RefCell::new(5));"></div><div data-l=""></div><div data-l="    let a = Rc::new(Cons(Rc::clone(&amp;value), Rc::new(Nil)));"></div><div data-l=""></div><div data-l="    let b = Cons(Rc::new(RefCell::new(6)), Rc::clone(&amp;a));"></div><div data-l="    let c = Cons(Rc::new(RefCell::new(10)), Rc::clone(&amp;a));"></div><div data-l=""></div><div data-l="    *value.borrow_mut() += 10;"></div><div data-l=""></div><div data-l="    println!(&quot;a after = {:?}&quot;, a);"></div><div data-l="    println!(&quot;b after = {:?}&quot;, b);"></div><div data-l="    println!(&quot;c after = {:?}&quot;, c);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 15-24: Using <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code> to create a <code>List</code> that we can mutate</span></span> <span class=caption>リスト15-24： <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code>を使用して、変更可能な<code>List</code>を作成する</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We create a value that is an instance of <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code> and store it in a variable named <code>value</code> so we can access it directly later.</span>私たちは、 <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code>インスタンスである値を作成し、それを後で直接アクセスできるように<code>value</code>という名前の変数に格納します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then we create a <code>List</code> in <code>a</code> with a <code>Cons</code> variant that holds <code>value</code> .</span>その後、我々は、作成する<code>List</code>中での<code>a</code> <code>Cons</code>を保持バリアント<code>value</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We need to clone <code>value</code> so both <code>a</code> and <code>value</code> have ownership of the inner <code>5</code> value rather than transferring ownership from <code>value</code> to <code>a</code> or having <code>a</code> borrow from <code>value</code> .</span>私たちは、クローンを作成する必要がある<code>value</code>両方ので<code>a</code>と<code>value</code> 、内側の所有権が持っている<code>5</code>むしろから所有権を転送するよりも、値を<code>value</code>にか持つからボロー<code>a</code> <code>a</code> <code>value</code> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We wrap the list <code>a</code> in an <code>Rc&lt;T&gt;</code> so when we create lists <code>b</code> and <code>c</code> , they can both refer to <code>a</code> , which is what we did in Listing 15-18.</span>私たちは、リストラップ<code>a</code>で<code>Rc&lt;T&gt;</code>我々はリスト作成時にその<code>b</code>および<code>c</code> 、彼らは両方を参照することができ、我々はリスト15-18で何をしたかです。 <code>a</code></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">After we&#39;ve created the lists in <code>a</code> , <code>b</code> , and <code>c</code> , we add 10 to the value in <code>value</code> .</span> <code>a</code> 、 <code>b</code> 、 <code>c</code>にリストを作成した後、valueの値に10を追加し<code>value</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We do this by calling <code>borrow_mut</code> on <code>value</code> , which uses the automatic dereferencing feature we discussed in Chapter 5 (see the section “Where&#39;s the <code>-&gt;</code> Operator?”) to dereference the <code>Rc&lt;T&gt;</code> to the inner <code>RefCell&lt;T&gt;</code> value.</span>私たちは、呼び出すことによってこれを行う<code>borrow_mut</code>に<code>value</code> （「だセクションを参照我々は、第5章で説明した自動逆参照機能を使用して、 <code>-&gt;</code>逆参照に？演算子」） <code>Rc&lt;T&gt;</code>の内側に<code>RefCell&lt;T&gt;</code>値。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>borrow_mut</code> method returns a <code>RefMut&lt;T&gt;</code> smart pointer, and we use the dereference operator on it and change the inner value.</span> <code>borrow_mut</code>メソッドは<code>RefMut&lt;T&gt;</code>スマートポインタを返し、それに対して逆参照演算子を使用して内部値を変更します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When we print <code>a</code> , <code>b</code> , and <code>c</code> , we can see that they all have the modified value of 15 rather than 5:</span> <code>a</code> 、 <code>b</code> 、 <code>c</code>を印刷<code>a</code> 、5つではなく15の値が変更されていることがわかります。</span> </p><br><div data-lang=text><div data-l="a after = Cons(RefCell { value: 15 }, Nil)"></div><div data-l="b after = Cons(RefCell { value: 6 }, Cons(RefCell { value: 15 }, Nil))"></div><div data-l="c after = Cons(RefCell { value: 10 }, Cons(RefCell { value: 15 }, Nil))"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This technique is pretty neat!</span>このテクニックはかなりきれいです！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">By using <code>RefCell&lt;T&gt;</code> , we have an outwardly immutable <code>List</code> value.</span> <code>RefCell&lt;T&gt;</code>を使用することで、外部的に不変な<code>List</code>値が得られます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But we can use the methods on <code>RefCell&lt;T&gt;</code> that provide access to its interior mutability so we can modify our data when we need to.</span>しかし<code>RefCell&lt;T&gt;</code>メソッドを使用すると、内部の変更が可能になり、必要なときにデータを変更できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The runtime checks of the borrowing rules protect us from data races, and it&#39;s sometimes worth trading a bit of speed for this flexibility in our data structures.</span>実行時の借用ルールのチェックにより、データ競合から私たちを守ることができます。データ構造の柔軟性のために、時には速度を少し上げる価値があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The standard library has other types that provide interior mutability, such as <code>Cell&lt;T&gt;</code> , which is similar except that instead of giving references to the inner value, the value is copied in and out of the <code>Cell&lt;T&gt;</code> .</span>標準ライブラリのような内部可変性を提供する他のタイプ有する<code>Cell&lt;T&gt;</code>の代わりに内部値への参照を与えることを除いて同様である、値がの内外にコピーされる<code>Cell&lt;T&gt;</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There&#39;s also <code>Mutex&lt;T&gt;</code> , which offers interior mutability that&#39;s safe to use across threads;</span>また、 <code>Mutex&lt;T&gt;</code>もあります。これはスレッド間で安全に使用できる内部の変更を提供します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">we&#39;ll discuss its use in Chapter 16. Check out the standard library docs for more details on the differences between these types.</span>第16章でその使い方について説明します。これらの型の違いの詳細については、標準ライブラリのドキュメントを参照してください。</span> </p><script>_addload(function(){_setupIW('com');_csi('en','ja','ch15-05-interior-mutability.html');});</script>