<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180709_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=ch15-02-deref.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Treating Smart Pointers Like Regular References with the <code>Deref</code> Trait</span> <code>Deref</code> Traitとの正規の参照のようなスマートポインタの処理</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Implementing the <code>Deref</code> trait allows you to customize the behavior of the <i>dereference operator</i> , <code>*</code> (as opposed to the multiplication or glob operator).</span> <code>Deref</code>特性を実装すると、 <i>逆参照演算子</i> <code>*</code> （乗算またはglob演算子とは対照的に）の動作をカスタマイズできます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">By implementing <code>Deref</code> in such a way that a smart pointer can be treated like a regular reference, you can write code that operates on references and use that code with smart pointers too.</span>スマートポインタを通常のリファレンスのように扱えるように<code>Deref</code>を実装することで、リファレンスで動作するコードを記述し、スマートポインタでそのコードを使用することができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s first look at how the dereference operator works with regular references.</span>逆参照演算子が正規の参照とどのように機能するかを見てみましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then we&#39;ll try to define a custom type that behaves like <code>Box&lt;T&gt;</code> , and see why the dereference operator doesn&#39;t work like a reference on our newly defined type.</span>次に、 <code>Box&lt;T&gt;</code>ような振る舞いをするカスタム型を定義して、逆参照演算子が新しく定義された型の参照のように動作しない理由を確認します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll explore how implementing the <code>Deref</code> trait makes it possible for smart pointers to work in a similar way as references.</span> <code>Deref</code>特性を実装することで、スマートポインタが参照と同様の方法で動作することが可能になります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then we&#39;ll look at Rust&#39;s <i>deref coercion</i> feature and how it lets us work with either references or smart pointers.</span>次に、Rustの<i>deref強制</i>機能と、それが参照やスマートポインタのどちらを<i>扱う</i>かについて説明します。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Following the Pointer to the Value with the Dereference Operator</span> Dereference演算子を持つ値へのポインタに続いて</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A regular reference is a type of pointer, and one way to think of a pointer is as an arrow to a value stored somewhere else.</span>通常の参照はポインタの型であり、ポインタを考える方法の1つは、他の場所に格納された値への矢印のようなものです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In Listing 15-6, we create a reference to an <code>i32</code> value and then use the dereference operator to follow the reference to the data:</span>コードリスト15-6では、 <code>i32</code>値への参照を作成し、逆参照演算子を使用してデータへの参照を追跡します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="fn main() {"></div><div data-l="    let x = 5;"></div><div data-l="    let y = &amp;x;"></div><div data-l=""></div><div data-l="    assert_eq!(5, x);"></div><div data-l="    assert_eq!(5, *y);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 15-6: Using the dereference operator to follow a reference to an <code>i32</code> value</span></span> <span class=caption>リスト15-6：逆参照演算子を使って<code>i32</code>値への参照を追跡する</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The variable <code>x</code> holds an <code>i32</code> value, <code>5</code> .</span>変数<code>x</code>は<code>i32</code>値<code>5</code>保持します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We set <code>y</code> equal to a reference to <code>x</code> .</span> <code>y</code>を<code>x</code>参照と等しく設定する。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can assert that <code>x</code> is equal to <code>5</code> .</span> <code>x</code>は<code>5</code>等しいと主張することができる。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, if we want to make an assertion about the value in <code>y</code> , we have to use <code>*y</code> to follow the reference to the value it&#39;s pointing to (hence <i>dereference</i> ).</span>しかし、 <code>y</code>の値についてのアサーションを作成したい場合は、それが指す値への参照に従うために<code>*y</code>を使用する必要があります（したがって<i>逆参照</i> ）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Once we dereference <code>y</code> , we have access to the integer value <code>y</code> is pointing to that we can compare with <code>5</code> .</span>いったん<code>y</code>を参照解除すると、整数値<code>y</code>アクセスすることができ、 <code>y</code>は<code>5</code>と比較できることを示しています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we tried to write <code>assert_eq€(5, y);</code></span> <code>assert_eq€(5, y);</code>を書こうとすると<code>assert_eq€(5, y);</code></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">instead, we would get this compilation error:</span>代わりに、このコンパイルエラーが発生します。</span> </p><br><div data-lang=text><div data-l="error[E0277]: the trait bound `{integer}: std::cmp::PartialEq&lt;&amp;{integer}&gt;` is"></div><div data-l="not satisfied"></div><div data-l=" --&gt; src/main.rs:6:5"></div><div data-l="  |"></div><div data-l="6 |     assert_eq!(5, y);"></div><div data-l="  |     ^^^^^^^^^^^^^^^^^ can't compare `{integer}` with `&amp;{integer}`"></div><div data-l="  |"></div><div data-l="  = help: the trait `std::cmp::PartialEq&lt;&amp;{integer}&gt;` is not implemented for"></div><div data-l="  `{integer}`"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Comparing a number and a reference to a number isn&#39;t allowed because they&#39;re different types.</span>数値と参照の比較は、異なる型であるため許可されていません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We must use the dereference operator to follow the reference to the value it&#39;s pointing to.</span>参照している値への参照に従うには、逆参照演算子を使用する必要があります。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Using <code>Box&lt;T&gt;</code> Like a Reference</span>参照と同様に<code>Box&lt;T&gt;</code>を使う</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can rewrite the code in Listing 15-6 to use a <code>Box&lt;T&gt;</code> instead of a reference;</span>リスト15-6のコードを書き換えて、参照の代わりに<code>Box&lt;T&gt;</code>使うことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">the dereference operator will work as shown in Listing 15-7:</span>逆参照演算子はリスト15-7のように動作します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="fn main() {"></div><div data-l="    let x = 5;"></div><div data-l="    let y = Box::new(x);"></div><div data-l=""></div><div data-l="    assert_eq!(5, x);"></div><div data-l="    assert_eq!(5, *y);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 15-7: Using the dereference operator on a <code>Box&lt;i32&gt;</code></span></span> <span class=caption>リスト15-7： <code>Box&lt;i32&gt;</code>逆参照演算子を使う<code>Box&lt;i32&gt;</code></span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The only difference between Listing 15-7 and Listing 15-6 is that here we set <code>y</code> to be an instance of a box pointing to the value in <code>x</code> rather than a reference pointing to the value of <code>x</code> .</span>表15-7および表15-6との間の唯一の違いは、ここでは、設定することである<code>y</code>の値を指すボックスのインスタンスであることが<code>x</code>よりもむしろの値を指す参照<code>x</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In the last assertion, we can use the dereference operator to follow the box&#39;s pointer in the same way that we did when <code>y</code> was a reference.</span>最後のアサーションでは、逆参照演算子を使用して、 <code>y</code>が参照のときと同じ方法でボックスのポインタに従うことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Next, we&#39;ll explore what is special about <code>Box&lt;T&gt;</code> that enables us to use the dereference operator by defining our own box type.</span>次に、独自のボックス型を定義して参照解除演算子を使用できるようにする<code>Box&lt;T&gt;</code>特別な点について検討します。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Defining Our Own Smart Pointer</span>独自のスマートポインタの定義</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s build a smart pointer similar to the <code>Box&lt;T&gt;</code> type provided by the standard library to experience how smart pointers behave differently than references by default.</span>標準ライブラリによって提供される<code>Box&lt;T&gt;</code>型に似たスマートポインタを構築して、スマートポインタがデフォルトで参照とは異なる動作をする様子を見てみましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then we&#39;ll look at how to add the ability to use the dereference operator.</span>次に、逆参照演算子を使用する機能を追加する方法を見ていきます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Box&lt;T&gt;</code> type is ultimately defined as a tuple struct with one element, so Listing 15-8 defines a <code>MyBox&lt;T&gt;</code> type in the same way.</span> <code>Box&lt;T&gt;</code>型は最終的に1つの要素を持つタプル構造体として定義されているので、リスト15-8も同じように<code>MyBox&lt;T&gt;</code>型を定義しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll also define a <code>new</code> function to match the <code>new</code> function defined on <code>Box&lt;T&gt;</code> .</span>また、 <code>Box&lt;T&gt;</code>定義された<code>new</code>関数と一致する<code>new</code>関数を定義します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="struct MyBox&lt;T&gt;(T);"></div><div data-l=""></div><div data-l="impl&lt;T&gt; MyBox&lt;T&gt; {"></div><div data-l="    fn new(x: T) -&gt; MyBox&lt;T&gt; {"></div><div data-l="        MyBox(x)"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 15-8: Defining a <code>MyBox&lt;T&gt;</code> type</span></span> <span class=caption>リスト15-8： <code>MyBox&lt;T&gt;</code>型の定義</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We define a struct named <code>MyBox</code> and declare a generic parameter <code>T</code> , because we want our type to hold values of any type.</span> <code>MyBox</code>という名前の構造体を定義し、汎用型のパラメータ<code>T</code>を宣言します。これは、型に任意の型の値を保持させるためです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>MyBox</code> type is a tuple struct with one element of type <code>T</code> .</span> <code>MyBox</code>型は、 <code>T</code>型の要素を1つ含むタプル構造体です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>MyBox::new</code> function takes one parameter of type <code>T</code> and returns a <code>MyBox</code> instance that holds the value passed in.</span> <code>MyBox::new</code>関数は、 <code>T</code>型の1つのパラメータをとり、渡された値を保持する<code>MyBox</code>インスタンスを返します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s try adding the <code>main</code> function in Listing 15-7 to Listing 15-8 and changing it to use the <code>MyBox&lt;T&gt;</code> type we&#39;ve defined instead of <code>Box&lt;T&gt;</code> .</span>リスト15-7の<code>main</code>関数をリスト15-8に追加し、 <code>Box&lt;T&gt;</code>代わりに定義した<code>MyBox&lt;T&gt;</code>型を使用するように変更してみましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The code in Listing 15-9 won&#39;t compile because Rust doesn&#39;t know how to dereference <code>MyBox</code> .</span> Rustは<code>MyBox</code>を逆参照する方法を知らないので、リスト15-9のコードはコンパイルされません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust,ignore><div data-l="fn main() {"></div><div data-l="    let x = 5;"></div><div data-l="    let y = MyBox::new(x);"></div><div data-l=""></div><div data-l="    assert_eq!(5, x);"></div><div data-l="    assert_eq!(5, *y);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 15-9: Attempting to use <code>MyBox&lt;T&gt;</code> in the same way we used references and <code>Box&lt;T&gt;</code></span></span> <span class=caption>リスト15-9： <code>MyBox&lt;T&gt;</code>を参照と同じ方法で使用しようとし、 <code>Box&lt;T&gt;</code></span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here&#39;s the resulting compilation error:</span>結果として生じるコンパイルエラーは次のとおりです。</span> </p><br><div data-lang=text><div data-l="error[E0614]: type `MyBox&lt;{integer}&gt;` cannot be dereferenced"></div><div data-l="  --&gt; src/main.rs:14:19"></div><div data-l="   |"></div><div data-l="14 |     assert_eq!(5, *y);"></div><div data-l="   |                   ^^"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Our <code>MyBox&lt;T&gt;</code> type can&#39;t be dereferenced because we haven&#39;t implemented that ability on our type.</span>私たちの<code>MyBox&lt;T&gt;</code>型は、その型に対してその能力を実装していないため、逆参照できません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To enable dereferencing with the <code>*</code> operator, we implement the <code>Deref</code> trait.</span> <code>*</code>演算子で参照解除を有効にするには、 <code>Deref</code>特性を実装します。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Treating a Type Like a Reference by Implementing the <code>Deref</code> Trait</span> <code>Deref</code>特性を実装して参照型の型を扱う</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As discussed in Chapter 10, to implement a trait, we need to provide implementations for the trait&#39;s required methods.</span>第10章で説明したように、形質を実装するためには、形質の必須メソッドの実装を提供する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Deref</code> trait, provided by the standard library, requires us to implement one method named <code>deref</code> that borrows <code>self</code> and returns a reference to the inner data.</span>標準ライブラリによって提供される<code>Deref</code>特性は、 <code>deref</code>という名前のメソッドを実装する必要があります<code>deref</code>は<code>self</code>を借りて内部データへの参照を返します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 15-10 contains an implementation of <code>Deref</code> to add to the definition of <code>MyBox</code> :</span> 15-10のリストの実装が含まれ<code>Deref</code>定義に追加する<code>MyBox</code> ：</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="use std::ops::Deref;"></div><div data-l=""></div><div data-l="# struct MyBox&lt;T&gt;(T);"></div><div data-l="impl&lt;T&gt; Deref for MyBox&lt;T&gt; {"></div><div data-l="    type Target = T;"></div><div data-l=""></div><div data-l="    fn deref(&amp;self) -&gt; &amp;T {"></div><div data-l="        &amp;self.0"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 15-10: Implementing <code>Deref</code> on <code>MyBox&lt;T&gt;</code></span></span> <span class=caption>15-10リスト：実装<code>Deref</code>の<code>MyBox&lt;T&gt;</code></span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>type Target = T;</code></span> <code>type Target = T;</code></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">syntax defines an associated type for the <code>Deref</code> trait to use.</span>構文は、 <code>Deref</code>形質が使用する関連タイプを定義します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Associated types are a slightly different way of declaring a generic parameter, but you don&#39;t need to worry about them for now;</span>関連する型は、ジェネリックパラメータを宣言する方法が少し異なりますが、今のところそれらについて心配する必要はありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">we&#39;ll cover them in more detail in Chapter 19.</span>第19章で詳しく説明します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We fill in the body of the <code>deref</code> method with <code>&amp;self.0</code> so <code>deref</code> returns a reference to the value we want to access with the <code>*</code> operator.</span> <code>deref</code>メソッドの本体を<code>&amp;self.0</code>ので、 <code>deref</code>は<code>*</code>演算子でアクセスしたい値への参照を返します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>main</code> function in Listing 15-9 that calls <code>*</code> on the <code>MyBox&lt;T&gt;</code> value now compiles, and the assertions pass!</span>リスト15-9の<code>main</code>関数は、 <code>MyBox&lt;T&gt;</code>値で<code>*</code>を呼び出すようになり、アサーションが成功するようになりました！</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Without the <code>Deref</code> trait, the compiler can only dereference <code>&amp;</code> references.</span> <code>Deref</code>特性がなければ、コンパイラは参照<code>&amp;</code>参照のみを参照できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>deref</code> method gives the compiler the ability to take a value of any type that implements <code>Deref</code> and call the <code>deref</code> method to get a <code>&amp;</code> reference that it knows how to dereference.</span> <code>deref</code>方法は、コンパイラに実装する任意の型の値取る能力与え<code>Deref</code>して呼び出す<code>deref</code>取得する方法を<code>&amp;</code>それがどのように間接参照に知っているの参照を。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When we entered <code>*y</code> in Listing 15-9, behind the scenes Rust actually ran this code:</span>リスト15-9の<code>*y</code>を入力したとき、Rustは実際にこのコードを実行しました：</span> </p><br><div data-lang=rust,ignore><div data-l=*(y.deref())></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust substitutes the <code>*</code> operator with a call to the <code>deref</code> method and then a plain dereference so we don&#39;t have to think about whether or not we need to call the <code>deref</code> method.</span> Rustは<code>*</code>演算子を<code>deref</code>メソッドの呼び出しで置き換えてから、単純な逆参照を行うため、 <code>deref</code>メソッドを呼び出す必要があるかどうかについて考える必要はありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This Rust feature lets us write code that functions identically whether we have a regular reference or a type that implements <code>Deref</code> .</span>この錆（Rust）機能を使用すると、通常の参照を持っていようと、 <code>Deref</code>を実装する型を持っていても、同じように機能するコードを書くことができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The reason the <code>deref</code> method returns a reference to a value and that the plain dereference outside the parentheses in <code>*(y.deref())</code> is still necessary is the ownership system.</span> <code>deref</code>メソッドが値への参照を返し、 <code>*(y.deref())</code>かっこ以外の単純な参照が依然として必要である<code>*(y.deref())</code>は、所有権システムです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If the <code>deref</code> method returned the value directly instead of a reference to the value, the value would be moved out of <code>self</code> .</span> <code>deref</code>メソッドが値への参照ではなく値を直接返す場合、値は<code>self</code>から移動されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We don&#39;t want to take ownership of the inner value inside <code>MyBox&lt;T&gt;</code> in this case or in most cases where we use the dereference operator.</span>この場合<code>MyBox&lt;T&gt;</code>内の内部値の所有権や、参照解除演算子を使用するほとんどの場合、所有権を取得したくありません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that the <code>*</code> operator is replaced with a call to the <code>deref</code> method and then a call to the <code>*</code> operator just once, each time we use a <code>*</code> in our code.</span> <code>*</code>演算子は<code>deref</code>メソッドへの呼び出しに置き換えられ、 <code>*</code>演算子への呼び出しはコードで<code>*</code>を使うたびに一度だけ呼び出されることに注意してください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because the substitution of the <code>*</code> operator does not recurse infinitely, we end up with data of type <code>i32</code> , which matches the <code>5</code> in <code>assert_eq€</code> in Listing 15-9.</span> <code>*</code>演算子の代入は無限に<code>assert_eq€</code> 、リスト15-9の<code>assert_eq€</code>の<code>5</code>に一致するタイプ<code>i32</code>データになります。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Implicit Deref Coercions with Functions and Methods</span>関数とメソッドを使った暗黙的なDeref強制</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><i>Deref coercion</i> is a convenience that Rust performs on arguments to functions and methods.</span> <i>Derefの強制</i>は、Rustが関数とメソッドの引数に実行する便利な機能です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Deref coercion converts a reference to a type that implements <code>Deref</code> into a reference to a type that <code>Deref</code> can convert the original type into.</span> DEREF強制を実装するタイプへの参照に変換<code>Deref</code>型への参照に<code>Deref</code>に元の型を変換することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Deref coercion happens automatically when we pass a reference to a particular type&#39;s value as an argument to a function or method that doesn&#39;t match the parameter type in the function or method definition.</span>特定の型の値への参照を、関数またはメソッド定義のパラメータ型と一致しない関数またはメソッドの引数として渡すと、Deref強制が自動的に発生します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A sequence of calls to the <code>deref</code> method converts the type we provided into the type the parameter needs.</span> <code>deref</code>メソッドへの一連の呼び出しは、指定した型をパラメータが必要とする型に変換します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Deref coercion was added to Rust so that programmers writing function and method calls don&#39;t need to add as many explicit references and dereferences with <code>&amp;</code> and <code>*</code> .</span>関数とメソッド呼び出しを書くプログラマーが<code>&amp;</code>と<code>*</code>使って多くの明示的な参照と逆参照を追加する必要がないように、Deref強制がRustに追加されました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The deref coercion feature also lets us write more code that can work for either references or smart pointers.</span> deref強制機能では、参照やスマートポインタのどちらでも動作するコードを書くことができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To see deref coercion in action, let&#39;s use the <code>MyBox&lt;T&gt;</code> type we defined in Listing 15-8 as well as the implementation of <code>Deref</code> that we added in Listing 15-10.</span>アクションでDEREF強制を確認するには、のは、使用してみましょう<code>MyBox&lt;T&gt;</code>タイプを、私たちは、リスト15-8で定義されているだけでなく、実装の<code>Deref</code>私たちは、リスト15-10で追加されていること。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 15-11 shows the definition of a function that has a string slice parameter:</span>リスト15-11は、文字列sliceパラメータを持つ関数の定義を示しています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="fn hello(name: &amp;str) {"></div><div data-l="    println!(&quot;Hello, {}!&quot;, name);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 15-11: A <code>hello</code> function that has the parameter <code>name</code> of type <code>&amp;str</code></span></span> <span class=caption>リスト15-11： <code>&amp;str</code>型のパラメータ<code>name</code>を持つ<code>hello</code>関数</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can call the <code>hello</code> function with a string slice as an argument, such as <code>hello(&quot;Rust&quot;);</code></span> <code>hello(&quot;Rust&quot;);</code>ように、文字列sliceを引数として<code>hello</code>関数を呼び出すことができます<code>hello(&quot;Rust&quot;);</code></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">for example.</span>例えば。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Deref coercion makes it possible to call <code>hello</code> with a reference to a value of type <code>MyBox&lt;String&gt;</code> , as shown in Listing 15-12:</span> Deref強制は、リスト15-12に示すように、 <code>MyBox&lt;String&gt;</code>型の値への参照で<code>hello</code>を呼び出すことができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="# use std::ops::Deref;"></div><div data-l=#></div><div data-l="# struct MyBox&lt;T&gt;(T);"></div><div data-l=#></div><div data-l="# impl&lt;T&gt; MyBox&lt;T&gt; {"></div><div data-l="#     fn new(x: T) -&gt; MyBox&lt;T&gt; {"></div><div data-l="#         MyBox(x)"></div><div data-l="#     }"></div><div data-l="# }"></div><div data-l=#></div><div data-l="# impl&lt;T&gt; Deref for MyBox&lt;T&gt; {"></div><div data-l="#     type Target = T;"></div><div data-l=#></div><div data-l="#     fn deref(&amp;self) -&gt; &amp;T {"></div><div data-l="#         &amp;self.0"></div><div data-l="#     }"></div><div data-l="# }"></div><div data-l=#></div><div data-l="# fn hello(name: &amp;str) {"></div><div data-l="#     println!(&quot;Hello, {}!&quot;, name);"></div><div data-l="# }"></div><div data-l=#></div><div data-l="fn main() {"></div><div data-l="    let m = MyBox::new(String::from(&quot;Rust&quot;));"></div><div data-l="    hello(&amp;m);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 15-12: Calling <code>hello</code> with a reference to a <code>MyBox&lt;String&gt;</code> value, which works because of deref coercion</span></span> <span class=caption>リスト15-12：deref強制のために動作する<code>MyBox&lt;String&gt;</code>値への参照で<code>hello</code>を呼び出す</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here we&#39;re calling the <code>hello</code> function with the argument <code>&amp;m</code> , which is a reference to a <code>MyBox&lt;String&gt;</code> value.</span>ここでは、 <code>MyBox&lt;String&gt;</code>値への参照である引数<code>&amp;m</code>して<code>hello</code>関数を呼び出しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because we implemented the <code>Deref</code> trait on <code>MyBox&lt;T&gt;</code> in Listing 15-10, Rust can turn <code>&amp;MyBox&lt;String&gt;</code> into <code>&amp;String</code> by calling <code>deref</code> .</span>我々が実装されているので<code>Deref</code>上の形質を<code>MyBox&lt;T&gt;</code>リスト15-10で、錆を変えることができます<code>&amp;MyBox&lt;String&gt;</code>に<code>&amp;String</code>を呼び出すことによって<code>deref</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The standard library provides an implementation of <code>Deref</code> on <code>String</code> that returns a string slice, and this is in the API documentation for <code>Deref</code> .</span>標準ライブラリは文字列スライスを返す<code>Deref</code> on <code>String</code>実装を提供しています。これは<code>Deref</code> APIドキュメントにあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust calls <code>deref</code> again to turn the <code>&amp;String</code> into <code>&amp;str</code> , which matches the <code>hello</code> function&#39;s definition.</span> Rustは<code>deref</code>再度呼び出して、 <code>&amp;String</code>を<code>&amp;str</code>に変換し<code>&amp;str</code> 。これは<code>hello</code>関数の定義に一致します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If Rust didn&#39;t implement deref coercion, we would have to write the code in Listing 15-13 instead of the code in Listing 15-12 to call <code>hello</code> with a value of type <code>&amp;MyBox&lt;String&gt;</code> .</span> Rustが逆参照を実装していない場合は、リスト15-12のコードの代わりにリスト15-13のコードを記述して、 <code>&amp;MyBox&lt;String&gt;</code>型の値で<code>hello</code>を呼び出す必要があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="# use std::ops::Deref;"></div><div data-l=#></div><div data-l="# struct MyBox&lt;T&gt;(T);"></div><div data-l=#></div><div data-l="# impl&lt;T&gt; MyBox&lt;T&gt; {"></div><div data-l="#     fn new(x: T) -&gt; MyBox&lt;T&gt; {"></div><div data-l="#         MyBox(x)"></div><div data-l="#     }"></div><div data-l="# }"></div><div data-l=#></div><div data-l="# impl&lt;T&gt; Deref for MyBox&lt;T&gt; {"></div><div data-l="#     type Target = T;"></div><div data-l=#></div><div data-l="#     fn deref(&amp;self) -&gt; &amp;T {"></div><div data-l="#         &amp;self.0"></div><div data-l="#     }"></div><div data-l="# }"></div><div data-l=#></div><div data-l="# fn hello(name: &amp;str) {"></div><div data-l="#     println!(&quot;Hello, {}!&quot;, name);"></div><div data-l="# }"></div><div data-l=#></div><div data-l="fn main() {"></div><div data-l="    let m = MyBox::new(String::from(&quot;Rust&quot;));"></div><div data-l="    hello(&amp;(*m)[..]);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 15-13: The code we would have to write if Rust didn&#39;t have deref coercion</span></span> <span class=caption>リスト15-13：Rustが逆参照を持たない場合に書くべきコード</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>(*m)</code> dereferences the <code>MyBox&lt;String&gt;</code> into a <code>String</code> .</span> <code>(*m)</code>逆参照<code>MyBox&lt;String&gt;</code>に<code>String</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then the <code>&amp;</code> and <code>[..]</code> take a string slice of the <code>String</code> that is equal to the whole string to match the signature of <code>hello</code> .</span>次に、 <code>&amp;</code>と<code>[..]</code>は、 <code>hello</code>のシグネチャと一致する文字列全体に等しい<code>String</code>文字列スライスを取ります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The code without deref coercions is harder to read, write, and understand with all of these symbols involved.</span>参照元変換を持たないコードは、これらのシンボルがすべて読み込まれ、記述され、理解するのが困難です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Deref coercion allows Rust to handle these conversions for us automatically.</span> Derefの強制はRustにこれらの変換を自動的に処理させます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When the <code>Deref</code> trait is defined for the types involved, Rust will analyze the types and use <code>Deref::deref</code> as many times as necessary to get a reference to match the parameter&#39;s type.</span>関係する型に対して<code>Deref</code>特性が定義されている場合、Rustは型を解析し、 <code>Deref::deref</code>を必要なだけ何度も使用して、パラメータの型に一致する参照を取得します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The number of times that <code>Deref::deref</code> needs to be inserted is resolved at compile time, so there is no runtime penalty for taking advantage of deref coercion!</span> <code>Deref::deref</code>を挿入する必要がある回数はコンパイル時に解決されるため、逆変換を利用するための実行時のペナルティはありません。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">How Deref Coercion Interacts with Mutability</span> Deref強制とMutabilityとの相互作用</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Similar to how you use the <code>Deref</code> trait to override the <code>*</code> operator on immutable references, you can use the <code>DerefMut</code> trait to override the <code>*</code> operator on mutable references.</span>あなたが使用する方法と同様に<code>Deref</code>上書きする形質を<code>*</code>不変の参照の演算子を、あなたが使用することができ<code>DerefMut</code>上書きする形質を<code>*</code>変更可能な参照の演算子を。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust does deref coercion when it finds types and trait implementations in three cases:</span>錆は3つのケースでタイプと特性の実装を見つけたときには逆変換を行います。</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">From <code>&amp;T</code> to <code>&amp;U</code> when <code>T: Deref&lt;Target=U&gt;</code></span> <code>T: Deref&lt;Target=U&gt;</code>ときに<code>&amp;T</code>から<code>&amp;U</code>まで</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">From <code>&amp;mut T</code> to <code>&amp;mut U</code> when <code>T: DerefMut&lt;Target=U&gt;</code></span> <code>T: DerefMut&lt;Target=U&gt;</code>とき、 <code>&amp;mut T</code>から<code>&amp;mut U</code>へ</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">From <code>&amp;mut T</code> to <code>&amp;U</code> when <code>T: Deref&lt;Target=U&gt;</code></span> <code>T: Deref&lt;Target=U&gt;</code>とき、 <code>&amp;mut T</code>から<code>&amp;U</code>へ</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The first two cases are the same except for mutability.</span>最初の2つのケースは、変更可能性を除いて同じです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The first case states that if you have a <code>&amp;T</code> , and <code>T</code> implements <code>Deref</code> to some type <code>U</code> , you can get a <code>&amp;U</code> transparently.</span>最初のケースでは、 <code>&amp;T</code>があり、 <code>T</code>が<code>Deref</code>をある種の<code>U</code>実装すると、 <code>&amp;U</code>透過的に得ることができると述べています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The second case states that the same deref coercion happens for mutable references.</span> 2番目のケースでは、可変参照のために同じ逆変換が行われると述べています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The third case is trickier: Rust will also coerce a mutable reference to an immutable one.</span> 3番目のケースは扱いにくいです：Rustは不変のものへの変更可能な参照を強制します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But the reverse is <i>not</i> possible: immutable references will never coerce to mutable references.</span>しかし、その逆は<i>できません</i> 。不変参照は決して変更可能な参照を強制しません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because of the borrowing rules, if you have a mutable reference, that mutable reference must be the only reference to that data (otherwise, the program wouldn&#39;t compile).</span>借用ルールのために、変更可能な参照がある場合、その変更可能な参照はそのデータへの唯一の参照でなければなりません（そうでなければ、プログラムはコンパイルされません）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Converting one mutable reference to one immutable reference will never break the borrowing rules.</span> 1つの可変参照を1つの不変参照に変換することは、借用ルールを破ることはありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Converting an immutable reference to a mutable reference would require that there is only one immutable reference to that data, and the borrowing rules don&#39;t guarantee that.</span>不変参照を変更可能な参照に変換するには、そのデータへの不変参照が1つしかないことが必要であり、借用規則はそれを保証するものではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Therefore, Rust can&#39;t make the assumption that converting an immutable reference to a mutable reference is possible.</span>したがって、Rustは不変参照を可変参照に変換することは可能であると仮定することはできません。</span> </p><script>_addload(function(){_setupIW('com');_csi('en','ja','ch15-02-deref.html');});</script>