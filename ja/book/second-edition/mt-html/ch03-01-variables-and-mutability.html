<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180709_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=ch03-01-variables-and-mutability.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Variables and Mutability</span>変数と変更可能性</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As mentioned in Chapter 2, by default variables are immutable.</span>第2章で述べたように、デフォルトでは変数は不変です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is one of many nudges Rust gives you to write your code in a way that takes advantage of the safety and easy concurrency that Rust offers.</span> Rustは、Rustが提供する安全性と容易な並行性を利用してコードを記述するために、多くのナッジの1つです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, you still have the option to make your variables mutable.</span>ただし、変数を変更可能にするオプションはあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s explore how and why Rust encourages you to favor immutability and why sometimes you might want to opt out.</span>どのように、そしてなぜRustがあなたに不変性を奨励し、なぜ時々オプトアウトを希望するのかを探そう。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When a variable is immutable, once a value is bound to a name, you can&#39;t change that value.</span>変数が不変の場合、値が名前にバインドされると、その値を変更することはできません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To illustrate this, let&#39;s generate a new project called <i>variables</i> in your <i>projects</i> directory by using <code>cargo new --bin variables</code> .</span>これを説明するために、 <code>cargo new --bin variables</code>を使用して、 <i>projects</i>ディレクトリに<i>variables</i>という新しいプロジェクトを生成しましょう。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then, in your new <i>variables</i> directory, open <i>src/main.rs</i> and replace its code with the following code that won&#39;t compile just yet:</span>次に、新しい<i>変数</i>ディレクトリで、 <i>src / main.rs</i>を開き、そのコードを、まだコンパイルされない次のコードに置き換えます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust,ignore><div data-l="fn main() {"></div><div data-l="    let x = 5;"></div><div data-l="    println!(&quot;The value of x is: {}&quot;, x);"></div><div data-l="    x = 6;"></div><div data-l="    println!(&quot;The value of x is: {}&quot;, x);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Save and run the program using <code>cargo run</code> .</span>カーゴランを使用してプログラムを保存して実行し<code>cargo run</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You should receive an error message, as shown in this output:</span>次の出力に示すように、エラーメッセージが表示されます。</span> </p><br><div data-lang=text><div data-l="error[E0384]: cannot assign twice to immutable variable `x`"></div><div data-l=" --&gt; src/main.rs:4:5"></div><div data-l="  |"></div><div data-l="2 |     let x = 5;"></div><div data-l="  |         - first assignment to `x`"></div><div data-l="3 |     println!(&quot;The value of x is: {}&quot;, x);"></div><div data-l="4 |     x = 6;"></div><div data-l="  |     ^^^^^ cannot assign twice to immutable variable"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This example shows how the compiler helps you find errors in your programs.</span>この例は、コンパイラがどのようにプログラムのエラーを見つけるのに役立つかを示しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Even though compiler errors can be frustrating, they only mean your program isn&#39;t safely doing what you want it to do yet;</span>コンパイラのエラーは苛立つことがありますが、あなたのプログラムはあなたがまだやりたいことを安全に実行していないことを意味します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">they do <i>not</i> mean that you&#39;re not a good programmer!</span>彼らはあなたが良いプログラマーでは<i>ない</i>ということを意味するものではありません！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Experienced Rustaceans still get compiler errors.</span>経験豊富な錆びた人はまだコンパイラのエラーが発生します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The error message indicates that the cause of the error is that you <code>cannot assign twice to immutable variable x</code> , because you tried to assign a second value to the immutable <code>x</code> variable.</span>エラーメッセージは、immutable <code>x</code>変数に2番目の値を代入しようとしたため、エラーの原因が<code>cannot assign twice to immutable variable x</code>示しています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It&#39;s important that we get compile-time errors when we attempt to change a value that we previously designated as immutable because this very situation can lead to bugs.</span>このような状況がバグにつながる可能性があるため、以前は不変として指定した値を変更しようとするとコンパイル時エラーが発生することが重要です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If one part of our code operates on the assumption that a value will never change and another part of our code changes that value, it&#39;s possible that the first part of the code won&#39;t do what it was designed to do.</span>コードの一部が変更されず、コードの別の部分がその値を変更すると仮定してコードの一部が動作する場合、コードの最初の部分は設計されたものを実行しない可能性があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The cause of this kind of bug can be difficult to track down after the fact, especially when the second piece of code changes the value only <i>sometimes</i> .</span>この種のバグの原因は事実の後で追跡するのが難しい場合が<i>あり</i>ます。特にコードの2番目の部分が値を<i>時々</i>変更する場合は特にそうです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In Rust, the compiler guarantees that when you state that a value won&#39;t change, it really won&#39;t change.</span> Rustでは、コンパイラは、値が変更されないことを宣言すると、実際には変更されないことを保証します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That means that when you&#39;re reading and writing code, you don&#39;t have to keep track of how and where a value might change.</span>つまり、コードを読み書きしているときに、値と値がどこでどのように変化するかを把握する必要はありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Your code is thus easier to reason through.</span>したがって、あなたのコードは理性的に簡単です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But mutability can be very useful.</span>しかし、変更可能性は非常に便利です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Variables are immutable only by default;</span>変数はデフォルトでのみ変更できません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">as you did in Chapter 2, you can make them mutable by adding <code>mut</code> in front of the variable name.</span>第2章で行ったように、変数名の前に<code>mut</code>を追加することで変数を変更可能にすることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In addition to allowing this value to change, <code>mut</code> conveys intent to future readers of the code by indicating that other parts of the code will be changing this variable value.</span>この値を変更できることに加えて、 <code>mut</code>は、コードの他の部分がこの変数値を変更することを示すことによって、将来のコード読者に意図を伝えます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, let&#39;s change <i>src/main.rs</i> to the following:</span>たとえば、 <i>src / main.rs</i>を次のように変更します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="fn main() {"></div><div data-l="    let mut x = 5;"></div><div data-l="    println!(&quot;The value of x is: {}&quot;, x);"></div><div data-l="    x = 6;"></div><div data-l="    println!(&quot;The value of x is: {}&quot;, x);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When we run the program now, we get this:</span>プログラムを今実行すると、次のようになります。</span> </p><br><div data-lang=text><div data-l="$ cargo run"></div><div data-l="   Compiling variables v0.1.0 (file:///projects/variables)"></div><div data-l="    Finished dev [unoptimized + debuginfo] target(s) in 0.30 secs"></div><div data-l="     Running `target/debug/variables`"></div><div data-l="The value of x is: 5"></div><div data-l="The value of x is: 6"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;re allowed to change the value that <code>x</code> binds to from <code>5</code> to <code>6</code> when <code>mut</code> is used.</span> <code>mut</code>が使用されているとき、 <code>x</code>バインドする値を<code>5</code>から<code>6</code>に変更することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In some cases, you&#39;ll want to make a variable mutable because it makes the code more convenient to write than if it had only immutable variables.</span>場合によっては、変数を変更可能にする必要があります。これは、変数に不変な変数がある場合よりも、コードを書く方が便利なためです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There are multiple trade-offs to consider in addition to the prevention of bugs.</span>バグの防止に加えて、考慮すべき複数のトレードオフがあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, in cases where you&#39;re using large data structures, mutating an instance in place may be faster than copying and returning newly allocated instances.</span>たとえば、大規模なデータ構造を使用している場合、インスタンスを変更すると、新しく割り当てられたインスタンスをコピーして返すよりも速くなる場合があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">With smaller data structures, creating new instances and writing in a more functional programming style may be easier to think through, so lower performance might be a worthwhile penalty for gaining that clarity.</span>より小さなデータ構造では、新しいインスタンスを作成し、より機能的なプログラミングスタイルで記述することが考えやすくなります。そのため、パフォーマンスが低下すると、その明快さを得るための価値のあるペナルティになる可能性があります。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Differences Between Variables and Constants</span>変数と定数の違い</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Being unable to change the value of a variable might have reminded you of another programming concept that most other languages have: <i>constants</i> .</span>変数の値を変更できない場合は、他のほとんどの言語で使用されている別のプログラミング概念、つまり<i>定数</i>を思い出させるかもしれません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Like immutable variables, constants are values that are bound to a name and are not allowed to change, but there are a few differences between constants and variables.</span>不変変数と同様に、定数は名前にバインドされ、変更が許可されない値ですが、定数と変数の間にはいくつかの違いがあります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">First, you aren&#39;t allowed to use <code>mut</code> with constants.</span>まず、定数で<code>mut</code>を使用することはできません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Constants aren&#39;t just immutable by default—they&#39;re always immutable.</span>定数は、デフォルトで不変ではなく、常に不変です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You declare constants using the <code>const</code> keyword instead of the <code>let</code> keyword, and the type of the value <i>must</i> be annotated.</span> <code>let</code>キーワードの代わりに<code>const</code>キーワードを使用して定数を宣言し、値の型に注釈を付ける<i>必要</i>が<i>あり</i>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;re about to cover types and type annotations in the next section, “Data Types,” so don&#39;t worry about the details right now.</span>次のセクション「データ型」で型と型名を扱いますので、今のところ詳細を心配しないでください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Just know that you must always annotate the type.</span>必ずタイプに注釈を付ける必要があることをご存じですか。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Constants can be declared in any scope, including the global scope, which makes them useful for values that many parts of code need to know about.</span>定数はグローバルスコープを含む任意のスコープで宣言することができ、コードの多くの部分が知る必要がある値に便利です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The last difference is that constants may be set only to a constant expression, not the result of a function call or any other value that could only be computed at runtime.</span>最後の違いは、定数は関数呼び出しの結果や実行時にのみ計算できる他の値ではなく、定数式にのみ設定できることです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here&#39;s an example of a constant declaration where the constant&#39;s name is <code>MAX_POINTS</code> and its value is set to 100,000.</span>次に、定数の名前が<code>MAX_POINTS</code> 、その値が100,000に設定されている定数宣言の例を示します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">(Rust&#39;s naming convention for constants is to use all uppercase with underscores between words):</span> （Rustの定数の命名規則では、単語の間に下線を付けて大文字を使用します）。</span> </p><br><div data-lang=rust><div data-l="const MAX_POINTS: u32 = 100_000;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Constants are valid for the entire time a program runs, within the scope they were declared in, making them a useful choice for values in your application domain that multiple parts of the program might need to know about, such as the maximum number of points any player of a game is allowed to earn or the speed of light.</span>定数は、プログラムが実行されている間、宣言されたスコープ内で有効です。プログラムの複数の部分について知る必要のあるアプリケーションドメイン内の値（たとえば、最大ポイント数ゲームのプレイヤーは、光の速度を得ることができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Naming hardcoded values used throughout your program as constants is useful in conveying the meaning of that value to future maintainers of the code.</span>プログラム全体で定数として使用されているハードコーディングされた値の名前は、その値の意味を将来のコードのメンテナに伝えるのに便利です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It also helps to have only one place in your code you would need to change if the hardcoded value needed to be updated in the future.</span>また、ハードコードされた値を将来更新する必要がある場合は、コード内に1つの場所だけを変更して変更する必要があります。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Shadowing</span>シャドウイング</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As you saw in the guessing game tutorial in the “Comparing the Guess to the Secret Number” section in Chapter 2, you can declare a new variable with the same name as a previous variable, and the new variable shadows the previous variable.</span>第2章の「推測値と秘密番号の比較」のセクションのゲームのチュートリアルで見たように、以前の変数と同じ名前の新しい変数を宣言し、新しい変数が前の変数をシャドウします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rustaceans say that the first variable is <i>shadowed</i> by the second, which means that the second variable&#39;s value is what appears when the variable is used.</span> Rustaceansは、最初の変数は2番目の変数によって<i>覆わ</i>れていると言います。つまり、2番目の変数の値は変数が使用されたときの値です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can shadow a variable by using the same variable&#39;s name and repeating the use of the <code>let</code> keyword as follows:</span>同じ変数の名前を使用し、 <code>let</code>キーワードの使用を次のように繰り返して、変数をシャドーできます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="fn main() {"></div><div data-l="    let x = 5;"></div><div data-l=""></div><div data-l="    let x = x + 1;"></div><div data-l=""></div><div data-l="    let x = x * 2;"></div><div data-l=""></div><div data-l="    println!(&quot;The value of x is: {}&quot;, x);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This program first binds <code>x</code> to a value of <code>5</code> .</span>このプログラムはまず、 <code>x</code>を値<code>5</code>バインドします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then it shadows <code>x</code> by repeating <code>let x =</code> , taking the original value and adding <code>1</code> so the value of <code>x</code> is then <code>6</code> .</span>それ影<code>x</code>繰り返すことにより、 <code>let x =</code> 、元の値を取得し、追加<code>1</code>の値ように<code>x</code>次にである<code>6</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The third <code>let</code> statement also shadows <code>x</code> , multiplying the previous value by <code>2</code> to give <code>x</code> a final value of <code>12</code> .</span> 3番目の<code>let</code>ステートメントは<code>x</code>シャドウし、前の値に<code>2</code>を掛けて<code>x</code>に最終値<code>12</code>を与えます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When we run this program, it will output the following:</span>このプログラムを実行すると、次のものが出力されます：</span> </p><br><div data-lang=text><div data-l="$ cargo run"></div><div data-l="   Compiling variables v0.1.0 (file:///projects/variables)"></div><div data-l="    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs"></div><div data-l="     Running `target/debug/variables`"></div><div data-l="The value of x is: 12"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Shadowing is different than marking a variable as <code>mut</code> , because we&#39;ll get a compile-time error if we accidentally try to reassign to this variable without using the <code>let</code> keyword.</span>シャドーイングは変数を<code>mut</code>としてマークするのとは異なります。なぜなら、誤って<code>let</code>キーワードを使用<code>let</code>ずにこの変数に再割り当てしようとすると、コンパイル時エラーが発生するからです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">By using <code>let</code> , we can perform a few transformations on a value but have the variable be immutable after those transformations have been completed.</span> <code>let</code>を使って、値に対していくつかの変換を実行できますが、変換が完了した後は変数を不変にすることができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The other difference between <code>mut</code> and shadowing is that because we&#39;re effectively creating a new variable when we use the <code>let</code> keyword again, we can change the type of the value but reuse the same name.</span> <code>mut</code>とshadowingのもう一つの違いは、 <code>let</code>キーワードを再び使用するときに新しい変数を効果的に作成するため、同じ名前を再利用することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, say our program asks a user to show how many spaces they want between some text by inputting space characters, but we really want to store that input as a number:</span>例えば、私たちのプログラムでは、スペース文字を入力することによってテキストの間にいくつのスペースが必要かを表示するようにユーザーに求めていますが、実際にはその入力を数値として保存したいとします。</span> </p><br><div data-lang=rust><div data-l="let spaces = &quot;   &quot;;"></div><div data-l="let spaces = spaces.len();"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This construct is allowed because the first <code>spaces</code> variable is a string type and the second <code>spaces</code> variable, which is a brand-new variable that happens to have the same name as the first one, is a number type.</span>最初の<code>spaces</code>変数が文字列型で、最初のものと同じ名前を持つまったく新しい変数である2番目の<code>spaces</code>変数が数値型なので、この構造体は許可されています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Shadowing thus spares us from having to come up with different names, such as <code>spaces_str</code> and <code>spaces_num</code> ;</span>したがって、 <code>spaces_str</code>や<code>spaces_num</code>ような異なる名前を<code>spaces_num</code>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">instead, we can reuse the simpler <code>spaces</code> name.</span>代わりに、より単純な<code>spaces</code>名を再利用することができ<code>spaces</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, if we try to use <code>mut</code> for this, as shown here, we&#39;ll get a compile-time error:</span>ただし、ここに示すように<code>mut</code>を使用しようとすると、コンパイル時エラーが発生します。</span> </p><br><div data-lang=rust,ignore><div data-l="let mut spaces = &quot;   &quot;;"></div><div data-l="spaces = spaces.len();"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The error says we&#39;re not allowed to mutate a variable&#39;s type:</span>エラーは、変数の型を変更することができないと言っています：</span> </p><br><div data-lang=text><div data-l="error[E0308]: mismatched types"></div><div data-l=" --&gt; src/main.rs:3:14"></div><div data-l="  |"></div><div data-l="3 |     spaces = spaces.len();"></div><div data-l="  |              ^^^^^^^^^^^^ expected &amp;str, found usize"></div><div data-l="  |"></div><div data-l="  = note: expected type `&amp;str`"></div><div data-l="             found type `usize`"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now that we&#39;ve explored how variables work, let&#39;s look at more data types they can have.</span>変数がどのように機能するかを調べたので、もっと多くのデータ型を見てみましょう。</span> </p><script>_addload(function(){_setupIW('com');_csi('en','ja','ch03-01-variables-and-mutability.html');});</script>