<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180709_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=appendix-04-macros.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Appendix D: Macros</span>付録D：マクロ</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ve used macros like <code>println€</code> throughout this book but haven&#39;t fully explored what a macro is and how it works.</span>この本では<code>println€</code>ようなマクロを使用しましたが、マクロが何であるか、そしてマクロがどのように機能しているかを完全には調べていません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This appendix explains macros as follows:</span>この付録では、マクロについて次のように説明します。</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">What macros are and how they differ from functions</span>マクロとはどのようなもので、どのように機能と異なるのか</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">How to define a declarative macro to do metaprogramming</span>メタプログラミングを行うための宣言型マクロの定義方法</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">How to define a procedural macro to create custom <code>derive</code> traits</span>カスタム<code>derive</code>特性を作成する手続き型マクロを定義する方法</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;re covering the details of macros in an appendix because they&#39;re still evolving in Rust.</span>付録のマクロの詳細については、まだRustで進化しているため、詳しく説明しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Macros have changed and, in the near future, will change at a quicker rate than the rest of the language and standard library since Rust 1.0, so this section is more likely to become out-of-date than the rest of the book.</span>マクロは変更されています。近い将来、Rust 1.0以来、言語と標準ライブラリの残りの部分よりも速い速度で変更されるため、このセクションは本書の他の部分よりも古くなる可能性が高くなります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Due to Rust&#39;s stability guarantees, the code shown here will continue to work with future versions, but there may be additional capabilities or easier ways to write macros that weren&#39;t available at the time of this publication.</span> Rustの安定性保証のため、ここに示すコードは今後のバージョンでも引き続き動作しますが、本書の発行時点では入手できなかったマクロを書くための追加機能や簡単な方法があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Bear that in mind when you try to implement anything from this appendix.</span>あなたがこの付録から何かを実装しようとするとき、それを念頭に置いてください。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The Difference Between Macros and Functions</span>マクロと関数の違い</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Fundamentally, macros are a way of writing code that writes other code, which is known as <i>metaprogramming</i> .</span>基本的に、マクロは他のコードを書き込むコードを書く方法です。これは<i>メタプログラミング</i>と呼ばれています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In Appendix C, we discussed the <code>derive</code> attribute, which generates an implementation of various traits for you.</span>付録Cでは、さまざまな特性の実装を生成<code>derive</code>属性について説明しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ve also used the <code>println€</code> and <code>vec€</code> macros throughout the book.</span>また、本の中で<code>println€</code>と<code>vec€</code>マクロを使用しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">All of these macros <i>expand</i> to produce more code than the code you&#39;ve written manually.</span>これらのマクロはすべて、手動で記述したコードよりも多くのコードを生成するように<i>拡張</i>されています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Metaprogramming is useful for reducing the amount of code you have to write and maintain, which is also one of the roles of functions.</span>メタプログラミングは、コードの量を減らすのに役立ちます。これは、関数の役割の1つです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, macros have some additional powers that functions don&#39;t have.</span>しかし、マクロには、機能にはないいくつかの追加機能があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A function signature must declare the number and type of parameters the function has.</span>関数シグネチャは、その関数が持つパラメータの数と型を宣言しなければなりません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Macros, on the other hand, can take a variable number of parameters: we can call <code>println€(&quot;hello&quot;)</code> with one argument or <code>println€(&quot;hello {}&quot;, name)</code> with two arguments.</span>一方、マクロは、さまざまなパラメータを取ることができます<code>println€(&quot;hello&quot;)</code>を1つの引数で、 <code>println€(&quot;hello {}&quot;, name)</code>を2つの引数で呼び出すことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Also, macros are expanded before the compiler interprets the meaning of the code, so a macro can, for example, implement a trait on a given type.</span>また、マクロは、コンパイラがコードの意味を解釈する前に展開されるため、マクロは、たとえば、特定の型の特性を実装できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A function can&#39;t, because it gets called at runtime and a trait needs to be implemented at compile time.</span>関数は実行時に呼び出され、コンパイル時に特性を実装する必要があるため、できません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The downside to implementing a macro instead of a function is that macro definitions are more complex than function definitions because you&#39;re writing Rust code that writes Rust code.</span>関数の代わりにマクロを実装することの欠点は、マクロ定義が関数定義よりも複雑であることです.Rustコードを記述するRustコードを記述しているからです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Due to this indirection, macro definitions are generally more difficult to read, understand, and maintain than function definitions.</span>この間接指定のため、マクロ定義は一般に、関数定義よりも読み込み、理解、および保守がより困難です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Another difference between macros and functions is that macro definitions aren&#39;t namespaced within modules like function definitions are.</span>マクロと関数の別の違いは、マクロ定義は関数定義のようにモジュール内で名前空間を持たないということです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To prevent unexpected name clashes when using external crates, you have to explicitly bring the macros into the scope of your project at the same time as you bring the external crate into scope, using the <code>#[macro_use]</code> annotation.</span>外部クレートを使用するときに予期しない名前の衝突を防ぐために、 <code>#[macro_use]</code>アノテーションを使用して外部クレートをスコープに入れると同時に、マクロをプロジェクトのスコープに明示的に持ち込まなければなりません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The following example would bring all the macros defined in the <code>serde</code> crate into the scope of the current crate:</span>次の例では、 <code>serde</code>定義されているすべてのマクロを現在の<code>serde</code>のスコープに<code>serde</code>ます。</span> </p><br><div data-lang=rust,ignore><div data-l=#[macro_use]></div><div data-l="extern crate serde;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If <code>extern crate</code> was able to bring macros into scope by default without this explicit annotation, you would be prevented from using two crates that happened to define macros with the same name.</span>この明示的な注釈がなくても<code>extern crate</code>がデフォルトでマクロをスコープに入れることができれば、同じ名前のマクロを定義した2つの枠を使用することはできません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In practice, this conflict doesn&#39;t occur often, but the more crates you use, the more likely it is.</span>実際には、この競合は頻繁には発生しませんが、使用するクレートが多いほど、可能性が高くなります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There is one last important difference between macros and functions: you must define or bring macros into scope <i>before</i> you call them in a file, whereas you can define functions anywhere and call them anywhere.</span>マクロと関数の間には最後に重要な違いが1つあります。ファイルを呼び出す<i>前に</i>マクロを定義または指定しなければなりませんが、どこでも関数を定義してどこでも呼び出すことができます。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Declarative Macros with <code>macro_rules€</code> for General Metaprogramming</span>一般的なメタプログラミングのための<code>macro_rules€</code>持つ宣言的マクロ</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The most widely used form of macros in Rust are <i>declarative macros</i> .</span> Rustの中で最も広く使われているマクロは、 <i>宣言型のマクロ</i>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These are also sometimes referred to as <i>macros by example</i> , <i>`macro_rules!` macros</i> , or just plain <i>macros</i> .</span>これらは<i>、例として</i> 、 <i>マクロ</i> 、 <i>マクロ</i> 、または単純な<i>マクロでマクロ</i>と呼ばれることもあり<i>ます</i> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">At their core, declarative macros allow you to write something similar to a Rust <code>match</code> expression.</span>彼らのコアでは、宣言型マクロを使用して、Rust <code>match</code>式に類似したものを書くことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As discussed in Chapter 6, <code>match</code> expressions are control structures that take an expression, compare the resulting value of the expression to patterns, and then run the code associated with the matching pattern.</span>第6章で説明したように、 <code>match</code>式は式を取得し、結果の式の値をパターンと比較し、一致するパターンに関連付けられたコードを実行する制御構造です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Macros also compare a value to patterns that have code associated with them;</span>また、マクロは値を、それらに関連付けられたコードを持つパターンと比較します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">in this situation, the value is the literal Rust source code passed to the macro, the patterns are compared with the structure of that source code, and the code associated with each pattern is the code that replaces the code passed to the macro.</span>この状況では、値はマクロに渡されるリテラルルストソースコードであり、パターンはそのソースコードの構造と比較され、各パターンに関連付けられたコードは、マクロに渡されたコードを置き換えるコードです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This all happens during compilation.</span>これはすべてコンパイル時に発生します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To define a macro, you use the <code>macro_rules€</code> construct.</span>マクロを定義するには、 <code>macro_rules€</code>構造を使用します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s explore how to use <code>macro_rules€</code> by looking at how the <code>vec€</code> macro is defined.</span> <code>vec€</code>マクロがどのように定義されているかを見て、 <code>macro_rules€</code>どのように使用するかを<code>macro_rules€</code>う。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Chapter 8 covered how we can use the <code>vec€</code> macro to create a new vector with particular values.</span>第8章では、 <code>vec€</code>マクロを使用して特定の値を持つ新しいベクトルを作成する方法について説明しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, the following macro creates a new vector with three integers inside:</span>たとえば、次のマクロは、内部に3つの整数を持つ新しいベクトルを作成します。</span> </p><br><div data-lang=rust><div data-l="let v: Vec&lt;u32&gt; = vec![1, 2, 3];"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We could also use the <code>vec€</code> macro to make a vector of two integers or a vector of five string slices.</span> <code>vec€</code>マクロを使って、2つの整数のベクトルまたは5つの文字列スライスのベクトルを作ることもできます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We wouldn&#39;t be able to use a function to do the same because we wouldn&#39;t know the number or type of values up front.</span>値の数や型が前もってわからないので、同じことをする関数を使用することはできません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s look at a slightly simplified definition of the <code>vec€</code> macro in Listing D-1.</span>リストD-1の<code>vec€</code>マクロのやや簡略化された定義を見てみましょう。</span> </p><br><div data-lang=rust><div data-l=#[macro_export]></div><div data-l="macro_rules! vec {"></div><div data-l="    ( $( $x:expr ),* ) =&gt; {"></div><div data-l="        {"></div><div data-l="            let mut temp_vec = Vec::new();"></div><div data-l="            $("></div><div data-l="                temp_vec.push($x);"></div><div data-l="            )*"></div><div data-l="            temp_vec"></div><div data-l="        }"></div><div data-l="    };"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing D-1: A simplified version of the <code>vec€</code> macro definition</span></span> <span class=caption>リストD-1： <code>vec€</code>マクロ定義の簡略化されたバージョン</span></span> </p><br><blockquote><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note: The actual definition of the <code>vec€</code> macro in the standard library includes code to preallocate the correct amount of memory up front.</span>注：標準ライブラリの<code>vec€</code>マクロの実際の定義には、正しい量のメモリを事前に割り当てるためのコードが含まれています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That code is an optimization that we don&#39;t include here to make the example simpler.</span>このコードは、例を簡単にするためにここには含まれていない最適化です。</span> </p></blockquote><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>#[macro_export]</code> annotation indicates that this macro should be made available whenever the crate in which we&#39;re defining the macro is imported.</span> <code>#[macro_export]</code>アノテーションは、マクロを定義しているクレートをインポートするたびにこのマクロを使用可能にする必要があることを示します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Without this annotation, even if someone depending on this crate uses the <code>#[macro_use]</code> annotation, the macro wouldn&#39;t be brought into scope.</span>この注釈がなければ、たとえこのクレートに依存する人が<code>#[macro_use]</code>注釈を使用しても、マクロはスコープに入れられません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We then start the macro definition with <code>macro_rules€</code> and the name of the macro we&#39;re defining <i>without</i> the exclamation mark.</span>次に、マクロ定義を<code>macro_rules€</code>開始し、マクロの名前を感嘆符<i>なしで</i>定義します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The name, in this case <code>vec</code> , is followed by curly brackets denoting the body of the macro definition.</span>名前（この場合は<code>vec</code> ）の後に、マクロ定義の本文を示す中括弧が続きます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The structure in the <code>vec€</code> body is similar to the structure of a <code>match</code> expression.</span> <code>vec€</code>本文の構造は、 <code>match</code>式の構造に似ています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here we have one arm with the pattern <code>( $( $x:expr ),* )</code> , followed by <code>=&gt;</code> and the block of code associated with this pattern.</span>ここでは、パターン<code>( $( $x:expr ),* )</code>あとに<code>=&gt;</code>とこのパターンに関連付けられたコードブロックが続く1つの腕があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If the pattern matches, the associated block of code will be emitted.</span>パターンが一致すると、関連付けられたコードブロックが発行されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Given that this is the only pattern in this macro, there is only one valid way to match;</span>これがこのマクロの唯一のパターンであることを考えれば、一致させる有効な方法は1つだけです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">any other will be an error.</span>それ以外の場合はエラーになります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">More complex macros will have more than one arm.</span>より複雑なマクロは、複数のアームを持ちます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Valid pattern syntax in macro definitions is different than the pattern syntax covered in Chapter 18 because macro patterns are matched against Rust code structure rather than values.</span>マクロ定義の有効なパターン構文は、マクロパターンが値ではなく錆のコード構造と照合されるため、第18章で説明するパターン構文とは異なります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s walk through what the pieces of the pattern in Listing D-1 mean;</span>リストD-1のパターンの部分が何を意味しているかを見てみましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">for the full macro pattern syntax, see <a class=notranslate href="#4the reference">the reference</a> .</span>マクロパターンの完全な構文について<a class=notranslate href="#4the reference">the reference</a>参照し<a class=notranslate href="#4the reference">the reference</a> 。</span> </p><br> <a class=notranslate href=#1../../reference/macros.html>the reference</a> <br> <p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">First, a set of parentheses encompasses the whole pattern.</span>第1に、カッコの集合はパターン全体を包含する。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Next comes a dollar sign ( <code>$</code> ) followed by a set of parentheses, which captures values that match the pattern within the parentheses for use in the replacement code.</span>次に、ドル記号（ <code>$</code> ）とそれに続くカッコがあり、置換コードで使用するカッコ内のパターンと一致する値を取得します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Within <code>$()</code> is <code>$x:expr</code> , which matches any Rust expression and gives the expression the name <code>$x</code> .</span> <code>$()</code>内には<code>$x:expr</code>があり、Rust式に一致し、 <code>$x</code>という名前の式になります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The comma following <code>$()</code> indicates that a literal comma separator character could optionally appear after the code that matches the code captured in <code>$()</code> .</span> <code>$()</code>後のカンマは、 <code>$()</code>取り込まれたコードと一致するコードの後に​​リテラルカンマ区切り文字がオプションで現れることを示します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>*</code> following the comma specifies that the pattern matches zero or more of whatever precedes the <code>*</code> .</span> <code>*</code>は、コンマの後に<code>*</code>が先行するものの0個以上と一致することを指定します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When we call this macro with <code>vec€[1, 2, 3];</code></span>このマクロを<code>vec€[1, 2, 3];</code>と呼ぶと<code>vec€[1, 2, 3];</code></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">, the <code>$x</code> pattern matches three times with the three expressions <code>1</code> , <code>2</code> , and <code>3</code> .</span> 、 <code>$x</code>パターンは3つの式で三回に一致する<code>1</code> 、 <code>2</code> 、および<code>3</code> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now let&#39;s look at the pattern in the body of the code associated with this arm: the <code>temp_vec.push()</code> code within the <code>$()*</code> part is generated for each part that matches <code>$()</code> in the pattern, zero or more times depending on how many times the pattern matches.</span>それでは、このアームに関連するコードの本体内のパターンを見てみましょう： <code>temp_vec.push()</code>内のコード<code>$()*</code>の部分が一致する部分ごとに生成される<code>$()</code>パターンで、0回以上の依存しますパターンの一致回数</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>$x</code> is replaced with each expression matched.</span> <code>$x</code>は、一致した各式に置き換えられます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When we call this macro with <code>vec€[1, 2, 3];</code></span>このマクロを<code>vec€[1, 2, 3];</code>と呼ぶと<code>vec€[1, 2, 3];</code></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">, the code generated that replaces this macro call will be the following:</span>このマクロ呼び出しを置き換えて生成されるコードは、次のようになります。</span> </p><br><div data-lang=rust,ignore><div data-l="let mut temp_vec = Vec::new();"></div><div data-l=temp_vec.push(1);></div><div data-l=temp_vec.push(2);></div><div data-l=temp_vec.push(3);></div><div data-l=temp_vec></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ve defined a macro that can take any number of arguments of any type and can generate code to create a vector containing the specified elements.</span>任意の数の引数を取ることができるマクロを定義し、指定された要素を含むベクトルを作成するコードを生成できます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Given that most Rust programmers will <i>use</i> macros more than <i>write</i> macros, we won&#39;t discuss <code>macro_rules€</code> any further.</span>ほとんどのRustプログラマがマクロを<i>書く</i>以上にマクロを<i>使用</i>することを考えれば、 <code>macro_rules€</code>についてはこれ以上議論しません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To learn more about how to write macros, consult the online documentation or other resources, such as <a href=#3tlborm>“The Little Book of Rust Macros”</a> .</span>マクロの作成方法の詳細については、オンラインドキュメントまたは<a href=#3tlborm>「The Little Book of Rust Macros」</a>などの他のリソースを参照してください。</span> </p><br> <a class=notranslate href=#1https://danielkeep.github.io/tlborm/book/index.html>tlborm</a> <br> <h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Procedural Macros for Custom <code>derive</code></span>カスタム用プロシージャ・マクロの<code>derive</code></span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The second form of macros is called <i>procedural macros</i> because they&#39;re more like functions (which are a type of procedure).</span>マクロの第2の形式は、 <i>プロシージャ型</i>マクロと呼ばれ<i>ます。</i>なぜなら、マクロは関数（プロシージャの一種）のようなものですからです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Procedural macros accept some Rust code as an input, operate on that code, and produce some Rust code as an output rather than matching against patterns and replacing the code with other code as declarative macros do.</span>手続き型マクロは、入力としていくつかの錆コードを受け入れ、そのコードを操作し、パターンと照合する代わりに出力としていくつかの錆コードを生成し、宣言的マクロのようにコードを他のコードに置き換えます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">At the time of this writing, you can only define procedural macros to allow your traits to be implemented on a type by specifying the trait name in a <code>derive</code> annotation.</span>この執筆時点では、手続き型マクロを定義するだけで、型に型を実装できるようにすることができます。型名を<code>derive</code>アノテーションに指定します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll create a crate named <code>hello_macro</code> that defines a trait named <code>HelloMacro</code> with one associated function named <code>hello_macro</code> .</span>私たちは、クレートという名前の作成します<code>hello_macro</code>という名前の特色定義<code>HelloMacro</code>という名前の関連する機能を<code>hello_macro</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rather than making our crate users implement the <code>HelloMacro</code> trait for each of their types, we&#39;ll provide a procedural macro so users can annotate their type with <code>#[derive(HelloMacro)]</code> to get a default implementation of the <code>hello_macro</code> function.</span>私たちの箱のユーザーにそれぞれの型の<code>HelloMacro</code>特性を実装させるのではなく、手続き型マクロを用意し、 <code>#[derive(HelloMacro)]</code>注釈を付けて<code>hello_macro</code>関数のデフォルト実装を得ることが<code>hello_macro</code>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The default implementation will print <code>Hello, Macro€ My name is TypeName€</code> where <code>TypeName</code> is the name of the type on which this trait has been defined.</span>デフォルト実装は<code>Hello, Macro€ My name is TypeName€</code>を出力します<code>Hello, Macro€ My name is TypeName€</code>ここで、 <code>TypeName</code>は、この特性が定義されているタイプの名前です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In other words, we&#39;ll write a crate that enables another programmer to write code like Listing D-2 using our crate.</span>言い換えれば、別のプログラマーが私たちのクレートを使ってリストD-2のようなコードを書くことを可能にする木枠を書くでしょう。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust,ignore><div data-l="extern crate hello_macro;"></div><div data-l=#[macro_use]></div><div data-l="extern crate hello_macro_derive;"></div><div data-l=""></div><div data-l="use hello_macro::HelloMacro;"></div><div data-l=""></div><div data-l=#[derive(HelloMacro)]></div><div data-l="struct Pancakes;"></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    Pancakes::hello_macro();"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing D-2: The code a user of our crate will be able to write when using our procedural macro</span></span> <span class=caption>リストD-2：手続き型マクロを使用しているときに、crateのユーザが書き込むことができるコード</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This code will print <code>Hello, Macro€ My name is Pancakes€</code> when we&#39;re done.</span>このコードは<code>Hello, Macro€ My name is Pancakes€</code>を印刷します。私たちが終わっ<code>Hello, Macro€ My name is Pancakes€</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The first step is to make a new library crate, like this:</span>最初のステップは、次のように新しいライブラリの箱を作ることです：</span> </p><br><div data-lang=text><div data-l="$ cargo new hello_macro --lib"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Next, we&#39;ll define the <code>HelloMacro</code> trait and its associated function:</span>次に、 <code>HelloMacro</code>特性とそれに関連する関数を定義します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/lib.rs</span></span> <span class=filename>ファイル名：src / lib.rs</span></span> </p><br><div data-lang=rust><div data-l="pub trait HelloMacro {"></div><div data-l="    fn hello_macro();"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We have a trait and its function.</span>私たちは特性とその機能を持っています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">At this point, our crate user could implement the trait to achieve the desired functionality, like so:</span>この時点で、私たちのクレートユーザーは、以下のように、目的の機能を実現するために特性を実装することができます：</span> </p><br><div data-lang=rust,ignore><div data-l="extern crate hello_macro;"></div><div data-l=""></div><div data-l="use hello_macro::HelloMacro;"></div><div data-l=""></div><div data-l="struct Pancakes;"></div><div data-l=""></div><div data-l="impl HelloMacro for Pancakes {"></div><div data-l="    fn hello_macro() {"></div><div data-l="        println!(&quot;Hello, Macro! My name is Pancakes!&quot;);"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    Pancakes::hello_macro();"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, they would need to write the implementation block for each type they wanted to use with <code>hello_macro</code> ;</span>ただし、 <code>hello_macro</code>使用したいそれぞれのタイプの実装ブロックを記述する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">we want to spare them from having to do this work.</span>私たちは彼らがこの仕事をしなくて済むようにしたいと思っています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Additionally, we can&#39;t yet provide a default implementation for the <code>hello_macro</code> function that will print the name of the type the trait is implemented on: Rust doesn&#39;t have reflection capabilities, so it can&#39;t look up the type&#39;s name at runtime.</span>さらに、特性が実装されている型の名前を表示する<code>hello_macro</code>関数のデフォルト実装をまだ提供することはできません<code>hello_macro</code>は<code>hello_macro</code>機能を持たないため、実行時に型名をルックアップすることはできません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We need a macro to generate code at compile time.</span>コンパイル時にコードを生成するにはマクロが必要です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The next step is to define the procedural macro.</span>次の手順では手続き型マクロを定義します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">At the time of this writing, procedural macros need to be in their own crate.</span>この記事の執筆時点では、手続き型マクロは独自の枠組みに入れる必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Eventually, this restriction might be lifted.</span>最終的には、この制限が解除される可能性があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The convention for structuring crates and macro crates is as follows: for a crate named <code>foo</code> , a custom derive procedural macro crate is called <code>foo_derive</code> .</span>次のように構造化木箱やマクロ箱のための規則は次のとおりです。名前のクレートのため<code>foo</code> 、カスタム手続きマクロクレートが呼び出される派生<code>foo_derive</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s start a new crate called <code>hello_macro_derive</code> inside our <code>hello_macro</code> project:</span> <code>hello_macro</code>プロジェクトの中に<code>hello_macro_derive</code>という新しいクレートを<code>hello_macro_derive</code>ましょう：</span> </p><br><div data-lang=text><div data-l="$ cargo new hello_macro_derive --lib"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Our two crates are tightly related, so we create the procedural macro crate within the directory of our <code>hello_macro</code> crate.</span>私たちの2つの箱は密接に関連しているので、私たちは<code>hello_macro</code>箱のディレクトリ内に手順マクロクレートを作成します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we change the trait definition in <code>hello_macro</code> , we&#39;ll have to change the implementation of the procedural macro in <code>hello_macro_derive</code> as well.</span>私たちが形質定義を変更した場合<code>hello_macro</code> 、我々は中に手続きマクロの実装に変更する必要があります<code>hello_macro_derive</code>同様。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The two crates will need to be published separately, and programmers using these crates will need to add both as dependencies and bring them both into scope.</span> 2つのテンプレートは別々に公開する必要があり、これらのテンプレートを使用するプログラマは、両方を依存関係として追加し、それらの両方を有効範囲に入れる必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We could instead have the <code>hello_macro</code> crate use <code>hello_macro_derive</code> as a dependency and reexport the procedural macro code.</span>代わりに、 <code>hello_macro</code>依存関係として<code>hello_macro_derive</code>を使用させ、手続き型マクロコードを再<code>hello_macro_derive</code>することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But the way we&#39;ve structured the project makes it possible for programmers to use <code>hello_macro</code> even if they don&#39;t want the <code>derive</code> functionality.</span>しかし、私たちがプロジェクトを構造化したやり方によって、プログラマは、たとえそれが<code>derive</code>機能を望まないとしても、 <code>hello_macro</code>を使うことができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We need to declare the <code>hello_macro_derive</code> crate as a procedural macro crate.</span> <code>hello_macro_derive</code>枠を手続きマクロ枠として宣言する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll also need functionality from the <code>syn</code> and <code>quote</code> crates, as you&#39;ll see in a moment, so we need to add them as dependencies.</span>また、 <code>syn</code>と<code>quote</code>クレートの機能が必要になり<code>quote</code>すぐにわかるように、それらを依存関係として追加する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Add the following to the <i>Cargo.toml</i> file for <code>hello_macro_derive</code> :</span>用<i>Cargo.tomlファイル</i>に次の行を追加します<code>hello_macro_derive</code> ：</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: hello_macro_derive/Cargo.toml</span></span> <span class=filename>ファイル名：hello_macro_derive / Cargo.toml</span></span> </p><br><div data-lang=toml><div data-l=[lib]></div><div data-l="proc-macro = true"></div><div data-l=""></div><div data-l=[dependencies]></div><div data-l="syn = &quot;0.11.11&quot;"></div><div data-l="quote = &quot;0.3.15&quot;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To start defining the procedural macro, place the code in Listing D-3 into your <i>src/lib.rs</i> file for the <code>hello_macro_derive</code> crate.</span>手続きマクロの定義を開始するには、あなたのため<i>のsrc / lib.rsファイル</i>にリストD-3のコードを配置<code>hello_macro_derive</code>クレート。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that this code won&#39;t compile until we add a definition for the <code>impl_hello_macro</code> function.</span>このコードは、 <code>impl_hello_macro</code>関数の定義を追加するまでコンパイルされません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: hello_macro_derive/src/lib.rs</span></span> <span class=filename>ファイル名：hello_macro_derive / src / lib.rs</span></span> </p><br><div data-lang=rust,ignore><div data-l="extern crate proc_macro;"></div><div data-l="extern crate syn;"></div><div data-l=#[macro_use]></div><div data-l="extern crate quote;"></div><div data-l=""></div><div data-l="use proc_macro::TokenStream;"></div><div data-l=""></div><div data-l=#[proc_macro_derive(HelloMacro)]></div><div data-l="pub fn hello_macro_derive(input: TokenStream) -&gt; TokenStream {"></div><div data-l="#    // Construct a string representation of the type definition"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Construct a string representation of the type definition</span>型定義の文字列表現を構築します。</span> </div><div data-l="    let s = input.to_string();"></div><div data-l=""></div><div data-l="#    // Parse the string representation"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Parse the string representation</span>文字列表現を解析する</span> </div><div data-l="    let ast = syn::parse_derive_input(&amp;s).unwrap();"></div><div data-l=""></div><div data-l="#    // Build the impl"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Build the impl</span>インプラントを構築する</span> </div><div data-l="    let gen = impl_hello_macro(&amp;ast);"></div><div data-l=""></div><div data-l="#    // Return the generated impl"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Return the generated impl</span>生成されたimplを返す</span> </div><div data-l="    gen.parse().unwrap()"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing D-3: Code that most procedural macro crates will need to have for processing Rust code</span></span> <span class=caption>リストD-3：錆コードを処理するために、ほとんどの手続き型マクロクラートで必要となるコード</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Notice the way we&#39;ve split the functions in D-3;</span> D-3で関数を分割した方法に注目してください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">this will be the same for almost every procedural macro crate you see or create, because it makes writing a procedural macro more convenient.</span>手続き型マクロの作成がより便利になるため、表示または作成するほとんどすべての手続き型マクロクレートで同じ結果になります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">What you choose to do in the place where the <code>impl_hello_macro</code> function is called will be different depending on your procedural macro&#39;s purpose.</span> <code>impl_hello_macro</code>関数が呼び出される場所で行うことは、手続き型マクロの目的によって異なります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ve introduced three new crates: <code>proc_macro</code> , <a class=notranslate href="#4`syn`">`syn`</a> , and <a class=notranslate href="#4`quote`">`quote`</a> .</span> ：私たちは3つの新しい箱を導入しました<code>proc_macro</code> 、 <a class=notranslate href="#4`syn`">`syn`</a> 、および<a class=notranslate href="#4`quote`">`quote`</a> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>proc_macro</code> crate comes with Rust, so we didn&#39;t need to add that to the dependencies in <i>Cargo.toml</i> .</span> <code>proc_macro</code>箱にはRustが付いているので、 <i>Cargo.toml</i>の依存関係に追加する必要はありません<i>でした</i> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>proc_macro</code> crate allows us to convert Rust code into a string containing that Rust code.</span> <code>proc_macro</code> 、RustコードをそのRustコードを含む文字列に変換することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>syn</code> crate parses Rust code from a string into a data structure that we can perform operations on.</span> <code>syn</code>クレートは、我々は上の操作を行うことができ、データ構造に文字列から錆コードを解析します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>quote</code> crate takes <code>syn</code> data structures and turns them back into Rust code.</span> <code>quote</code>クレートは<code>syn</code>データ構造を取り、それを錆コードに戻します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These crates make it much simpler to parse any sort of Rust code we might want to handle: writing a full parser for Rust code is no simple task.</span>これらの箱は、処理したいあらゆる種類の錆コードを解析するのがはるかに簡単になります。錆コードの完全なパーサーを書くことは簡単な作業ではありません。</span> </p><br> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a class=notranslate href=#1https://crates.io/crates/syn>`syn`</a> <a class=notranslate href=#1https://crates.io/crates/quote>`quote`</a></span> <a class=notranslate href=#1https://crates.io/crates/syn>`syn`</a> <a class=notranslate href=#1https://crates.io/crates/quote>`quote`</a></span> <br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>hello_macro_derive</code> function will get called when a user of our library specifies <code>#[derive(HelloMacro)]</code> on a type.</span> <code>hello_macro_derive</code>関数は、ライブラリのユーザがあるタイプに対して<code>#[derive(HelloMacro)]</code>を指定したときに呼び出されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The reason is that we&#39;ve annotated the <code>hello_macro_derive</code> function here with <code>proc_macro_derive</code> and specified the name, <code>HelloMacro</code> , which matches our trait name;</span>その理由は、私たちが注釈を付けたことである<code>hello_macro_derive</code>とここに機能を<code>proc_macro_derive</code> 、名前、指定<code>HelloMacro</code>当社の特色名と一致します;</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">that&#39;s the convention most procedural macros follow.</span>それはほとんどの手続き型マクロが従う規約です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This function first converts the <code>input</code> from a <code>TokenStream</code> to a <code>String</code> by calling <code>to_string</code> .</span>この関数は、最初の変換<code>input</code>から<code>TokenStream</code>に<code>String</code>呼び出すことにより、 <code>to_string</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This <code>String</code> is a string representation of the Rust code for which we are deriving <code>HelloMacro</code> .</span>この<code>String</code>は、 <code>HelloMacro</code>を派生させている錆コードの文字列表現です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In the example in Listing D-2, <code>s</code> will have the <code>String</code> value <code>struct Pancakes;</code></span>リストD-2の例では、 <code>s</code>は<code>String</code>値<code>struct Pancakes;</code>を持ち<code>struct Pancakes;</code></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">because that is the Rust code we added the <code>#[derive(HelloMacro)]</code> annotation to.</span>これは<code>#[derive(HelloMacro)]</code>アノテーションを追加した錆コードです。</span> </p><br><blockquote><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note: At the time of this writing, you can only convert a <code>TokenStream</code> to a string.</span>注意：この執筆時点では、 <code>TokenStream</code>を文字列に変換することしかできません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A richer API will exist in the future.</span>将来、豊富なAPIが存在するでしょう。</span> </p></blockquote><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now we need to parse the Rust code <code>String</code> into a data structure that we can then interpret and perform operations on.</span>次に、Rustコード<code>String</code>を解析して操作を実行できるデータ構造に解析する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is where <code>syn</code> comes into play.</span>これが<code>syn</code>が出場する場所です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>parse_derive_input</code> function in <code>syn</code> takes a <code>String</code> and returns a <code>DeriveInput</code> struct representing the parsed Rust code.</span> <code>syn</code>の<code>parse_derive_input</code>関数は<code>String</code>をとり、解析されたRustコードを表す<code>DeriveInput</code>構造体を返します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The following code shows the relevant parts of the <code>DeriveInput</code> struct we get from parsing the string <code>struct Pancakes;</code></span>次のコードは、 <code>struct Pancakes;</code>という文字列を解析して得られる<code>DeriveInput</code>構造体の関連部分を示しています<code>struct Pancakes;</code></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">:</span> ：</span> </p><br><div data-lang=rust,ignore><div data-l="DeriveInput {"></div><div data-l="#    // --snip--"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">--snip--</span> --snip--</span> </div><div data-l=""></div><div data-l="    ident: Ident("></div><div data-l="        &quot;Pancakes&quot;"></div><div data-l="    ),"></div><div data-l="    body: Struct("></div><div data-l="        Unit"></div><div data-l="    )"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The fields of this struct show that the Rust code we&#39;ve parsed is a unit struct with the <code>ident</code> (identifier, meaning the name) of <code>Pancakes</code> .</span>この構造体のフィールドは、解析した錆コードが<code>Pancakes</code>の<code>ident</code> （識別子、名前を意味する）を持つ単位構造体であることを示しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There are more fields on this struct for describing all sorts of Rust code;</span>この構造体には、あらゆる種類の錆コードを記述するフィールドがあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">check the <a href=#3syn-docs><code>syn</code> documentation for <code>DeriveInput</code></a> for more information.</span>詳細については<a href=#3syn-docs>、 <code>DeriveInput</code></a>の<a href=#3syn-docs><code>syn</code>ドキュメントを<code>DeriveInput</code></a>してください。</span> </p><br> <a class=notranslate href=#1https://docs.rs/syn/0.11.11/syn/struct.DeriveInput.html>syn-docs</a> <br> <p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">At this point, we haven&#39;t defined the <code>impl_hello_macro</code> function, which is where we&#39;ll build the new Rust code we want to include.</span>この時点では、 <code>impl_hello_macro</code>関数を定義していません。これは、インクルードしたい新しいRustコードを作成するところです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But before we do, note that the last part of this <code>hello_macro_derive</code> function uses the <code>parse</code> function from the <code>quote</code> crate to turn the output of the <code>impl_hello_macro</code> function back into a <code>TokenStream</code> .</span>私たちは前にしかし、これの最後の部分に注意<code>hello_macro_derive</code>機能が使用する<code>parse</code>から機能を<code>quote</code>の出力オンにするクレート<code>impl_hello_macro</code>バックに関数を<code>TokenStream</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The returned <code>TokenStream</code> is added to the code that our crate users write, so when they compile their crate, they&#39;ll get extra functionality that we provide.</span>返された<code>TokenStream</code>は、クレートユーザーが書き込むコードに追加されるので、クレートをコンパイルすると、追加機能が提供されます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You might have noticed that we&#39;re calling <code>unwrap</code> to panic if the calls to the <code>parse_derive_input</code> or <code>parse</code> functions fail here.</span> <code>parse_derive_input</code>関数または<code>parse</code>関数の呼び出しがここで失敗した場合、私たちは<code>unwrap</code>をパニックに呼んでいることに気づいたかもしれません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Panicking on errors is necessary in procedural macro code because <code>proc_macro_derive</code> functions must return <code>TokenStream</code> rather than <code>Result</code> to conform to the procedural macro API.</span> proc_macro_derive関数は手続き型マクロAPIに準拠するために<code>Result</code>ではなく<code>TokenStream</code>返さなければならないため、手続き型マクロコードではエラーを<code>proc_macro_derive</code>する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ve chosen to simplify this example by using <code>unwrap</code> ;</span> <code>unwrap</code>を使用してこの例を単純化することを選択しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">in production code, you should provide more specific error messages about what went wrong by using <code>panic€</code> or <code>expect</code> .</span>生産コードで、あなたが使用して何が悪かったのかについて、より具体的なエラーメッセージが提供しなければならない<code>panic€</code>や<code>expect</code> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now that we have the code to turn the annotated Rust code from a <code>TokenStream</code> into a <code>String</code> and a <code>DeriveInput</code> instance, let&#39;s generate the code that implements the <code>HelloMacro</code> trait on the annotated type:</span>注釈付きRustコードを<code>TokenStream</code>から<code>String</code>および<code>DeriveInput</code>インスタンスに<code>DeriveInput</code>するコードがあるので、 <code>HelloMacro</code>特性を実装するコードを注釈付き型に生成してみましょう。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: hello_macro_derive/src/lib.rs</span></span> <span class=filename>ファイル名：hello_macro_derive / src / lib.rs</span></span> </p><br><div data-lang=rust,ignore><div data-l="fn impl_hello_macro(ast: &amp;syn::DeriveInput) -&gt; quote::Tokens {"></div><div data-l="    let name = &amp;ast.ident;"></div><div data-l="    quote! {"></div><div data-l="        impl HelloMacro for #name {"></div><div data-l="            fn hello_macro() {"></div><div data-l="                println!(&quot;Hello, Macro! My name is {}&quot;, stringify!(#name));"></div><div data-l="            }"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We get an <code>Ident</code> struct instance containing the name (identifier) of the annotated type using <code>ast.ident</code> .</span> <code>ast.ident</code>を使用して注釈付きタイプの名前（識別子）を含む<code>Ident</code>構造体インスタンスを取得します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The code in Listing D-2 specifies that the <code>name</code> will be <code>Ident(&quot;Pancakes&quot;)</code> .</span>リストD-2のコードは、 <code>name</code>が<code>Ident(&quot;Pancakes&quot;)</code>ます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>quote€</code> macro lets us write the Rust code that we want to return and convert it into <code>quote::Tokens</code> .</span> <code>quote€</code>マクロを使用すると、返されたい錆のコードを書き、 <code>quote::Tokens</code>変換することができ<code>quote::Tokens</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This macro also provides some very cool templating mechanics;</span>このマクロはまた、非常にクールなテンプレート機構を提供します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">we can write <code>#name</code> , and <code>quote€</code> will replace it with the value in the variable named <code>name</code> .</span>私たちは<code>#name</code>を書くことができ、 <code>quote€</code>はそれを<code>name</code>という<code>name</code>の変数の値で置き換えます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can even do some repetition similar to the way regular macros work.</span>あなたは、通常のマクロが動作するのと同様の繰り返しを行うことさえできます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Check out <a href=#3quote-docs>the <code>quote</code> crate&#39;s docs</a> for a thorough introduction.</span> <a href=#3quote-docs><code>quote</code>箱の</a>徹底的なご紹介を<a href=#3quote-docs>ご覧</a>ください。</span> </p><br> <a class=notranslate href=#1https://docs.rs/quote>quote-docs</a> <br> <p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We want our procedural macro to generate an implementation of our <code>HelloMacro</code> trait for the type the user annotated, which we can get by using <code>#name</code> .</span>手続き型マクロは、 <code>HelloMacro</code>を使用して取得できる、ユーザーが注釈した型の<code>HelloMacro</code>特性の実装を生成し<code>#name</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The trait implementation has one function, <code>hello_macro</code> , whose body contains the functionality we want to provide: printing <code>Hello, Macro€ My name is</code> and then the name of the annotated type.</span>特性の実装には、 <code>hello_macro</code> 1つの関数があります。この関数の本体には、私たちが提供したい機能が含まれています： <code>hello_macro</code> <code>Hello, Macro€ My name is</code> 、そして注釈付きの名前です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>stringify€</code> macro used here is built into Rust.</span>ここで使用される<code>stringify€</code>マクロは、Rustに組み込まれています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It takes a Rust expression, such as <code>1 + 2</code> , and at compile time turns the expression into a string literal, such as <code>&quot;1 + 2&quot;</code> .</span>それは<code>1 + 2</code>ようなRust式をとり、コンパイル時に式を<code>&quot;1 + 2&quot;</code>ような文字列リテラルに変換します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is different than <code>format€</code> or <code>println€</code> , which evaluate the expression and then turn the result into a <code>String</code> .</span>これは、式を評価して結果を<code>String</code> <code>format€</code>または<code>println€</code>とは異なり<code>format€</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There is a possibility that the <code>#name</code> input might be an expression to print literally, so we use <code>stringify€</code> .</span>そこている可能性である<code>#name</code>入力は文字通り印刷する表現かもしれませんが、私たちは使う<code>stringify€</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Using <code>stringify€</code> also saves an allocation by converting <code>#name</code> to a string literal at compile time.</span>使用して<code>stringify€</code>も変換することによって、割り当てを保存<code>#name</code>コンパイル時にリテラル文字列に。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">At this point, <code>cargo build</code> should complete successfully in both <code>hello_macro</code> and <code>hello_macro_derive</code> .</span>この時点で、 <code>cargo build</code>は<code>hello_macro</code>と<code>hello_macro_derive</code>両方で正常に完了<code>cargo build</code>はず<code>hello_macro_derive</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s hook up these crates to the code in Listing D-2 to see the procedural macro in action!</span>これらのクレートをリストD-2のコードにリンクして、手続き型マクロの実際の動作を見てみましょう！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Create a new binary project in your <i>projects</i> directory using <code>cargo new --bin pancakes</code> .</span> <code>cargo new --bin pancakes</code>を使用して<i>プロジェクト</i>ディレクトリに新しいバイナリプロジェクトを作成します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We need to add <code>hello_macro</code> and <code>hello_macro_derive</code> as dependencies in the <code>pancakes</code> crate&#39;s <i>Cargo.toml</i> .</span>私たちは、追加する必要があり<code>hello_macro</code>と<code>hello_macro_derive</code>中に依存関係として<code>pancakes</code>クレートの<i>Cargo.toml。</i></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you&#39;re publishing your versions of <code>hello_macro</code> and <code>hello_macro_derive</code> to <i>https://crates.io/</i> , they would be regular dependencies;</span> <code>hello_macro</code>と<code>hello_macro_derive</code>バージョンを<i>https://crates.io/</i>に公開しているのであれば、定期的な依存関係になります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">if not, you can specify them as <code>path</code> dependencies as follows:</span>そうでない場合は、次のように<code>path</code>依存関係として指定できます。</span> </p><br><div data-lang=toml><div data-l=[dependencies]></div><div data-l="hello_macro = { path = &quot;../hello_macro&quot; }"></div><div data-l="hello_macro_derive = { path = &quot;../hello_macro/hello_macro_derive&quot; }"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Put the code from Listing D-2 into <i>src/main.rs</i> , and run <code>cargo run</code> : it should print <code>Hello, Macro€ My name is Pancakes€</code> The implementation of the <code>HelloMacro</code> trait from the procedural macro was included without the <code>pancakes</code> crate needing to implement it;</span> <i>SRC / main.rs</i>にリストD-2からのコードを入れて、実行<code>cargo run</code> ：それは印刷する必要があります<code>Hello, Macro€ My name is Pancakes€</code>の実装<code>HelloMacro</code>手続きマクロからの特性をせずに含まれていた<code>pancakes</code>に必要クレートそれを実装する。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">the <code>#[derive(HelloMacro)]</code> added the trait implementation.</span> <code>#[derive(HelloMacro)]</code>は特性の実装を追加しました。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The Future of Macros</span>マクロの未来</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In the future, Rust will expand declarative and procedural macros.</span>将来、Rustは宣言型マクロとプロシージャ型マクロを拡張します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust will use a better declarative macro system with the <code>macro</code> keyword and will add more types of procedural macros for more powerful tasks than just <code>derive</code> .</span> Rustは<code>macro</code>キーワードでより良い宣言的なマクロシステムを使用し、より強力なタスクのためにより多くのタイプの手続き型マクロを追加し<code>derive</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These systems are still under development at the time of this publication;</span>これらのシステムは、この刊行時点ではまだ開発中です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">please consult the online Rust documentation for the latest information.</span>最新の情報については、Rustのオンラインマニュアルを参照してください。</span> </p><script>_addload(function(){_setupIW('com');_csi('en','ja','appendix-04-macros.html');});</script>