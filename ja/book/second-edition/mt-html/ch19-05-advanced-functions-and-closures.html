<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180709_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=ch19-05-advanced-functions-and-closures.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Advanced Functions and Closures</span>高度な機能とクロージャ</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Finally, we&#39;ll explore some advanced features related to functions and closures, which include function pointers and returning closures.</span>最後に、関数ポインタと関数クロージャを含む関数とクロージャに関するいくつかの高度な機能について説明します。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Function Pointers</span>関数ポインタ</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ve talked about how to pass closures to functions;</span>関数にクロージャを渡す方法について話しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">you can also pass regular functions to functions!</span>正規関数を関数に渡すこともできます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This technique is useful when you want to pass a function you&#39;ve already defined rather than defining a new closure.</span>この手法は、新しいクロージャを定義するのではなく、すでに定義した関数を渡す場合に便利です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Doing this with function pointers will allow you to use functions as arguments to other functions.</span>関数ポインタでこれを行うと、関数を他の関数の引数として使用できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Functions coerce to the type <code>fn</code> (with a lowercase f), not to be confused with the <code>Fn</code> closure trait.</span>ファンクションは、 <code>Fn</code>クロージャーの特性と混同しないように、 <code>fn</code> （小文字のf）型を強制します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>fn</code> type is called a <i>function pointer</i> .</span> <code>fn</code>型は<i>関数ポインタ</i>と呼ばれ<i>ます</i> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The syntax for specifying that a parameter is a function pointer is similar to that of closures, as shown in Listing 19-35.</span>パラメータが関数ポインタであることを指定する構文は、リスト19-35に示すように、クロージャの構文に似ています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="fn add_one(x: i32) -&gt; i32 {"></div><div data-l="    x + 1"></div><div data-l=}></div><div data-l=""></div><div data-l="fn do_twice(f: fn(i32) -&gt; i32, arg: i32) -&gt; i32 {"></div><div data-l="    f(arg) + f(arg)"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let answer = do_twice(add_one, 5);"></div><div data-l=""></div><div data-l="    println!(&quot;The answer is: {}&quot;, answer);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 19-35: Using the <code>fn</code> type to accept a function pointer as an argument</span></span> <span class=caption>リスト19-35： <code>fn</code>型を使って関数ポインタを引数として受け入れる</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This code prints <code>The answer is: 12</code> .</span>このコード<code>The answer is: 12</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We specify that the parameter <code>f</code> in <code>do_twice</code> is an <code>fn</code> that takes one parameter of type <code>i32</code> and returns an <code>i32</code> .</span> <code>do_twice</code>のパラメータ<code>f</code>は、タイプ<code>i32</code> 1つのパラメータをとり、 <code>i32</code>を返す<code>fn</code>あると指定します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can then call <code>f</code> in the body of <code>do_twice</code> .</span> <code>do_twice</code>の本文で<code>f</code>を呼び出すことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In <code>main</code> , we can pass the function name <code>add_one</code> as the first argument to <code>do_twice</code> .</span>では<code>main</code> 、我々は関数名を渡すことができ<code>add_one</code>最初の引数として<code>do_twice</code> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Unlike closures, <code>fn</code> is a type rather than a trait, so we specify <code>fn</code> as the parameter type directly rather than declaring a generic type parameter with one of the <code>Fn</code> traits as a trait bound.</span>クロージャとは異なり、 <code>fn</code>は特性ではなくタイプなので、 <code>Fn</code>特性の1つを特性境界として持つジェネリック型パラメータを宣言するのではなく、直接パラメータ型として<code>fn</code>を指定します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Function pointers implement all three of the closure traits ( <code>Fn</code> , <code>FnMut</code> , and <code>FnOnce</code> ), so you can always pass a function pointer as an argument for a function that expects a closure.</span>関数ポインタは、3つのクロージャー特性（ <code>Fn</code> 、 <code>FnMut</code> 、および<code>FnOnce</code> ）をすべて実装しているため、クロージャーが必要な関数の引数として関数ポインターを渡すことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It&#39;s best to write functions using a generic type and one of the closure traits so your functions can accept either functions or closures.</span>ジェネリック型とクロージャー特性の1つを使用して関数を書くことが最善です。そのため、関数は関数またはクロージャを受け入れることができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">An example of where you would want to only accept <code>fn</code> and not closures is when interfacing with external code that doesn&#39;t have closures: C functions can accept functions as arguments, but C doesn&#39;t have closures.</span>クロージャを持たない外部コードとのインタフェースをとる場合は、 <code>fn</code>だけを受け取り、クロージャを受け入れない場合の例です。C関数は関数を引数として受け入れることができますが、Cにはクロージャはありません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As an example of where you could use either a closure defined inline or a named function, let&#39;s look at a use of <code>map</code> .</span>インラインで定義されたクロージャーまたは名前付き関数を使用できる場所の例として、 <code>map</code>使用を見てみましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To use the <code>map</code> function to turn a vector of numbers into a vector of strings, we could use a closure, like this:</span> <code>map</code>関数を使用して数値のベクトルを文字列のベクトルにするには、次のようにクロージャを使用します。</span> </p><br><div data-lang=rust><div data-l="let list_of_numbers = vec![1, 2, 3];"></div><div data-l="let list_of_strings: Vec&lt;String&gt; = list_of_numbers"></div><div data-l="    .iter()"></div><div data-l="    .map(|i| i.to_string())"></div><div data-l="    .collect();"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Or we could name a function as the argument to <code>map</code> instead of the closure, like this:</span>あるいは、次のようにクロージャの代わりに関数を<code>map</code>の引数として指定することもできます。</span> </p><br><div data-lang=rust><div data-l="let list_of_numbers = vec![1, 2, 3];"></div><div data-l="let list_of_strings: Vec&lt;String&gt; = list_of_numbers"></div><div data-l="    .iter()"></div><div data-l="    .map(ToString::to_string)"></div><div data-l="    .collect();"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that we must use the fully qualified syntax that we talked about earlier in the “Advanced Traits” section because there are multiple functions available named <code>to_string</code> .</span> <code>to_string</code>という名前の関数が複数存在するので、「先進的な特性」のセクションで前述した完全修飾構文を使用する必要があることに注意してください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here, we&#39;re using the <code>to_string</code> function defined in the <code>ToString</code> trait, which the standard library has implemented for any type that implements <code>Display</code> .</span>ここでは、 <code>ToString</code>特性で定義された<code>to_string</code>関数を使用しています。標準ライブラリは、 <code>Display</code>実装するすべての型に対して実装しています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Some people prefer this style, and some people prefer to use closures.</span>このスタイルを好む人もいれば、クロージャを使う人もいます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">They end up compiling to the same code, so use whichever style is clearer to you.</span>それらは同じコードにコンパイルされてしまいますので、どちらのスタイルでもより明確になります。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Returning Closures</span>戻る閉鎖</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Closures are represented by traits, which means you can&#39;t return closures directly.</span>クロージャは特性によって表されます。つまり、クロージャを直接返すことはできません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In most cases where you might want to return a trait, you can instead use the concrete type that implements the trait as the return value of the function.</span>ほとんどの場合、特性を返す必要がある場合は、その特性を実装する具象型を関数の戻り値として使用することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But you can&#39;t do that with closures because they don&#39;t have a concrete type that is returnable;</span>しかし、クロージャではリターン可能な具体的な型がないため、これを行うことはできません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">you&#39;re not allowed to use the function pointer <code>fn</code> as a return type, for example.</span>たとえば、戻り値の型として関数ポインタ<code>fn</code>を使用することはできません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The following code tries to return a closure directly, but it won&#39;t compile:</span>次のコードはクロージャを直接返しますが、コンパイルされません。</span> </p><br><div data-lang=rust,ignore><div data-l="fn returns_closure() -&gt; Fn(i32) -&gt; i32 {"></div><div data-l="    |x| x + 1"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The compiler error is as follows:</span>コンパイラのエラーは次のとおりです。</span> </p><br><div data-lang=text><div data-l="error[E0277]: the trait bound `std::ops::Fn(i32) -&gt; i32 + 'static:"></div><div data-l="std::marker::Sized` is not satisfied"></div><div data-l=" --&gt;"></div><div data-l="  |"></div><div data-l="1 | fn returns_closure() -&gt; Fn(i32) -&gt; i32 {"></div><div data-l="  |                         ^^^^^^^^^^^^^^ `std::ops::Fn(i32) -&gt; i32 + 'static`"></div><div data-l="  does not have a constant size known at compile-time"></div><div data-l="  |"></div><div data-l="  = help: the trait `std::marker::Sized` is not implemented for"></div><div data-l="  `std::ops::Fn(i32) -&gt; i32 + 'static`"></div><div data-l="  = note: the return type of a function must have a statically known size"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The error references the <code>Sized</code> trait again!</span>エラーは<code>Sized</code>特性を再度参照します！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust doesn&#39;t know how much space it will need to store the closure.</span>錆は、クロージャーを保管するためにどれだけのスペースが必要かを知らない。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We saw a solution to this problem earlier.</span>私たちは、この問題を早期に解決する方法を見つけました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can use a trait object:</span>特性オブジェクトを使うことができます：</span> </p><br><div data-lang=rust><div data-l="fn returns_closure() -&gt; Box&lt;Fn(i32) -&gt; i32&gt; {"></div><div data-l="    Box::new(|x| x + 1)"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This code will compile just fine.</span>このコードはうまくコンパイルされます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For more about trait objects, refer to the “Using Trait Objects That Allow for Values of Different Types” section in Chapter 17.</span>特性オブジェクトの詳細は、第17章の「異なるタイプの値を許容する特性オブジェクトの使用」を参照してください。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Summary</span>概要</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Whew!</span>すごい！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now you have some features of Rust in your toolbox that you won&#39;t use often, but you&#39;ll know they&#39;re available in very particular circumstances.</span>今ではツールボックスにRustの機能がいくつかありますが、頻繁に使用することはありませんが、非常に特殊な状況で使用できることがわかります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ve introduced several complex topics so that when you encounter them in error message suggestions or in other peoples&#39; code, you&#39;ll be able to recognize these concepts and syntax.</span>エラーメッセージの提案や他の人々のコードに遭遇したときに、これらの概念や構文を認識できるように、いくつかの複雑なトピックを紹介しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Use this chapter as a reference to guide you to solutions.</span>この章を参考にして、ソリューションをご案内します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Next, we&#39;ll put everything we&#39;ve discussed throughout the book into practice and do one more project!</span>次に、本で議論したことのすべてを実践し、もう1つのプロジェクトを行います。</span> </p><script>_addload(function(){_setupIW('com');_csi('en','ja','ch19-05-advanced-functions-and-closures.html');});</script>