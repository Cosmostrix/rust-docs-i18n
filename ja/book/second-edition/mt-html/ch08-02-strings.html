<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180709_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=ch08-02-strings.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Storing UTF-8 Encoded Text with Strings</span> UTF-8でエンコードされた文字列を格納する</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We talked about strings in Chapter 4, but we&#39;ll look at them in more depth now.</span>第4章で文字列について説明しましたが、ここではそれらをさらに詳しく見ていきます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">New Rustaceans commonly get stuck on strings for a combination of three reasons: Rust&#39;s propensity for exposing possible errors, strings being a more complicated data structure than many programmers give them credit for, and UTF-8.</span>新しい屋根裏部屋は、一般的に、可能性のあるエラーを表示するためのRustの傾向、文字列が多くのプログラマーよりも複雑なデータ構造であること、そしてUTF-8の3つの理由の組み合わせで文字列に突き当たります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These factors combine in a way that can seem difficult when you&#39;re coming from other programming languages.</span>これらの要素は、他のプログラミング言語から来ているときには難しいように見えます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It&#39;s useful to discuss strings in the context of collections because strings are implemented as a collection of bytes, plus some methods to provide useful functionality when those bytes are interpreted as text.</span>文字列はバイトの集合として実装されているので、コレクションのコンテキストで文字列を議論すると便利です。さらに、これらのバイトがテキストとして解釈されるときに便利な機能を提供するいくつかのメソッドがあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this section, we&#39;ll talk about the operations on <code>String</code> that every collection type has, such as creating, updating, and reading.</span>このセクションでは、作成、更新、および読み込みなど、すべてのコレクションタイプに含まれる<code>String</code>の操作について説明します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll also discuss the ways in which <code>String</code> is different from the other collections, namely how indexing into a <code>String</code> is complicated by the differences between how people and computers interpret <code>String</code> data.</span>また、 <code>String</code>が他のコレクションと異なる方法、つまり人とコンピュータが<code>String</code>データをどのように解釈するかの違いによって、 <code>String</code>への索引付けがどのように複雑になるかについても説明します。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">What Is a String?</span>文字列とは何ですか？</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll first define what we mean by the term <i>string</i> .</span>まず、 <i>文字列</i>という意味を定義し<i>ます</i> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust has only one string type in the core language, which is the string slice <code>str</code> that is usually seen in its borrowed form <code>&amp;str</code> .</span> Rustには、コア言語の文字列型が1つしかありません。これは、通常は借用された形式<code>&amp;str</code>で表示される文字列slice <code>str</code>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In Chapter 4, we talked about <i>string slices</i> , which are references to some UTF-8 encoded string data stored elsewhere.</span>第4章では、 <i>文字列スライス</i>について説明しました。これは、他の場所に格納されているUTF-8でエンコードされた文字列データへの参照です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">String literals, for example, are stored in the binary output of the program and are therefore string slices.</span>たとえば、文字列リテラルは、プログラムのバイナリ出力に格納されるため、文字列スライスです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>String</code> type, which is provided by Rust&#39;s standard library rather than coded into the core language, is a growable, mutable, owned, UTF-8 encoded string type.</span>コア言語にコード化されるのではなく、Rustの標準ライブラリによって提供される<code>String</code>型は、拡張可能で変更可能なUTF-8エンコードされた文字列型です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When Rustaceans refer to “strings” in Rust, they usually mean the <code>String</code> and the string slice <code>&amp;str</code> types, not just one of those types.</span> RustaceansがRustの &quot;strings&quot;を参照するとき、通常、それらの型の1つだけでなく、 <code>String</code>とstring slice <code>&amp;str</code>型を意味します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Although this section is largely about <code>String</code> , both types are used heavily in Rust&#39;s standard library, and both <code>String</code> and string slices are UTF-8 encoded.</span>このセクションでは主に<code>String</code>について説明しますが、どちらのタイプもRustの標準ライブラリで頻繁に使用されており、 <code>String</code>とstringスライスの両方がUTF-8でエンコードされています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust&#39;s standard library also includes a number of other string types, such as <code>OsString</code> , <code>OsStr</code> , <code>CString</code> , and <code>CStr</code> .</span> Rustの標準ライブラリには、 <code>OsString</code> 、 <code>OsStr</code> 、 <code>CString</code> 、 <code>CStr</code>などの他の多くの文字列型も含まれてい<code>CStr</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Library crates can provide even more options for storing string data.</span>ライブラリのテンプレートは、文字列データを格納するためのさらに多くのオプションを提供します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">See how those names all end in <code>String</code> or <code>Str</code> ?</span>それらの名前がす​​べて<code>String</code>または<code>Str</code>でどのように終わるかを見てください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">They refer to owned and borrowed variants, just like the <code>String</code> and <code>str</code> types you&#39;ve seen previously.</span>それらは、あなたが以前に見た<code>String</code>型や<code>str</code>型と同じように、所有し、借用しているバリアントを参照します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These string types can store text in different encodings or be represented in memory in a different way, for example.</span>これらの文字列型は、異なるエンコーディングでテキストを格納したり、異なる方法でメモリに表現することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We won&#39;t discuss these other string types in this chapter;</span>この章では、他の文字列型については説明しません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">see their API documentation for more about how to use them and when each is appropriate.</span> APIの使用方法とそれぞれが適切な場合のAPIドキュメントを参照してください。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Creating a New String</span>新しい文字列の作成</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Many of the same operations available with <code>Vec&lt;T&gt;</code> are available with <code>String</code> as well, starting with the <code>new</code> function to create a string, shown in Listing 8-11.</span>リスト8-11に示すように、 <code>Vec&lt;T&gt;</code>利用可能な同じ操作の多くは、文字列を作成する<code>new</code>関数から始めて、 <code>String</code>でも使用できます。</span> </p><br><div data-lang=rust><div data-l="let mut s = String::new();"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 8-11: Creating a new, empty <code>String</code></span></span> <span class=caption>リスト8-11：新しい空文字<code>String</code>作成</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This line creates a new empty string called <code>s</code> , which we can then load data into.</span>この行は、 <code>s</code>という新しい空文字列を作成し、データを読み込むことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Often, we&#39;ll have some initial data that we want to start the string with.</span>多くの場合、文字列を開始する初期データがあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For that, we use the <code>to_string</code> method, which is available on any type that implements the <code>Display</code> trait, as string literals do.</span>そのためには、 <code>to_string</code>メソッドを使用します。これは、文字列リテラルのように、 <code>Display</code>特性を実装するすべてのタイプで使用できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 8-12 shows two examples.</span>リスト8-12に2つの例を示します。</span> </p><br><div data-lang=rust><div data-l="let data = &quot;initial contents&quot;;"></div><div data-l=""></div><div data-l="let s = data.to_string();"></div><div data-l=""></div><div data-l="#// the method also works on a literal directly:"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">the method also works on a literal directly:</span>このメソッドはリテラルでも直接動作します：</span> </div><div data-l="let s = &quot;initial contents&quot;.to_string();"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 8-12: Using the <code>to_string</code> method to create a <code>String</code> from a string literal</span></span> <span class=caption>リスト8-12： <code>to_string</code>メソッドを使って<code>String</code>列リテラルから文字列を作成する</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This code creates a string containing <code>initial contents</code> .</span>このコードは、 <code>initial contents</code>を含む文字列を作成します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can also use the function <code>String::from</code> to create a <code>String</code> from a string literal.</span> <code>String::from</code>関数を使用して、文字列リテラルから<code>String</code>を作成することもできます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The code in Listing 8-13 is equivalent to the code from Listing 8-12 that uses <code>to_string</code> .</span>リスト8-13のコードは、 <code>to_string</code>を使用するコード8-12のコードに相当します。</span> </p><br><div data-lang=rust><div data-l="let s = String::from(&quot;initial contents&quot;);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 8-13: Using the <code>String::from</code> function to create a <code>String</code> from a string literal</span></span> <span class=caption>リスト8-13： <code>String::from</code>関数を使って<code>String</code>列リテラルから文字列を作成する</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because strings are used for so many things, we can use many different generic APIs for strings, providing us with a lot of options.</span>文字列は非常に多くのものに使用されているため、文字列にはさまざまな汎用APIを使用でき、多くのオプションが用意されています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Some of them can seem redundant, but they all have their place!</span>それらのいくつかは冗長に見えるかもしれませんが、彼らはすべて自分の場所を持っています！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this case, <code>String::from</code> and <code>to_string</code> do the same thing, so which you choose is a matter of style.</span>この場合、 <code>String::from</code>と<code>to_string</code>は同じことを行います。したがって、あなたが選択するのはスタイルの問題です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Remember that strings are UTF-8 encoded, so we can include any properly encoded data in them, as shown in Listing 8-14.</span>文字列はUTF-8でエンコードされているので、リスト8-14に示すように、適切にエンコードされたデータをエンコードすることができます。</span> </p><br><div data-lang=rust><div data-l="let hello = String::from(&quot;السلام عليكم&quot;);"></div><div data-l="let hello = String::from(&quot;Dobrý den&quot;);"></div><div data-l="let hello = String::from(&quot;Hello&quot;);"></div><div data-l="let hello = String::from(&quot;שָׁלוֹם&quot;);"></div><div data-l="let hello = String::from(&quot;नमस्ते&quot;);"></div><div data-l="let hello = String::from(&quot;こんにちは&quot;);"></div><div data-l="let hello = String::from(&quot;안녕하세요&quot;);"></div><div data-l="let hello = String::from(&quot;你好&quot;);"></div><div data-l="let hello = String::from(&quot;Olá&quot;);"></div><div data-l="let hello = String::from(&quot;Здравствуйте&quot;);"></div><div data-l="let hello = String::from(&quot;Hola&quot;);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 8-14: Storing greetings in different languages in strings</span></span> <span class=caption>リスト8-14：文字列内の異なる言語でのグリーティングの保存</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">All of these are valid <code>String</code> values.</span>これらはすべて有効な<code>String</code>値です。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Updating a String</span>文字列の更新</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A <code>String</code> can grow in size and its contents can change, just like the contents of a <code>Vec&lt;T&gt;</code> , if you push more data into it.</span> <code>Vec&lt;T&gt;</code>内容と同じように、 <code>String</code>サイズが大きくなり、その内容が変更される可能性があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In addition, you can conveniently use the <code>+</code> operator or the <code>format€</code> macro to concatenate <code>String</code> values.</span>さらに、 <code>+</code>演算子または<code>format€</code>マクロを使用すると、 <code>String</code>値を連結することができます。</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Appending to a String with <code>push_str</code> and <code>push</code></span> <code>push_str</code>と<code>push</code>文字列に<code>push_str</code> <code>push</code></span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can grow a <code>String</code> by using the <code>push_str</code> method to append a string slice, as shown in Listing 8-15.</span>リスト8-15に示すように、 <code>push_str</code>メソッドを使用して文字列スライスを追加することによって、 <code>String</code>を<code>push_str</code>できます。</span> </p><br><div data-lang=rust><div data-l="let mut s = String::from(&quot;foo&quot;);"></div><div data-l=s.push_str(&quot;bar&quot;);></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 8-15: Appending a string slice to a <code>String</code> using the <code>push_str</code> method</span></span> <span class=caption>リスト8-15：に文字列スライス追加は<code>String</code>使用して<code>push_str</code>方法を</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">After these two lines, <code>s</code> will contain <code>foobar</code> .</span>この2行の後、 <code>s</code>含まれています<code>foobar</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>push_str</code> method takes a string slice because we don&#39;t necessarily want to take ownership of the parameter.</span> <code>push_str</code>メソッドは、必ずしもパラメータの所有権を取得する必要がないため、文字列スライスを使用します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, the code in Listing 8-16 shows that it would be unfortunate if we weren&#39;t able to use <code>s2</code> after appending its contents to <code>s1</code> .</span>例えば、リスト8-16のコードは、 <code>s1</code>内容を追加した後に<code>s2</code>を使用できなかった場合、残念であることを示しています。</span> </p><br><div data-lang=rust><div data-l="let mut s1 = String::from(&quot;foo&quot;);"></div><div data-l="let s2 = &quot;bar&quot;;"></div><div data-l=s1.push_str(s2);></div><div data-l="println!(&quot;s2 is {}&quot;, s2);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 8-16: Using a string slice after appending its contents to a <code>String</code></span></span> <span class=caption>リスト8-16：にその内容を付加した後、文字列のスライスを使用して<code>String</code></span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If the <code>push_str</code> method took ownership of <code>s2</code> , we wouldn&#39;t be able to print its value on the last line.</span> <code>push_str</code>メソッドが<code>s2</code>所有権を取得した場合、最後の行にその値を出力することはできません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, this code works as we&#39;d expect!</span>しかし、このコードは期待どおりに動作します！</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>push</code> method takes a single character as a parameter and adds it to the <code>String</code> .</span> <code>push</code>メソッドは、パラメータとして単一の文字を取り、それを<code>String</code>追加します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 8-17 shows code that adds the letter <i>l</i> to a <code>String</code> using the <code>push</code> method.</span>リスト8-17は<code>push</code>メソッドを使って文字<i>l</i>を<code>String</code>追加するコードを示しています。</span> </p><br><div data-lang=rust><div data-l="let mut s = String::from(&quot;lo&quot;);"></div><div data-l="s.push('l');"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 8-17: Adding one character to a <code>String</code> value using <code>push</code></span></span> <span class=caption>リスト8-17： <code>push</code>を使って<code>String</code>値に文字を1つ追加する</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As a result of this code, <code>s</code> will contain <code>lol</code> .</span>このコードの結果、 <code>s</code>には<code>lol</code>が含まれます。</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Concatenation with the <code>+</code> Operator or the <code>format€</code> Macro</span> <code>+</code>演算子または<code>format€</code>マクロとの連結</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Often, you&#39;ll want to combine two existing strings.</span>しばしば、2つの既存の文字列を結合したいと思うでしょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">One way is to use the <code>+</code> operator, as shown in Listing 8-18.</span> 1つの方法は、リスト8-18に示すように、 <code>+</code>演算子を使用することです。</span> </p><br><div data-lang=rust><div data-l="let s1 = String::from(&quot;Hello, &quot;);"></div><div data-l="let s2 = String::from(&quot;world!&quot;);"></div><div data-l="#//let s3 = s1 + &amp;s2; // note s1 has been moved here and can no longer be used"></div><div data-l="let s3 = s1 + &amp;s2; // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">note s1 has been moved here and can no longer be used</span> note s1はここに移動されており、使用できなくなりました</span> </div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 8-18: Using the <code>+</code> operator to combine two <code>String</code> values into a new <code>String</code> value</span></span> <span class=caption>リスト8-18： <code>+</code>演算子を使って2つの<code>String</code>値を新しい<code>String</code>値に結合する</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The string <code>s3</code> will contain <code>Hello, world€</code> as a result of this code.</span>文字列<code>s3</code>は、このコードの結果として<code>Hello, world€</code>が含まれます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The reason <code>s1</code> is no longer valid after the addition and the reason we used a reference to <code>s2</code> has to do with the signature of the method that gets called when we use the <code>+</code> operator.</span>理由は、 <code>s1</code>が加算の後にもはや有効でなく、 <code>s2</code>への参照を使用した理由が、 <code>+</code>演算子を使用したときに呼び出されるメソッドのシグネチャと関係があるためです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>+</code> operator uses the <code>add</code> method, whose signature looks something like this:</span> <code>+</code>演算子は<code>add</code>メソッドを使用します。その署名は次のようになります。</span> </p><br><div data-lang=rust,ignore><div data-l="fn add(self, s: &amp;str) -&gt; String {"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This isn&#39;t the exact signature that&#39;s in the standard library: in the standard library, <code>add</code> is defined using generics.</span>これは標準ライブラリにある正確な署名ではありません。標準ライブラリでは、 <code>add</code>はジェネリックを使って定義されています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here, we&#39;re looking at the signature of <code>add</code> with concrete types substituted for the generic ones, which is what happens when we call this method with <code>String</code> values.</span>ここでは、genericの代わりに具体的な型<code>add</code>持つ<code>add</code>のシグネチャを見ています。これは、このメソッドを<code>String</code>値で呼び出すときに起こります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll discuss generics in Chapter 10. This signature gives us the clues we need to understand the tricky bits of the <code>+</code> operator.</span>第10章でジェネリックについて説明します。このシグネチャは、 <code>+</code>演算子のトリッキーなビットを理解するために必要な手がかりを与えます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">First, <code>s2</code> has an <code>&amp;</code> , meaning that we&#39;re adding a <i>reference</i> of the second string to the first string because of the <code>s</code> parameter in the <code>add</code> function: we can only add a <code>&amp;str</code> to a <code>String</code> ;</span>まず、 <code>s2</code>持っている<code>&amp;</code>私たちがための最初の文字列に2番目の文字列の<i>参照</i>追加していることを意味し、 <code>s</code>中のパラメータ<code>add</code>機能を：我々だけ追加することができます<code>&amp;str</code>に<code>String</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">we can&#39;t add two <code>String</code> values together.</span> 2つの<code>String</code>値を一緒に追加することはできません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But wait—the type of <code>&amp;s2</code> is <code>&amp;String</code> , not <code>&amp;str</code> , as specified in the second parameter to <code>add</code> .</span>しかし、待って-のタイプ<code>&amp;s2</code>ある<code>&amp;String</code>ではない、 <code>&amp;str</code>ための2番目のパラメータで指定されているように、 <code>add</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So why does Listing 8-18 compile?</span>なぜ、リスト8-18はコンパイルされますか？</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The reason we&#39;re able to use <code>&amp;s2</code> in the call to <code>add</code> is that the compiler can <i>coerce</i> the <code>&amp;String</code> argument into a <code>&amp;str</code> .</span> <code>add</code>の呼び出しで<code>&amp;s2</code>を使用できる理由は、コンパイラが<code>&amp;String</code>引数を<code>&amp;str</code> <i>強制</i>することができるためです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When we call the <code>add</code> method, Rust uses a <i>deref coercion</i> , which here turns <code>&amp;s2</code> into <code>&amp;s2[..]</code> .</span> <code>add</code>メソッドを呼び出すと、Rustは<i>deref強制を</i>使用し<code>&amp;s2[..]</code>ここで<code>&amp;s2</code>は<code>&amp;s2[..]</code>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll discuss deref coercion in more depth in Chapter 15. Because <code>add</code> does not take ownership of the <code>s</code> parameter, <code>s2</code> will still be a valid <code>String</code> after this operation.</span>ので、我々は第15章で詳しく被参照強制を説明します<code>add</code>所有取らない<code>s</code>パラメータを、 <code>s2</code>まだ有効になります<code>String</code>この操作の後。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Second, we can see in the signature that <code>add</code> takes ownership of <code>self</code> , because <code>self</code> does <i>not</i> have an <code>&amp;</code> .</span>次に、シグネチャでは、 <code>add</code>は<code>self</code>所有権があることがわかります。 <code>self</code>は<code>&amp;</code>が<i>ない</i>ためです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This means <code>s1</code> in Listing 8-18 will be moved into the <code>add</code> call and no longer be valid after that.</span>これは、リスト8-18の<code>s1</code>が<code>add</code>呼び出しに移動され、その後は有効ではなくなることを意味します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So although <code>let s3 = s1 + &amp;s2;</code></span>だから<code>let s3 = s1 + &amp;s2;</code></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">looks like it will copy both strings and create a new one, this statement actually takes ownership of <code>s1</code> , appends a copy of the contents of <code>s2</code> , and then returns ownership of the result.</span>両方の文字列をコピーして新しいものを作成するように見えますが、このステートメントは実際に<code>s1</code>所有権を持ち、 <code>s2</code>の内容のコピーを追加してから、結果の所有権を返します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In other words, it looks like it&#39;s making a lot of copies but isn&#39;t;</span>言い換えれば、それはコピーをたくさん作っているように見えますが、そうではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">the implementation is more efficient than copying.</span>実装はコピーよりも効率的です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we need to concatenate multiple strings, the behavior of the <code>+</code> operator gets unwieldy:</span>複数の文字列を連結する必要がある場合、 <code>+</code>演算子の動作は扱いにくくなります。</span> </p><br><div data-lang=rust><div data-l="let s1 = String::from(&quot;tic&quot;);"></div><div data-l="let s2 = String::from(&quot;tac&quot;);"></div><div data-l="let s3 = String::from(&quot;toe&quot;);"></div><div data-l=""></div><div data-l="let s = s1 + &quot;-&quot; + &amp;s2 + &quot;-&quot; + &amp;s3;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">At this point, <code>s</code> will be <code>tic-tac-toe</code> .</span>この時点で、 <code>s</code>は<code>tic-tac-toe</code>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">With all of the <code>+</code> and <code>&quot;</code> characters, it&#39;s difficult to see what&#39;s going on. For more complicated string combining, we can use the <code>format€</code> macro:</span>すべてに<code>+</code>と<code>&quot;</code>の文字、それは何が起こっているかを見ることは困難だより複雑な文字列を組み合わせることについて、私たちが使用することができます。 <code>format€</code>マクロを：</span> </p><br><div data-lang=rust><div data-l="let s1 = String::from(&quot;tic&quot;);"></div><div data-l="let s2 = String::from(&quot;tac&quot;);"></div><div data-l="let s3 = String::from(&quot;toe&quot;);"></div><div data-l=""></div><div data-l="let s = format!(&quot;{}-{}-{}&quot;, s1, s2, s3);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This code also sets <code>s</code> to <code>tic-tac-toe</code> .</span>このコードでは、 <code>s</code>を<code>tic-tac-toe</code>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>format€</code> macro works in the same way as <code>println€</code> , but instead of printing the output to the screen, it returns a <code>String</code> with the contents.</span> <code>format€</code>マクロは<code>println€</code>と同じように動作しますが、出力を画面に出力するのではなく、内容を含む<code>String</code>を返します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The version of the code using <code>format€</code> is much easier to read and doesn&#39;t take ownership of any of its parameters.</span> <code>format€</code>を使用したコードのバージョンは読みやすく、そのパラメータの所有権を取得しません。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Indexing into Strings</span>ストリングへの索引付け</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In many other programming languages, accessing individual characters in a string by referencing them by index is a valid and common operation.</span>他の多くのプログラミング言語では、文字列内の個々の文字にインデックスで参照してアクセスすることは、有効かつ一般的な操作です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, if you try to access parts of a <code>String</code> using indexing syntax in Rust, you&#39;ll get an error.</span>ただし、Rustのインデックス構文を使用して<code>String</code>一部にアクセスしようとすると、エラーが発生します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Consider the invalid code in Listing 8-19.</span>リスト8-19の無効なコードを考えてみましょう。</span> </p><br><div data-lang=rust,ignore><div data-l="let s1 = String::from(&quot;hello&quot;);"></div><div data-l="let h = s1[0];"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 8-19: Attempting to use indexing syntax with a String</span></span> <span class=caption>コードリスト8-19：文字列でインデックス構文を使用しようとする</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This code will result in the following error:</span>このコードでは、次のエラーが発生します。</span> </p><br><div data-lang=text><div data-l="error[E0277]: the trait bound `std::string::String: std::ops::Index&lt;{integer}&gt;` is not satisfied"></div><div data-l=" --&gt;"></div><div data-l="  |"></div><div data-l="3 |     let h = s1[0];"></div><div data-l="  |             ^^^^^ the type `std::string::String` cannot be indexed by `{integer}`"></div><div data-l="  |"></div><div data-l="  = help: the trait `std::ops::Index&lt;{integer}&gt;` is not implemented for `std::string::String`"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The error and the note tell the story: Rust strings don&#39;t support indexing.</span>エラーとノートはストーリーに伝えます：錆ストリングはインデックス作成をサポートしていません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But why not?</span>しかし、どうしてですか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To answer that question, we need to discuss how Rust stores strings in memory.</span>その質問に答えるために、我々はRustが文字列をメモリにどのように格納するかについて議論する必要があります。</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Internal Representation</span>内部表現</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A <code>String</code> is a wrapper over a <code>Vec&lt;u8&gt;</code> .</span> <code>String</code>は、 <code>Vec&lt;u8&gt;</code>上のラッパーです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s look at some of our properly encoded UTF-8 example strings from Listing 8-14.</span>リスト8-14の適切にエンコードされたUTF-8のサンプル・ストリングのいくつかを見てみましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">First, this one:</span>まず、この1つ：</span> </p><br><div data-lang=rust><div data-l="let len = String::from(&quot;Hola&quot;).len();"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this case, <code>len</code> will be 4, which means the vector storing the string “Hola” is 4 bytes long.</span>この場合、 <code>len</code>は4になります。これは、文字列 &quot;Hola&quot;を格納するベクトルが4バイト長であることを意味します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Each of these letters takes 1 byte when encoded in UTF-8.</span>これらの文字のそれぞれは、UTF-8でエンコードされたときに1バイトをとります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But what about the following line?</span>しかし、次の行はどうですか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">(Note that this string begins with the capital Cyrillic letter Ze, not the Arabic number 3.)</span> （この文字列は、アラビア数字3ではなく、キリル文字Zeで始まることに注意してください。）</span> </p><br><div data-lang=rust><div data-l="let len = String::from(&quot;Здравствуйте&quot;).len();"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Asked how long the string is, you might say 12. However, Rust&#39;s answer is 24: that&#39;s the number of bytes it takes to encode “Здравствуйте” in UTF-8, because each Unicode scalar value takes 2 bytes of storage.</span>しかし、Rustの答えは24です。これは、Unicodeの各スカラー値が2バイトの記憶域を必要とするため、UTF-8でエンコードするのに必要なバイト数です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Therefore, an index into the string&#39;s bytes will not always correlate to a valid Unicode scalar value.</span>したがって、文字列のバイトへのインデックスは、有効なUnicodeスカラー値と必ずしも相関しません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To demonstrate, consider this invalid Rust code:</span>実証するために、この無効な錆のコードを考えてみましょう：</span> </p><br><div data-lang=rust,ignore><div data-l="let hello = &quot;Здравствуйте&quot;;"></div><div data-l="let answer = &amp;hello[0];"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">What should the value of <code>answer</code> be?</span> <code>answer</code>の価値はどうあるべきですか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Should it be <code>З</code> , the first letter?</span>それがあるべき<code>З</code> 、最初の文字？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When encoded in UTF-8, the first byte of <code>З</code> is <code>208</code> and the second is <code>151</code> , so <code>answer</code> should in fact be <code>208</code> , but <code>208</code> is not a valid character on its own.</span> UTF-8でエンコードされている場合、 <code>З</code>の最初のバイトは<code>208</code>で、2番目のバイトは<code>151</code>なので、 <code>answer</code>は実際には<code>208</code>でなければなりませんが、 <code>208</code>はそれ自体で有効な文字ではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Returning <code>208</code> is likely not what a user would want if they asked for the first letter of this string;</span> <code>208</code>返すことは、ユーザーがこの文字列の最初の文字を尋ねた場合、ユーザーが望むものではない可能性があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">however, that&#39;s the only data that Rust has at byte index 0. Users generally don&#39;t want the byte value returned, even if the string contains only Latin letters: if <code>&amp;&quot;hello&quot;[0]</code> were valid code that returned the byte value, it would return <code>104</code> , not <code>h</code> .</span>しかし、これはRustがバイトインデックス0で持つ唯一のデータです。文字列にラテン文字のみが含まれていても、ユーザーは一般的に返されるバイト値を望ましくありません： <code>&amp;&quot;hello&quot;[0]</code>がバイト値を返す有効なコードそれは<code>h</code>ではなく<code>104</code>を返します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To avoid returning an unexpected value and causing bugs that might not be discovered immediately, Rust doesn&#39;t compile this code at all and prevents misunderstandings early in the development process.</span>予期しない値を返さず、直ちに発見されない可能性のあるバグを引き起こさないように、Rustはこのコードをまったくコンパイルせず、開発プロセスの初期段階で誤解を防止します。</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Bytes and Scalar Values and Grapheme Clusters!</span>バイトとスカラの値とグレーフェームクラスタ！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Oh My!</span>ああ私！</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Another point about UTF-8 is that there are actually three relevant ways to look at strings from Rust&#39;s perspective: as bytes, scalar values, and grapheme clusters (the closest thing to what we would call <i>letters</i> ).</span> UTF-8についてのもう一つの点は、実際には、Rustの観点から文字列をバイト、スカラー値、および文字列クラスター（ <i>文字</i>と呼んで<i>いる</i>ものに最も近いもの）として見るための3つの関連する方法があるということです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we look at the Hindi word “नमस्ते” written in the Devanagari script, it is stored as a vector of <code>u8</code> values that looks like this:</span> Devanagariスクリプトで書かれたヒンディー語の &quot;नमस्ते&quot;を見ると、次のような<code>u8</code>値のベクトルとして格納されます。</span> </p><br><div data-lang=text><div data-l="[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,"></div><div data-l="224, 165, 135]"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That&#39;s 18 bytes and is how computers ultimately store this data.</span>これは18バイトで、コンピュータが最終的にこのデータをどのように格納するかです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we look at them as Unicode scalar values, which are what Rust&#39;s <code>char</code> type is, those bytes look like this:</span> Rustの<code>char</code>型であるUnicodeのスカラー値として見れば、これらのバイトは次のようになります。</span> </p><br><div data-lang=text><div data-l="['न', 'म', 'स', '्', 'त', 'े']"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There are six <code>char</code> values here, but the fourth and sixth are not letters: they&#39;re diacritics that don&#39;t make sense on their own.</span>ここには6つの<code>char</code>値がありますが、4番目と6番目の文字は文字ではありません。それは独自の意味を持たない発音区別記号です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Finally, if we look at them as grapheme clusters, we&#39;d get what a person would call the four letters that make up the Hindi word:</span>最後に、それらを書記官クラスターとして見ると、ヒンディー語を構成する4つの文字を人が何と呼ぶか​​を知ることができます。</span> </p><br><div data-lang=text><div data-l="[&quot;न&quot;, &quot;म&quot;, &quot;स्&quot;, &quot;ते&quot;]"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust provides different ways of interpreting the raw string data that computers store so that each program can choose the interpretation it needs, no matter what human language the data is in.</span> Rustは、データがどのような人間言語であっても、各プログラムが必要とする解釈を選択できるように、コンピュータが格納する生の文字列データを解釈するさまざまな方法を提供します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A final reason Rust doesn&#39;t allow us to index into a <code>String</code> to get a character is that indexing operations are expected to always take constant time (O(1)).</span> Rustが<code>String</code>を取得するために文字<code>String</code>にインデックスを付けることができないという最終的な理由は、インデックス処理が常に一定の時間（O（1））を取ることが予想されることです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But it isn&#39;t possible to guarantee that performance with a <code>String</code> , because Rust would have to walk through the contents from the beginning to the index to determine how many valid characters there were.</span>しかし、 <code>String</code>でそのパフォーマンスを保証することはできません。なぜなら、有効な文字がいくつあるのかを判断するために、Rustは最初から最後まで内容を調べなければならないからです。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Slicing Strings</span>スライシングストリング</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Indexing into a string is often a bad idea because it&#39;s not clear what the return type of the string-indexing operation should be: a byte value, a character, a grapheme cluster, or a string slice.</span>文字列インデクシング操作の戻り値の型は、バイト値、文字、グラフェンクラスター、または文字列スライスのどれであるべきかが明確でないため、文字列へのインデックス付けはしばしば悪い考えです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Therefore, Rust asks you to be more specific if you really need to use indices to create string slices.</span>したがって、実際にインデックスを使用して文字列スライスを作成する必要がある場合、Rustはより具体的になるように指示します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To be more specific in your indexing and indicate that you want a string slice, rather than indexing using <code>[]</code> with a single number, you can use <code>[]</code> with a range to create a string slice containing particular bytes:</span>より具体的にインデックスを作成し、文字列スライスが必要であることを示すには、 <code>[]</code>を単一の数字でインデックスするのではなく、 <code>[]</code>で範囲を指定して特定のバイトを含む文字列スライスを作成します。</span> </p><br><div data-lang=rust><div data-l="let hello = &quot;Здравствуйте&quot;;"></div><div data-l=""></div><div data-l="let s = &amp;hello[0..4];"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here, <code>s</code> will be a <code>&amp;str</code> that contains the first 4 bytes of the string.</span>ここで、 <code>s</code>は<code>&amp;str</code>の最初の4バイトを含む<code>&amp;str</code>になります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Earlier, we mentioned that each of these characters was 2 bytes, which means <code>s</code> will be <code>Зд</code> .</span>以前は、これらの文字のそれぞれが2バイトであることを述べ<code>Зд</code> 。これは、 <code>s</code>が<code>Зд</code>であることを意味します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">What would happen if we used <code>&amp;hello[0..1]</code> ?</span> <code>&amp;hello[0..1]</code>を使用するとどうなりますか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The answer: Rust would panic at runtime in the same way as if an invalid index were accessed in a vector:</span>答え：ベクトルで無効なインデックスがアクセスされたのと同じ方法で、実行時にRustがパニックに陥る：</span> </p><br><div data-lang=text><div data-l="thread 'main' panicked at 'byte index 1 is not a char boundary; it is inside 'З' (bytes 0..2) of `Здравствуйте`', src/libcore/str/mod.rs:2188:4"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You should use ranges to create string slices with caution, because doing so can crash your program.</span>文字列スライスを作成するには、プログラムをクラッシュさせる可能性があるため、範囲を使用して慎重に文字列スライスを作成する必要があります。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Methods for Iterating Over Strings</span>オーバーストリング反復法</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Fortunately, you can access elements in a string in other ways.</span>幸い、文字列内の要素には他の方法でアクセスできます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you need to perform operations on individual Unicode scalar values, the best way to do so is to use the <code>chars</code> method.</span>個々のUnicodeスカラ値に対して操作を実行する必要がある場合は、 <code>chars</code>メソッドを使用するのが最善の方法です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Calling <code>chars</code> on “नमस्ते” separates out and returns six values of type <code>char</code> , and you can iterate over the result to access each element:</span> &quot;नमस्ते&quot;の<code>chars</code>を呼び出すと、 <code>char</code>型の6つの値が返され、結果を繰り返して各要素にアクセスできます。</span> </p><br><div data-lang=rust><div data-l="for c in &quot;नमस्ते&quot;.chars() {"></div><div data-l="    println!(&quot;{}&quot;, c);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This code will print the following:</span>このコードは以下を出力します：</span> </p><br><div data-lang=text><div data-l="न"></div><div data-l="म"></div><div data-l="स"></div><div data-l="्"></div><div data-l="त"></div><div data-l="े"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>bytes</code> method returns each raw byte, which might be appropriate for your domain:</span> <code>bytes</code>メソッドは、生の各<code>bytes</code>を返します。これは、あなたのドメインに適しています。</span> </p><br><div data-lang=rust><div data-l="for b in &quot;नमस्ते&quot;.bytes() {"></div><div data-l="    println!(&quot;{}&quot;, b);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This code will print the 18 bytes that make up this <code>String</code> :</span>このコードは、この<code>String</code>を構成する18バイトを出力します：</span> </p><br><div data-lang=text><div data-l=224></div><div data-l=164></div><div data-l="#// --snip--"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">--snip--</span> --snip--</span> </div><div data-l=165></div><div data-l=135></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But be sure to remember that valid Unicode scalar values may be made up of more than 1 byte.</span>しかし、有効なUnicodeスカラ値は1バイト以上で構成されることを覚えておいてください。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Getting grapheme clusters from strings is complex, so this functionality is not provided by the standard library.</span>文字列から書記素クラスタを得ることは複雑なので、この機能は標準ライブラリでは提供されていません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Crates are available on <a class=notranslate href=#2https://crates.io>crates.io</a> if this is the functionality you need.</span>これがあなたが必要とする機能性のものであれば、 <a class=notranslate href=#2https://crates.io>crates.io</a> Cratesを利用できます。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Strings Are Not So Simple</span>文字列は単純ではありません</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To summarize, strings are complicated.</span>まとめると、文字列は複雑です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Different programming languages make different choices about how to present this complexity to the programmer.</span>異なるプログラミング言語は、この複雑さをどのようにプログラマに提示するかについて異なる選択をする。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust has chosen to make the correct handling of <code>String</code> data the default behavior for all Rust programs, which means programmers have to put more thought into handling UTF-8 data upfront.</span> Rustは、すべてのRustプログラムのデフォルトの動作である<code>String</code>データの正しい処理を行うことを選択しました。これは、プログラマがUTF-8データを先に処理することをもっと考慮する必要があることを意味します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This trade-off exposes more of the complexity of strings than is apparent in other programming languages, but it prevents you from having to handle errors involving non-ASCII characters later in your development life cycle.</span>このトレードオフは、他のプログラミング言語よりも複雑なストリングを提供しますが、開発ライフサイクルの後半で非ASCII文字を含むエラーを処理する必要がなくなります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s switch to something a bit less complex: hash maps!</span>ちょっと複雑ではないものに切り替えることができます：ハッシュマップ！</span> </p><script>_addload(function(){_setupIW('com');_csi('en','ja','ch08-02-strings.html');});</script>