<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180709_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=ch20-03-graceful-shutdown-and-cleanup.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Graceful Shutdown and Cleanup</span>グレースフルシャットダウンとクリーンアップ</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The code in Listing 20-21 is responding to requests asynchronously through the use of a thread pool, as we intended.</span>コードリスト20-21のコードは、意図したとおり、スレッドプールを使用して非同期的に要求に応答しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We get some warnings about the <code>workers</code> , <code>id</code> , and <code>thread</code> fields that we&#39;re not using in a direct way that reminds us we&#39;re not cleaning up anything.</span>私たちは、私たちが何かをきれいにしていないことを思い出させる直接的な方法で使用していない<code>workers</code> 、 <code>id</code> 、 <code>thread</code>フィールドについていくつかの警告を出します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When we use the less elegant <span class=keystroke>ctrl-c</span> method to halt the main thread, all other threads are stopped immediately as well, even if they&#39;re in the middle of serving a request.</span>それほど洗練されていない<span class=keystroke>ctrl-c</span>メソッドを使用してメインスレッドを停止すると、他のすべてのスレッドは要求の処理中であってもすぐに停止します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now we&#39;ll implement the <code>Drop</code> trait to call <code>join</code> on each of the threads in the pool so they can finish the requests they&#39;re working on before closing.</span>ここで、 <code>Drop</code>特性を実装して、プール内の各スレッドで<code>join</code>を呼び出して、クローズする前に作業している要求を完了できるようにします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then we&#39;ll implement a way to tell the threads they should stop accepting new requests and shut down.</span>次に、スレッドが新しい要求の受け入れを停止してシャットダウンするように指示する方法を実装します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To see this code in action, we&#39;ll modify our server to accept only two requests before gracefully shutting down its thread pool.</span>このコードが実際に動作するように、スレッドプールを正常にシャットダウンする前に、2つの要求だけを受け入れるようにサーバーを修正します。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Implementing the <code>Drop</code> Trait on <code>ThreadPool</code></span> <code>ThreadPool</code>の<code>Drop</code>特性の実装</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s start with implementing <code>Drop</code> on our thread pool.</span>スレッドプールで<code>Drop</code>を実装することから始めましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When the pool is dropped, our threads should all join to make sure they finish their work.</span>プールが削除されると、スレッドがすべて終了して作業が完了するようにします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 20-23 shows a first attempt at a <code>Drop</code> implementation;</span>リスト20-23は、 <code>Drop</code>実装の最初の試みを示しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">this code won&#39;t quite work yet.</span>このコードはまだ動作しません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/lib.rs</span></span> <span class=filename>ファイル名：src / lib.rs</span></span> </p><br><div data-lang=rust,ignore><div data-l="impl Drop for ThreadPool {"></div><div data-l="    fn drop(&amp;mut self) {"></div><div data-l="        for worker in &amp;mut self.workers {"></div><div data-l="            println!(&quot;Shutting down worker {}&quot;, worker.id);"></div><div data-l=""></div><div data-l="            worker.thread.join().unwrap();"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 20-23: Joining each thread when the thread pool goes out of scope</span></span> <span class=caption>リスト20-23：スレッドプールがスコープから外れたときに各スレッドに参加する</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">First, we loop through each of the thread pool <code>workers</code> .</span>まず、各スレッドプール<code>workers</code>をループします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We use <code>&amp;mut</code> for this because <code>self</code> is a mutable reference, and we also need to be able to mutate <code>worker</code> .</span>私たちは<code>&amp;mut</code>を使用します。なぜなら、 <code>self</code>は可変参照であり、 <code>worker</code>変更も可能でなければならないからです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For each worker, we print a message saying that this particular worker is shutting down, and then we call <code>join</code> on that worker&#39;s thread.</span>各ワーカーに対して、この特定のワーカーがシャットダウンしていることを示すメッセージを出力し、そのワーカーのスレッドに対して<code>join</code>を呼び出します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If the call to <code>join</code> fails, we use <code>unwrap</code> to make Rust panic and go into an ungraceful shutdown.</span> <code>join</code>への呼び出しに失敗した場合は、 <code>unwrap</code>を使用してRustパニックを起こし、悲惨なシャットダウンに入ります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here is the error we get when we compile this code:</span>このコードをコンパイルするときのエラーは次のとおりです。</span> </p><br><div data-lang=text><div data-l="error[E0507]: cannot move out of borrowed content"></div><div data-l="  --&gt; src/lib.rs:65:13"></div><div data-l="   |"></div><div data-l="65 |             worker.thread.join().unwrap();"></div><div data-l="   |             ^^^^^^ cannot move out of borrowed content"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The error tells us we can&#39;t call <code>join</code> because we only have a mutable borrow of each <code>worker</code> and <code>join</code> takes ownership of its argument.</span>このエラーは、各<code>worker</code>可変的な借用しか持たず、 <code>join</code>がその引数の所有権を取るため、 <code>join</code>を呼び出すことができないことを示しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To solve this issue, we need to move the thread out of the <code>Worker</code> instance that owns <code>thread</code> so <code>join</code> can consume the thread.</span>この問題を解決するには、スレッドを所有する<code>Worker</code>インスタンスからスレッドを移動して、スレッドが<code>thread</code>を消費するように<code>join</code>があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We did this in Listing 17-15: if <code>Worker</code> holds an <code>Option&lt;thread::JoinHandle&lt;()&gt;</code> instead, we can call the <code>take</code> method on the <code>Option</code> to move the value out of the <code>Some</code> variant and leave a <code>None</code> variant in its place.</span>私たちは、リスト17-15でこれをやった次の場合<code>Worker</code>保持している<code>Option&lt;thread::JoinHandle&lt;()&gt;</code>の代わりに、我々は呼び出すことができ<code>take</code>の方法<code>Option</code>外の値を移動するには<code>Some</code>変種と残し<code>None</code>でバリアントをその場所。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In other words, a <code>Worker</code> that is running will have a <code>Some</code> variant in <code>thread</code> , and when we want to clean up a <code>Worker</code> , we&#39;ll replace <code>Some</code> with <code>None</code> so the <code>Worker</code> doesn&#39;t have a thread to run.</span>言い換えれば、 <code>Worker</code>実行している必要があります<code>Some</code>中にバリアント<code>thread</code> 、私たちはクリーンアップする際に<code>Worker</code> 、我々は交換してくださいよ<code>Some</code>と<code>None</code>ように、 <code>Worker</code>実行するスレッドを持っていません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So we know we want to update the definition of <code>Worker</code> like this:</span>そこで、 <code>Worker</code>の定義を次のように更新したいと考えています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/lib.rs</span></span> <span class=filename>ファイル名：src / lib.rs</span></span> </p><br><div data-lang=rust><div data-l="# use std::thread;"></div><div data-l="struct Worker {"></div><div data-l="    id: usize,"></div><div data-l="    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now let&#39;s lean on the compiler to find the other places that need to change.</span>次に、変更する必要がある他の場所を見つけるためにコンパイラを手放しましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Checking this code, we get two errors:</span>このコードを確認すると、2つのエラーが発生します。</span> </p><br><div data-lang=text><div data-l="error[E0599]: no method named `join` found for type"></div><div data-l="`std::option::Option&lt;std::thread::JoinHandle&lt;()&gt;&gt;` in the current scope"></div><div data-l="  --&gt; src/lib.rs:65:27"></div><div data-l="   |"></div><div data-l="65 |             worker.thread.join().unwrap();"></div><div data-l="   |                           ^^^^"></div><div data-l=""></div><div data-l="error[E0308]: mismatched types"></div><div data-l="  --&gt; src/lib.rs:89:13"></div><div data-l="   |"></div><div data-l="89 |             thread,"></div><div data-l="   |             ^^^^^^"></div><div data-l="   |             |"></div><div data-l="   |             expected enum `std::option::Option`, found struct"></div><div data-l="   `std::thread::JoinHandle`"></div><div data-l="   |             help: try using a variant of the expected type: `Some(thread)`"></div><div data-l="   |"></div><div data-l="   = note: expected type `std::option::Option&lt;std::thread::JoinHandle&lt;()&gt;&gt;`"></div><div data-l="              found type `std::thread::JoinHandle&lt;_&gt;`"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s address the second error, which points to the code at the end of <code>Worker::new</code> ;</span> <code>Worker::new</code>最後のコードを指す2番目のエラーを解決しましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">we need to wrap the <code>thread</code> value in <code>Some</code> when we create a new <code>Worker</code> .</span>新しい<code>Worker</code>を作成するときに、 <code>Some</code>に<code>thread</code>値をラップする必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Make the following changes to fix this error:</span>このエラーを修正するには、次の変更を行います。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/lib.rs</span></span> <span class=filename>ファイル名：src / lib.rs</span></span> </p><br><div data-lang=rust,ignore><div data-l="impl Worker {"></div><div data-l="    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {"></div><div data-l="#        // --snip--"></div><div data-l="        // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">--snip--</span> --snip--</span> </div><div data-l=""></div><div data-l="        Worker {"></div><div data-l="            id,"></div><div data-l="            thread: Some(thread),"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The first error is in our <code>Drop</code> implementation.</span>最初のエラーは<code>Drop</code>実装です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We mentioned earlier that we intended to call <code>take</code> on the <code>Option</code> value to move <code>thread</code> out of <code>worker</code> .</span>先に、 <code>thread</code>を<code>worker</code>から移動させるために<code>Option</code>値を<code>take</code>ことを意図したと述べました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The following changes will do so:</span>次の変更がこれを行います：</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/lib.rs</span></span> <span class=filename>ファイル名：src / lib.rs</span></span> </p><br><div data-lang=rust,ignore><div data-l="impl Drop for ThreadPool {"></div><div data-l="    fn drop(&amp;mut self) {"></div><div data-l="        for worker in &amp;mut self.workers {"></div><div data-l="            println!(&quot;Shutting down worker {}&quot;, worker.id);"></div><div data-l=""></div><div data-l="            if let Some(thread) = worker.thread.take() {"></div><div data-l="                thread.join().unwrap();"></div><div data-l="            }"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As discussed in Chapter 17, the <code>take</code> method on <code>Option</code> takes the <code>Some</code> variant out and leaves <code>None</code> in its place.</span>第17章で説明した<code>take</code> 、 <code>Option</code>の<code>take</code>メソッドは、 <code>Some</code> variantを取り出し、 <code>None</code>をそのまま残します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;re using <code>if let</code> to destructure the <code>Some</code> and get the thread;</span>私たちは<code>Some</code>を破壊してスレッドを手に入れよ<code>if let</code>とする<code>if let</code>使っています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">then we call <code>join</code> on the thread.</span>スレッド上で<code>join</code>を呼び出します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If a worker&#39;s thread is already <code>None</code> , we know that worker has already had its thread cleaned up, so nothing happens in that case.</span>ワーカーのスレッドが既に<code>None</code>の場合、ワーカーは既にスレッドをクリーンアップしていることがわかっているので、その場合は何も起こりません。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Signaling to the Threads to Stop Listening for Jobs</span>ジョブのリッスンを停止するためのスレッドへのシグナリング</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">With all the changes we&#39;ve made, our code compiles without any warnings.</span>私たちが行ったすべての変更により、コードは警告なしでコンパイルされます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But the bad news is this code doesn&#39;t function the way we want it to yet.</span>しかし、悪い知らせは、このコードは我々がまだ望むように機能しないということです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The key is the logic in the closures run by the threads of the <code>Worker</code> instances: at the moment, we call <code>join</code> , but that won&#39;t shut down the threads because they <code>loop</code> forever looking for jobs.</span>キーは、 <code>Worker</code>インスタンスのスレッドによって実行されるクロージャーのロジックです：現時点では<code>join</code>を呼び出します<code>join</code> 、スレッドを永久に<code>loop</code>ため、スレッドをシャットダウンしません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we try to drop our <code>ThreadPool</code> with our current implementation of <code>drop</code> , the main thread will block forever waiting for the first thread to finish.</span>現在の<code>drop</code>実装で<code>ThreadPool</code>を削除しようとすると、メインスレッドは最初のスレッドが終了するのを永久にブロックします。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To fix this problem, we&#39;ll modify the threads so they listen for either a <code>Job</code> to run or a signal that they should stop listening and exit the infinite loop.</span>彼らはどちらかのために聞くように、この問題を解決するために、我々はスレッドを修正します<code>Job</code>を実行したり、彼らが聞いて停止し、無限ループを終了しなければならない信号。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Instead of <code>Job</code> instances, our channel will send one of these two enum variants.</span> <code>Job</code>インスタンスの代わりに、私たちのチャンネルはこれら2つの列挙型の1つを送信します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/lib.rs</span></span> <span class=filename>ファイル名：src / lib.rs</span></span> </p><br><div data-lang=rust><div data-l="# struct Job;"></div><div data-l="enum Message {"></div><div data-l="    NewJob(Job),"></div><div data-l="    Terminate,"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This <code>Message</code> enum will either be a <code>NewJob</code> variant that holds the <code>Job</code> the thread should run, or it will be a <code>Terminate</code> variant that will cause the thread to exit its loop and stop.</span>この<code>Message</code> enumは、スレッドが実行する<code>Job</code>を保持する<code>NewJob</code>バリアントか、スレッドがループを終了して停止する<code>Terminate</code>バリアントになります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We need to adjust the channel to use values of type <code>Message</code> rather than type <code>Job</code> , as shown in Listing 20-24.</span>リスト20-24に示すように、 <code>Job</code>型を入力するのではなく、 <code>Message</code>型の値を使用するようにチャネルを調整する必要があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/lib.rs</span></span> <span class=filename>ファイル名：src / lib.rs</span></span> </p><br><div data-lang=rust,ignore><div data-l="pub struct ThreadPool {"></div><div data-l="    workers: Vec&lt;Worker&gt;,"></div><div data-l="    sender: mpsc::Sender&lt;Message&gt;,"></div><div data-l=}></div><div data-l=""></div><div data-l="#// --snip--"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">--snip--</span> --snip--</span> </div><div data-l=""></div><div data-l="impl ThreadPool {"></div><div data-l="#    // --snip--"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">--snip--</span> --snip--</span> </div><div data-l=""></div><div data-l="    pub fn execute&lt;F&gt;(&amp;self, f: F)"></div><div data-l="        where"></div><div data-l="            F: FnOnce() + Send + 'static"></div><div data-l="    {"></div><div data-l="        let job = Box::new(f);"></div><div data-l=""></div><div data-l="        self.sender.send(Message::NewJob(job)).unwrap();"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="#// --snip--"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">--snip--</span> --snip--</span> </div><div data-l=""></div><div data-l="impl Worker {"></div><div data-l="    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Message&gt;&gt;&gt;) -&gt;"></div><div data-l="        Worker {"></div><div data-l=""></div><div data-l="        let thread = thread::spawn(move ||{"></div><div data-l="            loop {"></div><div data-l="                let message = receiver.lock().unwrap().recv().unwrap();"></div><div data-l=""></div><div data-l="                match message {"></div><div data-l="                    Message::NewJob(job) =&gt; {"></div><div data-l="                        println!(&quot;Worker {} got a job; executing.&quot;, id);"></div><div data-l=""></div><div data-l="                        job.call_box();"></div><div data-l="                    },"></div><div data-l="                    Message::Terminate =&gt; {"></div><div data-l="                        println!(&quot;Worker {} was told to terminate.&quot;, id);"></div><div data-l=""></div><div data-l="                        break;"></div><div data-l="                    },"></div><div data-l="                }"></div><div data-l="            }"></div><div data-l="        });"></div><div data-l=""></div><div data-l="        Worker {"></div><div data-l="            id,"></div><div data-l="            thread: Some(thread),"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 20-24: Sending and receiving <code>Message</code> values and exiting the loop if a <code>Worker</code> receives <code>Message::Terminate</code></span></span> <span class=caption>リスト20-24： <code>Message</code>値を送受信すると、 <code>Worker</code> <code>Message::Terminate</code>を受け取った場合にループを<code>Message::Terminate</code></span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To incorporate the <code>Message</code> enum, we need to change <code>Job</code> to <code>Message</code> in two places: the definition of <code>ThreadPool</code> and the signature of <code>Worker::new</code> .</span> <code>Message</code> enumを組み込むには、 <code>ThreadPool</code>の定義と<code>Worker::new</code>署名の2つの場所で<code>Job</code>から<code>Message</code>に変更する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>execute</code> method of <code>ThreadPool</code> needs to send jobs wrapped in the <code>Message::NewJob</code> variant.</span> <code>ThreadPool</code>の<code>execute</code>メソッドは、 <code>Message::NewJob</code>バリアントにラップされたジョブを送信する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then, in <code>Worker::new</code> where a <code>Message</code> is received from the channel, the job will be processed if the <code>NewJob</code> variant is received, and the thread will break out of the loop if the <code>Terminate</code> variant is received.</span>次に、 <code>Worker::new</code>でチャネルから<code>Message</code>を受信すると、 <code>NewJob</code>バリアントが受信された場合にジョブが処理され、 <code>Terminate</code>バリアントが受信された場合にスレッドからループが抜けます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">With these changes, the code will compile and continue to function in the same way as it did after Listing 20-21.</span>これらの変更により、コードはコードリスト20-21の場合と同じ方法でコンパイルされ、機能し続けます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But we&#39;ll get a warning because we aren&#39;t creating any messages of the <code>Terminate</code> variety.</span>しかし、 <code>Terminate</code>種類のメッセージを作成していないため、警告が表示されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s fix this warning by changing our <code>Drop</code> implementation to look like Listing 20-25.</span>リスト20-25のように<code>Drop</code>実装を変更して、この警告を修正しましょう。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/lib.rs</span></span> <span class=filename>ファイル名：src / lib.rs</span></span> </p><br><div data-lang=rust,ignore><div data-l="impl Drop for ThreadPool {"></div><div data-l="    fn drop(&amp;mut self) {"></div><div data-l="        println!(&quot;Sending terminate message to all workers.&quot;);"></div><div data-l=""></div><div data-l="        for _ in &amp;mut self.workers {"></div><div data-l="            self.sender.send(Message::Terminate).unwrap();"></div><div data-l="        }"></div><div data-l=""></div><div data-l="        println!(&quot;Shutting down all workers.&quot;);"></div><div data-l=""></div><div data-l="        for worker in &amp;mut self.workers {"></div><div data-l="            println!(&quot;Shutting down worker {}&quot;, worker.id);"></div><div data-l=""></div><div data-l="            if let Some(thread) = worker.thread.take() {"></div><div data-l="                thread.join().unwrap();"></div><div data-l="            }"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 20-25: Sending <code>Message::Terminate</code> to the workers before calling <code>join</code> on each worker thread</span></span> <span class=caption>リスト20-25： <code>Message::Terminate</code>送信する<code>Message::Terminate</code>各ワーカースレッドで<code>join</code>を呼び出す前にworkerを<code>Message::Terminate</code>する</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;re now iterating over the workers twice: once to send one <code>Terminate</code> message for each worker and once to call <code>join</code> on each worker&#39;s thread.</span>従業員ごとに1回<code>Terminate</code>メッセージを送信し、各ワーカーのスレッドで1回<code>join</code>を呼び出すよう<code>join</code>ました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we tried to send a message and <code>join</code> immediately in the same loop, we couldn&#39;t guarantee that the worker in the current iteration would be the one to get the message from the channel.</span>メッセージを送信してすぐに同じループで<code>join</code>しようと<code>join</code>と、現行反復のワーカーがチャンネルからメッセージを受け取ることが保証されませんでした。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To better understand why we need two separate loops, imagine a scenario with two workers.</span> 2つの別々のループが必要な理由をよりよく理解するには、2人の作業者がいるシナリオを想像してみてください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we used a single loop to iterate through each worker, on the first iteration a terminate message would be sent down the channel and <code>join</code> called on the first worker&#39;s thread.</span>私たちは各ワーカーを反復処理する単一のループを使用した場合、最初の反復で終わるメッセージはチャンネルをダウン送信されますと、 <code>join</code>最初のワーカーのスレッドで呼び出さ。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If that first worker was busy processing a request at that moment, the second worker would pick up the terminate message from the channel and shut down.</span>その最初のワーカーがその時点で要求を処理するのに忙しかった場合、2番目のワーカーはそのチャネルから終了メッセージを取り出してシャットダウンします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We would be left waiting on the first worker to shut down, but it never would because the second thread picked up the terminate message.</span>最初のワーカーがシャットダウンするのを待つままにしておきますが、2番目のスレッドが終了メッセージを受け取ったために決して実行されません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Deadlock!</span>デッドロック！</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To prevent this scenario, we first put all of our <code>Terminate</code> messages on the channel in one loop;</span>このシナリオを防ぐために、最初にすべての<code>Terminate</code>メッセージを1つのループでチャネルに配置します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">then we join on all the threads in another loop.</span>別のループのすべてのスレッドに参加します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Each worker will stop receiving requests on the channel once it gets a terminate message.</span>各作業者は、終了メッセージを受信すると、チャネル上で要求の受信を停止します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So, we can be sure that if we send the same number of terminate messages as there are workers, each worker will receive a terminate message before <code>join</code> is called on its thread.</span>したがって、ワーカーが存在するのと同じ数の終了メッセージを送信すると、各ワーカーはそのスレッドで<code>join</code>が呼び出される前<code>join</code>終了メッセージを受け取ることができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To see this code in action, let&#39;s modify <code>main</code> to accept only two requests before gracefully shutting down the server, as shown in Listing 20-26.</span>このコードを実行するには、リスト20-26に示すように、サーバーを正常にシャットダウンする前に、 <code>main</code>を変更して2つの要求のみを受け入れるようにしましょう。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/bin/main.rs</span></span> <span class=filename>ファイル名：src / bin / main.rs</span></span> </p><br><div data-lang=rust,ignore><div data-l="fn main() {"></div><div data-l="    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();"></div><div data-l="    let pool = ThreadPool::new(4);"></div><div data-l=""></div><div data-l="    for stream in listener.incoming().take(2) {"></div><div data-l="        let stream = stream.unwrap();"></div><div data-l=""></div><div data-l="        pool.execute(|| {"></div><div data-l="            handle_connection(stream);"></div><div data-l="        });"></div><div data-l="    }"></div><div data-l=""></div><div data-l="    println!(&quot;Shutting down.&quot;);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 20-26: Shut down the server after serving two requests by exiting the loop</span></span> <span class=caption>リスト20-26：ループを終了して2つのリクエストを処理した後にサーバをシャットダウンする</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You wouldn&#39;t want a real-world web server to shut down after serving only two requests.</span> 2つの要求のみを処理した後、現実のWebサーバーをシャットダウンする必要はありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This code just demonstrates that the graceful shutdown and cleanup is in working order.</span>このコードは、正常なシャットダウンとクリーンアップが正常に動作していることを示しています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>take</code> method is defined in the <code>Iterator</code> trait and limits the iteration to the first two items at most.</span> <code>take</code>メソッドは<code>Iterator</code>特性で定義され、反復を多くても最初の2つのアイテムに制限します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>ThreadPool</code> will go out of scope at the end of <code>main</code> , and the <code>drop</code> implementation will run.</span> <code>ThreadPool</code>は<code>main</code>の最後にスコープから外れ、 <code>drop</code>実装が実行されます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Start the server with <code>cargo run</code> , and make three requests.</span> <code>cargo run</code>でサーバーを始動し、3つの要求をします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The third request should error, and in your terminal you should see output similar to this:</span> 3番目のリクエストにエラーがあり、端末に次のような出力が表示されます。</span> </p><br><div data-lang=text><div data-l="$ cargo run"></div><div data-l="   Compiling hello v0.1.0 (file:///projects/hello)"></div><div data-l="    Finished dev [unoptimized + debuginfo] target(s) in 1.0 secs"></div><div data-l="     Running `target/debug/hello`"></div><div data-l="Worker 0 got a job; executing."></div><div data-l="Worker 3 got a job; executing."></div><div data-l="Shutting down."></div><div data-l="Sending terminate message to all workers."></div><div data-l="Shutting down all workers."></div><div data-l="Shutting down worker 0"></div><div data-l="Worker 1 was told to terminate."></div><div data-l="Worker 2 was told to terminate."></div><div data-l="Worker 0 was told to terminate."></div><div data-l="Worker 3 was told to terminate."></div><div data-l="Shutting down worker 1"></div><div data-l="Shutting down worker 2"></div><div data-l="Shutting down worker 3"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You might see a different ordering of workers and messages printed.</span>作業員とメッセージの順序が異なることがあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can see how this code works from the messages: workers 0 and 3 got the first two requests, and then on the third request, the server stopped accepting connections.</span>このコードがメッセージからどのように機能するかを見ることができます。ワーカー0と3が最初の2つの要求を受け取り、3番目の要求では、サーバーは接続の受け入れを停止しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When the <code>ThreadPool</code> goes out of scope at the end of <code>main</code> , its <code>Drop</code> implementation kicks in, and the pool tells all workers to terminate.</span> <code>ThreadPool</code>が<code>main</code>の終わりにスコープから外れると、その<code>Drop</code>実装が起動し、プールはすべてのワーカーに終了を指示します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The workers each print a message when they see the terminate message, and then the thread pool calls <code>join</code> to shut down each worker thread.</span>ワーカーはそれぞれ、終了メッセージが表示されたときにメッセージを出力し、スレッドプールは<code>join</code>を呼び出して各ワーカースレッドをシャットダウンします。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Notice one interesting aspect of this particular execution: the <code>ThreadPool</code> sent the terminate messages down the channel, and before any worker received the messages, we tried to join worker 0. Worker 0 had not yet received the terminate message, so the main thread blocked waiting for worker 0 to finish.</span>この特定の実行の興味深い点の1つに注目してください<code>ThreadPool</code>はチャネルの終端メッセージを送信し、ワーカーがメッセージを受け取る前にワーカー0に参加しようとしました。ワーカー0はまだ終了メッセージを受信して​​いないので、作業者0が終了する。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In the meantime, each of the workers received the termination messages.</span>その間、各作業員は終了メッセージを受信した。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When worker 0 finished, the main thread waited for the rest of the workers to finish.</span>作業者0が終了すると、メインスレッドは残りの作業者が終了するのを待っていました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">At that point, they had all received the termination message and were able to shut down.</span>その時点で、彼らはすべて終了メッセージを受信して​​シャットダウンすることができました。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Congrats!</span>おめでとう！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ve now completed our project;</span>これでプロジェクトが完了しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">we have a basic web server that uses a thread pool to respond asynchronously.</span>非同期に応答するためにスレッドプールを使用する基本的なWebサーバーがあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;re able to perform a graceful shutdown of the server, which cleans up all the threads in the pool.</span>サーバを正常にシャットダウンすることができ、プール内のすべてのスレッドがクリーンアップされます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here&#39;s the full code for reference:</span>参考までに完全なコードは次のとおりです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/bin/main.rs</span></span> <span class=filename>ファイル名：src / bin / main.rs</span></span> </p><br><div data-lang=rust,ignore><div data-l="extern crate hello;"></div><div data-l="use hello::ThreadPool;"></div><div data-l=""></div><div data-l="use std::io::prelude::*;"></div><div data-l="use std::net::TcpListener;"></div><div data-l="use std::net::TcpStream;"></div><div data-l="use std::fs::File;"></div><div data-l="use std::thread;"></div><div data-l="use std::time::Duration;"></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();"></div><div data-l="    let pool = ThreadPool::new(4);"></div><div data-l=""></div><div data-l="    for stream in listener.incoming().take(2) {"></div><div data-l="        let stream = stream.unwrap();"></div><div data-l=""></div><div data-l="        pool.execute(|| {"></div><div data-l="            handle_connection(stream);"></div><div data-l="        });"></div><div data-l="    }"></div><div data-l=""></div><div data-l="    println!(&quot;Shutting down.&quot;);"></div><div data-l=}></div><div data-l=""></div><div data-l="fn handle_connection(mut stream: TcpStream) {"></div><div data-l="    let mut buffer = [0; 512];"></div><div data-l="    stream.read(&amp;mut buffer).unwrap();"></div><div data-l=""></div><div data-l="    let get = b&quot;GET / HTTP/1.1\r\n&quot;;"></div><div data-l="    let sleep = b&quot;GET /sleep HTTP/1.1\r\n&quot;;"></div><div data-l=""></div><div data-l="    let (status_line, filename) = if buffer.starts_with(get) {"></div><div data-l="        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)"></div><div data-l="    } else if buffer.starts_with(sleep) {"></div><div data-l="        thread::sleep(Duration::from_secs(5));"></div><div data-l="        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)"></div><div data-l="    } else {"></div><div data-l="        (&quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;, &quot;404.html&quot;)"></div><div data-l="    };"></div><div data-l=""></div><div data-l="     let mut file = File::open(filename).unwrap();"></div><div data-l="     let mut contents = String::new();"></div><div data-l=""></div><div data-l="     file.read_to_string(&amp;mut contents).unwrap();"></div><div data-l=""></div><div data-l="     let response = format!(&quot;{}{}&quot;, status_line, contents);"></div><div data-l=""></div><div data-l="     stream.write(response.as_bytes()).unwrap();"></div><div data-l="     stream.flush().unwrap();"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/lib.rs</span></span> <span class=filename>ファイル名：src / lib.rs</span></span> </p><br><div data-lang=rust><div data-l="use std::thread;"></div><div data-l="use std::sync::mpsc;"></div><div data-l="use std::sync::Arc;"></div><div data-l="use std::sync::Mutex;"></div><div data-l=""></div><div data-l="enum Message {"></div><div data-l="    NewJob(Job),"></div><div data-l="    Terminate,"></div><div data-l=}></div><div data-l=""></div><div data-l="pub struct ThreadPool {"></div><div data-l="    workers: Vec&lt;Worker&gt;,"></div><div data-l="    sender: mpsc::Sender&lt;Message&gt;,"></div><div data-l=}></div><div data-l=""></div><div data-l="trait FnBox {"></div><div data-l="    fn call_box(self: Box&lt;Self&gt;);"></div><div data-l=}></div><div data-l=""></div><div data-l="impl&lt;F: FnOnce()&gt; FnBox for F {"></div><div data-l="    fn call_box(self: Box&lt;F&gt;) {"></div><div data-l="        (*self)()"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="type Job = Box&lt;FnBox + Send + 'static&gt;;"></div><div data-l=""></div><div data-l="impl ThreadPool {"></div><div data-l="#//    /// Create a new ThreadPool."></div><div data-l="    /// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Create a new ThreadPool.</span>新しいThreadPoolを作成します。</span> </div><div data-l="    ///"></div><div data-l="#//    /// The size is the number of threads in the pool."></div><div data-l="    /// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The size is the number of threads in the pool.</span>サイズは、プール内のスレッドの数です。</span> </div><div data-l="    ///"></div><div data-l="#//    /// # Panics"></div><div data-l="    /// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"># Panics</span> ＃パニック</span> </div><div data-l="    ///"></div><div data-l="#//    /// The `new` function will panic if the size is zero."></div><div data-l="    /// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>new</code> function will panic if the size is zero.</span>サイズがゼロの場合、 <code>new</code>関数はパニックに陥ります。</span> </div><div data-l="    pub fn new(size: usize) -&gt; ThreadPool {"></div><div data-l="        assert!(size &gt; 0);"></div><div data-l=""></div><div data-l="        let (sender, receiver) = mpsc::channel();"></div><div data-l=""></div><div data-l="        let receiver = Arc::new(Mutex::new(receiver));"></div><div data-l=""></div><div data-l="        let mut workers = Vec::with_capacity(size);"></div><div data-l=""></div><div data-l="        for id in 0..size {"></div><div data-l="            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));"></div><div data-l="        }"></div><div data-l=""></div><div data-l="        ThreadPool {"></div><div data-l="            workers,"></div><div data-l="            sender,"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=""></div><div data-l="    pub fn execute&lt;F&gt;(&amp;self, f: F)"></div><div data-l="        where"></div><div data-l="            F: FnOnce() + Send + 'static"></div><div data-l="    {"></div><div data-l="        let job = Box::new(f);"></div><div data-l=""></div><div data-l="        self.sender.send(Message::NewJob(job)).unwrap();"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="impl Drop for ThreadPool {"></div><div data-l="    fn drop(&amp;mut self) {"></div><div data-l="        println!(&quot;Sending terminate message to all workers.&quot;);"></div><div data-l=""></div><div data-l="        for _ in &amp;mut self.workers {"></div><div data-l="            self.sender.send(Message::Terminate).unwrap();"></div><div data-l="        }"></div><div data-l=""></div><div data-l="        println!(&quot;Shutting down all workers.&quot;);"></div><div data-l=""></div><div data-l="        for worker in &amp;mut self.workers {"></div><div data-l="            println!(&quot;Shutting down worker {}&quot;, worker.id);"></div><div data-l=""></div><div data-l="            if let Some(thread) = worker.thread.take() {"></div><div data-l="                thread.join().unwrap();"></div><div data-l="            }"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="struct Worker {"></div><div data-l="    id: usize,"></div><div data-l="    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,"></div><div data-l=}></div><div data-l=""></div><div data-l="impl Worker {"></div><div data-l="    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Message&gt;&gt;&gt;) -&gt;"></div><div data-l="        Worker {"></div><div data-l=""></div><div data-l="        let thread = thread::spawn(move ||{"></div><div data-l="            loop {"></div><div data-l="                let message = receiver.lock().unwrap().recv().unwrap();"></div><div data-l=""></div><div data-l="                match message {"></div><div data-l="                    Message::NewJob(job) =&gt; {"></div><div data-l="                        println!(&quot;Worker {} got a job; executing.&quot;, id);"></div><div data-l=""></div><div data-l="                        job.call_box();"></div><div data-l="                    },"></div><div data-l="                    Message::Terminate =&gt; {"></div><div data-l="                        println!(&quot;Worker {} was told to terminate.&quot;, id);"></div><div data-l=""></div><div data-l="                        break;"></div><div data-l="                    },"></div><div data-l="                }"></div><div data-l="            }"></div><div data-l="        });"></div><div data-l=""></div><div data-l="        Worker {"></div><div data-l="            id,"></div><div data-l="            thread: Some(thread),"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We could do more here!</span>もっともっとここでやることができます！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you want to continue enhancing this project, here are some ideas:</span>このプロジェクトの改善を継続したい場合は、以下のアイデアを参考にしてください。</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Add more documentation to <code>ThreadPool</code> and its public methods.</span> <code>ThreadPool</code>とそのパブリックメソッドにさらにドキュメントを追加してください。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Add tests of the library&#39;s functionality.</span>ライブラリの機能のテストを追加します。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Change calls to <code>unwrap</code> to more robust error handling.</span> <code>unwrap</code>するコールをより堅牢なエラー処理に変更します。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Use <code>ThreadPool</code> to perform some task other than serving web requests.</span> Web要求を処理する以外のタスクを実行するには、 <code>ThreadPool</code>を使用します。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Find a thread pool crate on <i>https://crates.io/</i> and implement a similar web server using the crate instead.</span> <i>https://crates.io/で</i>スレッドプールの枠を見つけて、代わりにクレートを使用して同様のWebサーバーを実装して<i>ください</i> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then compare its API and robustness to the thread pool we implemented.</span>その後、APIと堅牢性を実装したスレッドプールと比較します。</span> </div><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Summary</span>概要</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Well done!</span>よくやった！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You&#39;ve made it to the end of the book!</span>あなたは本の終わりまでそれを作った！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We want to thank you for joining us on this tour of Rust.</span>このRustのツアーに参加してくれてありがとう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You&#39;re now ready to implement your own Rust projects and help with other peoples&#39; projects.</span>これであなた自身のRustプロジェクトを実装し、他の人々のプロジェクトに協力する準備が整いました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Keep in mind that there is a welcoming community of other Rustaceans who would love to help you with any challenges you encounter on your Rust journey.</span>あなたの錆びた旅で遭遇するあらゆる挑戦をお手伝いしたいと思う他の錆びた人の歓迎するコミュニティがあることに留意してください。</span> </p><script>_addload(function(){_setupIW('com');_csi('en','ja','ch20-03-graceful-shutdown-and-cleanup.html');});</script>