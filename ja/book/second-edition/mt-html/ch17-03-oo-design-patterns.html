<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180709_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=ch17-03-oo-design-patterns.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Implementing an Object-Oriented Design Pattern</span>オブジェクト指向設計パターンの実装</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <i>state pattern</i> is an object-oriented design pattern.</span> <i>状態パターン</i>は、オブジェクト指向の設計パターンです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The crux of the pattern is that a value has some internal state, which is represented by a set of <i>state objects</i> , and the value&#39;s behavior changes based on the internal state.</span>パターンの要点は、ある値にある内部状態があり、それが<i>状態オブジェクトの</i>集合で表され、その値の振る舞いは内部状態に基づいて変化するということです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The state objects share functionality: in Rust, of course, we use structs and traits rather than objects and inheritance.</span>状態オブジェクトは機能を共有しています。もちろん、Rustではオブジェクトや継承ではなく構造体と特性を使用します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Each state object is responsible for its own behavior and for governing when it should change into another state.</span>各状態オブジェクトは、自身の振る舞いと、それが別の状態に変わるべき時を管理する役割を担う。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The value that holds a state object knows nothing about the different behavior of the states or when to transition between states.</span>状態オブジェクトを保持する値は、状態の異なる振る舞いや状態の遷移の時期については何も知らない。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Using the state pattern means when the business requirements of the program change, we won&#39;t need to change the code of the value holding the state or the code that uses the value.</span>状態パターンを使用するとは、プログラムのビジネス要件が変わったときに、その状態を保持する値のコードまたはその値を使用するコードを変更する必要はありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll only need to update the code inside one of the state objects to change its rules or perhaps add more state objects.</span>状態オブジェクトの1つの内部のコードを更新してルールを変更するか、または状態オブジェクトを追加する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s look at an example of the state design pattern and how to use it in Rust.</span>状態の設計パターンの例と、それをRustで使用する方法を見てみましょう。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll implement a blog post workflow in an incremental way.</span>ブログ投稿のワークフローを段階的に実装します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The blog&#39;s final functionality will look like this:</span>ブログの最終的な機能は次のようになります。</span> </p><br><div data-b=1.> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A blog post starts as an empty draft.</span>ブログ投稿は空のドラフトとして開始されます。</span> </div><div data-b=2.> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When the draft is done, a review of the post is requested.</span>ドラフトが完了したら、投稿のレビューが要求されます。</span> </div><div data-b=3.> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When the post is approved, it gets published.</span>投稿が承認されると、公開されます。</span> </div><div data-b=4.> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Only published blog posts return content to print, so unapproved posts can&#39;t accidentally be published.</span>公開されたブログ投稿のみがコンテンツを印刷するので、承認されていない投稿を誤って公開することはできません。</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Any other changes attempted on a post should have no effect.</span>投稿に加えられた他の変更は効果がありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, if we try to approve a draft blog post before we&#39;ve requested a review, the post should remain an unpublished draft.</span>たとえば、レビューをリクエストする前にブログ投稿の下書きを承認しようとすると、その投稿は未公開のまま残るはずです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 17-11 shows this workflow in code form: this is an example usage of the API we&#39;ll implement in a library crate named <code>blog</code> .</span>コードリスト17-11に、このワークフローをコードフォームで示します。これは、ライブラリcrateという名前の<code>blog</code>実装するAPIの使用例です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This won&#39;t compile yet because we haven&#39;t implemented the <code>blog</code> crate yet.</span>私たちはまだ<code>blog</code>箱を実装していないので、これはまだコンパイルされません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust,ignore><div data-l="extern crate blog;"></div><div data-l="use blog::Post;"></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let mut post = Post::new();"></div><div data-l=""></div><div data-l="    post.add_text(&quot;I ate a salad for lunch today&quot;);"></div><div data-l="    assert_eq!(&quot;&quot;, post.content());"></div><div data-l=""></div><div data-l="    post.request_review();"></div><div data-l="    assert_eq!(&quot;&quot;, post.content());"></div><div data-l=""></div><div data-l="    post.approve();"></div><div data-l="    assert_eq!(&quot;I ate a salad for lunch today&quot;, post.content());"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 17-11: Code that demonstrates the desired behavior we want our <code>blog</code> crate to have</span></span> <span class=caption>リスト17-11：私たちの<code>blog</code>クレートに必要な動作を示すコード</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We want to allow the user to create a new draft blog post with <code>Post::new</code> .</span>私たちは<code>Post::new</code>使ってブログ投稿の新しいドラフトを作成できるようにしたいと考えています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then we want to allow text to be added to the blog post while it&#39;s in the draft state.</span>次に、ドラフト状態にある間にブログ投稿にテキストを追加できるようにします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we try to get the post&#39;s content immediately, before approval, nothing should happen because the post is still a draft.</span>投稿の内容をすぐに取得しようとすると、承認前に投稿がまだ草稿であるため、何も起こらないはずです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ve added <code>assert_eq€</code> in the code for demonstration purposes.</span>デモンストレーションの目的で<code>assert_eq€</code>をコードに追加しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">An excellent unit test for this would be to assert that a draft blog post returns an empty string from the <code>content</code> method, but we&#39;re not going to write tests for this example.</span>このための優れた単体テストは、ブログ投稿のドラフトが<code>content</code>メソッドから空の文字列を返すと主張することですが、この例ではテストを書くつもりはありません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Next, we want to enable a request for a review of the post, and we want <code>content</code> to return an empty string while waiting for the review.</span>次に、我々はポストの見直しの要求を有効にしたい、と我々はしたい<code>content</code>審査を待っている間に空の文字列を返すこと。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When the post receives approval, it should get published, meaning the text of the post will be returned when <code>content</code> is called.</span>投稿が承認されると、投稿が公開されるはずです。つまり、 <code>content</code>呼び出し時に投稿のテキストが返されます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Notice that the only type we&#39;re interacting with from the crate is the <code>Post</code> type.</span>私たちが木箱からやり取りしている唯一のタイプは<code>Post</code>タイプです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This type will use the state pattern and will hold a value that will be one of three state objects representing the various states a post can be in—draft, waiting for review, or published.</span>このタイプは状態パターンを使用し、投稿が草案中であるか、レビューを待っているか、公開されているかを示す3つの状態オブジェクトの1つになる値を保持します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Changing from one state to another will be managed internally within the <code>Post</code> type.</span>ある状態から別の状態への変更は、 <code>Post</code>型で内部的に管理されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The states change in response to the methods called by our library&#39;s users on the <code>Post</code> instance, but they don&#39;t have to manage the state changes directly.</span> <code>Post</code>インスタンスのライブラリのユーザーから呼び出されたメソッドに応答してステートが変更されますが、ステートの変更を直接管理する必要はありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Also, users can&#39;t make a mistake with the states, like publishing a post before it&#39;s reviewed.</span>また、ユーザーはレビューの前に投稿を公開するなど、州で間違いを犯すことはできません。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Defining <code>Post</code> and Creating a New Instance in the Draft State</span> <code>Post</code>定義とドラフト状態での新規インスタンスの作成</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s get started on the implementation of the library!</span>ライブラリの実装を開始しましょう！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We know we need a public <code>Post</code> struct that holds some content, so we&#39;ll start with the definition of the struct and an associated public <code>new</code> function to create an instance of <code>Post</code> , as shown in Listing 17-12.</span>リスト17-12に示すように、いくつかのコンテンツを保持するpublic <code>Post</code>構造体が必要であることがわかっているので、構造体の定義と<code>Post</code>インスタンスを作成する関連するpublic <code>new</code>関数から始めます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll also make a private <code>State</code> trait.</span>私たちはまた、私有の<code>State</code>特性を作ります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then <code>Post</code> will hold a trait object of <code>Box&lt;State&gt;</code> inside an <code>Option</code> in a private field named <code>state</code> .</span>その後、 <code>Post</code>の形質オブジェクト保持する<code>Box&lt;State&gt;</code>内部で<code>Option</code>という名前の民間分野での<code>state</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You&#39;ll see why the <code>Option</code> is necessary in a bit.</span>この<code>Option</code>がなぜ必要なのかが分かります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/lib.rs</span></span> <span class=filename>ファイル名：src / lib.rs</span></span> </p><br><div data-lang=rust><div data-l="pub struct Post {"></div><div data-l="    state: Option&lt;Box&lt;State&gt;&gt;,"></div><div data-l="    content: String,"></div><div data-l=}></div><div data-l=""></div><div data-l="impl Post {"></div><div data-l="    pub fn new() -&gt; Post {"></div><div data-l="        Post {"></div><div data-l="            state: Some(Box::new(Draft {})),"></div><div data-l="            content: String::new(),"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="trait State {}"></div><div data-l=""></div><div data-l="struct Draft {}"></div><div data-l=""></div><div data-l="impl State for Draft {}"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 17-12: Definition of a <code>Post</code> struct and a <code>new</code> function that creates a new <code>Post</code> instance, a <code>State</code> trait, and a <code>Draft</code> struct</span></span> <span class=caption>定義：リスト17-12 <code>Post</code>構造体と<code>new</code>新しい作成機能<code>Post</code>インスタンスを、 <code>State</code>特性、および<code>Draft</code>構造体を</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>State</code> trait defines the behavior shared by different post states, and the <code>Draft</code> , <code>PendingReview</code> , and <code>Published</code> states will all implement the <code>State</code> trait.</span> <code>State</code>特性は、異なる郵便州によって共有される振る舞いを定義し、 <code>Draft</code> 、 <code>PendingReview</code> 、 <code>Published</code>州はすべて<code>State</code>特性を実装します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For now, the trait doesn&#39;t have any methods, and we&#39;ll start by defining just the <code>Draft</code> state because that is the state we want a post to start in.</span>今のところ、形質には方法がありません。 <code>Draft</code>状態を定義することから始めることにします。これは、投稿を開始する状態であるためです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When we create a new <code>Post</code> , we set its <code>state</code> field to a <code>Some</code> value that holds a <code>Box</code> .</span>我々は新しい作成するときに<code>Post</code> 、私たちは、その設定され<code>state</code>にフィールドを<code>Some</code>保持している値<code>Box</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This <code>Box</code> points to a new instance of the <code>Draft</code> struct.</span>この<code>Box</code>は<code>Draft</code>構造体の新しいインスタンスを指し示します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This ensures whenever we create a new instance of <code>Post</code> , it will start out as a draft.</span>これにより、 <code>Post</code>新しいインスタンスを作成するたびに、ドラフトとして開始されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because the <code>state</code> field of <code>Post</code> is private, there is no way to create a <code>Post</code> in any other state!</span> <code>Post</code>の<code>state</code>フィールドはプライベートなので、他の状態で<code>Post</code>を作成する方法はありません！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In the <code>Post::new</code> function, we set the <code>content</code> field to a new, empty <code>String</code> .</span> <code>Post::new</code>関数では、 <code>content</code>フィールドを新しい空の<code>String</code>ます。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Storing the Text of the Post Content</span>投稿コンテンツのテキストの保存</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 17-11 showed that we want to be able to call a method named <code>add_text</code> and pass it a <code>&amp;str</code> that is then added to the text content of the blog post.</span>リスト17-11は、 <code>add_text</code>という名前の<code>add_text</code>を呼び出して、 <code>&amp;str</code>を渡してブログ記事のテキストコンテンツに追加したいということを示しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We implement this as a method rather than exposing the <code>content</code> field as <code>pub</code> .</span>これをメソッドとして実装します。これは、 <code>content</code>フィールドを<code>pub</code>として公開するのではなく、</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This means we can implement a method later that will control how the <code>content</code> field&#39;s data is read.</span>つまり、 <code>content</code>フィールドのデータの読み込み方法を制御するメソッドを後で実装することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>add_text</code> method is pretty straightforward, so let&#39;s add the implementation in Listing 17-13 to the <code>impl Post</code> block:</span> <code>add_text</code>メソッドはかなり簡単ですので、リスト17-13の実装を<code>impl Post</code>ブロックに追加しましょう：</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/lib.rs</span></span> <span class=filename>ファイル名：src / lib.rs</span></span> </p><br><div data-lang=rust><div data-l="# pub struct Post {"></div><div data-l="#     content: String,"></div><div data-l="# }"></div><div data-l=#></div><div data-l="impl Post {"></div><div data-l="#    // --snip--"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">--snip--</span> --snip--</span> </div><div data-l="    pub fn add_text(&amp;mut self, text: &amp;str) {"></div><div data-l="        self.content.push_str(text);"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 17-13: Implementing the <code>add_text</code> method to add text to a post&#39;s <code>content</code></span></span> <span class=caption>リスト17-13：投稿の<code>content</code>テキストを追加する<code>add_text</code>実装</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>add_text</code> method takes a mutable reference to <code>self</code> , because we&#39;re changing the <code>Post</code> instance that we&#39;re calling <code>add_text</code> on.</span>私たちが<code>add_text</code>を呼び出す<code>Post</code>インスタンスを変更しているため、 <code>add_text</code>メソッドは<code>self</code>への変更可能な参照を取ります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We then call <code>push_str</code> on the <code>String</code> in <code>content</code> and pass the <code>text</code> argument to add to the saved <code>content</code> .</span>次に、 <code>content</code>内の<code>String</code> <code>push_str</code>を呼び出し、 <code>text</code>引数を渡して、保存された<code>content</code>に追加し<code>content</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This behavior doesn&#39;t depend on the state the post is in, so it&#39;s not part of the state pattern.</span>この動作は、投稿が入っている状態に依存しないため、状態パターンの一部ではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>add_text</code> method doesn&#39;t interact with the <code>state</code> field at all, but it is part of the behavior we want to support.</span> <code>add_text</code>メソッドは<code>state</code>フィールドと全くやり取りし<code>add_text</code>が、サポートしたい動作の一部です。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Ensuring the Content of a Draft Post Is Empty</span>ドラフト投稿の内容が空であることを確認する</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Even after we&#39;ve called <code>add_text</code> and added some content to our post, we still want the <code>content</code> method to return an empty string slice because the post is still in the draft state, as shown on line 8 of Listing 17-11.</span>私たちが呼ばれてきた後でも<code>add_text</code>と私たちの記事にいくつかのコンテンツを追加して、我々はまだしたい<code>content</code>リスト17-11の8行目に示すように、ポストは、ドラフト状態のままであるため、空の文字列のスライスを返すようにする方法を。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For now, let&#39;s implement the <code>content</code> method with the simplest thing that will fulfill this requirement: always returning an empty string slice.</span>ここでは、 <code>content</code>メソッドを、この要件を満たす最も簡単なもので実装しましょう：常に空の文字列スライスを返します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll change this later once we implement the ability to change a post&#39;s state so it can be published.</span>投稿の状態を変更して公開できるようにしたら、これを後で変更します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So far, posts can only be in the draft state, so the post content should always be empty.</span>これまでの投稿は下書きの状態にしかないので、投稿の内容は常に空でなければなりません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 17-14 shows this placeholder implementation:</span>リスト17-14は、このプレースホルダの実装を示しています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/lib.rs</span></span> <span class=filename>ファイル名：src / lib.rs</span></span> </p><br><div data-lang=rust><div data-l="# pub struct Post {"></div><div data-l="#     content: String,"></div><div data-l="# }"></div><div data-l=#></div><div data-l="impl Post {"></div><div data-l="#    // --snip--"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">--snip--</span> --snip--</span> </div><div data-l="    pub fn content(&amp;self) -&gt; &amp;str {"></div><div data-l="        &quot;&quot;"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 17-14: Adding a placeholder implementation for the <code>content</code> method on <code>Post</code> that always returns an empty string slice</span></span> <span class=caption>リスト17-14： <code>Post</code>の<code>content</code>メソッドのプレースホルダ実装を追加すると、常に空の文字列スライスが返されます</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">With this added <code>content</code> method, everything in Listing 17-11 up to line 8 works as intended.</span>この<code>content</code>メソッドを追加すると、リスト17-11の8行目までのすべてが意図した通りに機能します。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Requesting a Review of the Post Changes Its State</span>投稿の審査を要求するとその状態が変わる</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Next, we need to add functionality to request a review of a post, which should change its state from <code>Draft</code> to <code>PendingReview</code> .</span>次に、ポストのレビューをリクエストするための機能を追加する必要があります。ポストの状態を<code>Draft</code>から<code>PendingReview</code>変更する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 17-15 shows this code:</span>リスト17-15にこのコードを示します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/lib.rs</span></span> <span class=filename>ファイル名：src / lib.rs</span></span> </p><br><div data-lang=rust><div data-l="# pub struct Post {"></div><div data-l="#     state: Option&lt;Box&lt;State&gt;&gt;,"></div><div data-l="#     content: String,"></div><div data-l="# }"></div><div data-l=#></div><div data-l="impl Post {"></div><div data-l="#    // --snip--"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">--snip--</span> --snip--</span> </div><div data-l="    pub fn request_review(&amp;mut self) {"></div><div data-l="        if let Some(s) = self.state.take() {"></div><div data-l="            self.state = Some(s.request_review())"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="trait State {"></div><div data-l="    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt;;"></div><div data-l=}></div><div data-l=""></div><div data-l="struct Draft {}"></div><div data-l=""></div><div data-l="impl State for Draft {"></div><div data-l="    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt; {"></div><div data-l="        Box::new(PendingReview {})"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="struct PendingReview {}"></div><div data-l=""></div><div data-l="impl State for PendingReview {"></div><div data-l="    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt; {"></div><div data-l="        self"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 17-15: Implementing <code>request_review</code> methods on <code>Post</code> and the <code>State</code> trait</span></span> <span class=caption>リスト17-15： <code>Post</code>と<code>State</code>特性に対する<code>request_review</code>メソッドの実装</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We give <code>Post</code> a public method named <code>request_review</code> that will take a mutable reference to <code>self</code> .</span>私たちは<code>Post</code> <code>request_review</code>というパブリックメソッドを与えます。パブリックメソッドは<code>self</code>への参照を変更します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then we call an internal <code>request_review</code> method on the current state of <code>Post</code> , and this second <code>request_review</code> method consumes the current state and returns a new state.</span>次に、 <code>Post</code>の現在の状態について内部<code>request_review</code>メソッドを呼び出します。この2番目の<code>request_review</code>メソッドは現在の状態を消費し、新しい状態を返します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ve added the <code>request_review</code> method to the <code>State</code> trait;</span> <code>State</code>特性に<code>request_review</code>メソッドを追加しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">all types that implement the trait will now need to implement the <code>request_review</code> method.</span>特性を実装するすべての型は、 <code>request_review</code>メソッドを実装する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that rather than having <code>self</code> , <code>&amp;self</code> , or <code>&amp;mut self</code> as the first parameter of the method, we have <code>self: Box&lt;Self&gt;</code> .</span>メソッドの最初のパラメータとして<code>self</code> 、 <code>&amp;self</code> 、または<code>&amp;mut self</code>を持つのではなく、 <code>self: Box&lt;Self&gt;</code>を持つことに注意してください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This syntax means the method is only valid when called on a <code>Box</code> holding the type.</span>この構文は、その型を保持する<code>Box</code>上で呼び出されたときにのみメソッドが有効であることを意味します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This syntax takes ownership of <code>Box&lt;Self&gt;</code> , invalidating the old state so the state value of the <code>Post</code> can transform into a new state.</span>この構文は、 <code>Box&lt;Self&gt;</code>所有権を取り、古い状態を無効にして、 <code>Post</code>状態値が新しい状態に変換できるようにします。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To consume the old state, the <code>request_review</code> method needs to take ownership of the state value.</span>古い状態を消費するには、 <code>request_review</code>メソッドが状態値の所有権を取得する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is where the <code>Option</code> in the <code>state</code> field of <code>Post</code> comes in: we call the <code>take</code> method to take the <code>Some</code> value out of the <code>state</code> field and leave a <code>None</code> in its place, because Rust doesn&#39;t let us have unpopulated fields in structs.</span>これはどこにある<code>Option</code>で<code>state</code>のフィールド<code>Post</code>に来る：私たちは呼んで<code>take</code>取る方法を<code>Some</code>の外の値を<code>state</code>フィールドと残さない<code>None</code>錆は私たちが構造体で未実装のフィールドを持って聞かせていないため、その場所に。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This lets us move the <code>state</code> value out of <code>Post</code> rather than borrowing it.</span>これにより、 <code>state</code>値を借用するのではなく、 <code>Post</code>から移動することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then we&#39;ll set the post&#39;s <code>state</code> value to the result of this operation.</span>次に、この操作の結果にポストの<code>state</code>値を設定します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We need to set <code>state</code> to <code>None</code> temporarily rather than setting it directly with code like <code>self.state = self.state.request_review();</code></span> <code>self.state = self.state.request_review();</code>ようなコードで直接設定するのではなく、 <code>state</code>を<code>None</code>一時的に設定する必要があり<code>self.state = self.state.request_review();</code></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">to get ownership of the <code>state</code> value.</span> <code>state</code>値の所有権を取得する。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This ensures <code>Post</code> can&#39;t use the old <code>state</code> value after we&#39;ve transformed it into a new state.</span>これにより、 <code>Post</code>は新しい状態に変換した後に古い<code>state</code>値を使用できなくなります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>request_review</code> method on <code>Draft</code> needs to return a new, boxed instance of a new <code>PendingReview</code> struct, which represents the state when a post is waiting for a review.</span> <code>Draft</code>の<code>request_review</code>メソッドは、新しい<code>PendingReview</code>構造体の新しいボックス化されたインスタンスを返す必要があります。これは、投稿がレビューを待っているときの状態を表します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>PendingReview</code> struct also implements the <code>request_review</code> method but doesn&#39;t do any transformations.</span> <code>PendingReview</code>構造体も<code>request_review</code>メソッドを実装し<code>request_review</code>が、変換は一切行いません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rather, it returns itself, because when we request a review on a post already in the <code>PendingReview</code> state, it should stay in the <code>PendingReview</code> state.</span>我々はすでにポストに審査を要求したときのでむしろ、それは、自分自身を返し<code>PendingReview</code>状態、それが中にとどまるべき<code>PendingReview</code>状態。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now we can start seeing the advantages of the state pattern: the <code>request_review</code> method on <code>Post</code> is the same no matter its <code>state</code> value.</span>今、私たちは状態パターンの利点を見始めることができます。 <code>request_review</code>上のメソッド<code>Post</code>関係なく、その同じではない<code>state</code>値です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Each state is responsible for its own rules.</span>各州はそれぞれ独自のルールを担当しています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll leave the <code>content</code> method on <code>Post</code> as is, returning an empty string slice.</span> <code>content</code>メソッドを<code>Post</code>ままにして、空の文字列スライスを返します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can now have a <code>Post</code> in the <code>PendingReview</code> state as well as in the <code>Draft</code> state, but we want the same behavior in the <code>PendingReview</code> state.</span>私たちは、今持っていることができます<code>Post</code>に<code>PendingReview</code>状態などで<code>Draft</code>状態が、我々は中に同じ動作たい<code>PendingReview</code>状態を。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 17-11 now works up to line 11!</span>リスト17-11は現在11行目まで動作します！</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Adding the <code>approve</code> Method that Changes the Behavior of <code>content</code></span> <code>content</code>の動作を変更<code>approve</code>メソッドの追加</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>approve</code> method will be similar to the <code>request_review</code> method: it will set <code>state</code> to the value that the current state says it should have when that state is approved, as shown in Listing 17-16:</span> <code>approve</code>メソッドは<code>request_review</code>メソッドに似てい<code>request_review</code> ：リスト17-16に示すように、現在の状態がその状態が承認されたときに持つべき値を<code>state</code>に設定します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/lib.rs</span></span> <span class=filename>ファイル名：src / lib.rs</span></span> </p><br><div data-lang=rust><div data-l="# pub struct Post {"></div><div data-l="#     state: Option&lt;Box&lt;State&gt;&gt;,"></div><div data-l="#     content: String,"></div><div data-l="# }"></div><div data-l=#></div><div data-l="impl Post {"></div><div data-l="#    // --snip--"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">--snip--</span> --snip--</span> </div><div data-l="    pub fn approve(&amp;mut self) {"></div><div data-l="        if let Some(s) = self.state.take() {"></div><div data-l="            self.state = Some(s.approve())"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="trait State {"></div><div data-l="    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt;;"></div><div data-l="    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt;;"></div><div data-l=}></div><div data-l=""></div><div data-l="struct Draft {}"></div><div data-l=""></div><div data-l="impl State for Draft {"></div><div data-l="#     fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt; {"></div><div data-l="#         Box::new(PendingReview {})"></div><div data-l="#     }"></div><div data-l=#></div><div data-l="#    // --snip--"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">--snip--</span> --snip--</span> </div><div data-l="    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt; {"></div><div data-l="        self"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="struct PendingReview {}"></div><div data-l=""></div><div data-l="impl State for PendingReview {"></div><div data-l="#     fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt; {"></div><div data-l="#         self"></div><div data-l="#     }"></div><div data-l=#></div><div data-l="#    // --snip--"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">--snip--</span> --snip--</span> </div><div data-l="    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt; {"></div><div data-l="        Box::new(Published {})"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="struct Published {}"></div><div data-l=""></div><div data-l="impl State for Published {"></div><div data-l="    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt; {"></div><div data-l="        self"></div><div data-l="    }"></div><div data-l=""></div><div data-l="    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;State&gt; {"></div><div data-l="        self"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 17-16: Implementing the <code>approve</code> method on <code>Post</code> and the <code>State</code> trait</span></span> <span class=caption>リスト17-16： <code>Post</code>と<code>State</code>特性に対する<code>approve</code>メソッドの実装</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We add the <code>approve</code> method to the <code>State</code> trait and add a new struct that implements <code>State</code> , the <code>Published</code> state.</span>私たちは、追加<code>approve</code>にメソッドを<code>State</code>特性と実装する新しい構造体追加<code>State</code> 、 <code>Published</code>状態を。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Similar to <code>request_review</code> , if we call the <code>approve</code> method on a <code>Draft</code> , it will have no effect because it will return <code>self</code> .</span> <code>request_review</code>と同様に、 <code>Draft</code>で<code>approve</code>メソッドを呼び出すと、 <code>self</code>を返すため、何も効果がありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When we call <code>approve</code> on <code>PendingReview</code> , it returns a new, boxed instance of the <code>Published</code> struct.</span>私たちが呼び出すと<code>approve</code>に<code>PendingReview</code> 、それは新しい、箱入りインスタンスを返し<code>Published</code>構造体を。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Published</code> struct implements the <code>State</code> trait, and for both the <code>request_review</code> method and the <code>approve</code> method, it returns itself, because the post should stay in the <code>Published</code> state in those cases.</span> <code>Published</code>構造体は<code>State</code>特性を実装し、 <code>request_review</code>メソッドと<code>approve</code>メソッドの両方で、ポストはそのような場合に<code>Published</code>状態を維持する必要があるため、自身を返します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now we need to update the <code>content</code> method on <code>Post</code> : if the state is <code>Published</code> , we want to return the value in the post&#39;s <code>content</code> field;</span>ここで、 <code>Post</code>の<code>content</code>メソッドを更新する必要があります。状態が<code>Published</code>の場合は、投稿の<code>content</code>フィールドに値を返します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">otherwise, we want to return an empty string slice, as shown in Listing 17-17:</span>それ以外の場合は、リスト17-17に示すように空の文字列スライスを返します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/lib.rs</span></span> <span class=filename>ファイル名：src / lib.rs</span></span> </p><br><div data-lang=rust><div data-l="# trait State {"></div><div data-l="#     fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str;"></div><div data-l="# }"></div><div data-l="# pub struct Post {"></div><div data-l="#     state: Option&lt;Box&lt;State&gt;&gt;,"></div><div data-l="#     content: String,"></div><div data-l="# }"></div><div data-l=#></div><div data-l="impl Post {"></div><div data-l="#    // --snip--"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">--snip--</span> --snip--</span> </div><div data-l="    pub fn content(&amp;self) -&gt; &amp;str {"></div><div data-l="        self.state.as_ref().unwrap().content(&amp;self)"></div><div data-l="    }"></div><div data-l="#    // --snip--"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">--snip--</span> --snip--</span> </div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 17-17: Updating the <code>content</code> method on <code>Post</code> to delegate to a <code>content</code> method on <code>State</code></span></span> <span class=caption>リスト17-17：更新<code>content</code>にメソッドを<code>Post</code>に委任する<code>content</code>のメソッド<code>State</code></span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because the goal is to keep all these rules inside the structs that implement <code>State</code> , we call a <code>content</code> method on the value in <code>state</code> and pass the post instance (that is, <code>self</code> ) as an argument.</span>目的は<code>State</code>を実装する構造体の中にこれらのルールをすべて保持することですので、 <code>state</code>の値に対して<code>content</code>メソッドを呼び出し、ポストインスタンス（つまり<code>self</code> ）を引数として渡します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then we return the value that is returned from using the <code>content</code> method on the <code>state</code> value.</span>次に、 <code>content</code>メソッドを使って返された値を<code>state</code>値に返します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We call the <code>as_ref</code> method on the <code>Option</code> because we want a reference to the value inside the <code>Option</code> rather than ownership of the value.</span> <code>Option</code> <code>as_ref</code>メソッドは、値の所有権ではなく、 <code>Option</code>中の値への参照を必要とするため、 <code>Option</code>呼び出しを行います。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because <code>state</code> is an <code>Option&lt;Box&lt;State&gt;&gt;</code> , when we call <code>as_ref</code> , an <code>Option&lt;&amp;Box&lt;State&gt;&gt;</code> is returned.</span> <code>state</code>は<code>Option&lt;Box&lt;State&gt;&gt;</code> <code>as_ref</code> 、 <code>as_ref</code>を呼び出すと、 <code>Option&lt;&amp;Box&lt;State&gt;&gt;</code>が返されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we didn&#39;t call <code>as_ref</code> , we would get an error because we can&#39;t move <code>state</code> out of the borrowed <code>&amp;self</code> of the function parameter.</span> <code>as_ref</code>を呼び出さなかった場合、関数パラメータの借用された<code>&amp;self</code>から<code>state</code>移動できないため、エラーが発生します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We then call the <code>unwrap</code> method, which we know will never panic, because we know the methods on <code>Post</code> ensure that <code>state</code> will always contain a <code>Some</code> value when those methods are done.</span> <code>Post</code>のメソッドが<code>state</code>が常にそれらのメソッドが完了したときに<code>Some</code>値を含むことを保証していることを知っているので、私たちは<code>unwrap</code>メソッドを呼び出します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is one of the cases we talked about in the “Cases When You Have More Information Than the Compiler” section of Chapter 9 when we know that a <code>None</code> value is never possible, even though the compiler isn&#39;t able to understand that.</span>これは、たとえコンパイラがそれを理解できないとしても、 <code>None</code>値が決して不可能であることがわかっているときに、第9章の「コンパイラより多くの情報がある場合のケース」のセクションで述べたケースの1つです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">At this point, when we call <code>content</code> on the <code>&amp;Box&lt;State&gt;</code> , deref coercion will take effect on the <code>&amp;</code> and the <code>Box</code> so the <code>content</code> method will ultimately be called on the type that implements the <code>State</code> trait.</span>この時点で、私たちが呼ぶとき<code>content</code>の<code>&amp;Box&lt;State&gt;</code> 、DEREF強制は上有効になります<code>&amp;</code>および<code>Box</code>ので、 <code>content</code>方法は、最終的に実装する型で呼び出される<code>State</code>形質を。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That means we need to add <code>content</code> to the <code>State</code> trait definition, and that is where we&#39;ll put the logic for what content to return depending on which state we have, as shown in Listing 17-18:</span>これは、 <code>State</code>特性定義に<code>content</code>を追加する必要があることを意味します。リスト17-18に示すように、状態に応じてコンテンツを返すロジックを配置します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/lib.rs</span></span> <span class=filename>ファイル名：src / lib.rs</span></span> </p><br><div data-lang=rust><div data-l="# pub struct Post {"></div><div data-l="#     content: String"></div><div data-l="# }"></div><div data-l="trait State {"></div><div data-l="#    // --snip--"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">--snip--</span> --snip--</span> </div><div data-l="    fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str {"></div><div data-l="        &quot;&quot;"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="#// --snip--"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">--snip--</span> --snip--</span> </div><div data-l="struct Published {}"></div><div data-l=""></div><div data-l="impl State for Published {"></div><div data-l="#    // --snip--"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">--snip--</span> --snip--</span> </div><div data-l="    fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str {"></div><div data-l="        &amp;post.content"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 17-18: Adding the <code>content</code> method to the <code>State</code> trait</span></span> <span class=caption>リスト17-18： <code>State</code>メソッドへの<code>content</code>メソッドの追加</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We add a default implementation for the <code>content</code> method that returns an empty string slice.</span>空の文字列スライスを返す<code>content</code>メソッドの既定の実装を追加します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That means we don&#39;t need to implement <code>content</code> on the <code>Draft</code> and <code>PendingReview</code> structs.</span>つまり、 <code>Draft</code>および<code>PendingReview</code>構造体に<code>content</code>を実装<code>content</code>必要はありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Published</code> struct will override the <code>content</code> method and return the value in <code>post.content</code> .</span> <code>Published</code>構造体は<code>content</code>メソッドをオーバーライドし、 <code>post.content</code>の値を<code>post.content</code>ます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that we need lifetime annotations on this method, as we discussed in Chapter 10. We&#39;re taking a reference to a <code>post</code> as an argument and returning a reference to part of that <code>post</code> , so the lifetime of the returned reference is related to the lifetime of the <code>post</code> argument.</span>第10章で説明したように、このメソッドでは生涯アノテーションが必要であることに注意してください。引数として<code>post</code>を参照し、その<code>post</code>一部への参照を返すので、返されるリファレンスの存続期間は<code>post</code>議論の生涯。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">And we&#39;re done—all of Listing 17-11 now works!</span>これで完了です。リスト17-11のすべてが現在機能しています！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ve implemented the state pattern with the rules of the blog post workflow.</span>私たちは、ブログポストワークフローのルールで州のパターンを実装しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The logic related to the rules lives in the state objects rather than being scattered throughout <code>Post</code> .</span>ルールに関連するロジックは、 <code>Post</code>全体に散在するのではなく、状態オブジェクトに存在します。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Trade-offs of the State Pattern</span>状態パターンのトレードオフ</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ve shown that Rust is capable of implementing the object-oriented state pattern to encapsulate the different kinds of behavior a post should have in each state.</span> Rustは、オブジェクト指向の状態パターンを実装して、各状態で投稿が持つべきさまざまな種類の動作をカプセル化できることを示しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The methods on <code>Post</code> know nothing about the various behaviors.</span> <code>Post</code>のメソッドは、さまざまな動作について何も知らない。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The way we organized the code, we have to look in only one place to know the different ways a published post can behave: the implementation of the <code>State</code> trait on the <code>Published</code> struct.</span>実装：私たちは、コードを整理方法は、我々は公表ポストが振る舞うことができるさまざまな方法を知るための唯一の場所で見ている<code>State</code>での特性<code>Published</code>構造体を。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we were to create an alternative implementation that didn&#39;t use the state pattern, we might instead use <code>match</code> expressions in the methods on <code>Post</code> or even in the <code>main</code> code that checks the state of the post and changes behavior in those places.</span>状態パターンを使用しない代替実装を作成する場合は、 <code>Post</code>のメソッドで<code>match</code>式を使用するか、 <code>main</code>コード内で<code>match</code>式を使用して、ポストの状態をチェックし、それらの場所の動作を変更することがあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That would mean we would have to look in several places to understand all the implications of a post being in the published state!</span>それは、出版された州での投稿の意味を理解するためには、いくつかの場所を見る必要があるということです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This would only increase the more states we added: each of those <code>match</code> expressions would need another arm.</span>これにより、追加した状態が増えるだけです。それぞれの<code>match</code>式に別の腕が必要です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">With the state pattern, the <code>Post</code> methods and the places we use <code>Post</code> don&#39;t need <code>match</code> expressions, and to add a new state, we would only need to add a new struct and implement the trait methods on that one struct.</span>状態パターンでは、 <code>Post</code>メソッドと<code>Post</code>が使用する場所は<code>match</code>式を必要<code>match</code>せず、新しい状態を追加するために、新しい構造体を追加し、その構造体にtraitメソッドを実装するだけで済みます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The implementation using the state pattern is easy to extend to add more functionality.</span>状態パターンを使用した実装は、機能を追加するために拡張が容易です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To see the simplicity of maintaining code that uses the state pattern, try a few of these suggestions:</span>状態パターンを使用するコードのメンテナンスの簡素化を確認するには、次のようないくつかの提案を試してください。</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Add a <code>reject</code> method that changes the post&#39;s state from <code>PendingReview</code> back to <code>Draft</code> .</span>投稿の状態を<code>PendingReview</code>から<code>Draft</code>戻す<code>reject</code>メソッドを追加します。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Require two calls to <code>approve</code> before the state can be changed to <code>Published</code> .</span>状態を[ <code>Published</code>に変更<code>approve</code>には、 <code>approve</code>するために2回の呼び出しが必要です。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Allow users to add text content only when a post is in the <code>Draft</code> state.</span>投稿が<code>Draft</code>状態の場合にのみ、テキストコンテンツを追加できるようにします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Hint: have the state object responsible for what might change about the content but not responsible for modifying the <code>Post</code> .</span>ヒント：状態オブジェクトはコンテンツについて何が変わる可能性があるのか​​責任を負いませんが、 <code>Post</code>を変更する責任はありません。</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">One downside of the state pattern is that, because the states implement the transitions between states, some of the states are coupled to each other.</span>状態パターンの1つの欠点は、状態が状態間の遷移を実装するので、状態のいくつかは互いに結合されることである。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we add another state between <code>PendingReview</code> and <code>Published</code> , such as <code>Scheduled</code> , we would have to change the code in <code>PendingReview</code> to transition to <code>Scheduled</code> instead.</span>我々は間、別の状態を追加する場合<code>PendingReview</code>や<code>Published</code>など、 <code>Scheduled</code> 、我々は中にコードを変更する必要があります<code>PendingReview</code>への移行を<code>Scheduled</code>代わりに。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It would be less work if <code>PendingReview</code> didn&#39;t need to change with the addition of a new state, but that would mean switching to another design pattern.</span> <code>PendingReview</code>が新しい状態の追加で変更する必要はないが、それは別の設計パターンに切り替えることを意味する。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Another downside is that we&#39;ve duplicated some logic.</span>もう一つの欠点は、我々がいくつかのロジックを複製したことです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To eliminate some of the duplication, we might try to make default implementations for the <code>request_review</code> and <code>approve</code> methods on the <code>State</code> trait that return <code>self</code> ;</span>重複のいくつかを排除するために、 <code>request_review</code>デフォルトの実装を行い、 <code>self</code>を返す<code>State</code>メソッドを<code>approve</code>しようとします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">however, this would violate object safety, because the trait doesn&#39;t know what the concrete <code>self</code> will be exactly.</span>しかし、これは、オブジェクトの安全性に違反します。なぜなら、その特性は、具体的な<code>self</code>が正確に何であるかを知らないからです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We want to be able to use <code>State</code> as a trait object, so we need its methods to be object safe.</span> <code>State</code>を特性オブジェクトとして使用できるようにするためには、そのメソッドがオブジェクトセーフである必要があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Other duplication includes the similar implementations of the <code>request_review</code> and <code>approve</code> methods on <code>Post</code> .</span>他の複製には、 <code>Post</code> <code>request_review</code>メソッドと<code>approve</code>メソッドの同様の実装が含まれます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Both methods delegate to the implementation of the same method on the value in the <code>state</code> field of <code>Option</code> and set the new value of the <code>state</code> field to the result.</span>両方の方法は、の値に同じメソッドの実装に委任<code>state</code>のフィールド<code>Option</code>との新たな値に設定<code>state</code>結果にフィールドを。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we had a lot of methods on <code>Post</code> that followed this pattern, we might consider defining a macro to eliminate the repetition (see Appendix D for more on macros).</span> <code>Post</code>でこのパターンに従ったメソッドがたくさんある場合は、マクロを定義してその繰り返しを排除することを検討することもできます（マクロの詳細は付録Dを参照してください）。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">By implementing the state pattern exactly as it&#39;s defined for object-oriented languages, we&#39;re not taking as full advantage of Rust&#39;s strengths as we could.</span>オブジェクト指向言語用に定義されているように状態パターンを正確に実装することで、Rustの強みを十分に活用することはできません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s look at some changes we can make to the <code>blog</code> crate that can make invalid states and transitions into compile time errors.</span>無効な状態やコンパイル時のエラーへの移行を引き起こす可能性のある<code>blog</code>ボックスに加えることができるいくつかの変更を見てみましょう。</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Encoding States and Behavior as Types</span>型としての状態と振る舞いの符号化</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll show you how to rethink the state pattern to get a different set of trade-offs.</span>状態パターンを再考して、異なるトレードオフを得る方法を紹介します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rather than encapsulating the states and transitions completely so outside code has no knowledge of them, we&#39;ll encode the states into different types.</span>ステートとトランジションを完全にカプセル化するのではなく、外部のコードがそれらを認識していないので、ステートを異なるタイプにエンコードします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Consequently, Rust&#39;s type checking system will prevent attempts to use draft posts where only published posts are allowed by issuing a compiler error.</span>したがって、Rustの型チェックシステムは、コンパイルエラーを出すことによって、公開された投稿のみが許可されている下書き投稿を使用しようとする試みを防ぎます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s consider the first part of <code>main</code> in Listing 17-11:</span>リスト17-11の<code>main</code>の最初の部分について考えてみましょう。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust,ignore><div data-l="fn main() {"></div><div data-l="    let mut post = Post::new();"></div><div data-l=""></div><div data-l="    post.add_text(&quot;I ate a salad for lunch today&quot;);"></div><div data-l="    assert_eq!(&quot;&quot;, post.content());"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We still enable the creation of new posts in the draft state using <code>Post::new</code> and the ability to add text to the post&#39;s content.</span>私たちは、 <code>Post::new</code>と投稿のコンテンツにテキストを追加する機能を使用して、ドラフト状態で新しい投稿を作成できるようにします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But instead of having a <code>content</code> method on a draft post that returns an empty string, we&#39;ll make it so draft posts don&#39;t have the <code>content</code> method at all.</span>しかし、空の文字列を返すドラフトポストに<code>content</code>メソッドを持たせる代わりに、ドラフト投稿に<code>content</code>メソッドがまったくないようにします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That way, if we try to get a draft post&#39;s content, we&#39;ll get a compiler error telling us the method doesn&#39;t exist.</span>そうすれば、草稿の内容を取得しようとすると、メソッドが存在しないことを示すコンパイラエラーが発生します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As a result, it will be impossible for us to accidentally display draft post content in production, because that code won&#39;t even compile.</span>その結果、コードがコンパイルされなくなるため、偶発的に草稿コンテンツを本番で表示することは不可能になります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 17-19 shows the definition of a <code>Post</code> struct and a <code>DraftPost</code> struct, as well as methods on each:</span>リスト17-19に、 <code>Post</code>構造体と<code>DraftPost</code>構造体の定義と、それぞれのメソッドを示します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/lib.rs</span></span> <span class=filename>ファイル名：src / lib.rs</span></span> </p><br><div data-lang=rust><div data-l="pub struct Post {"></div><div data-l="    content: String,"></div><div data-l=}></div><div data-l=""></div><div data-l="pub struct DraftPost {"></div><div data-l="    content: String,"></div><div data-l=}></div><div data-l=""></div><div data-l="impl Post {"></div><div data-l="    pub fn new() -&gt; DraftPost {"></div><div data-l="        DraftPost {"></div><div data-l="            content: String::new(),"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=""></div><div data-l="    pub fn content(&amp;self) -&gt; &amp;str {"></div><div data-l="        &amp;self.content"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="impl DraftPost {"></div><div data-l="    pub fn add_text(&amp;mut self, text: &amp;str) {"></div><div data-l="        self.content.push_str(text);"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 17-19: A <code>Post</code> with a <code>content</code> method and a <code>DraftPost</code> without a <code>content</code> method</span></span> <span class=caption>リスト17-19： <code>content</code>メソッドと<code>DraftPost</code>持たず、 <code>content</code>メソッドを持たない<code>Post</code></span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Both the <code>Post</code> and <code>DraftPost</code> structs have a private <code>content</code> field that stores the blog post text.</span> <code>Post</code>および<code>DraftPost</code>構造体には、ブログ投稿テキストを格納するプライベート<code>content</code>フィールドがあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The structs no longer have the <code>state</code> field because we&#39;re moving the encoding of the state to the types of the structs.</span>構造体は、 <code>state</code>のエンコーディングを構造体の型に移しているので、もはや<code>state</code>フィールドを持ちません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Post</code> struct will represent a published post, and it has a <code>content</code> method that returns the <code>content</code> .</span> <code>Post</code>構造体には、公開の投稿を表します、そしてそれが持っている<code>content</code>を返すメソッド<code>content</code> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We still have a <code>Post::new</code> function, but instead of returning an instance of <code>Post</code> , it returns an instance of <code>DraftPost</code> .</span>我々はまだ持っている<code>Post::new</code>機能を、代わりのインスタンスを返すの<code>Post</code> 、それがのインスタンスを返し<code>DraftPost</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because <code>content</code> is private and there aren&#39;t any functions that return <code>Post</code> , it&#39;s not possible to create an instance of <code>Post</code> right now.</span> <code>content</code>はプライベートであり、 <code>Post</code>を返す関数はないので、今すぐ<code>Post</code>インスタンスを作成することはできません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>DraftPost</code> struct has an <code>add_text</code> method, so we can add text to <code>content</code> as before, but note that <code>DraftPost</code> does not have a <code>content</code> method defined!</span> <code>DraftPost</code>構造体には<code>add_text</code>メソッドがあるので、以前と同じように<code>content</code>にテキストを追加できますが、 <code>DraftPost</code>は<code>content</code>メソッドが定義されていないことに注意してください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So now the program ensures all posts start as draft posts, and draft posts don&#39;t have their content available for display.</span>今では、すべての投稿が草稿として開始され、ドラフト投稿には表示可能なコンテンツがありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Any attempt to get around these constraints will result in a compiler error.</span>これらの制約を回避しようとすると、コンパイラー・エラーが発生します。</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Implementing Transitions as Transformations into Different Types</span>異なるタイプへの変換としてのトランジションの実装</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So how do we get a published post?</span>では、どのように公開された投稿を入手するのですか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We want to enforce the rule that a draft post has to be reviewed and approved before it can be published.</span>私たちは、草案草案を公表する前にレビューと承認を行わなければならないという規則を施行したいと考えています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A post in the pending review state should still not display any content.</span>保留中のレビュー状態の投稿にはまだコンテンツが表示されません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s implement these constraints by adding another struct, <code>PendingReviewPost</code> , defining the <code>request_review</code> method on <code>DraftPost</code> to return a <code>PendingReviewPost</code> , and defining an <code>approve</code> method on <code>PendingReviewPost</code> to return a <code>Post</code> , as shown in Listing 17-20:</span>のは、別の構造体を追加することによって、これらの制約を実装してみましょう<code>PendingReviewPost</code> 、定義<code>request_review</code>上の方法を<code>DraftPost</code>返すように<code>PendingReviewPost</code> 、と定義する<code>approve</code>のメソッドを<code>PendingReviewPost</code>返すために<code>Post</code>リスト17-20で示されるように、：</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/lib.rs</span></span> <span class=filename>ファイル名：src / lib.rs</span></span> </p><br><div data-lang=rust><div data-l="# pub struct Post {"></div><div data-l="#     content: String,"></div><div data-l="# }"></div><div data-l=#></div><div data-l="# pub struct DraftPost {"></div><div data-l="#     content: String,"></div><div data-l="# }"></div><div data-l=#></div><div data-l="impl DraftPost {"></div><div data-l="#    // --snip--"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">--snip--</span> --snip--</span> </div><div data-l=""></div><div data-l="    pub fn request_review(self) -&gt; PendingReviewPost {"></div><div data-l="        PendingReviewPost {"></div><div data-l="            content: self.content,"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="pub struct PendingReviewPost {"></div><div data-l="    content: String,"></div><div data-l=}></div><div data-l=""></div><div data-l="impl PendingReviewPost {"></div><div data-l="    pub fn approve(self) -&gt; Post {"></div><div data-l="        Post {"></div><div data-l="            content: self.content,"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 17-20: A <code>PendingReviewPost</code> that gets created by calling <code>request_review</code> on <code>DraftPost</code> and an <code>approve</code> method that turns a <code>PendingReviewPost</code> into a published <code>Post</code></span></span> <span class=caption>リスト17-20： <code>PendingReviewPost</code>呼び出すことによって作成される<code>request_review</code>上<code>DraftPost</code>し、 <code>approve</code>変わる方法<code>PendingReviewPost</code>公表へ<code>Post</code></span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>request_review</code> and <code>approve</code> methods take ownership of <code>self</code> , thus consuming the <code>DraftPost</code> and <code>PendingReviewPost</code> instances and transforming them into a <code>PendingReviewPost</code> and a published <code>Post</code> , respectively.</span> <code>request_review</code>メソッドと<code>approve</code>メソッドは<code>self</code>所有権を取得し、 <code>DraftPost</code>インスタンスと<code>PendingReviewPost</code>インスタンスを消費し、それらをそれぞれ<code>PendingReviewPost</code>と公開された<code>Post</code>に変換します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This way, we won&#39;t have any lingering <code>DraftPost</code> instances after we&#39;ve called <code>request_review</code> on them, and so forth.</span>このように、私たちは<code>request_review</code>を呼び出した後に、残っている<code>DraftPost</code>インスタンスを保持しません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>PendingReviewPost</code> struct doesn&#39;t have a <code>content</code> method defined on it, so attempting to read its content results in a compiler error, as with <code>DraftPost</code> .</span> <code>PendingReviewPost</code>構造体には<code>content</code>メソッドが定義されていないため、 <code>content</code>を読み取ろうとすると、 <code>DraftPost</code>ようにコンパイラー・エラーが発生します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because the only way to get a published <code>Post</code> instance that does have a <code>content</code> method defined is to call the <code>approve</code> method on a <code>PendingReviewPost</code> , and the only way to get a <code>PendingReviewPost</code> is to call the <code>request_review</code> method on a <code>DraftPost</code> , we&#39;ve now encoded the blog post workflow into the type system.</span>公表され得る唯一の方法なので<code>Post</code>持っているインスタンス<code>content</code>定義されたメソッドを呼び出すことで<code>approve</code>の方法<code>PendingReviewPost</code> 、および取得する唯一の方法<code>PendingReviewPost</code>呼び出すことです<code>request_review</code>上の方法を<code>DraftPost</code>我々は今エンコードされてきました、ブログはタイプシステムへのワークフローをポストします。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But we also have to make some small changes to <code>main</code> .</span>しかし、我々はまた、 <code>main</code>いくつかの小さな変更を加える必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>request_review</code> and <code>approve</code> methods return new instances rather than modifying the struct they&#39;re called on, so we need to add more <code>let post =</code> shadowing assignments to save the returned instances.</span> <code>request_review</code>メソッドと<code>approve</code>メソッドは、呼び出された構造体を変更するのではなく、新しいインスタンスを返します。したがって、返されたインスタンスを保存するために、 <code>let post =</code> shadowing代入を追加する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We also can&#39;t have the assertions about the draft and pending review post&#39;s contents be empty strings, nor do we need them: we can&#39;t compile code that tries to use the content of posts in those states any longer.</span>ドラフトや保留中のレビューポストの内容が空の文字列である必要はなく、それらの状態のポストの内容を使用しようとするコードをコンパイルすることはできません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The updated code in <code>main</code> is shown in Listing 17-21:</span>リスト17-21に、 <code>main</code>の更新されたコードを示します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust,ignore><div data-l="extern crate blog;"></div><div data-l="use blog::Post;"></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let mut post = Post::new();"></div><div data-l=""></div><div data-l="    post.add_text(&quot;I ate a salad for lunch today&quot;);"></div><div data-l=""></div><div data-l="    let post = post.request_review();"></div><div data-l=""></div><div data-l="    let post = post.approve();"></div><div data-l=""></div><div data-l="    assert_eq!(&quot;I ate a salad for lunch today&quot;, post.content());"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 17-21: Modifications to <code>main</code> to use the new implementation of the blog post workflow</span></span> <span class=caption>リスト17-21：blog post workflowの新しい実装を使用する<code>main</code>への変更</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The changes we needed to make to <code>main</code> to reassign <code>post</code> mean that this implementation doesn&#39;t quite follow the object-oriented state pattern anymore: the transformations between the states are no longer encapsulated entirely within the <code>Post</code> implementation.</span> <code>post</code>を再割り当てするために<code>main</code>に変更する必要があったのは、この実装がオブジェクト指向の状態パターンに従わなくなったことです。つまり、状態間の変換は<code>Post</code>実装内に完全にカプセル化されなくなりました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, our gain is that invalid states are now impossible because of the type system and the type checking that happens at compile time!</span>しかし、私たちの利益は、型システムとコンパイル時に発生する型チェックのために無効な状態が不可能になったことです！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This ensures that certain bugs, such as display of the content of an unpublished post, will be discovered before they make it to production.</span>これにより、未発表の投稿の内容を表示するなどの特定のバグが発見されてから運用されるようになります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Try the tasks suggested for additional requirements that we mentioned at the start of this section on the <code>blog</code> crate as it is after Listing 17-20 to see what you think about the design of this version of the code.</span>私たちは、このセクションの最初に言及した追加要件のために提案されたタスク試し<code>blog</code> 、それはあなたがこのコードのバージョンの設計について考えるものを見るためにリスト17-20の後にあるようクレートを。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that some of the tasks might be completed already in this design.</span>この設計では、タスクのいくつかがすでに完了している可能性があることに注意してください。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ve seen that even though Rust is capable of implementing object-oriented design patterns, other patterns, such as encoding state into the type system, are also available in Rust.</span> Rustはオブジェクト指向のデザインパターンを実装することができますが、型システムに状態を​​エンコードするなどの他のパタ​​ーンもRustで利用可能です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These patterns have different trade-offs.</span>これらのパターンには異なるトレードオフがあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Although you might be very familiar with object-oriented patterns, rethinking the problem to take advantage of Rust&#39;s features can provide benefits, such as preventing some bugs at compile time.</span>オブジェクト指向のパターンに精通しているかもしれませんが、Rustの機能を利用するために問題を再考すると、コンパイル時にいくつかのバグを防ぐなどの利点があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Object-oriented patterns won&#39;t always be the best solution in Rust due to certain features, like ownership, that object-oriented languages don&#39;t have.</span>オブジェクト指向のパターンは、オブジェクト指向言語にはない所有権などの特定の機能のために、常にRustの最良の解決策ではありません。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Summary</span>概要</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">No matter whether or not you think Rust is an object-oriented language after reading this chapter, you now know that you can use trait objects to get some object-oriented features in Rust.</span>この章を読んだあと、Rustがオブジェクト指向言語であると考えるかどうかに関わらず、Rustでは特性オブジェクトを使用してオブジェクト指向の機能を利用できることが分かりました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Dynamic dispatch can give your code some flexibility in exchange for a bit of runtime performance.</span>動的ディスパッチは、少しの実行時パフォーマンスと引き換えにコードに柔軟性を与えます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can use this flexibility to implement object-oriented patterns that can help your code&#39;s maintainability.</span>この柔軟性を使用して、コードの保守性に役立つオブジェクト指向のパターンを実装できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust also has other features, like ownership, that object-oriented languages don&#39;t have.</span> Rustには、オブジェクト指向言語にはない所有権のような他の機能もあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">An object-oriented pattern won&#39;t always be the best way to take advantage of Rust&#39;s strengths, but is an available option.</span>オブジェクト指向のパターンは、Rustの強みを利用する最良の方法ではありませんが、利用可能なオプションです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Next, we&#39;ll look at patterns, which are another of Rust&#39;s features that enable lots of flexibility.</span>次に、パターンを見ていきます。パターンは、柔軟性を可能にするRustの特徴の1つです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ve looked at them briefly throughout the book but haven&#39;t seen their full capability yet.</span>私たちは本の中でそれらを簡単に見てきましたが、まだ完全な能力を見ていませんでした。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s go!</span>行こう！</span> </p><script>_addload(function(){_setupIW('com');_csi('en','ja','ch17-03-oo-design-patterns.html');});</script>