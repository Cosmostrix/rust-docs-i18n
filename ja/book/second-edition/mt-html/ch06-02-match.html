<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180709_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=ch06-02-match.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>match</code> Control Flow Operator</span> <code>match</code>コントロールフローオペレータ</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust has an extremely powerful control flow operator called <code>match</code> that allows you to compare a value against a series of patterns and then execute code based on which pattern matches.</span> Rustには非常に強力な制御フロー演算子<code>match</code>があり、一連のパターンと値を比較し、一致するパターンに基づいてコードを実行することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Patterns can be made up of literal values, variable names, wildcards, and many other things;</span>パターンは、リテラル値、変数名、ワイルドカード、その他多くのもので構成できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Chapter 18 covers all the different kinds of patterns and what they do.</span>第18章では、さまざまな種類のパターンとそのパターンについて説明します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The power of <code>match</code> comes from the expressiveness of the patterns and the fact that the compiler confirms that all possible cases are handled.</span> <code>match</code>の威力は、パターンの表現力と、可能性のあるすべてのケースが処理されていることをコンパイラーが確認したことにあります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Think of a <code>match</code> expression as being like a coin-sorting machine: coins slide down a track with variously sized holes along it, and each coin falls through the first hole it encounters that it fits into.</span> <code>match</code>式をコイン選別機のように考える：コインは、それに沿ってさまざまなサイズの穴があるトラックを滑り落ち、各コインは、適合する最初の穴に落ちます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In the same way, values go through each pattern in a <code>match</code> , and at the first pattern the value “fits,” the value falls into the associated code block to be used during execution.</span>同様に、値は<code>match</code>各パターンを通過し、最初のパターンでは値が「適合」すると、その値は実行中に使用される関連するコードブロックに分類されます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because we just mentioned coins, let&#39;s use them as an example using <code>match</code> !</span>私たちはちょうどコインについて言及したので、 <code>match</code>使用してコインを例として使用しましょう！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can write a function that can take an unknown United States coin and, in a similar way as the counting machine, determine which coin it is and return its value in cents, as shown here in Listing 6-3.</span>リスト6-3に示すように、未知の米国のコインを受け取る関数を書くことができます。これは、計数機と同様に、コインがどれであるかを判定し、その値をセントで返すことができます。</span> </p><br><div data-lang=rust><div data-l="enum Coin {"></div><div data-l="    Penny,"></div><div data-l="    Nickel,"></div><div data-l="    Dime,"></div><div data-l="    Quarter,"></div><div data-l=}></div><div data-l=""></div><div data-l="fn value_in_cents(coin: Coin) -&gt; u32 {"></div><div data-l="    match coin {"></div><div data-l="        Coin::Penny =&gt; 1,"></div><div data-l="        Coin::Nickel =&gt; 5,"></div><div data-l="        Coin::Dime =&gt; 10,"></div><div data-l="        Coin::Quarter =&gt; 25,"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 6-3: An enum and a <code>match</code> expression that has the variants of the enum as its patterns</span></span> <span class=caption>リスト6-3：列挙型とそのパターンとしての列挙型の変形を持つ<code>match</code>式</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s break down the <code>match</code> in the <code>value_in_cents</code> function.</span> <code>value_in_cents</code>関数の<code>match</code>を分解してみましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">First, we list the <code>match</code> keyword followed by an expression, which in this case is the value <code>coin</code> .</span>まず、 <code>match</code>キーワードの後に​​式を指定します。この場合、値は<code>coin</code>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This seems very similar to an expression used with <code>if</code> , but there&#39;s a big difference: with <code>if</code> , the expression needs to return a Boolean value, but here, it can be any type.</span>これはで使用される式に非常に似ているようだ<code>if</code> 、しかし、大きな違いがあります：で<code>if</code> 、式はブール値を返す必要がありますが、ここでは、それがどのタイプにすることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The type of <code>coin</code> in this example is the <code>Coin</code> enum that we defined on line 1.</span>この例の<code>coin</code>のタイプは、1行目で定義した<code>Coin</code>列挙型です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Next are the <code>match</code> arms.</span>次は<code>match</code>アームです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">An arm has two parts: a pattern and some code.</span>アームにはパターンとコードの2つの部分があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The first arm here has a pattern that is the value <code>Coin::Penny</code> and then the <code>=&gt;</code> operator that separates the pattern and the code to run.</span>最初の腕には、値<code>Coin::Penny</code>のパターンがあり、パターンと実行するコードを分ける<code>=&gt;</code>演算子があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The code in this case is just the value <code>1</code> .</span>この場合のコードは値<code>1</code>すぎません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Each arm is separated from the next with a comma.</span>各腕は次の腕とカンマで区切られています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When the <code>match</code> expression executes, it compares the resulting value against the pattern of each arm, in order.</span> <code>match</code>式が実行されると、結果の値と各アームのパターンが順番に比較されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If a pattern matches the value, the code associated with that pattern is executed.</span>パターンが値と一致する場合、そのパターンに関連付けられたコードが実行されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If that pattern doesn&#39;t match the value, execution continues to the next arm, much as in a coin-sorting machine.</span>そのパターンが値と一致しない場合、コインソーティングマシンと同様に、次のアームに実行が継続されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can have as many arms as we need: in Listing 6-3, our <code>match</code> has four arms.</span>リスト6-3では、私たちの<code>match</code>は4つの武器があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The code associated with each arm is an expression, and the resulting value of the expression in the matching arm is the value that gets returned for the entire <code>match</code> expression.</span>各腕に関連付けられたコードは式であり、一致する腕の式の結果の値は<code>match</code>式全体に対して返される値です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Curly brackets typically aren&#39;t used if the match arm code is short, as it is in Listing 6-3 where each arm just returns a value.</span>カーブブラケットは、マッチアームコードが短い場合は通常は使用されません。リスト6-3のように、各アームが値を返すだけです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you want to run multiple lines of code in a match arm, you can use curly brackets.</span>マッチアームで複数行のコードを実行する場合は、中括弧を使用できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, the following code would print “Lucky penny!” every time the method was called with a <code>Coin::Penny</code> but would still return the last value of the block, <code>1</code> :</span>たとえば、次のコードは、メソッドが<code>Coin::Penny</code>呼び出されるたびに &quot;Lucky penny！&quot;を出力しますが、ブロックの最後の値を返します（ <code>1</code> ：</span> </p><br><div data-lang=rust><div data-l="# enum Coin {"></div><div data-l="#    Penny,"></div><div data-l="#    Nickel,"></div><div data-l="#    Dime,"></div><div data-l="#    Quarter,"></div><div data-l="# }"></div><div data-l=#></div><div data-l="fn value_in_cents(coin: Coin) -&gt; u32 {"></div><div data-l="    match coin {"></div><div data-l="        Coin::Penny =&gt; {"></div><div data-l="            println!(&quot;Lucky penny!&quot;);"></div><div data-l="            1"></div><div data-l="        },"></div><div data-l="        Coin::Nickel =&gt; 5,"></div><div data-l="        Coin::Dime =&gt; 10,"></div><div data-l="        Coin::Quarter =&gt; 25,"></div><div data-l="    }"></div><div data-l=}></div></div><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Patterns that Bind to Values</span>値にバインドするパターン</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Another useful feature of match arms is that they can bind to the parts of the values that match the pattern.</span>マッチアームのもう1つの便利な機能は、パターンにマッチする値の部分にバインドできることです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is how we can extract values out of enum variants.</span>これは列挙型から値を抽出する方法です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As an example, let&#39;s change one of our enum variants to hold data inside it.</span>例として、enumバリアントの1つを内部に保持するように変更しましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">From 1999 through 2008, the United States minted quarters with different designs for each of the 50 states on one side.</span> 1999年から2008年にかけて、米国は50の州ごとに異なる設計の四半期を片面化した。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">No other coins got state designs, so only quarters have this extra value.</span>他の硬貨は国家の設計を得ていませんので、四半期にはこの特別な価値があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can add this information to our <code>enum</code> by changing the <code>Quarter</code> variant to include a <code>UsState</code> value stored inside it, which we&#39;ve done here in Listing 6-4.</span>この情報を<code>enum</code>追加するには、 <code>Quarter</code>バリアントを変更して、内部に格納された<code>UsState</code>値を<code>UsState</code>ます（リスト6-4を参照）。</span> </p><br><div data-lang=rust><div data-l="#//#[derive(Debug)] // so we can inspect the state in a minute"></div><div data-l="#[derive(Debug)] // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">so we can inspect the state in a minute</span>私たちは1分で状態を検査することができます</span> </div><div data-l="enum UsState {"></div><div data-l="    Alabama,"></div><div data-l="    Alaska,"></div><div data-l="#    // --snip--"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">--snip--</span> --snip--</span> </div><div data-l=}></div><div data-l=""></div><div data-l="enum Coin {"></div><div data-l="    Penny,"></div><div data-l="    Nickel,"></div><div data-l="    Dime,"></div><div data-l="    Quarter(UsState),"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 6-4: A <code>Coin</code> enum in which the <code>Quarter</code> variant also holds a <code>UsState</code> value</span></span> <span class=caption><code>UsState</code>リスト6-4： <code>Quarter</code>変種も<code>UsState</code>値を保持する<code>Coin</code>列挙型</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s imagine that a friend of ours is trying to collect all 50 state quarters.</span>私たちの友人が全50州の四半期を収集しようとしているとしましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">While we sort our loose change by coin type, we&#39;ll also call out the name of the state associated with each quarter so if it&#39;s one our friend doesn&#39;t have, they can add it to their collection.</span>コインタイプで緩やかな変更を並べ替える間に、各四半期に関連する州の名前も呼び出すので、友達が持っていない場合はコレクションに追加することができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In the match expression for this code, we add a variable called <code>state</code> to the pattern that matches values of the variant <code>Coin::Quarter</code> .</span>このコードの一致式では、変数<code>Coin::Quarter</code>値と一致するパターンに<code>state</code>という変数を追加します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When a <code>Coin::Quarter</code> matches, the <code>state</code> variable will bind to the value of that quarter&#39;s state.</span> <code>Coin::Quarter</code>一致すると、 <code>state</code>変数はその四半期の状態の値にバインドされます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then we can use <code>state</code> in the code for that arm, like so:</span>次に、そのようなコードの<code>state</code>で、次のように使用できます。</span> </p><br><div data-lang=rust><div data-l="# #[derive(Debug)]"></div><div data-l="# enum UsState {"></div><div data-l="#    Alabama,"></div><div data-l="#    Alaska,"></div><div data-l="# }"></div><div data-l=#></div><div data-l="# enum Coin {"></div><div data-l="#    Penny,"></div><div data-l="#    Nickel,"></div><div data-l="#    Dime,"></div><div data-l="#    Quarter(UsState),"></div><div data-l="# }"></div><div data-l=#></div><div data-l="fn value_in_cents(coin: Coin) -&gt; u32 {"></div><div data-l="    match coin {"></div><div data-l="        Coin::Penny =&gt; 1,"></div><div data-l="        Coin::Nickel =&gt; 5,"></div><div data-l="        Coin::Dime =&gt; 10,"></div><div data-l="        Coin::Quarter(state) =&gt; {"></div><div data-l="            println!(&quot;State quarter from {:?}!&quot;, state);"></div><div data-l="            25"></div><div data-l="        },"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we were to call <code>value_in_cents(Coin::Quarter(UsState::Alaska))</code> , <code>coin</code> would be <code>Coin::Quarter(UsState::Alaska)</code> .</span> <code>value_in_cents(Coin::Quarter(UsState::Alaska))</code>を呼び出す場合、 <code>coin</code>は<code>Coin::Quarter(UsState::Alaska)</code>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When we compare that value with each of the match arms, none of them match until we reach <code>Coin::Quarter(state)</code> .</span>その値を各マッチアームと比較すると、 <code>Coin::Quarter(state)</code>達するまで一致するものはありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">At that point, the binding for <code>state</code> will be the value <code>UsState::Alaska</code> .</span>その時点で、 <code>state</code>のバインディングは値<code>UsState::Alaska</code>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can then use that binding in the <code>println€</code> expression, thus getting the inner state value out of the <code>Coin</code> enum variant for <code>Quarter</code> .</span> <code>println€</code>式でそのバインディングを使うことができるので、 <code>Quarter</code> <code>Coin</code>列挙型の内部状態値が得られます。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Matching with <code>Option&lt;T&gt;</code></span> <code>Option&lt;T&gt;</code>とのマッチング</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In the previous section, we wanted to get the inner <code>T</code> value out of the <code>Some</code> case when using <code>Option&lt;T&gt;</code> ;</span>前のセクションでは、 <code>Option&lt;T&gt;</code>を使用して<code>Some</code>場合、 <code>Some</code>場合の内部<code>T</code>値を取得したいと考えました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">we can also handle <code>Option&lt;T&gt;</code> using <code>match</code> as we did with the <code>Coin</code> enum!</span>私たちは<code>Coin</code> enumで行ったように、 <code>Option&lt;T&gt;</code>を<code>match</code>扱うこともできます！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Instead of comparing coins, we&#39;ll compare the variants of <code>Option&lt;T&gt;</code> , but the way that the <code>match</code> expression works remains the same.</span>コインを比較するのではなく、 <code>Option&lt;T&gt;</code>バリエーションを比較しますが、 <code>match</code>式の動作方法は変わりません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s say we want to write a function that takes an <code>Option&lt;i32&gt;</code> and, if there&#39;s a value inside, adds 1 to that value.</span> <code>Option&lt;i32&gt;</code>をとる関数を記述したいとしましょう。内部に値がある場合はその値に1を加えます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If there isn&#39;t a value inside, the function should return the <code>None</code> value and not attempt to perform any operations.</span>内部に値がない場合、関数は<code>None</code>値を返し、何も操作を行わないようにしなければなりません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This function is very easy to write, thanks to <code>match</code> , and will look like Listing 6-5.</span>この関数は、感謝して、書くのは非常に簡単で<code>match</code> 、かつ、リスト6-5のようになります。</span> </p><br><div data-lang=rust><div data-l="fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {"></div><div data-l="    match x {"></div><div data-l="        None =&gt; None,"></div><div data-l="        Some(i) =&gt; Some(i + 1),"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="let five = Some(5);"></div><div data-l="let six = plus_one(five);"></div><div data-l="let none = plus_one(None);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 6-5: A function that uses a <code>match</code> expression on an <code>Option&lt;i32&gt;</code></span></span> <span class=caption>リスト6-5： <code>Option&lt;i32&gt;</code> <code>match</code>式を使用する関数</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s examine the first execution of <code>plus_one</code> in more detail.</span> <code>plus_one</code>の最初の実行を詳細に調べてみましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When we call <code>plus_one(five)</code> , the variable <code>x</code> in the body of <code>plus_one</code> will have the value <code>Some(5)</code> .</span> <code>plus_one(five)</code>を呼び出すと、 <code>plus_one(five)</code>本体の変数<code>x</code>に<code>Some(5)</code>という値が<code>plus_one</code>されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We then compare that against each match arm.</span>次に、それを各マッチアームと比較します。</span> </p><br><div data-lang=rust,ignore><div data-l="None =&gt; None,"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Some(5)</code> value doesn&#39;t match the pattern <code>None</code> , so we continue to the next arm.</span> <code>Some(5)</code>値がパターン<code>None</code>と一致しないので、次のアームに進みます。</span> </p><br><div data-lang=rust,ignore><div data-l="Some(i) =&gt; Some(i + 1),"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Does <code>Some(5)</code> match <code>Some(i)</code> ?</span> <code>Some(5)</code>は<code>Some(5)</code> <code>Some(i)</code>マッチしますか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Why yes it does!</span>なぜそうですか！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We have the same variant.</span>私たちは同じ変種を持っています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>i</code> binds to the value contained in <code>Some</code> , so <code>i</code> takes the value <code>5</code> .</span> <code>i</code>中に含まれる値に結合する<code>Some</code> 、そう<code>i</code>価値取る<code>5</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The code in the match arm is then executed, so we add 1 to the value of <code>i</code> and create a new <code>Some</code> value with our total <code>6</code> inside.</span>次に、マッチアームのコードが実行されるので、 <code>i</code>の値に1を加え、内部に合計<code>6</code>個の新しい<code>Some</code>値を作成します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now let&#39;s consider the second call of <code>plus_one</code> in Listing 6-5, where <code>x</code> is <code>None</code> .</span>リスト6-5の2番目の<code>plus_one</code>呼び出しを考えてみましょう。ここで<code>x</code>は<code>None</code>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We enter the <code>match</code> and compare to the first arm.</span> <code>match</code>入り、最初の腕と比較する。</span> </p><br><div data-lang=rust,ignore><div data-l="None =&gt; None,"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It matches!</span>それは一致します！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There&#39;s no value to add to, so the program stops and returns the <code>None</code> value on the right side of <code>=&gt;</code> .</span>追加する値はないので、プログラムは停止し、 <code>=&gt;</code>右側に<code>None</code>値を返します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because the first arm matched, no other arms are compared.</span>最初の腕が一致したので、他の腕は比較されません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Combining <code>match</code> and enums is useful in many situations.</span> <code>match</code>と列挙を組み合わせることは、多くの状況で役立ちます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You&#39;ll see this pattern a lot in Rust code: <code>match</code> against an enum, bind a variable to the data inside, and then execute code based on it.</span>このパターンはRustコードでよく見えます：enumとの<code>match</code> 、変数を内部のデータにバインドし、それに基づいてコードを実行します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It&#39;s a bit tricky at first, but once you get used to it, you&#39;ll wish you had it in all languages.</span>最初はややこしいですが、慣れてしまえば、すべての言語でそれを使いたいと思うでしょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It&#39;s consistently a user favorite.</span>一貫してユーザーのお気に入りです。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Matches Are Exhaustive</span>マッチは徹底的です</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There&#39;s one other aspect of <code>match</code> we need to discuss.</span>一つの他の側面があります<code>match</code> 、我々が議論する必要があるが。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Consider this version of our <code>plus_one</code> function that has a bug and won&#39;t compile:</span>バグがあり、コンパイルされない<code>plus_one</code>関数のこのバージョンを考えてみましょう：</span> </p><br><div data-lang=rust,ignore><div data-l="fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {"></div><div data-l="    match x {"></div><div data-l="        Some(i) =&gt; Some(i + 1),"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We didn&#39;t handle the <code>None</code> case, so this code will cause a bug.</span> <code>None</code>ケースは扱わなかったので、このコードはバグを引き起こします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Luckily, it&#39;s a bug Rust knows how to catch.</span>幸いにも、それはバグです.Rustはどのように捕まえるのかを知っています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we try to compile this code, we&#39;ll get this error:</span>このコードをコンパイルしようとすると、このエラーが発生します：</span> </p><br><div data-lang=text><div data-l="error[E0004]: non-exhaustive patterns: `None` not covered"></div><div data-l=" --&gt;"></div><div data-l="  |"></div><div data-l="6 |         match x {"></div><div data-l="  |               ^ pattern `None` not covered"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust knows that we didn&#39;t cover every possible case and even knows which pattern we forgot!</span>錆は、我々があらゆる可能なケースをカバーしていないことを知っていて、忘れたパターンも知っている！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Matches in Rust are <i>exhaustive</i> : we must exhaust every last possibility in order for the code to be valid.</span> Rustのマッチは<i>網羅的</i>です：コードが有効であるためには、最後のすべての可能性を排除しなければなりません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Especially in the case of <code>Option&lt;T&gt;</code> , when Rust prevents us from forgetting to explicitly handle the <code>None</code> case, it protects us from assuming that we have a value when we might have null, thus making the billion-dollar mistake discussed earlier.</span>特に<code>Option&lt;T&gt;</code>場合、Rustが<code>None</code>ケースを明示的に処理するのを忘れるのを防ぎます.Nustがあると仮定することから私たちを保護して、10億ドルの間違いを早期に解消します。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>_</code> Placeholder</span> <code>_</code>プレースホルダ</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust also has a pattern we can use when we don&#39;t want to list all possible values.</span> Rustには、すべての可能な値をリストしたくないときに使用できるパターンもあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, a <code>u8</code> can have valid values of 0 through 255. If we only care about the values 1, 3, 5, and 7, we don&#39;t want to have to list out 0, 2, 4, 6, 8, 9 all the way up to 255. Fortunately, we don&#39;t have to: we can use the special pattern <code>_</code> instead:</span>たとえば、 <code>u8</code>は0〜255の有効な値を持つことができます<code>u8</code> 、および7の値のみを<code>u8</code>場合、 <code>u8</code>かをリストする必要はありません。 9までは最大255までです。幸い、特別なパターン<code>_</code>代わりに使用する必要はありません：</span> </p><br><div data-lang=rust><div data-l="let some_u8_value = 0u8;"></div><div data-l="match some_u8_value {"></div><div data-l="    1 =&gt; println!(&quot;one&quot;),"></div><div data-l="    3 =&gt; println!(&quot;three&quot;),"></div><div data-l="    5 =&gt; println!(&quot;five&quot;),"></div><div data-l="    7 =&gt; println!(&quot;seven&quot;),"></div><div data-l="    _ =&gt; (),"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>_</code> pattern will match any value.</span> <code>_</code>パターンは任意の値と一致します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">By putting it after our other arms, the <code>_</code> will match all the possible cases that aren&#39;t specified before it.</span>他の武器の後ろに置くことで、 <code>_</code>はその前に指定されていない可能性のあるすべてのケースに一致します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>()</code> is just the unit value, so nothing will happen in the <code>_</code> case.</span> <code>()</code>は単なる単なる値なので、 <code>_</code>場合は何も起こりません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As a result, we can say that we want to do nothing for all the possible values that we don&#39;t list before the <code>_</code> placeholder.</span>その結果、 <code>_</code>プレースホルダの前にリストされていない可能性のあるすべての値に対して何もしないと言うことができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, the <code>match</code> expression can be a bit wordy in a situation in which we care about only <i>one</i> of the cases.</span>しかし、 <code>match</code>式は、ケースの<i>うちの1つ</i>だけを気にする状況では、ちょっとしたものになる可能性があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For this situation, Rust provides <code>if let</code> .</span>この状況では<code>if let</code>提供します。</span> </p><script>_addload(function(){_setupIW('com');_csi('en','ja','ch06-02-match.html');});</script>