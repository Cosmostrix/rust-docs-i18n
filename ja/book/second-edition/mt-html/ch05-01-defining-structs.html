<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180709_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=ch05-01-defining-structs.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Defining and Instantiating Structs</span>構造体の定義とインスタンス化</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Structs are similar to tuples, which were discussed in Chapter 3. Like tuples, the pieces of a struct can be different types.</span>構造体は第3章で説明したタプルに似ています。タプルのように、構造体の断片は異なる型にすることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Unlike with tuples, you&#39;ll name each piece of data so it&#39;s clear what the values mean.</span>タプルとは異なり、各データに名前を付けて、値の意味を明確にします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As a result of these names, structs are more flexible than tuples: you don&#39;t have to rely on the order of the data to specify or access the values of an instance.</span>これらの名前の結果、構造体はタプルよりも柔軟性があります。つまり、インスタンスの値を指定またはアクセスするためにデータの順序に頼る必要はありません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To define a struct, we enter the keyword <code>struct</code> and name the entire struct.</span>構造体を定義するには、キーワード<code>struct</code>を入力し、 <code>struct</code>全体の名前を付けます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A struct&#39;s name should describe the significance of the pieces of data being grouped together.</span>構造体の名前は、一緒にグループ化されるデータの重要性を記述する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then, inside curly brackets, we define the names and types of the pieces of data, which we call <i>fields</i> .</span>次に、中括弧の中に、データと呼ばれるデータの名前と型を定義し<i>ます</i> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, Listing 5-1 shows a struct that stores information about a user account.</span>たとえば、リスト5-1は、ユーザーアカウントに関する情報を格納する構造体を示しています。</span> </p><br><div data-lang=rust><div data-l="struct User {"></div><div data-l="    username: String,"></div><div data-l="    email: String,"></div><div data-l="    sign_in_count: u64,"></div><div data-l="    active: bool,"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 5-1: A <code>User</code> struct definition</span></span> <span class=caption>リスト5-1： <code>User</code>構造体の定義</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To use a struct after we&#39;ve defined it, we create an <i>instance</i> of that struct by specifying concrete values for each of the fields.</span>構造体を定義した後でそれを使用するには、各構造体の具体的な値を指定して構造体の<i>インスタンス</i>を作成し<i>ます</i> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We create an instance by stating the name of the struct and then add curly brackets containing <code>key: value</code> pairs, where the keys are the names of the fields and the values are the data we want to store in those fields.</span>構造体の名前を記述してインスタンスを作成し、 <code>key: value</code>ペアを含む中括弧を追加し<code>key: value</code>ここで、キーはフィールドの名前であり、値はこれらのフィールドに格納するデータです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We don&#39;t have to specify the fields in the same order in which we declared them in the struct.</span>構造体で宣言したのと同じ順序でフィールドを指定する必要はありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In other words, the struct definition is like a general template for the type, and instances fill in that template with particular data to create values of the type.</span>言い換えれば、構造体の定義は型の一般的なテンプレートのようであり、インスタンスは型の値を作成するための特定のデータでそのテンプレートを埋めます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, we can declare a particular user as shown in Listing 5-2.</span>たとえば、リスト5-2に示すように特定のユーザーを宣言することができます。</span> </p><br><div data-lang=rust><div data-l="# struct User {"></div><div data-l="#     username: String,"></div><div data-l="#     email: String,"></div><div data-l="#     sign_in_count: u64,"></div><div data-l="#     active: bool,"></div><div data-l="# }"></div><div data-l=#></div><div data-l="let user1 = User {"></div><div data-l="    email: String::from(&quot;someone@example.com&quot;),"></div><div data-l="    username: String::from(&quot;someusername123&quot;),"></div><div data-l="    active: true,"></div><div data-l="    sign_in_count: 1,"></div><div data-l=};></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 5-2: Creating an instance of the <code>User</code> struct</span></span> <span class=caption>リスト5-2： <code>User</code>構造体のインスタンスを作成する</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To get a specific value from a struct, we can use dot notation.</span>構造体から特定の値を取得するには、ドット表記法を使用できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we wanted just this user&#39;s email address, we could use <code>user1.email</code> wherever we wanted to use this value.</span>このユーザーの電子メールアドレスだけが必要<code>user1.email</code>場合は、この値を使用したい場所で<code>user1.email</code>を使用できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If the instance is mutable, we can change a value by using the dot notation and assigning into a particular field.</span>インスタンスが変更可能な場合は、ドット表記を使用して特定のフィールドに値を割り当てることで値を変更できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 5-3 shows how to change the value in the <code>email</code> field of a mutable <code>User</code> instance.</span>リスト5-3は、変更可能な<code>User</code>インスタンスの<code>email</code>フィールドの値を変更する方法を示しています。</span> </p><br><div data-lang=rust><div data-l="# struct User {"></div><div data-l="#     username: String,"></div><div data-l="#     email: String,"></div><div data-l="#     sign_in_count: u64,"></div><div data-l="#     active: bool,"></div><div data-l="# }"></div><div data-l=#></div><div data-l="let mut user1 = User {"></div><div data-l="    email: String::from(&quot;someone@example.com&quot;),"></div><div data-l="    username: String::from(&quot;someusername123&quot;),"></div><div data-l="    active: true,"></div><div data-l="    sign_in_count: 1,"></div><div data-l=};></div><div data-l=""></div><div data-l="user1.email = String::from(&quot;anotheremail@example.com&quot;);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 5-3: Changing the value in the <code>email</code> field of a <code>User</code> instance</span></span> <span class=caption>リスト5-3： <code>User</code>インスタンスの<code>email</code>フィールドの値を変更する</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that the entire instance must be mutable;</span>インスタンス全体は変更可能でなければならないことに注意してください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust doesn&#39;t allow us to mark only certain fields as mutable.</span>錆は、特定のフィールドだけを変更可能としてマークすることはできません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As with any expression, we can construct a new instance of the struct as the last expression in the function body to implicitly return that new instance.</span>任意の式と同様に、関数本体の最後の式として構造体の新しいインスタンスを構築して、その新しいインスタンスを暗黙的に返すことができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 5-4 shows a <code>build_user</code> function that returns a <code>User</code> instance with the given email and username.</span>リスト5-4に、指定した電子メールとユーザー名で<code>User</code>インスタンスを返す<code>build_user</code>関数を示します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>active</code> field gets the value of <code>true</code> , and the <code>sign_in_count</code> gets a value of <code>1</code> .</span> <code>active</code>フィールドは<code>true</code>の値を取得し、 <code>sign_in_count</code>は値<code>1</code>取得します。</span> </p><br><div data-lang=rust><div data-l="# struct User {"></div><div data-l="#     username: String,"></div><div data-l="#     email: String,"></div><div data-l="#     sign_in_count: u64,"></div><div data-l="#     active: bool,"></div><div data-l="# }"></div><div data-l=#></div><div data-l="fn build_user(email: String, username: String) -&gt; User {"></div><div data-l="    User {"></div><div data-l="        email: email,"></div><div data-l="        username: username,"></div><div data-l="        active: true,"></div><div data-l="        sign_in_count: 1,"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 5-4: A <code>build_user</code> function that takes an email and username and returns a <code>User</code> instance</span></span> <span class=caption>リスト5-4：電子メールとユーザー名をとり、 <code>User</code>インスタンスを返す<code>build_user</code>関数</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It makes sense to name the function parameters with the same name as the struct fields, but having to repeat the <code>email</code> and <code>username</code> field names and variables is a bit tedious.</span>構造体のフィールドと同じ名前の関数のパラメータに名前を付けるのは理にかなっていますが、 <code>email</code>と<code>username</code>フィールド名と変数を繰り返すことはやや面倒です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If the struct had more fields, repeating each name would get even more annoying.</span>構造体にさらにフィールドがある場合は、それぞれの名前を繰り返すとさらに迷惑になります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Luckily, there&#39;s a convenient shorthand!</span>幸いにも、便利な略記があります！</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Using the Field Init Shorthand when Variables and Fields Have the Same Name</span>フィールド初期化の使用変数とフィールドの名前が同じ場合の省略形</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because the parameter names and the struct field names are exactly the same in Listing 5-4, we can use the <i>field init shorthand</i> syntax to rewrite <code>build_user</code> so that it behaves exactly the same but doesn&#39;t have the repetition of <code>email</code> and <code>username</code> , as shown in Listing 5-5.</span>パラメータ名と構造体フィールド名はリスト5-4と全く同じ<code>build_user</code>ので、 <i>フィールドinitの短縮形</i>構文を使用して<code>build_user</code>を書き直して、まったく同じように動作し<code>username</code> 、 <code>email</code>と<code>username</code>繰り返しはありません。コードリスト5-5を参照してください。</span> </p><br><div data-lang=rust><div data-l="# struct User {"></div><div data-l="#     username: String,"></div><div data-l="#     email: String,"></div><div data-l="#     sign_in_count: u64,"></div><div data-l="#     active: bool,"></div><div data-l="# }"></div><div data-l=#></div><div data-l="fn build_user(email: String, username: String) -&gt; User {"></div><div data-l="    User {"></div><div data-l="        email,"></div><div data-l="        username,"></div><div data-l="        active: true,"></div><div data-l="        sign_in_count: 1,"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 5-5: A <code>build_user</code> function that uses field init shorthand because the <code>email</code> and <code>username</code> parameters have the same name as struct fields</span></span> <span class=caption>リスト5-5： <code>email</code>と<code>username</code>パラメータがstructフィールドと同じ名前を持つため、フィールドinitを簡潔に使用する<code>build_user</code>関数</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here, we&#39;re creating a new instance of the <code>User</code> struct, which has a field named <code>email</code> .</span>ここでは、 <code>email</code>という名前のフィールドを持つ<code>User</code>構造体の新しいインスタンスを作成してい<code>email</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We want to set the <code>email</code> field&#39;s value to the value in the <code>email</code> parameter of the <code>build_user</code> function.</span> <code>email</code>フィールドの値を<code>build_user</code>関数の<code>email</code>パラメータの値に設定し<code>email</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because the <code>email</code> field and the <code>email</code> parameter have the same name, we only need to write <code>email</code> rather than <code>email: email</code> .</span>そのため<code>email</code>フィールドと<code>email</code>パラメータが同じ名前を持って、我々は唯一の書く必要がある<code>email</code>するのではなく<code>email: email</code> 。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Creating Instances From Other Instances With Struct Update Syntax</span>構造体の更新構文を使用して他のインスタンスからインスタンスを作成する</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It&#39;s often useful to create a new instance of a struct that uses most of an old instance&#39;s values but changes some.</span>古いインスタンスの値の大部分を使用するが、いくつかを変更する構造体の新しいインスタンスを作成すると便利なことがよくあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You&#39;ll do this using <i>struct update syntax</i> .</span>これは<i>struct update構文</i>を使用して行い<i>ます</i> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">First, Listing 5-6 shows how we create a new <code>User</code> instance in <code>user2</code> without the update syntax.</span>まず、リスト5-6は、更新構文なしで<code>user2</code>新しい<code>User</code>インスタンスを作成する方法を示しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We set new values for <code>email</code> and <code>username</code> but otherwise use the same values from <code>user1</code> that we created in Listing 5-2.</span> <code>email</code>と<code>username</code>新しい値を設定し<code>username</code>が、リスト5-2で作成した<code>user1</code>値と同じ値を使用します。</span> </p><br><div data-lang=rust><div data-l="# struct User {"></div><div data-l="#     username: String,"></div><div data-l="#     email: String,"></div><div data-l="#     sign_in_count: u64,"></div><div data-l="#     active: bool,"></div><div data-l="# }"></div><div data-l=#></div><div data-l="# let user1 = User {"></div><div data-l="#     email: String::from(&quot;someone@example.com&quot;),"></div><div data-l="#     username: String::from(&quot;someusername123&quot;),"></div><div data-l="#     active: true,"></div><div data-l="#     sign_in_count: 1,"></div><div data-l="# };"></div><div data-l=#></div><div data-l="let user2 = User {"></div><div data-l="    email: String::from(&quot;another@example.com&quot;),"></div><div data-l="    username: String::from(&quot;anotherusername567&quot;),"></div><div data-l="    active: user1.active,"></div><div data-l="    sign_in_count: user1.sign_in_count,"></div><div data-l=};></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 5-6: Creating a new <code>User</code> instance using some of the values from <code>user1</code></span></span> <span class=caption>リスト5-6： <code>user1</code>の値のいくつかを使って新しい<code>User</code>インスタンスを作成する</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Using struct update syntax, we can achieve the same effect with less code, as shown in Listing 5-7.</span>構造体の更新構文を使用すると、リスト5-7に示すように、コードを減らして同じ効果を得ることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The syntax <code>..</code> specifies that the remaining fields not explicitly set should have the same value as the fields in the given instance.</span>構文<code>..</code>は、明示的に設定されていない残りのフィールドは、指定されたインスタンスのフィールドと同じ値を持つ必要があることを指定します。</span> </p><br><div data-lang=rust><div data-l="# struct User {"></div><div data-l="#     username: String,"></div><div data-l="#     email: String,"></div><div data-l="#     sign_in_count: u64,"></div><div data-l="#     active: bool,"></div><div data-l="# }"></div><div data-l=#></div><div data-l="# let user1 = User {"></div><div data-l="#     email: String::from(&quot;someone@example.com&quot;),"></div><div data-l="#     username: String::from(&quot;someusername123&quot;),"></div><div data-l="#     active: true,"></div><div data-l="#     sign_in_count: 1,"></div><div data-l="# };"></div><div data-l=#></div><div data-l="let user2 = User {"></div><div data-l="    email: String::from(&quot;another@example.com&quot;),"></div><div data-l="    username: String::from(&quot;anotherusername567&quot;),"></div><div data-l="    ..user1"></div><div data-l=};></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 5-7: Using struct update syntax to set new <code>email</code> and <code>username</code> values for a <code>User</code> instance but use the rest of the values from the fields of the instance in the <code>user1</code> variable</span></span> <span class=caption>コードリスト5-7： <code>User</code>インスタンスの新しい<code>email</code>と<code>username</code>値を設定するのにstruct update構文を使用しますが、 <code>user1</code>変数のインスタンスのフィールドから残りの値を使用します</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The code in Listing 5-7 also creates an instance in <code>user2</code> that has a different value for <code>email</code> and <code>username</code> but has the same values for the <code>active</code> and <code>sign_in_count</code> fields from <code>user1</code> .</span>リスト5-7のコードはまた、インスタンスを作成し<code>user2</code>ために異なる値持ち<code>email</code>と<code>username</code>しかし同じ値がある<code>active</code>と<code>sign_in_count</code>からフィールド<code>user1</code> 。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Using Tuple Structs without Named Fields to Create Different Types</span>名前付きフィールドのないタプル構造体を使用して異なる型を作成する</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can also define structs that look similar to tuples, called <i>tuple structs</i> .</span> <i>タプル構造体</i>と呼ばれる<i>タプルに</i>似た構造体を定義することもできます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Tuple structs have the added meaning the struct name provides but don&#39;t have names associated with their fields;</span>タプル構造体には、構造体名が提供する追加の意味がありますが、フィールドに関連付けられた名前はありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">rather, they just have the types of the fields.</span>むしろ、彼らはフィールドのタイプを持っています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Tuple structs are useful when you want to give the whole tuple a name and make the tuple be a different type than other tuples, and naming each field as in a regular struct would be verbose or redundant.</span>タプル構造体は、タプル全体に名前を付け、タプルを他のタプルとは異なる型にする場合や、通常の構造体のように各フィールドの名前を冗長または冗長にする場合に便利です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To define a tuple struct, start with the <code>struct</code> keyword and the struct name followed by the types in the tuple.</span>タプル構造体を定義するには、 <code>struct</code>キーワードと構造体名の後にタプルの型を続けます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, here are definitions and usages of two tuple structs named <code>Color</code> and <code>Point</code> :</span>たとえば、 <code>Color</code>と<code>Point</code>という名前の2つのタプル構造体の定義と用途を次に示します。</span> </p><br><div data-lang=rust><div data-l="struct Color(i32, i32, i32);"></div><div data-l="struct Point(i32, i32, i32);"></div><div data-l=""></div><div data-l="let black = Color(0, 0, 0);"></div><div data-l="let origin = Point(0, 0, 0);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that the <code>black</code> and <code>origin</code> values are different types, because they&#39;re instances of different tuple structs.</span> <code>black</code>と<code>origin</code>値は異なるタプル構造体のインスタンスなので、異なる型であることに注意してください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Each struct you define is its own type, even though the fields within the struct have the same types.</span>構造体内のフィールドに同じ型があっても、定義する各構造体は独自の型です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, a function that takes a parameter of type <code>Color</code> cannot take a <code>Point</code> as an argument, even though both types are made up of three <code>i32</code> values.</span>たとえば、 <code>Color</code>タイプのパラメータを受け取る関数は、両方のタイプが3つの<code>i32</code>値で構成されていても、 <code>Point</code>を引数として取ることはできません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Otherwise, tuple struct instances behave like tuples: you can destructure them into their individual pieces, you can use a <code>.</code></span>さもなければ、タプル構造体インスタンスはタプルのように振る舞います：それらを個々の部分に分解することができます<code>.</code></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">followed by the index to access an individual value, and so on.</span>その後に個別の値にアクセスするためのインデックスなどがあります。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Unit-Like Structs Without Any Fields</span>任意のフィールドを持たないユニットのような構造体</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can also define structs that don&#39;t have any fields!</span>また、フィールドを持たない構造体を定義することもできます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These are called <i>unit-like structs</i> because they behave similarly to <code>()</code> , the unit type.</span>彼らはと同様に動作するので、これらは、 <i>ユニットのような構造体</i>と呼ばれている<code>()</code>ユニットタイプ、。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Unit-like structs can be useful in situations in which you need to implement a trait on some type but don&#39;t have any data that you want to store in the type itself.</span>ユニットのような構造体は、ある型の型を実装する必要がありますが、型自体に格納するデータはありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll discuss traits in Chapter 10.</span>第10章で、形質について議論します。</span> </p><br><blockquote><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Ownership of Struct Data</span>構造データの所有権</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In the <code>User</code> struct definition in Listing 5-1, we used the owned <code>String</code> type rather than the <code>&amp;str</code> string slice type.</span>リスト5-1の<code>User</code>構造体定義では、 <code>&amp;str</code> stringスライス型ではなく、所有する<code>String</code>型を使用しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is a deliberate choice because we want instances of this struct to own all of its data and for that data to be valid for as long as the entire struct is valid.</span>この構造体のインスタンスがすべてのデータを所有し、構造体全体が有効である限り、そのデータが有効であることが望ましいため、これは意図的な選択です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It&#39;s possible for structs to store references to data owned by something else, but to do so requires the use of <i>lifetimes</i> , a Rust feature that we&#39;ll discuss in Chapter 10. Lifetimes ensure that the data referenced by a struct is valid for as long as the struct is.</span>これは、構造体は、他の何かが所有するデータへの参照を格納することは可能だが、そうすることは<i>寿命</i>の使用を必要とし、我々は第10章の有効期限に説明します錆機能は、構造体が参照するデータがある限りのために有効であることを確認してください構造体がそうであるように。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s say you try to store a reference in a struct without specifying lifetimes, like this, which won&#39;t work:</span>このように、動作しない寿命を指定せずに構造体に参照を格納しようとするとしましょう：</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust,ignore><div data-l="struct User {"></div><div data-l="    username: &amp;str,"></div><div data-l="    email: &amp;str,"></div><div data-l="    sign_in_count: u64,"></div><div data-l="    active: bool,"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let user1 = User {"></div><div data-l="        email: &quot;someone@example.com&quot;,"></div><div data-l="        username: &quot;someusername123&quot;,"></div><div data-l="        active: true,"></div><div data-l="        sign_in_count: 1,"></div><div data-l="    };"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The compiler will complain that it needs lifetime specifiers:</span>コンパイラは生涯指定子が必要であると不満を持ちます：</span> </p><br><div data-lang=text><div data-l="error[E0106]: missing lifetime specifier"></div><div data-l=" --&gt;"></div><div data-l="  |"></div><div data-l="2 |     username: &amp;str,"></div><div data-l="  |               ^ expected lifetime parameter"></div><div data-l=""></div><div data-l="error[E0106]: missing lifetime specifier"></div><div data-l=" --&gt;"></div><div data-l="  |"></div><div data-l="3 |     email: &amp;str,"></div><div data-l="  |            ^ expected lifetime parameter"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In Chapter 10, we&#39;ll discuss how to fix these errors so you can store references in structs, but for now, we&#39;ll fix errors like these using owned types like <code>String</code> instead of references like <code>&amp;str</code> .</span>第10章では、これらのエラーを修正して参照を構造体に格納する方法について説明しますが、今のところ、 <code>&amp;str</code>ような参照の代わりに<code>String</code>ような所有型を使用してエラーを修正し<code>&amp;str</code> 。</span> </p></blockquote><script>_addload(function(){_setupIW('com');_csi('en','ja','ch05-01-defining-structs.html');});</script>