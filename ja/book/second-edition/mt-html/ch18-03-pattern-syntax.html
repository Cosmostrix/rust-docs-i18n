<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180709_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=ch18-03-pattern-syntax.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Pattern Syntax</span>パターンの構文</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Throughout the book, you&#39;ve seen examples of many kinds of patterns.</span>この本を通して、あなたは多くの種類のパターンの例を見てきました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this section, we gather all the syntax valid in patterns and discuss why you might want to use each one.</span>このセクションでは、パターンで有効なすべての構文を収集し、それぞれの構文を使用する理由を説明します。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Matching Literals</span>マッチングリテラル</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As you saw in Chapter 6, you can match patterns against literals directly.</span>第6章で見たように、パターンとリテラルを直接照合することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The following code gives some examples:</span>次のコードはいくつかの例を示しています：</span> </p><br><div data-lang=rust><div data-l="let x = 1;"></div><div data-l=""></div><div data-l="match x {"></div><div data-l="    1 =&gt; println!(&quot;one&quot;),"></div><div data-l="    2 =&gt; println!(&quot;two&quot;),"></div><div data-l="    3 =&gt; println!(&quot;three&quot;),"></div><div data-l="    _ =&gt; println!(&quot;anything&quot;),"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This code prints <code>one</code> because the value in <code>x</code> is 1. This syntax is useful when you want your code to take an action if it gets a particular concrete value.</span>このコードは、 <code>x</code>の値が<code>one</code>ため<code>one</code>出力します。この構文は、特定の具体的な値を取得した場合にコードがアクションを起こさせる場合に便利です。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Matching Named Variables</span>名前付き変数のマッチング</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Named variables are irrefutable patterns that match any value, and we&#39;ve used them many times in the book.</span>名前付き変数は任意の値に一致する反駁可能なパターンであり、本で何度も使用しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, there is a complication when you use named variables in <code>match</code> expressions.</span>しかし、 <code>match</code>式で名前付き変数を使用すると、複雑になります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because <code>match</code> starts a new scope, variables declared as part of a pattern inside the <code>match</code> expression will shadow those with the same name outside the <code>match</code> construct, as is the case with all variables.</span> <code>match</code>は新しいスコープを開始するので、 <code>match</code>式の中でパターンの一部として宣言された変数は、すべての変数の場合と同様に、 <code>match</code>構造の外で同じ名前を持つ変数をシャドウします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In Listing 18-11, we declare a variable named <code>x</code> with the value <code>Some(5)</code> and a variable <code>y</code> with the value <code>10</code> .</span>リスト18-11で、我々は、という名前の変数を宣言<code>x</code>値を持つ<code>Some(5)</code>と、変数<code>y</code>値が<code>10</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We then create a <code>match</code> expression on the value <code>x</code> .</span>次に、 <code>x</code>の値に<code>match</code>式を作成します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Look at the patterns in the match arms and <code>println€</code> at the end, and try to figure out what the code will print before running this code or reading further.</span>マッチアームのパターンと最後に<code>println€</code>見て、このコードを実行する前にコードが何を出力するかを<code>println€</code>か、さらに読むことを試みてください。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="fn main() {"></div><div data-l="    let x = Some(5);"></div><div data-l="    let y = 10;"></div><div data-l=""></div><div data-l="    match x {"></div><div data-l="        Some(50) =&gt; println!(&quot;Got 50&quot;),"></div><div data-l="        Some(y) =&gt; println!(&quot;Matched, y = {:?}&quot;, y),"></div><div data-l="        _ =&gt; println!(&quot;Default case, x = {:?}&quot;, x),"></div><div data-l="    }"></div><div data-l=""></div><div data-l="    println!(&quot;at the end: x = {:?}, y = {:?}&quot;, x, y);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 18-11: A <code>match</code> expression with an arm that introduces a shadowed variable <code>y</code></span></span> <span class=caption>リスト18-11：シャドウ変数を導入する腕を持つ<code>match</code>式<code>y</code></span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s walk through what happens when the <code>match</code> expression runs.</span> <code>match</code>式が実行されたときの動作について説明しましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The pattern in the first match arm doesn&#39;t match the defined value of <code>x</code> , so the code continues.</span>最初のマッチアームのパターンが<code>x</code>の定義された値と一致しないため、コードは続行されます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The pattern in the second match arm introduces a new variable named <code>y</code> that will match any value inside a <code>Some</code> value.</span> 2番目のマッチアームのパターンは、 <code>Some</code>という名前の中の任意の値と一致する<code>y</code>という名前の新しい変数を導入します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because we&#39;re in a new scope inside the <code>match</code> expression, this is a new <code>y</code> variable, not the <code>y</code> we declared at the beginning with the value 10. This new <code>y</code> binding will match any value inside a <code>Some</code> , which is what we have in <code>x</code> .</span> <code>match</code>式の中で新しいスコープに入っているので、これは最初に値10で宣言した<code>y</code>ではなく、新しい<code>y</code>変数です。この新しい<code>y</code>バインディングは、 <code>Some</code>内部の値と一致します。 <code>x</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Therefore, this new <code>y</code> binds to the inner value of the <code>Some</code> in <code>x</code> .</span>したがって、この新しい<code>y</code>は<code>Some</code> in <code>x</code>内部値にバインドされます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That value is <code>5</code> , so the expression for that arm executes and prints <code>Matched, y = 5</code> .</span>その値は<code>5</code>なので、そのアームの式が実行され、 <code>Matched, y = 5</code>ます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If <code>x</code> had been a <code>None</code> value instead of <code>Some(5)</code> , the patterns in the first two arms wouldn&#39;t have matched, so the value would have matched to the underscore.</span> <code>x</code>が<code>Some(5)</code>ではなく<code>None</code>値だった場合、最初の2つのアームのパターンは一致しないので、値はアンダースコアに一致します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We didn&#39;t introduce the <code>x</code> variable in the pattern of the underscore arm, so the <code>x</code> in the expression is still the outer <code>x</code> that hasn&#39;t been shadowed.</span>アンダースコアアームのパターンに<code>x</code>変数を導入しなかったので、式の<code>x</code>はまだ影付きでない外側<code>x</code>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this hypothetical case, the <code>match</code> would print <code>Default case, x = None</code> .</span>この仮説的なケースでは、 <code>match</code>は<code>Default case, x = None</code>ます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When the <code>match</code> expression is done, its scope ends, and so does the scope of the inner <code>y</code> .</span> <code>match</code>式が終了すると、そのスコープは終了し、内側の<code>y</code>スコープも終了します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The last <code>println€</code> produces <code>at the end: x = Some(5), y = 10</code> .</span>最後の<code>println€</code>は最後に生成さ<code>at the end: x = Some(5), y = 10</code> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To create a <code>match</code> expression that compares the values of the outer <code>x</code> and <code>y</code> , rather than introducing a shadowed variable, we would need to use a match guard conditional instead.</span>影付きの変数を導入するのではなく、外側の<code>x</code>と<code>y</code>値を比較する<code>match</code>式を作成するには、代わりにマッチガード条件を使用する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll talk about match guards later in the “Extra Conditionals with Match Guards” section.</span>後で「マッチガード付きエクストラコンディション」セクションでマッチガードについて説明します。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Multiple Patterns</span>複数のパターン</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In <code>match</code> expressions, you can match multiple patterns using the <code>|</code></span> <code>match</code>式では、 <code>|</code>を使用して複数のパターンを一致させることができます<code>|</code></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">syntax, which means <i>or</i> .</span>構文、つまり<i>または</i>を意味します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, the following code matches the value of <code>x</code> against the match arms, the first of which has an <i>or</i> option, meaning if the value of <code>x</code> matches either of the values in that arm, that arm&#39;s code will run:</span>たとえば、次のコードでは、 <code>x</code>の値と一致する武器を照合します。その最初の桁には、 <i>または</i>オプションがあります。つまり、 <code>x</code>の値がその腕の値のいずれかと一致する場合、その腕のコードが実行されます。</span> </p><br><div data-lang=rust><div data-l="let x = 1;"></div><div data-l=""></div><div data-l="match x {"></div><div data-l="    1 | 2 =&gt; println!(&quot;one or two&quot;),"></div><div data-l="    3 =&gt; println!(&quot;three&quot;),"></div><div data-l="    _ =&gt; println!(&quot;anything&quot;),"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This code prints <code>one or two</code> .</span>このコードは<code>one or two</code>出力します。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Matching Ranges of Values with <code>...</code></span>値の一致する範囲と<code>...</code></span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>...</code> syntax allows us to match to an inclusive range of values.</span> <code>...</code>構文を使用すると、包括的な値の範囲に一致させることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In the following code, when a pattern matches any of the values within the range, that arm will execute:</span>次のコードでは、パターンが範囲内の値のいずれかと一致すると、その腕は次のように実行されます。</span> </p><br><div data-lang=rust><div data-l="let x = 5;"></div><div data-l=""></div><div data-l="match x {"></div><div data-l="    1 ... 5 =&gt; println!(&quot;one through five&quot;),"></div><div data-l="    _ =&gt; println!(&quot;something else&quot;),"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If <code>x</code> is 1, 2, 3, 4, or 5, the first arm will match.</span> <code>x</code>が1,2,3,4または5の場合、最初のアームが一致します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This syntax is more convenient than using the <code>|</code></span>この構文は、 <code>|</code></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">operator to express the same idea;</span>同じアイデアを表現するための演算子。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">instead of <code>1 ... 5</code> , we would have to specify <code>1 | 2 | 3 | 4 | 5</code></span> <code>1 ... 5</code>ではなく、 <code>1 ... 5</code> <code>1 | 2 | 3 | 4 | 5</code> <code>1 ... 5</code>を指定する必要があります<code>1 | 2 | 3 | 4 | 5</code></span> <code>1 | 2 | 3 | 4 | 5</code> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>1 | 2 | 3 | 4 | 5</code> if we used <code>|</code></span> <code>1 | 2 | 3 | 4 | 5</code>私たちが使用している場合<code>|</code></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">.</span> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Specifying a range is much shorter, especially if we want to match, say, any number between 1 and 1,000!</span>範囲を指定するのははるかに短く、特に1から1,000までの任意の数に一致させたい場合は特にそうです！</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Ranges are only allowed with numeric values or <code>char</code> values, because the compiler checks that the range isn&#39;t empty at compile time.</span>コンパイル時に範囲が空でないことをコンパイラがチェックするため、範囲には数値または<code>char</code>値しか使用できません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The only types for which Rust can tell if a range is empty or not are <code>char</code> and numeric values.</span>範囲が空であるかどうかをRustが判別できる唯一のタイプは、 <code>char</code>と数値です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here is an example using ranges of <code>char</code> values:</span>次に、 <code>char</code>値の範囲を使用する例を示します。</span> </p><br><div data-lang=rust><div data-l="let x = 'c';"></div><div data-l=""></div><div data-l="match x {"></div><div data-l="    'a' ... 'j' =&gt; println!(&quot;early ASCII letter&quot;),"></div><div data-l="    'k' ... 'z' =&gt; println!(&quot;late ASCII letter&quot;),"></div><div data-l="    _ =&gt; println!(&quot;something else&quot;),"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust can tell that <code>c</code> is within the first pattern&#39;s range and prints <code>early ASCII letter</code> .</span>錆は、 <code>c</code>が最初のパターンの範囲内にあり、 <code>early ASCII letter</code>を出力することが分かります。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Destructuring to Break Apart Values</span>離れた値を破るための破壊</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can also use patterns to destructure structs, enums, tuples, and references to use different parts of these values.</span>パターンを使用して、構造体、列挙型、タプル、および参照を破棄し、これらの値の異なる部分を使用することもできます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s walk through each value.</span>それぞれの価値観を歩みましょう。</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Destructuring Structs</span>構造物の破壊</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 18-12 shows a <code>Point</code> struct with two fields, <code>x</code> and <code>y</code> , that we can break apart using a pattern with a <code>let</code> statement.</span>リスト18-12は、2つのフィールド<code>x</code>と<code>y</code>を持つ<code>Point</code>構造体を示しています。これは、 <code>let</code>ステートメントでパターンを使用して分割できます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="struct Point {"></div><div data-l="    x: i32,"></div><div data-l="    y: i32,"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let p = Point { x: 0, y: 7 };"></div><div data-l=""></div><div data-l="    let Point { x: a, y: b } = p;"></div><div data-l="    assert_eq!(0, a);"></div><div data-l="    assert_eq!(7, b);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 18-12: Destructuring a struct&#39;s fields into separate variables</span></span> <span class=caption>リスト18-12：構造体のフィールドを別々の変数に分解する</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This code creates the variables <code>a</code> and <code>b</code> that match the values of the <code>x</code> and <code>y</code> fields of the <code>p</code> variable.</span>このコードは、 <code>p</code>変数の<code>x</code>および<code>y</code>フィールドの値と一致する変数<code>a</code>および<code>b</code>を作成します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This example shows that the names of the variables in the pattern don&#39;t have to match the field names of the struct.</span>この例は、パターン内の変数の名前が構造体のフィールド名と一致する必要はないことを示しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But it&#39;s common to want the variable names to match the field names to make it easier to remember which variables came from which fields.</span>しかし、どの変数がどのフィールドから来たのかを覚えやすくするために、変数名をフィールド名と一致させるのが一般的です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because having variable names match the fields is common and because writing <code>let Point { x: x, y: y } = p;</code></span>変数名がフィールドに一致するのは一般的で、 <code>let Point { x: x, y: y } = p;</code>書くため<code>let Point { x: x, y: y } = p;</code></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">contains a lot of duplication, there is a shorthand for patterns that match struct fields: you only need to list the name of the struct field, and the variables created from the pattern will have the same names.</span>構造体フィールドと一致するパターンの略語があります：構造体フィールドの名前をリストするだけで、パターンから作成された変数は同じ名前になります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 18-13 shows code that behaves in the same way as the code in Listing 18-12, but the variables created in the <code>let</code> pattern are <code>x</code> and <code>y</code> instead of <code>a</code> and <code>b</code> .</span>リスト18-13は、コードリスト18-12のコードと同じように動作するコードを示していますが、 <code>let</code>パターンで作成された変数は<code>a</code>と<code>b</code>ではなく<code>x</code>と<code>y</code>です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="struct Point {"></div><div data-l="    x: i32,"></div><div data-l="    y: i32,"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let p = Point { x: 0, y: 7 };"></div><div data-l=""></div><div data-l="    let Point { x, y } = p;"></div><div data-l="    assert_eq!(0, x);"></div><div data-l="    assert_eq!(7, y);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 18-13: Destructuring struct fields using struct field shorthand</span></span> <span class=caption>リスト18-13：構造体フィールドの構造体を使って構造体フィールドを破壊する</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This code creates the variables <code>x</code> and <code>y</code> that match the <code>x</code> and <code>y</code> fields of the <code>p</code> variable.</span>このコードは、 <code>p</code>変数の<code>x</code>および<code>y</code>フィールドに一致する変数<code>x</code>および<code>y</code>を作成します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The outcome is that the variables <code>x</code> and <code>y</code> contain the values from the <code>p</code> struct.</span>結果は、変数<code>x</code>と<code>y</code>に<code>p</code>構造体の値が含まれていることです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can also destructure with literal values as part of the struct pattern rather than creating variables for all the fields.</span>また、すべてのフィールドの変数を作成するのではなく、構造体パターンの一部としてリテラル値を使用して構造化することもできます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Doing so allows us to test some of the fields for particular values while creating variables to destructure the other fields.</span>そうすることで、特定の値のフィールドの一部をテストし、他のフィールドを分解する変数を作成することができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 18-14 shows a <code>match</code> expression that separates <code>Point</code> values into three cases: points that lie directly on the <code>x</code> axis (which is true when <code>y = 0</code> ), on the <code>y</code> axis ( <code>x = 0</code> ), or neither.</span>コードリスト18-14は、 <code>Point</code>値を3つのケースに分ける<code>match</code>式を示しています。ポイントは、 <code>x</code>軸に直接（ <code>y = 0</code>場合は真）、 <code>y</code>軸（ <code>x = 0</code> ）、またはどちらでもありません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="# struct Point {"></div><div data-l="#     x: i32,"></div><div data-l="#     y: i32,"></div><div data-l="# }"></div><div data-l=#></div><div data-l="fn main() {"></div><div data-l="    let p = Point { x: 0, y: 7 };"></div><div data-l=""></div><div data-l="    match p {"></div><div data-l="        Point { x, y: 0 } =&gt; println!(&quot;On the x axis at {}&quot;, x),"></div><div data-l="        Point { x: 0, y } =&gt; println!(&quot;On the y axis at {}&quot;, y),"></div><div data-l="        Point { x, y } =&gt; println!(&quot;On neither axis: ({}, {})&quot;, x, y),"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 18-14: Destructuring and matching literal values in one pattern</span></span> <span class=caption>リスト18-14：1つのパターンでリテラル値を分解して一致させる</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The first arm will match any point that lies on the <code>x</code> axis by specifying that the <code>y</code> field matches if its value matches the literal <code>0</code> .</span>最初の腕は、その値がリテラル<code>0</code>一致する場合に<code>y</code>フィールドが一致することを指定することによって、 <code>x</code>軸上の任意の点に一致します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The pattern still creates an <code>x</code> variable that we can use in the code for this arm.</span>パターンは、このアームのコードで使用できる<code>x</code>変数を作成します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Similarly, the second arm matches any point on the <code>y</code> axis by specifying that the <code>x</code> field matches if its value is <code>0</code> and creates a variable <code>y</code> for the value of the <code>y</code> field.</span>同様に、第2のアームは、その値が<code>0</code>場合に<code>x</code>フィールドが一致することを指定することによって<code>y</code>軸上の任意の点に一致し、 <code>y</code>フィールドの値に対する変数<code>y</code>を作成します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The third arm doesn&#39;t specify any literals, so it matches any other <code>Point</code> and creates variables for both the <code>x</code> and <code>y</code> fields.</span> 3番目の腕はリテラルを指定しないので、他の<code>Point</code>と一致し、 <code>x</code>と<code>y</code>両方のフィールドの変数を作成します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this example, the value <code>p</code> matches the second arm by virtue of <code>x</code> containing a 0, so this code will print <code>On the y axis at 7</code> .</span>この例では、値<code>p</code>は0を含む<code>x</code>によって2番目の腕に一致するため、このコードは<code>On the y axis at 7</code>ます。</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Destructuring Enums</span>列挙型の破壊</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ve destructured enums earlier in this book, for example, when we destructured <code>Option&lt;i32&gt;</code> in Listing 6-5 in Chapter 6. One detail we haven&#39;t mentioned explicitly is that the pattern to destructure an enum should correspond to the way the data stored within the enum is defined.</span>たとえば、リスト6-5の<code>Option&lt;i32&gt;</code>が第6章で破棄されたときなど、この本の前半のenumを破壊しました.1つの詳細について言及していない1つの詳細は、列挙型を破棄するパターンは、 enum内に格納されたデータが定義されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As an example, in Listing 18-15 we use the <code>Message</code> enum from Listing 6-2 and write a <code>match</code> with patterns that will destructure each inner value.</span>たとえば、リスト18-15では、リスト6-2の<code>Message</code> enumを使用して、各内部値を分解するパターンで<code>match</code>を書き込みます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="enum Message {"></div><div data-l="    Quit,"></div><div data-l="    Move { x: i32, y: i32 },"></div><div data-l="    Write(String),"></div><div data-l="    ChangeColor(i32, i32, i32),"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let msg = Message::ChangeColor(0, 160, 255);"></div><div data-l=""></div><div data-l="    match msg {"></div><div data-l="        Message::Quit =&gt; {"></div><div data-l="            println!(&quot;The Quit variant has no data to destructure.&quot;)"></div><div data-l="        },"></div><div data-l="        Message::Move { x, y } =&gt; {"></div><div data-l="            println!("></div><div data-l="                &quot;Move in the x direction {} and in the y direction {}&quot;,"></div><div data-l="                x,"></div><div data-l="                y"></div><div data-l="            );"></div><div data-l="        }"></div><div data-l="        Message::Write(text) =&gt; println!(&quot;Text message: {}&quot;, text),"></div><div data-l="        Message::ChangeColor(r, g, b) =&gt; {"></div><div data-l="            println!("></div><div data-l="                &quot;Change the color to red {}, green {}, and blue {}&quot;,"></div><div data-l="                r,"></div><div data-l="                g,"></div><div data-l="                b"></div><div data-l="            )"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 18-15: Destructuring enum variants that hold different kinds of values</span></span> <span class=caption>リスト18-15：異なる種類の値を保持する列挙型の変形</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This code will print <code>Change the color to red 0, green 160, and blue 255</code> .</span>このコードは<code>Change the color to red 0, green 160, and blue 255</code>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Try changing the value of <code>msg</code> to see the code from the other arms run.</span> <code>msg</code>の値を変更して、他のアームのコードを確認してみてください。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For enum variants without any data, like <code>Message::Quit</code> , we can&#39;t destructure the value any further.</span> <code>Message::Quit</code>ような、データを持たない列挙型の場合、それ以上値を破棄することはできません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can only match on the literal <code>Message::Quit</code> value, and no variables are in that pattern.</span>私たちは、リテラル<code>Message::Quit</code>値だけを照合することができ、そのパターンに変数はありません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For struct-like enum variants, such as <code>Message::Move</code> , we can use a pattern similar to the pattern we specify to match structs.</span> <code>Message::Move</code>ような構造体のような列挙型の場合、構造体と一致するように指定したパターンに似たパターンを使用できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">After the variant name, we place curly brackets and then list the fields with variables so we break apart the pieces to use in the code for this arm.</span>変種名の後に、中括弧を配置して変数を使用してフィールドをリストするので、このアームのコードで使用する部分を分割します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here we use the shorthand form as we did in Listing 18-13.</span>ここではリスト18-13のように省略形を使用します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For tuple-like enum variants, like <code>Message::Write</code> that holds a tuple with one element and <code>Message::ChangeColor</code> that holds a tuple with three elements, the pattern is similar to the pattern we specify to match tuples.</span> 1つの要素を持つタプルを保持する<code>Message::Write</code>や3つの要素を持つタプルを保持する<code>Message::ChangeColor</code>ようなタプルのような列挙型の場合、パターンはタプルに一致するように指定したパターンと似ています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The number of variables in the pattern must match the number of elements in the variant we&#39;re matching.</span>パターン内の変数の数は、一致するバリアント内の要素の数と一致する必要があります。</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Destructuring References</span>参照の破棄</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When the value we&#39;re matching to our pattern contains a reference, we need to destructure the reference from the value, which we can do by specifying a <code>&amp;</code> in the pattern.</span>パターンと一致する値に参照が含まれている場合は、その値から参照を削除する必要があります。これはパターンに<code>&amp;</code>を指定することで可能です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Doing so lets us get a variable holding the value that the reference points to rather than getting a variable that holds the reference.</span>そうすることで、参照を保持する変数を取得するのではなく、参照が参照する値を保持する変数を取得できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This technique is especially useful in closures where we have iterators that iterate over references, but we want to use the values in the closure rather than the references.</span>このテクニックは、参照を反復処理するイテレータがあるクロージャでは特に便利ですが、参照ではなくクロージャの値を使用したいと考えています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The example in Listing 18-16 iterates over references to <code>Point</code> instances in a vector, destructuring the reference and the struct so we can perform calculations on the <code>x</code> and <code>y</code> values easily.</span>コードリスト18-16の例は、Vector内の<code>Point</code>インスタンスへの参照を繰り返し、参照と構造体を破壊して、 <code>x</code>と<code>y</code>値を簡単に計算できます。</span> </p><br><div data-lang=rust><div data-l="# struct Point {"></div><div data-l="#     x: i32,"></div><div data-l="#     y: i32,"></div><div data-l="# }"></div><div data-l=#></div><div data-l="let points = vec!["></div><div data-l="    Point { x: 0, y: 0 },"></div><div data-l="    Point { x: 1, y: 5 },"></div><div data-l="    Point { x: 10, y: -3 },"></div><div data-l=];></div><div data-l=""></div><div data-l="let sum_of_squares: i32 = points"></div><div data-l="    .iter()"></div><div data-l="    .map(|&amp;Point { x, y }| x * x + y * y)"></div><div data-l="    .sum();"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 18-16: Destructuring a reference to a struct into the struct field values</span></span> <span class=caption>リスト18-16：構造体への参照を破壊する構造体のフィールド値</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This code gives us the variable <code>sum_of_squares</code> holding the value 135, which is the result of squaring the <code>x</code> value and the <code>y</code> value, adding those together, and then adding the result for each <code>Point</code> in the <code>points</code> vector to get one number.</span>このコードは、 <code>x</code>値と<code>y</code>値を二乗してそれらを<code>points</code>し、 <code>points</code>ベクトル内の各<code>Point</code>の結果を加算して1つの数値を得る結果の値135を保持する変数<code>sum_of_squares</code>ます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we had not included the <code>&amp;</code> in <code>&amp;Point { x, y }</code> , we&#39;d get a type mismatch error, because <code>iter</code> would then iterate over references to the items in the vector rather than the actual values.</span>我々は含まれていなかった場合は<code>&amp;</code>で<code>&amp;Point { x, y }</code>ので、我々は、型の不一致エラーを取得したい<code>iter</code> 、その後、ベクターではなく、実際の値でアイテムへの参照を反復処理します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The error would look like this:</span>エラーは次のようになります。</span> </p><br><div data-lang=text><div data-l="error[E0308]: mismatched types"></div><div data-l="  --&gt;"></div><div data-l="   |"></div><div data-l="14 |         .map(|Point { x, y }| x * x + y * y)"></div><div data-l="   |               ^^^^^^^^^^^^ expected &amp;Point, found struct `Point`"></div><div data-l="   |"></div><div data-l="   = note: expected type `&amp;Point`"></div><div data-l="              found type `Point`"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This error indicates that Rust was expecting our closure to match <code>&amp;Point</code> , but we tried to match directly to a <code>Point</code> value, not a reference to a <code>Point</code> .</span>このエラーは、Rustがクロージャが<code>&amp;Point</code>と一致すると予想していたが、 <code>Point</code>への参照ではなく<code>Point</code>値に直接一致させようとしたことを示しています。</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Destructuring Structs and Tuples</span>構造体とタプルの破壊</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can mix, match, and nest destructuring patterns in even more complex ways.</span>より複雑な方法で、非構造化パターンを混在、一致、および入れ子にすることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The following example shows a complicated destructure where we nest structs and tuples inside a tuple and destructure all the primitive values out:</span>次の例は、構造体とタプルをタプル内にネストし、すべてのプリミティブ値を破棄する複雑な構造を示しています。</span> </p><br><div data-lang=rust><div data-l="# struct Point {"></div><div data-l="#     x: i32,"></div><div data-l="#     y: i32,"></div><div data-l="# }"></div><div data-l=#></div><div data-l="let ((feet, inches), Point {x, y}) = ((3, 10), Point { x: 3, y: -10 });"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This code lets us break complex types into their component parts so we can use the values we&#39;re interested in separately.</span>このコードでは、複雑な型をコンポーネントの部分に分割して、別々の値を使用できます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Destructuring with patterns is a convenient way to use pieces of values, such as the value from each field in a struct, separately from each other.</span>パターンを使った破壊は、構造体の各フィールドの値など、値の断片を別々に使う便利な方法です。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Ignoring Values in a Pattern</span>パターン内の値を無視する</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You&#39;ve seen that it&#39;s sometimes useful to ignore values in a pattern, such as in the last arm of a <code>match</code> , to get a catchall that doesn&#39;t actually do anything but does account for all remaining possible values.</span>あなたはそれが、このような最後の腕のように、パターン内の値、無視すると便利な場合がありますことを見てきた<code>match</code> 、実際に何かをするが、残りのすべての可能な値のアカウントをしていないキャッチオールを得るために、。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There are a few ways to ignore entire values or parts of values in a pattern: using the <code>_</code> pattern (which you&#39;ve seen), using the <code>_</code> pattern within another pattern, using a name that starts with an underscore, or using <code>..</code> to ignore remaining parts of a value.</span> <code>_</code>パターン（見たことがある）を使用するか、別のパターン内の<code>_</code>パターンを使用するか、アンダースコアで始まる名前を使用するか、 <code>..</code>を使用して、パターン内の値全体または値の一部を無視する方法はいくつかあり<code>..</code>値の残りの部分を無視する。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s explore how and why to use each of these patterns.</span>どうやってこれらのパターンを使うのかを探そう。</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Ignoring an Entire Value with <code>_</code></span> <code>_</code>完全な値を無視する</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ve used the underscore ( <code>_</code> ) as a wildcard pattern that will match any value but not bind to the value.</span>アンダースコア（ <code>_</code> ）はワイルドカードパターンとして使用されていますが、値には一致しますが値にはバインドされません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Although the underscore <code>_</code> pattern is especially useful as the last arm in a <code>match</code> expression, we can use it in any pattern, including function parameters, as shown in Listing 18-17.</span>アンダースコア<code>_</code>パターンは、 <code>match</code>式の最後の腕として特に便利ですが、リスト18-17に示すように、関数パラメータを含むどのパターンでも使用できます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="fn foo(_: i32, y: i32) {"></div><div data-l="    println!(&quot;This code only uses the y parameter: {}&quot;, y);"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    foo(3, 4);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 18-17: Using <code>_</code> in a function signature</span></span> <span class=caption>リスト18-17：関数シグネチャで<code>_</code>を使う</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This code will completely ignore the value passed as the first argument, <code>3</code> , and will print <code>This code only uses the y parameter: 4</code> .</span>このコードは、最初の引数<code>3</code>として渡された値を完全に無視して出力します。 <code>This code only uses the y parameter: 4</code> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In most cases when you no longer need a particular function parameter, you would change the signature so it doesn&#39;t include the unused parameter.</span>ほとんどの場合、特定の関数パラメータが不要になったときに、未使用のパラメータが含まれないようにシグネチャを変更します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Ignoring a function parameter can be especially useful in some cases, for example, when implementing a trait when you need a certain type signature but the function body in your implementation doesn&#39;t need one of the parameters.</span>関数パラメータを無視すると、特定の型シグネチャが必要なときに特性を実装する場合など、実装の関数本体にパラメータの1つが必要ない場合など、いくつかの場合に特に便利です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The compiler will then not warn about unused function parameters, as it would if you used a name instead.</span>コンパイラは、代わりに名前を使用した場合と同様に、未使用の関数パラメータについて警告しません。</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Ignoring Parts of a Value with a Nested <code>_</code></span>ネストされた<code>_</code>を持つ値の部分を無視する</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can also use <code>_</code> inside another pattern to ignore just part of a value, for example, when we want to test for only part of a value but have no use for the other parts in the corresponding code we want to run.</span>たとえば、値の一部だけをテストしたいが、実行したいコードの他の部分には使用しないなど、別のパターンの中で<code>_</code>を使って値の一部を無視することもできます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 18-18 shows code responsible for managing a setting&#39;s value.</span>リスト18-18は、設定の値を管理するコードを示しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The business requirements are that the user should not be allowed to overwrite an existing customization of a setting but can unset the setting and can give the setting a value if it is currently unset.</span>ビジネス要件は、ユーザーが設定の既存のカスタマイズを上書きすることを許可されるべきではなく、設定を解除することができ、現在設定されていない場合に設定に値を与えることができるということです。</span> </p><br><div data-lang=rust><div data-l="let mut setting_value = Some(5);"></div><div data-l="let new_setting_value = Some(10);"></div><div data-l=""></div><div data-l="match (setting_value, new_setting_value) {"></div><div data-l="    (Some(_), Some(_)) =&gt; {"></div><div data-l="        println!(&quot;Can't overwrite an existing customized value&quot;);"></div><div data-l="    }"></div><div data-l="    _ =&gt; {"></div><div data-l="        setting_value = new_setting_value;"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="println!(&quot;setting is {:?}&quot;, setting_value);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 18-18: Using an underscore within patterns that match <code>Some</code> variants when we don&#39;t need to use the value inside the <code>Some</code></span></span> <span class=caption>リスト18-18：一致するパターン内にアンダースコアを使用する場合<code>Some</code>バリアントの<code>Some</code>値を使用する必要がない場合</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This code will print <code>Can&#39;t overwrite an existing customized value</code> and then <code>setting is Some(5)</code> .</span>このコードは<code>Can&#39;t overwrite an existing customized value</code>を<code>Can&#39;t overwrite an existing customized value</code>し、 <code>setting is Some(5)</code>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In the first match arm, we don&#39;t need to match on or use the values inside either <code>Some</code> variant, but we do need to test for the case when <code>setting_value</code> and <code>new_setting_value</code> are the <code>Some</code> variant.</span>最初のマッチでは、どちら<code>Some</code>バリエーションの<code>Some</code>値をマッチさせたり使用したりする必要はありませんが、 <code>setting_value</code>と<code>new_setting_value</code>が<code>Some</code>バリエーションである場合をテストする必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In that case, we print why we&#39;re not changing <code>setting_value</code> , and it doesn&#39;t get changed.</span>その場合、私たちはなぜ<code>setting_value</code>変更していないのかを<code>setting_value</code> 、変更されません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In all other cases (if either <code>setting_value</code> or <code>new_setting_value</code> are <code>None</code> ) expressed by the <code>_</code> pattern in the second arm, we want to allow <code>new_setting_value</code> to become <code>setting_value</code> .</span>それ以外の場合（2番目のアームの<code>_</code>パターンで表される<code>setting_value</code>または<code>new_setting_value</code>が<code>None</code> ）は、 <code>new_setting_value</code>を<code>new_setting_value</code>する必要が<code>setting_value</code>ます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can also use underscores in multiple places within one pattern to ignore particular values.</span>あるパターン内の複数の場所でアンダースコアを使用して、特定の値を無視することもできます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 18-19 shows an example of ignoring the second and fourth values in a tuple of five items.</span>リスト18-19は、5つの項目からなるタプルの2番目と4番目の値を無視する例を示しています。</span> </p><br><div data-lang=rust><div data-l="let numbers = (2, 4, 8, 16, 32);"></div><div data-l=""></div><div data-l="match numbers {"></div><div data-l="    (first, _, third, _, fifth) =&gt; {"></div><div data-l="        println!(&quot;Some numbers: {}, {}, {}&quot;, first, third, fifth)"></div><div data-l="    },"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 18-19: Ignoring multiple parts of a tuple</span></span> <span class=caption>リスト18-19：タプルの複数の部分を無視する</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This code will print <code>Some numbers: 2, 8, 32</code> , and the values 4 and 16 will be ignored.</span>このコードは<code>Some numbers: 2, 8, 32</code>を印刷し<code>Some numbers: 2, 8, 32</code> 、値4と16は無視されます。</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Ignoring an Unused Variable by Starting Its Name with <code>_</code></span>使用していない変数を無視する<code>_</code></span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you create a variable but don&#39;t use it anywhere, Rust will usually issue a warning because that could be a bug.</span>変数を作成してどこにも使用しない場合、Rustは通常はバグかもしれないので警告を出します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But sometimes it&#39;s useful to create a variable you won&#39;t use yet, such as when you&#39;re prototyping or just starting a project.</span>しかし、プロトタイプやプロジェクトの開始時など、まだ使用しない変数を作成すると便利なことがあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this situation, you can tell Rust not to warn you about the unused variable by starting the name of the variable with an underscore.</span>この状況では、変数の名前をアンダースコアで始めることによって、未使用変数について警告しないようRustに指示できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In Listing 18-20, we create two unused variables, but when we run this code, we should only get a warning about one of them.</span>リスト18-20では、2つの未使用変数を作成しますが、このコードを実行するときには、そのうちの1つについてのみ警告を出す必要があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="fn main() {"></div><div data-l="    let _x = 5;"></div><div data-l="    let y = 10;"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 18-20: Starting a variable name with an underscore to avoid getting unused variable warnings</span></span> <span class=caption>リスト18-20：未使用の変数警告を避けるために、変数名をアンダースコアで開始する</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here we get a warning about not using the variable <code>y</code> , but we don&#39;t get a warning about not using the variable preceded by the underscore.</span>ここでは、変数<code>y</code>を使用しないという警告が表示されますが、アンダースコアの前に変数を使用しないことに関する警告は表示されません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that there is a subtle difference between using only <code>_</code> and using a name that starts with an underscore.</span> <code>_</code>だけを使用する場合とアンダースコアで始まる名前を使用する場合には微妙な違いがあることに注意してください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The syntax <code>_x</code> still binds the value to the variable, whereas <code>_</code> doesn&#39;t bind at all.</span>構文<code>_x</code>は値を変数にバインドしますが、 <code>_</code>はまったくバインドしません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To show a case where this distinction matters, Listing 18-21 will provide us with an error.</span>この区別が重要な場合を示すために、リスト18-21はエラーを表示します。</span> </p><br><div data-lang=rust,ignore><div data-l="let s = Some(String::from(&quot;Hello!&quot;));"></div><div data-l=""></div><div data-l="if let Some(_s) = s {"></div><div data-l="    println!(&quot;found a string&quot;);"></div><div data-l=}></div><div data-l=""></div><div data-l="println!(&quot;{:?}&quot;, s);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 18-21: An unused variable starting with an underscore still binds the value, which might take ownership of the value</span></span> <span class=caption>リスト18-21：アンダースコアで始まる未使用の変数は引き続き値をバインドします。</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll receive an error because the <code>s</code> value will still be moved into <code>_s</code> , which prevents us from using <code>s</code> again.</span> <code>s</code>値が<code>_s</code>に移動されるため、エラーが返されます。これにより、 <code>s</code>再度使用することができなくなります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, using the underscore by itself doesn&#39;t ever bind to the value.</span>しかし、アンダースコア自体を使用しても値にバインドされることはありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 18-22 will compile without any errors because <code>s</code> doesn&#39;t get moved into <code>_</code> .</span>リスト18-22は、 <code>s</code>が<code>_</code>に移動しないため、エラーなしでコンパイルされます。</span> </p><br><div data-lang=rust><div data-l="let s = Some(String::from(&quot;Hello!&quot;));"></div><div data-l=""></div><div data-l="if let Some(_) = s {"></div><div data-l="    println!(&quot;found a string&quot;);"></div><div data-l=}></div><div data-l=""></div><div data-l="println!(&quot;{:?}&quot;, s);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 18-22: Using an underscore does not bind the value</span></span> <span class=caption>リスト18-22：アンダースコアを使用しても値はバインドされません</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This code works just fine because we never bind <code>s</code> to anything;</span>このコードは、 <code>s</code>を何もバインドしないのでうまく動作します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">it isn&#39;t moved.</span>それは動かされません。</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Ignoring Remaining Parts of a Value with <code>..</code></span>値の残りの部分を無視します<code>..</code></span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">With values that have many parts, we can use the <code>..</code> syntax to use only a few parts and ignore the rest, avoiding the need to list underscores for each ignored value.</span>多くの部分を持つ値では、 <code>..</code>構文を使用していくつかの部分のみを使用し、残りの部分は無視して、無視された値ごとにアンダースコアをリストする必要はありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>..</code> pattern ignores any parts of a value that we haven&#39;t explicitly matched in the rest of the pattern.</span> <code>..</code>パターンは、残りのパターンで明示的にマッチしていない値の部分を無視します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In Listing 18-23, we have a <code>Point</code> struct that holds a coordinate in three-dimensional space.</span>リスト18-23には、3次元空間内の座標を保持する<code>Point</code>構造体があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In the <code>match</code> expression, we want to operate only on the <code>x</code> coordinate and ignore the values in the <code>y</code> and <code>z</code> fields.</span> <code>match</code>式では、 <code>x</code>座標のみで操作し、 <code>y</code>と<code>z</code>フィールドの値は無視します。</span> </p><br><div data-lang=rust><div data-l="struct Point {"></div><div data-l="    x: i32,"></div><div data-l="    y: i32,"></div><div data-l="    z: i32,"></div><div data-l=}></div><div data-l=""></div><div data-l="let origin = Point { x: 0, y: 0, z: 0 };"></div><div data-l=""></div><div data-l="match origin {"></div><div data-l="    Point { x, .. } =&gt; println!(&quot;x is {}&quot;, x),"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 18-23: Ignoring all fields of a <code>Point</code> except for <code>x</code> by using <code>..</code></span></span> <span class=caption>リスト18-23： <code>..</code>を使って、 <code>x</code>を除く<code>Point</code>すべてのフィールドを無視する</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We list the <code>x</code> value and then just include the <code>..</code> pattern.</span> <code>x</code>値を列挙し、 <code>..</code>パターンだけを含め<code>..</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is quicker than having to list <code>y: _</code> and <code>z: _</code> , particularly when we&#39;re working with structs that have lots of fields in situations where only one or two fields are relevant.</span> 1つまたは2つのフィールドのみが関連する状況で多くのフィールドを持つ構造体を扱っている場合は特に、 <code>y: _</code>と<code>z: _</code>をリストする必要があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The syntax <code>..</code> will expand to as many values as it needs to be.</span>構文<code>..</code>は必要なだけ多くの値に展開されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 18-24 shows how to use <code>..</code> with a tuple.</span>リスト18-24は、タプルで<code>..</code>を使用する方法を示しています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="fn main() {"></div><div data-l="    let numbers = (2, 4, 8, 16, 32);"></div><div data-l=""></div><div data-l="    match numbers {"></div><div data-l="        (first, .., last) =&gt; {"></div><div data-l="            println!(&quot;Some numbers: {}, {}&quot;, first, last);"></div><div data-l="        },"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 18-24: Matching only the first and last values in a tuple and ignoring all other values</span></span> <span class=caption>リスト18-24：タプルの最初と最後の値だけを一致させ、他のすべての値を無視する</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this code, the first and last value are matched with <code>first</code> and <code>last</code> .</span>このコードでは、最初と最後の値が<code>first</code>と<code>last</code>一致します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>..</code> will match and ignore everything in the middle.</span> <code>..</code>は真ん中のすべてを無視して一致させます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, using <code>..</code> must be unambiguous.</span>しかし<code>..</code>を使用することはあいまいでなければなりません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If it is unclear which values are intended for matching and which should be ignored, Rust will give us an error.</span>どの値がマッチングの対象か、無視されるべきかが不明な場合、Rustはエラーを返します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 18-25 shows an example of using <code>..</code> ambiguously, so it will not compile.</span> 18-25のリストの使用例を示します<code>..</code>曖昧なので、それがコンパイルされません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust,ignore><div data-l="fn main() {"></div><div data-l="    let numbers = (2, 4, 8, 16, 32);"></div><div data-l=""></div><div data-l="    match numbers {"></div><div data-l="        (.., second, ..) =&gt; {"></div><div data-l="            println!(&quot;Some numbers: {}&quot;, second)"></div><div data-l="        },"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 18-25: An attempt to use <code>..</code> in an ambiguous way</span></span> <span class=caption>リスト18-25：あいまいな方法で<code>..</code>を使う試み</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When we compile this example, we get this error:</span>この例をコンパイルすると、次のエラーが発生します。</span> </p><br><div data-lang=text><div data-l="error: `..` can only be used once per tuple or tuple struct pattern"></div><div data-l=" --&gt; src/main.rs:5:22"></div><div data-l="  |"></div><div data-l="5 |         (.., second, ..) =&gt; {"></div><div data-l="  |                      ^^"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It&#39;s impossible for Rust to determine how many values in the tuple to ignore before matching a value with <code>second</code> and then how many further values to ignore thereafter.</span> Rustでは、値を<code>second</code>値と一致させる前に無視するタプル内の値の数を決定し、その後無視する値を何個追加するかを決定することは不可能です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This code could mean that we want to ignore <code>2</code> , bind <code>second</code> to <code>4</code> , and then ignore <code>8</code> , <code>16</code> , and <code>32</code> ;</span>このコードは、我々が無視することを意味する可能性がある<code>2</code> 、バインド<code>second</code>に<code>4</code>無視し、その後、および<code>8</code> 、 <code>16</code> 、および<code>32</code> 、</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">or that we want to ignore <code>2</code> and <code>4</code> , bind <code>second</code> to <code>8</code> , and then ignore <code>16</code> and <code>32</code> ;</span>または<code>2</code>と<code>4</code>を無視し、 <code>2</code> <code>second</code>を<code>8</code>にバインドしてから、 <code>16</code>と<code>32</code>を無視したいということです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">and so forth.</span>等々。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The variable name <code>second</code> doesn&#39;t mean anything special to Rust, so we get a compiler error because using <code>..</code> in two places like this is ambiguous.</span>変数名<code>second</code>はRustにとって特別なものではないので、このように2つの場所で<code>..</code>を使用するとあいまいであるため、コンパイラエラーが発生し<code>..</code> 。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Creating References in Patterns with <code>ref</code> and <code>ref mut</code></span> <code>ref</code>と<code>ref mut</code>使ってパターン内の参照を作成する</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s look at using <code>ref</code> to make references so ownership of the values isn&#39;t moved to variables in the pattern.</span> <code>ref</code>を作成して値の所有権をパターン内の変数に移動させないように<code>ref</code>を使ってみましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Usually, when you match against a pattern, the variables introduced by the pattern are bound to a value.</span>通常、パターンとマッチすると、パターンによって導入された変数は値にバインドされます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust&#39;s ownership rules mean the value will be moved into the <code>match</code> or wherever you&#39;re using the pattern.</span> Rustのオーナーシップルールは、値が<code>match</code>またはパターンを使用している場所に移動されることを意味します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 18-26 shows an example of a <code>match</code> that has a pattern with a variable and then usage of the entire value in the <code>println€</code> statement later, after the <code>match</code> .</span> 18-26のリストの例を示す<code>match</code>全体値の次に変数と使用のパターン有する<code>println€</code>後、後の文を<code>match</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This code will fail to compile because ownership of part of the <code>robot_name</code> value is transferred to the <code>name</code> variable in the pattern of the first <code>match</code> arm.</span>このコードは、 <code>robot_name</code>値の一部の所有権が最初の<code>match</code>アームのパターンで<code>name</code>変数に転送されるため、コンパイルに失敗します。</span> </p><br><div data-lang=rust,ignore><div data-l="let robot_name = Some(String::from(&quot;Bors&quot;));"></div><div data-l=""></div><div data-l="match robot_name {"></div><div data-l="    Some(name) =&gt; println!(&quot;Found a name: {}&quot;, name),"></div><div data-l="    None =&gt; (),"></div><div data-l=}></div><div data-l=""></div><div data-l="println!(&quot;robot_name is: {:?}&quot;, robot_name);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 18-26: Creating a variable in a <code>match</code> arm pattern takes ownership of the value</span></span> <span class=caption>リスト18-26： <code>match</code>アームパターンで変数を作成すると、値の所有権が得られます</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because ownership of part of <code>robot_name</code> has been moved to <code>name</code> , we can no longer use <code>robot_name</code> in the <code>println€</code> after the <code>match</code> because <code>robot_name</code> no longer has ownership.</span> <code>robot_name</code>の一部の所有権は<code>name</code>に移動されているため、 <code>robot_name</code>は所有権を持たないため、 <code>match</code>後に<code>println€</code> <code>robot_name</code>を使用することはできません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To fix this code, we want to make the <code>Some(name)</code> pattern <i>borrow</i> that part of <code>robot_name</code> rather than taking ownership.</span>このコードを修正するために、 <code>Some(name)</code>パターンを所有権を取得するのではなく、 <code>robot_name</code>その部分を<i>借用</i>したいと考えています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You&#39;ve already seen that, outside of patterns, the way to borrow a value is to create a reference using <code>&amp;</code> , so you might think the solution is changing <code>Some(name)</code> to <code>Some(&amp;name)</code> .</span>パターンの外で値を借りる方法は、 <code>&amp;</code>を使用して参照を作成することです。そのため、ソリューションが<code>Some(name)</code>を<code>Some(&amp;name)</code>変更して<code>Some(name)</code>と思うかもしれません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, as you saw in the “Destructuring to Break Apart Values” section, the syntax <code>&amp;</code> in patterns does not <i>create</i> a reference but <i>matches</i> an existing reference in the value.</span>ただし、「値を分割するためのデストラクタリング」のセクションで見たように、 <code>&amp;</code> inパターンの構文は参照を<i>作成</i>せず、値の既存の参照と<i>一致</i>します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because <code>&amp;</code> already has that meaning in patterns, we can&#39;t use <code>&amp;</code> to create a reference in a pattern.</span>ので<code>&amp;</code>すでにパターンでその意味を持って、我々は使用できません<code>&amp;</code>パターンで参照を作成します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Instead, to create a reference in a pattern, we use the <code>ref</code> keyword before the new variable, as shown in Listing 18-27.</span>代わりに、パターンで参照を作成するには、リスト18-27に示すように、新しい変数の前に<code>ref</code>キーワードを使用します。</span> </p><br><div data-lang=rust><div data-l="let robot_name = Some(String::from(&quot;Bors&quot;));"></div><div data-l=""></div><div data-l="match robot_name {"></div><div data-l="    Some(ref name) =&gt; println!(&quot;Found a name: {}&quot;, name),"></div><div data-l="    None =&gt; (),"></div><div data-l=}></div><div data-l=""></div><div data-l="println!(&quot;robot_name is: {:?}&quot;, robot_name);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 18-27: Creating a reference so a pattern variable does not take ownership of a value</span></span> <span class=caption>リスト18-27：パターン変数が値の所有権を取得しないように参照を作成する</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This example will compile because the value in the <code>Some</code> variant in <code>robot_name</code> is not moved into the <code>match</code> ;</span>この例は、 <code>robot_name</code>の<code>Some</code> variantの値が<code>match</code>移動されないためコンパイルされます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">the <code>match</code> only took a reference to the data in <code>robot_name</code> rather than moving it.</span>この<code>match</code>では、 <code>robot_name</code>移動するのではなく、そのデータを参照するだけでした。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To create a mutable reference so we&#39;re able to mutate a value matched in a pattern, we use <code>ref mut</code> instead of <code>&amp;mut</code> .</span> mutable参照を作成してパターンにマッチした値を変更できるようにするには、 <code>&amp;mut</code>代わりに<code>ref mut</code>を使用します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The reason is, again, that in patterns, the latter is for matching existing mutable references, not creating new ones.</span>その理由は、やはりパターンでは、後者は既存の可変参照を照合するためであり、新しい参照を作成するのではないからです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 18-28 shows an example of a pattern creating a mutable reference.</span>リスト18-28は、可変参照を作成するパターンの例を示しています。</span> </p><br><div data-lang=rust><div data-l="let mut robot_name = Some(String::from(&quot;Bors&quot;));"></div><div data-l=""></div><div data-l="match robot_name {"></div><div data-l="    Some(ref mut name) =&gt; *name = String::from(&quot;Another name&quot;),"></div><div data-l="    None =&gt; (),"></div><div data-l=}></div><div data-l=""></div><div data-l="println!(&quot;robot_name is: {:?}&quot;, robot_name);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 18-28: Creating a mutable reference to a value as part of a pattern using <code>ref mut</code></span></span> <span class=caption>リスト18-28： <code>ref mut</code>を使ってパターンの一部として値への可変参照を作成する</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This example will compile and print <code>robot_name is: Some(&quot;Another name&quot;)</code> .</span>この例では、 <code>robot_name is: Some(&quot;Another name&quot;)</code>コンパイルされ、表示されます<code>robot_name is: Some(&quot;Another name&quot;)</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because <code>name</code> is a mutable reference, we need to dereference within the match arm code using the <code>*</code> operator to mutate the value.</span> <code>name</code>は可変参照であるため、値を変更するには<code>*</code>演算子を使用してマッチ・アーム・コード内の参照を解除する必要があります。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Extra Conditionals with Match Guards</span>マッチガードを持つエクストラコンディション</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A <i>match guard</i> is an additional <code>if</code> condition specified after the pattern in a <code>match</code> arm that must also match, along with the pattern matching, for that arm to be chosen.</span> <i>マッチガード</i>は、 <code>match</code>アーム内のパターンの後に指定された追加の<code>if</code>条件であり、パターンマッチングとともにそのアームを選択する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Match guards are useful for expressing more complex ideas than a pattern alone allows.</span>マッチガードは、パターンだけで可能なものより複雑なアイデアを表現するのに便利です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The condition can use variables created in the pattern.</span>この条件では、パターンで作成された変数を使用できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 18-29 shows a <code>match</code> where the first arm has the pattern <code>Some(x)</code> and also has a match guard of <code>if x &lt; 5</code> .</span> 18-29をリスト示し<code>match</code>第一アームのパターンを有する<code>Some(x)</code>ともの一致ガード有する<code>if x &lt; 5</code> 。</span> </p><br><div data-lang=rust><div data-l="let num = Some(4);"></div><div data-l=""></div><div data-l="match num {"></div><div data-l="    Some(x) if x &lt; 5 =&gt; println!(&quot;less than five: {}&quot;, x),"></div><div data-l="    Some(x) =&gt; println!(&quot;{}&quot;, x),"></div><div data-l="    None =&gt; (),"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 18-29: Adding a match guard to a pattern</span></span> <span class=caption>リスト18-29：マッチガードをパターンに追加する</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This example will print <code>less than five: 4</code> .</span>この例では<code>less than five: 4</code>を出力します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When <code>num</code> is compared to the pattern in the first arm, it matches, because <code>Some(4)</code> matches <code>Some(x)</code> .</span> <code>num</code>最初の腕のパターンと比較すると、 <code>Some(4)</code> <code>Some(x)</code>一致するため、 <code>num</code>と一致します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then the match guard checks whether the value in <code>x</code> is less than <code>5</code> , and because it is, the first arm is selected.</span>その後、マッチガードは、 <code>x</code>の値が<code>5</code>より小さいかどうかをチェックし、そうであるため、最初のアームが選択されます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If <code>num</code> had been <code>Some(10)</code> instead, the match guard in the first arm would have been false because 10 is not less than 5. Rust would then go to the second arm, which would match because the second arm doesn&#39;t have a match guard and therefore matches any <code>Some</code> variant.</span>もし<code>num</code>が<code>Some(10)</code>だったら、10が5以上であるので、最初の腕のマッチガードは偽になるでしょう。錆は2番目の腕に行きます。2番目の腕にはしたがって、 <code>Some</code>変形にマッチします。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There is no way to express the <code>if x &lt; 5</code> condition within a pattern, so the match guard gives us the ability to express this logic.</span>パターン内で<code>if x &lt; 5</code>条件を表現する方法はないので、マッチガードはこのロジックを表現する能力を与えます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In Listing 18-11, we mentioned that we could use match guards to solve our pattern-shadowing problem.</span>リスト18-11では、マッチガードを使用してパターンシャドーイングの問題を解決できると述べました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Recall that a new variable was created inside the pattern in the <code>match</code> expression instead of using the variable outside the <code>match</code> .</span> <code>match</code>以外の変数を使用する代わりに、 <code>match</code>式のパターン内に新しい変数が作成されたことを思い出してください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That new variable meant we couldn&#39;t test against the value of the outer variable.</span>その新しい変数は、外部変数の値に対してテストできないことを意味しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 18-30 shows how we can use a match guard to fix this problem.</span>リスト18-30に、この問題を解決するためにマッチガードを使用する方法を示します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="fn main() {"></div><div data-l="    let x = Some(5);"></div><div data-l="    let y = 10;"></div><div data-l=""></div><div data-l="    match x {"></div><div data-l="        Some(50) =&gt; println!(&quot;Got 50&quot;),"></div><div data-l="        Some(n) if n == y =&gt; println!(&quot;Matched, n = {:?}&quot;, n),"></div><div data-l="        _ =&gt; println!(&quot;Default case, x = {:?}&quot;, x),"></div><div data-l="    }"></div><div data-l=""></div><div data-l="    println!(&quot;at the end: x = {:?}, y = {:?}&quot;, x, y);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 18-30: Using a match guard to test for equality with an outer variable</span></span> <span class=caption>リスト18-30：マッチガードを使って外部変数との等価性をテストする</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This code will now print <code>Default case, x = Some(5)</code> .</span>このコードでは<code>Default case, x = Some(5)</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The pattern in the second match arm doesn&#39;t introduce a new variable <code>y</code> that would shadow the outer <code>y</code> , meaning we can use the outer <code>y</code> in the match guard.</span> 2番目のマッチアームのパターンは外側の<code>y</code>をシャドウする新しい変数<code>y</code>を導入しないので、マッチガードの外側<code>y</code>を使用することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Instead of specifying the pattern as <code>Some(y)</code> , which would have shadowed the outer <code>y</code> , we specify <code>Some(n)</code> .</span>パターンを<code>Some(y)</code>として指定する代わりに、外側の<code>y</code>をシャドーにして、 <code>Some(n)</code>を指定します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This creates a new variable <code>n</code> that doesn&#39;t shadow anything because there is no <code>n</code> variable outside the <code>match</code> .</span>これは、 <code>match</code>外側に<code>n</code>変数がないため、何も陰をつけない新しい変数<code>n</code>を作成します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The match guard <code>if n == y</code> is not a pattern and therefore doesn&#39;t introduce new variables.</span> <code>if n == y</code>のマッチガードはパターンではないので、新しい変数を導入しません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This <code>y</code> <i>is</i> the outer <code>y</code> rather than a new shadowed <code>y</code> , and we can look for a value that has the same value as the outer <code>y</code> by comparing <code>n</code> to <code>y</code> .</span>この<code>y</code> 、外<i>である</i> <code>y</code>ではなく、新たな影のより<code>y</code> 、と私たちは外と同じ値を持つ値を探すことができ<code>y</code>比較することにより、 <code>n</code>する<code>y</code> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can also use the <i>or</i> operator <code>|</code></span> <i>または</i>演算子<code>|</code>使用することもできます<code>|</code></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">in a match guard to specify multiple patterns;</span>マッチガードで複数のパターンを指定する。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">the match guard condition will apply to all the patterns.</span>マッチガード条件はすべてのパターンに適用されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 18-31 shows the precedence of combining a match guard with a pattern that uses <code>|</code></span>リスト18-31に、マッチガードと<code>|</code>を使用するパターンを組み合わせた場合の優先順位を示します<code>|</code></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">.</span> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The important part of this example is that the <code>if y</code> match guard applies to <code>4</code> , <code>5</code> , <i>and</i> <code>6</code> , even though it might look like <code>if y</code> only applies to <code>6</code> .</span>この例の重要な部分は、ということである<code>if y</code>マッチガードが適用される<code>4</code> 、 <code>5</code> 、 <i>及び</i> <code>6</code>それはのように見える場合でも、 <code>if y</code>のみに適用されます<code>6</code> 。</span> </p><br><div data-lang=rust><div data-l="let x = 4;"></div><div data-l="let y = false;"></div><div data-l=""></div><div data-l="match x {"></div><div data-l="    4 | 5 | 6 if y =&gt; println!(&quot;yes&quot;),"></div><div data-l="    _ =&gt; println!(&quot;no&quot;),"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 18-31: Combining multiple patterns with a match guard</span></span> <span class=caption>リスト18-31：複数のパターンをマッチガードと組み合わせる</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The match condition states that the arm only matches if the value of <code>x</code> is equal to <code>4</code> , <code>5</code> , or <code>6</code> <i>and</i> if <code>y</code> is <code>true</code> .</span>一致条件は、腕のみの値場合に一致していることを述べて<code>x</code>に等しい<code>4</code> 、 <code>5</code> 、または<code>6</code>場合<i>に</i> <code>y</code>ある<code>true</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When this code runs, the pattern of the first arm matches because <code>x</code> is <code>4</code> , but the match guard <code>if y</code> is false, so the first arm is not chosen.</span>このコードが実行されると、 <code>x</code>が<code>4</code>であるため、最初のアームのパターンが一致しますが、 <code>if y</code>がfalseの<code>if y</code>はマッチガードが起きるため、最初のアームは選択されません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The code moves on to the second arm, which does match, and this program prints <code>no</code> .</span>コードは一致する第2のアームに移動し、このプログラムは<code>no</code>出力します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The reason is that the <code>if</code> condition applies to the whole pattern <code>4 | 5 | 6</code></span>理由は、 <code>if</code>条件がパターン全体に適用されるためです<code>4 | 5 | 6</code></span> <code>4 | 5 | 6</code> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>4 | 5 | 6</code> , not only to the last value <code>6</code> .</span> <code>4 | 5 | 6</code>だけでなく、最後の値<code>6</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In other words, the precedence of a match guard in relation to a pattern behaves like this:</span>言い換えれば、パターンに関連したマッチガードの優先順位は、次のようになります。</span> </p><br><div data-lang=text><div data-l="(4 | 5 | 6) if y =&gt; ..."></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">rather than this:</span>これよりむしろ：</span> </p><br><div data-lang=text><div data-l="4 | 5 | (6 if y) =&gt; ..."></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">After running the code, the precedence behavior is evident: if the match guard were applied only to the final value in the list of values specified using the <code>|</code></span>コードを実行した後、優先順位の動作が明白です。マッチガードが、 <code>|</code>値を使用して指定された値のリストの最終値にのみ適用された場合、</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">operator, the arm would have matched and the program would have printed <code>yes</code> .</span>アームは一致し、プログラムは<code>yes</code>と表示され<code>yes</code> 。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>@</code> Bindings</span> <code>@</code>バインディング</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <i>at</i> operator ( <code>@</code> ) lets us create a variable that holds a value at the same time we&#39;re testing that value to see whether it matches a pattern.</span> <i>at</i>演算子（ <code>@</code> ）を使用すると、パターンに一致するかどうかを調べるときにその値をテストすると同時に値を保持する変数を作成できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 18-32 shows an example where we want to test that a <code>Message::Hello</code> <code>id</code> field is within the range <code>3...7</code> .</span>リスト18-32は、 <code>Message::Hello</code> <code>id</code>フィールドが<code>3...7</code>範囲内にあることをテストするサンプルを示してい<code>3...7</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But we also want to bind the value to the variable <code>id_variable</code> so we can use it in the code associated with the arm.</span>しかし、値を変数<code>id_variable</code>にバインドして、アームに関連付けられたコードでその値を使用することもできます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We could name this variable <code>id</code> , the same as the field, but for this example we&#39;ll use a different name.</span>この変数<code>id</code>にはフィールドと同じ名前を付けることができますが、この例では別の名前を使用します。</span> </p><br><div data-lang=rust><div data-l="enum Message {"></div><div data-l="    Hello { id: i32 },"></div><div data-l=}></div><div data-l=""></div><div data-l="let msg = Message::Hello { id: 5 };"></div><div data-l=""></div><div data-l="match msg {"></div><div data-l="    Message::Hello { id: id_variable @ 3...7 } =&gt; {"></div><div data-l="        println!(&quot;Found an id in range: {}&quot;, id_variable)"></div><div data-l="    },"></div><div data-l="    Message::Hello { id: 10...12 } =&gt; {"></div><div data-l="        println!(&quot;Found an id in another range&quot;)"></div><div data-l="    },"></div><div data-l="    Message::Hello { id } =&gt; {"></div><div data-l="        println!(&quot;Found some other id: {}&quot;, id)"></div><div data-l="    },"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 18-32: Using <code>@</code> to bind to a value in a pattern while also testing it</span></span> <span class=caption>リスト18-32： <code>@</code>を使ってパターン内の値にバインドし、それをテストする</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This example will print <code>Found an id in range: 5</code> .</span>この例では<code>Found an id in range: 5</code>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">By specifying <code>id_variable @</code> before the range <code>3...7</code> , we&#39;re capturing whatever value matched the range while also testing that the value matched the range pattern.</span>指定することにより、 <code>id_variable @</code>範囲の前に<code>3...7</code> 、我々はまた、値が範囲のパターンと一致したことをテストしながら範囲をマッチしたどのような値獲得しています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In the second arm, where we only have a range specified in the pattern, the code associated with the arm doesn&#39;t have a variable that contains the actual value of the <code>id</code> field.</span>パターンに指定された範囲のみを持つ第2の腕では、腕に関連付けられたコードに<code>id</code>フィールドの実際の値を含む変数はありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>id</code> field&#39;s value could have been 10, 11, or 12, but the code that goes with that pattern doesn&#39;t know which it is.</span> <code>id</code>フィールドの値は10,11、または12であった可能性がありますが、そのパターンに含まれるコードは、そのコードがどれであるかわかりません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The pattern code isn&#39;t able to use the value from the <code>id</code> field, because we haven&#39;t saved the <code>id</code> value in a variable.</span>変数に<code>id</code>値を保存していないため、パターンコードは<code>id</code>フィールドの値を使用できません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In the last arm, where we&#39;ve specified a variable without a range, we do have the value available to use in the arm&#39;s code in a variable named <code>id</code> .</span>最後の腕では、範囲を持たない変数を指定していますが、腕のコードで<code>id</code>という名前の変数で使用できる値があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The reason is that we&#39;ve used the struct field shorthand syntax.</span>その理由は、構造体フィールドの短縮形構文を使用したためです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But we haven&#39;t applied any test to the value in the <code>id</code> field in this arm, as we did with the first two arms: any value would match this pattern.</span>しかし、最初の2つのアームで行ったように、このアームの<code>id</code>フィールドの値にはテストを適用していません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Using <code>@</code> lets us test a value and save it in a variable within one pattern.</span> <code>@</code>使用すると、値をテストして1つのパターン内の変数に保存できます。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Summary</span>概要</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust&#39;s patterns are very useful in that they help distinguish between different kinds of data.</span> Rustのパターンは、さまざまな種類のデータを区別するのに役立ちます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When used in <code>match</code> expressions, Rust ensures your patterns cover every possible value, or your program won&#39;t compile.</span> <code>match</code>式で使用する<code>match</code> 、Rustはパターンがすべての可能な値をカバーすることを保証します。そうしないと、プログラムはコンパイルされません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Patterns in <code>let</code> statements and function parameters make those constructs more useful, enabling the destructuring of values into smaller parts at the same time as assigning to variables.</span> <code>let</code>文と関数パラメータのパターンは<code>let</code>これらの構文をより便利にし、変数への代入と同時に小さな部分への値の破壊を可能にします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can create simple or complex patterns to suit our needs.</span>私たちは、私たちのニーズに合ったシンプルまたは複雑なパターンを作成できます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Next, for the penultimate chapter of the book, we&#39;ll look at some advanced aspects of a variety of Rust&#39;s features.</span>次に、本の最後から2番目の章について、さまざまなRustの機能のいくつかの高度な側面を見ていきます。</span> </p><script>_addload(function(){_setupIW('com');_csi('en','ja','ch18-03-pattern-syntax.html');});</script>