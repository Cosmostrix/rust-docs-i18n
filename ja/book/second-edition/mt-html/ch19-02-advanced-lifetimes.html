<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180709_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=ch19-02-advanced-lifetimes.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Advanced Lifetimes</span>高度なライフタイム</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In Chapter 10 in the “Validating References with Lifetimes” section, you learned how to annotate references with lifetime parameters to tell Rust how lifetimes of different references relate.</span>第10章の「寿命を持つ参照の検証」の節では、寿命のパラメータで参照に注釈を付けて、異なる参照の寿命がどのように関連しているかをRustに伝える方法を学習しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You saw how every reference has a lifetime, but most of the time, Rust will let you elide lifetimes.</span>あなたはすべてのリファレンスがどのように生涯を持っているかを見ましたが、ほとんどの場合、Rustは寿命を延ばすことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now we&#39;ll look at three advanced features of lifetimes that we haven&#39;t covered yet:</span>ここではまだ説明していない生涯の3つの高度な機能を見ていきます。</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Lifetime subtyping: ensures that one lifetime outlives another lifetime</span>生涯サブタイプ化：ある生涯が他の生涯よりも長生きすることを保証する</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Lifetime bounds: specifies a lifetime for a reference to a generic type</span>有効期間：汎用タイプへの参照の有効期間を指定します。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Inference of trait object lifetimes: allows the compiler to infer trait object lifetimes and when they need to be specified</span>特性オブジェクトの寿命の推論：コンパイラは特性オブジェクトの寿命を推測することができ、指定が必要な場合</span> </div><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Ensuring One Lifetime Outlives Another with Lifetime Subtyping</span> 1つの生涯が生涯のサブタイプでもう一方の生存を失うことを保証する</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><i>Lifetime subtyping</i> specifies that one lifetime should outlive another lifetime.</span> <i>生涯サブタイピング</i>は、ある生涯が別の生涯を生き延びるべきであることを指定します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To explore lifetime subtyping, imagine we want to write a parser.</span>生涯サブタイプを調べるには、パーサーを作成したいと考えてください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll use a structure called <code>Context</code> that holds a reference to the string we&#39;re parsing.</span>私たちは解析している文字列への参照を保持する<code>Context</code>という構造体を使います。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll write a parser that will parse this string and return success or failure.</span>この文字列を解析して成功または失敗を返すパーサーを作成します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The parser will need to borrow the <code>Context</code> to do the parsing.</span>パーサーは、構文解析を行うために<code>Context</code>を借りる必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 19-12 implements this parser code, except the code doesn&#39;t have the required lifetime annotations, so it won&#39;t compile.</span>コードリスト19-12はこのパーサー・コードを実装していますが、コードには必要な有効期間の注釈がないため、コンパイルされません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/lib.rs</span></span> <span class=filename>ファイル名：src / lib.rs</span></span> </p><br><div data-lang=rust,ignore><div data-l="struct Context(&amp;str);"></div><div data-l=""></div><div data-l="struct Parser {"></div><div data-l="    context: &amp;Context,"></div><div data-l=}></div><div data-l=""></div><div data-l="impl Parser {"></div><div data-l="    fn parse(&amp;self) -&gt; Result&lt;(), &amp;str&gt; {"></div><div data-l="        Err(&amp;self.context.0[1..])"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 19-12: Defining a parser without lifetime annotations</span></span> <span class=caption>リスト19-12：生涯アノテーションを持たないパーサーの定義</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Compiling the code results in errors because Rust expects lifetime parameters on the string slice in <code>Context</code> and the reference to a <code>Context</code> in <code>Parser</code> .</span>エラーのコード結果をコンパイル錆は文字列のスライスに寿命パラメータを受け取るため<code>Context</code>とを参照する<code>Context</code>で<code>Parser</code> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For simplicity&#39;s sake, the <code>parse</code> function returns <code>Result&lt;(), &amp;str&gt;</code> .</span>簡単にするために、 <code>parse</code>関数は<code>Result&lt;(), &amp;str&gt;</code>返します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That is, the function will do nothing on success and, on failure, will return the part of the string slice that didn&#39;t parse correctly.</span>つまり、関数は成功すると何もせず、失敗した場合、正しく解析されなかった文字列スライスの部分を返します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A real implementation would provide more error information and would return a structured data type when parsing succeeds.</span>実際の実装では、より多くのエラー情報が提供され、解析に成功すると構造化データ型が返されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We won&#39;t be discussing those details because they aren&#39;t relevant to the lifetimes part of this example.</span>これらの詳細については、この例の寿命の一部には関係しないため、説明しません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To keep this code simple, we won&#39;t write any parsing logic.</span>このコードを単純にするために、解析ロジックを記述しません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, it&#39;s very likely that somewhere in the parsing logic we would handle invalid input by returning an error that references the part of the input that is invalid;</span>しかし、構文解析ロジックのどこかで、入力の無効な部分を参照するエラーを返すことで無効な入力を処理する可能性が非常に高いです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">this reference is what makes the code example interesting in regard to lifetimes.</span>このリファレンスは、コード例を生涯に関して面白くするものです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s pretend that the logic of our parser is that the input is invalid after the first byte.</span>最初のバイトの後に入力が無効であるということをパーサーのロジックから推測しましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that this code might panic if the first byte is not on a valid character boundary;</span>最初のバイトが有効な文字境界にない場合、このコードはパニックになる可能性があることに注意してください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">again, we&#39;re simplifying the example to focus on the lifetimes involved.</span>再び、私たちは関係する生涯に焦点を当てるために例を単純化しています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To get this code to compile, we need to fill in the lifetime parameters for the string slice in <code>Context</code> and the reference to the <code>Context</code> in <code>Parser</code> .</span>このコードをコンパイルするには、 <code>Context</code> sliceスライスの有効期間パラメータと<code>Parser</code>の<code>Context</code>への参照を入力する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The most straightforward way to do this is to use the same lifetime name everywhere, as shown in Listing 19-13.</span>これを行う最も簡単な方法は、リスト19-13に示すように、すべての生涯同じ名前を使用することです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Recall from the “Lifetime Annotations in Struct Definitions” section in Chapter 10 that each of <code>struct Context&lt;&#39;a&gt;</code> , <code>struct Parser&lt;&#39;a&gt;</code> , and <code>impl&lt;&#39;a&gt;</code> is declaring a new lifetime parameter.</span> <code>struct Context&lt;&#39;a&gt;</code> 、 <code>struct Parser&lt;&#39;a&gt;</code> 、および<code>impl&lt;&#39;a&gt;</code>が新しい生涯パラメータを宣言していることを第10章の「構造体定義における生涯の注釈」のセクションから思い出してください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">While their names happen to all be the same, the three lifetime parameters declared in this example aren&#39;t related.</span>彼らの名前はすべて同じになりますが、この例で宣言された3つの有効期間パラメータは関連していません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/lib.rs</span></span> <span class=filename>ファイル名：src / lib.rs</span></span> </p><br><div data-lang=rust><div data-l="struct Context&lt;'a&gt;(&amp;'a str);"></div><div data-l=""></div><div data-l="struct Parser&lt;'a&gt; {"></div><div data-l="    context: &amp;'a Context&lt;'a&gt;,"></div><div data-l=}></div><div data-l=""></div><div data-l="impl&lt;'a&gt; Parser&lt;'a&gt; {"></div><div data-l="    fn parse(&amp;self) -&gt; Result&lt;(), &amp;str&gt; {"></div><div data-l="        Err(&amp;self.context.0[1..])"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 19-13: Annotating all references in <code>Context</code> and <code>Parser</code> with lifetime parameters</span></span> <span class=caption>リスト19-13：ライフタイムパラメータを持つ<code>Context</code>と<code>Parser</code>すべての参照に注釈を付ける</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This code compiles just fine.</span>このコードはうまくコンパイルされます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It tells Rust that a <code>Parser</code> holds a reference to a <code>Context</code> with lifetime <code>&#39;a</code> and that <code>Context</code> holds a string slice that also lives as long as the reference to the <code>Context</code> in <code>Parser</code> .</span>それは、 <code>Parser</code>が生存期間<code>&#39;a</code>を持つ<code>Context</code>への参照を保持し、その<code>Context</code>が、 <code>Parser</code>の<code>Context</code>への参照と同じ長さの文字列スライスを保持していることをRustに伝えます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust&#39;s compiler error message stated that lifetime parameters were required for these references, and we&#39;ve now added lifetime parameters.</span> Rustのコンパイラエラーメッセージでは、これらの参照にライフタイムパラメータが必要であると述べ、ライフタイムパラメータを追加しました。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Next, in Listing 19-14, we&#39;ll add a function that takes an instance of <code>Context</code> , uses a <code>Parser</code> to parse that context, and returns what <code>parse</code> returns.</span>次に、リスト19-14で、 <code>Context</code>インスタンスを<code>Context</code> 、そのコンテキストを解析するために<code>Parser</code>を使用し、 <code>parse</code>が返すものを返す関数を追加します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This code doesn&#39;t quite work.</span>このコードはうまく動作しません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/lib.rs</span></span> <span class=filename>ファイル名：src / lib.rs</span></span> </p><br><div data-lang=rust,ignore><div data-l="fn parse_context(context: Context) -&gt; Result&lt;(), &amp;str&gt; {"></div><div data-l="    Parser { context: &amp;context }.parse()"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 19-14: An attempt to add a <code>parse_context</code> function that takes a <code>Context</code> and uses a <code>Parser</code></span></span> <span class=caption>リスト19-14： <code>Context</code>をとり、 <code>Parser</code>を使用する<code>parse_context</code>関数を追加しようとする試み</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We get two verbose errors when we try to compile the code with the addition of the <code>parse_context</code> function:</span> <code>parse_context</code>関数を追加してコードをコンパイルしようとすると、2つの冗長なエラーが発生します。</span> </p><br><div data-lang=text><div data-l="error[E0597]: borrowed value does not live long enough"></div><div data-l="  --&gt; src/lib.rs:14:5"></div><div data-l="   |"></div><div data-l="14 |     Parser { context: &amp;context }.parse()"></div><div data-l="   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ does not live long enough"></div><div data-l="15 | }"></div><div data-l="   | - temporary value only lives until here"></div><div data-l="   |"></div><div data-l="note: borrowed value must be valid for the anonymous lifetime #1 defined on the function body at 13:1..."></div><div data-l="  --&gt; src/lib.rs:13:1"></div><div data-l="   |"></div><div data-l="13 | / fn parse_context(context: Context) -&gt; Result&lt;(), &amp;str&gt; {"></div><div data-l="14 | |     Parser { context: &amp;context }.parse()"></div><div data-l="15 | | }"></div><div data-l="   | |_^"></div><div data-l=""></div><div data-l="error[E0597]: `context` does not live long enough"></div><div data-l="  --&gt; src/lib.rs:14:24"></div><div data-l="   |"></div><div data-l="14 |     Parser { context: &amp;context }.parse()"></div><div data-l="   |                        ^^^^^^^ does not live long enough"></div><div data-l="15 | }"></div><div data-l="   | - borrowed value only lives until here"></div><div data-l="   |"></div><div data-l="note: borrowed value must be valid for the anonymous lifetime #1 defined on the function body at 13:1..."></div><div data-l="  --&gt; src/lib.rs:13:1"></div><div data-l="   |"></div><div data-l="13 | / fn parse_context(context: Context) -&gt; Result&lt;(), &amp;str&gt; {"></div><div data-l="14 | |     Parser { context: &amp;context }.parse()"></div><div data-l="15 | | }"></div><div data-l="   | |_^"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These errors state that the <code>Parser</code> instance that is created and the <code>context</code> parameter live only until the end of the <code>parse_context</code> function.</span>これらのエラーは、作成された<code>Parser</code>インスタンスと<code>context</code>パラメータは、 <code>parse_context</code>関数が終了するまでのみ存在することを<code>parse_context</code>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But they both need to live for the entire lifetime of the function.</span>しかし、彼らはその機能の生涯にわたって生きる必要があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In other words, <code>Parser</code> and <code>context</code> need to <i>outlive</i> the entire function and be valid before the function starts as well as after it ends for all the references in this code to always be valid.</span>言い換えれば、 <code>Parser</code>および<code>context</code> 、このコード内のすべての参照が常に有効であるために、それが終了した後に機能が起動するだけでなく、前に全体の機能を<i>より長生き</i>して有効にする必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Parser</code> we&#39;re creating and the <code>context</code> parameter go out of scope at the end of the function, because <code>parse_context</code> takes ownership of <code>context</code> .</span> <code>parse_context</code>は<code>context</code>所有権を取るため、作成している<code>Parser</code>と<code>context</code>パラメータは、関数の最後で範囲外になり<code>context</code> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To figure out why these errors occur, let&#39;s look at the definitions in Listing 19-13 again, specifically the references in the signature of the <code>parse</code> method:</span>これらのエラーが発生する理由を理解するために、リスト19-13の定義を再度見てみましょう。具体的には、 <code>parse</code>メソッドのシグネチャ内の参照です。</span> </p><br><div data-lang=rust,ignore><div data-l="    fn parse(&amp;self) -&gt; Result&lt;(), &amp;str&gt; {"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Remember the elision rules?</span>エリージョンルールを覚えていますか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we annotate the lifetimes of the references rather than eliding, the signature would be as follows:</span>参照の寿命に注釈を付けるのではなく、注釈を付けると、その署名は次のようになります。</span> </p><br><div data-lang=rust,ignore><div data-l="    fn parse&lt;'a&gt;(&amp;'a self) -&gt; Result&lt;(), &amp;'a str&gt; {"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That is, the error part of the return value of <code>parse</code> has a lifetime that is tied to the lifetime of the <code>Parser</code> instance (that of <code>&amp;self</code> in the <code>parse</code> method signature).</span>つまり、 <code>parse</code>の戻り値のエラー部分は、 <code>Parser</code>インスタンス（ <code>parse</code>メソッドのシグネチャでは<code>&amp;self</code> ）の存続期間に関連付けられた存続期間を持ちます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That makes sense: the returned string slice references the string slice in the <code>Context</code> instance held by the <code>Parser</code> , and the definition of the <code>Parser</code> struct specifies that the lifetime of the reference to <code>Context</code> and the lifetime of the string slice that <code>Context</code> holds should be the same.</span>それは理にかなっています：返された文字列スライスは、 <code>Parser</code>保持する<code>Context</code>インスタンスの文字列sliceを参照し、 <code>Parser</code>構造体の定義は、 <code>Context</code>への参照の有効期間と<code>Context</code>が保持する文字列スライスの有効期間を同じ。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The problem is that the <code>parse_context</code> function returns the value returned from <code>parse</code> , so the lifetime of the return value of <code>parse_context</code> is tied to the lifetime of the <code>Parser</code> as well.</span>問題は、 <code>parse_context</code>関数が<code>parse</code>から返された値を返すことです。そのため、 <code>parse_context</code>の戻り値の<code>parse_context</code>期間は、 <code>Parser</code>の存続期間にも関連付けられます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But the <code>Parser</code> instance created in the <code>parse_context</code> function won&#39;t live past the end of the function (it&#39;s temporary), and <code>context</code> will go out of scope at the end of the function ( <code>parse_context</code> takes ownership of it).</span>しかし、 <code>parse_context</code>関数で作成された<code>Parser</code>インスタンスは、関数の最後を過ぎても<code>parse_context</code>ません（一時的です）。関数の終わりに<code>context</code>がスコープから外れます（ <code>parse_context</code>はその所有権を<code>parse_context</code>ます）。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust thinks we&#39;re trying to return a reference to a value that goes out of scope at the end of the function, because we annotated all the lifetimes with the same lifetime parameter.</span> Rustは、すべての生存時間に同じ生涯パラメータで注釈を付けたので、関数の終わりに範囲外になる値への参照を返そうとしていると考えています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The annotations told Rust the lifetime of the string slice that <code>Context</code> holds is the same as that of the lifetime of the reference to <code>Context</code> that <code>Parser</code> holds.</span>この注釈は、 <code>Context</code>が保持する文字列スライスの有効期間は、 <code>Parser</code>が保持する<code>Context</code>への参照の存続期間と同じであるとRustに語った。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>parse_context</code> function can&#39;t see that within the <code>parse</code> function, the string slice returned will outlive <code>Context</code> and <code>Parser</code> and that the reference <code>parse_context</code> returns refers to the string slice, not to <code>Context</code> or <code>Parser</code> .</span> <code>parse_context</code>関数は、 <code>parse</code>関数内で返される文字列sliceが<code>Context</code>および<code>Parser</code>よりも長くなり、参照<code>parse_context</code> returnsが<code>Context</code>または<code>Parser</code>ではなく文字列sliceを参照することを<code>parse_context</code>できません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">By knowing what the implementation of <code>parse</code> does, we know that the only reason the return value of <code>parse</code> is tied to the <code>Parser</code> instance is that it&#39;s referencing the <code>Parser</code> instance&#39;s <code>Context</code> , which is referencing the string slice.</span> <code>parse</code>の実装が何をするかを知ることで、 <code>parse</code>の戻り値が<code>Parser</code>インスタンスに結びついている唯一の理由は、 <code>Parser</code>インスタンスの<code>Context</code> （文字列sliceを参照している）を参照しているということです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So, it&#39;s really the lifetime of the string slice that <code>parse_context</code> needs to care about.</span>したがって、実際には、 <code>parse_context</code>が気にする必要がある文字列スライスの寿命です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We need a way to tell Rust that the string slice in <code>Context</code> and the reference to the <code>Context</code> in <code>Parser</code> have different lifetimes and that the return value of <code>parse_context</code> is tied to the lifetime of the string slice in <code>Context</code> .</span> <code>Context</code>の文字列スライスと<code>Parser</code>の<code>Context</code>への参照には異なる寿命があり、 <code>parse_context</code>の戻り値は<code>Context</code> stringスライスの存続時間に結びついているとRustに伝える必要があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">First, we&#39;ll try giving <code>Parser</code> and <code>Context</code> different lifetime parameters, as shown in Listing 19-15.</span>まず、リスト19-15に示すように、 <code>Parser</code>と<code>Context</code>異なる生涯パラメータを与えることを試みます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll use <code>&#39;s</code> and <code>&#39;c</code> as lifetime parameter names to clarify which lifetime goes with the string slice in <code>Context</code> and which goes with the reference to <code>Context</code> in <code>Parser</code> .</span> <code>&#39;s</code>と<code>&#39;c</code>を生涯のパラメータ名として使用して、 <code>Context</code>内の文字列スライスの存続期間と、 <code>Parser</code> <code>Context</code>への参照となる生存期間を明確にします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that this solution won&#39;t completely fix the problem, but it&#39;s a start.</span>このソリューションは問題を完全に解決するわけではありませんが、これが始まりです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll look at why this fix isn&#39;t sufficient when we try to compile.</span>コンパイルしようとすると、なぜこの修正が十分でないのかを見ていきます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/lib.rs</span></span> <span class=filename>ファイル名：src / lib.rs</span></span> </p><br><div data-lang=rust,ignore><div data-l="struct Context&lt;'s&gt;(&amp;'s str);"></div><div data-l=""></div><div data-l="struct Parser&lt;'c, 's&gt; {"></div><div data-l="    context: &amp;'c Context&lt;'s&gt;,"></div><div data-l=}></div><div data-l=""></div><div data-l="impl&lt;'c, 's&gt; Parser&lt;'c, 's&gt; {"></div><div data-l="    fn parse(&amp;self) -&gt; Result&lt;(), &amp;'s str&gt; {"></div><div data-l="        Err(&amp;self.context.0[1..])"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="fn parse_context(context: Context) -&gt; Result&lt;(), &amp;str&gt; {"></div><div data-l="    Parser { context: &amp;context }.parse()"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 19-15: Specifying different lifetime parameters for the references to the string slice and to <code>Context</code></span></span> <span class=caption>リスト19-15：文字列sliceと<code>Context</code>への参照のための異なる有効期間パラメータの指定</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ve annotated the lifetimes of the references in all the same places that we annotated them in Listing 19-13.</span>リスト19-13で注釈したのと同じ場所に、参照の存続期間を注釈しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But this time we used different parameters depending on whether the reference goes with the string slice or with <code>Context</code> .</span>しかし、今回はリファレンスが文字列スライスか<code>Context</code>かに応じて異なるパラメータを使用しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ve also added an annotation to the string slice part of the return value of <code>parse</code> to indicate that it goes with the lifetime of the string slice in <code>Context</code> .</span>また、文字列スライス部分に、 <code>parse</code>の戻り値の注釈を追加して、 <code>Context</code>内の文字列スライスの存続期間に入ることを示しました。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When we try to compile now, we get the following error:</span>今コンパイルしようとすると、次のエラーが発生します。</span> </p><br><div data-lang=text><div data-l="error[E0491]: in type `&amp;'c Context&lt;'s&gt;`, reference has a longer lifetime than the data it references"></div><div data-l=" --&gt; src/lib.rs:4:5"></div><div data-l="  |"></div><div data-l="4 |     context: &amp;'c Context&lt;'s&gt;,"></div><div data-l="  |     ^^^^^^^^^^^^^^^^^^^^^^^^"></div><div data-l="  |"></div><div data-l="note: the pointer is valid for the lifetime 'c as defined on the struct at 3:1"></div><div data-l=" --&gt; src/lib.rs:3:1"></div><div data-l="  |"></div><div data-l="3 | / struct Parser&lt;'c, 's&gt; {"></div><div data-l="4 | |     context: &amp;'c Context&lt;'s&gt;,"></div><div data-l="5 | | }"></div><div data-l="  | |_^"></div><div data-l="note: but the referenced data is only valid for the lifetime 's as defined on the struct at 3:1"></div><div data-l=" --&gt; src/lib.rs:3:1"></div><div data-l="  |"></div><div data-l="3 | / struct Parser&lt;'c, 's&gt; {"></div><div data-l="4 | |     context: &amp;'c Context&lt;'s&gt;,"></div><div data-l="5 | | }"></div><div data-l="  | |_^"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust doesn&#39;t know of any relationship between <code>&#39;c</code> and <code>&#39;s</code> .</span>錆は<code>&#39;c</code>と<code>&#39;s</code>関係を知らない。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To be valid, the referenced data in <code>Context</code> with lifetime <code>&#39;s</code> needs to be constrained to guarantee that it lives longer than the reference with lifetime <code>&#39;c</code> .</span>有効な、参照されるデータであるために<code>Context</code>寿命を持つ<code>&#39;s</code> 、それは長い寿命を持つ基準より住んでいることを保証するように制限する必要が<code>&#39;c</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If <code>&#39;s</code> is not longer than <code>&#39;c</code> , the reference to <code>Context</code> might not be valid.</span> <code>&#39;s</code>が<code>&#39;c</code>より長くない場合は、 <code>Context</code>への参照が有効でない可能性があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now we get to the point of this section: the Rust feature <i>lifetime subtyping</i> specifies that one lifetime parameter lives at least as long as another one.</span>ここでは、このセクションのポイントについて説明します。Rust機能の<i>ライフタイムサブタイプで</i>は、1つの有効期間パラメータが少なくとも別の有効期間パラメータと同じ長さであることが指定されています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In the angle brackets where we declare lifetime parameters, we can declare a lifetime <code>&#39;a</code> as usual and declare a lifetime <code>&#39;b</code> that lives at least as long as <code>&#39;a</code> by declaring <code>&#39;b</code> using the syntax <code>&#39;b: &#39;a</code> .</span>私たちは一生のパラメータを宣言角括弧では、我々は生涯を宣言することができます<code>&#39;a</code>いつものように、寿命を宣言<code>&#39;b</code> 、少なくとも限り、住ん<code>&#39;a</code>宣言することにより、 <code>&#39;b</code>の構文を使用して<code>&#39;b: &#39;a</code> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In our definition of <code>Parser</code> , to say that <code>&#39;s</code> (the lifetime of the string slice) is guaranteed to live at least as long as <code>&#39;c</code> (the lifetime of the reference to <code>Context</code> ), we change the lifetime declarations to look like this:</span>当社の定義では<code>Parser</code> 、と言うこと<code>&#39;s</code> （文字列スライスの寿命）は、少なくとも限り生きることが保証されて<code>&#39;c</code> （参照の寿命<code>Context</code> ）、私たちはこのように見えるように生涯の宣言を変更します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/lib.rs</span></span> <span class=filename>ファイル名：src / lib.rs</span></span> </p><br><div data-lang=rust><div data-l="# struct Context&lt;'a&gt;(&amp;'a str);"></div><div data-l=#></div><div data-l="struct Parser&lt;'c, 's: 'c&gt; {"></div><div data-l="    context: &amp;'c Context&lt;'s&gt;,"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now the reference to <code>Context</code> in the <code>Parser</code> and the reference to the string slice in the <code>Context</code> have different lifetimes;</span>今を参照する<code>Context</code>で<code>Parser</code>との文字列のスライスを参照する<code>Context</code>異なる寿命を有します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">we&#39;ve ensured that the lifetime of the string slice is longer than the reference to the <code>Context</code> .</span>文字列スライスの存続期間が<code>Context</code>への参照よりも長くなるようにしました。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That was a very long-winded example, but as we mentioned at the start of this chapter, Rust&#39;s advanced features are very specific.</span>それは非常に長年にわたる例でしたが、この章の冒頭で述べたように、Rustの高度な機能は非常に特殊です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You won&#39;t often need the syntax we described in this example, but in such situations, you&#39;ll know how to refer to something and give it the necessary lifetime.</span>この例で説明した構文はしばしば必要ではありませんが、そのような状況では、何かを参照して必要な生涯を与える方法を知っています。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Lifetime Bounds on References to Generic Types</span>一般的な型への参照における永続的な境界</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In the “Trait Bounds” section in Chapter 10, we discussed using trait bounds on generic types.</span>第10章の「Trait Bounds」セクションでは、ジェネリック型の特性境界の使用について説明しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can also add lifetime parameters as constraints on generic types;</span>また、生涯パラメータをジェネリック型の制約として追加することもできます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">these are called <i>lifetime bounds</i> .</span>これらは<i>生涯の境界</i>と呼ばれ<i>ます</i> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Lifetime bounds help Rust verify that references in generic types won&#39;t outlive the data they&#39;re referencing.</span>生涯の境界は、Rustがジェネリック型の参照が、参照しているデータよりも長く残らないことを確認します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As an example, consider a type that is a wrapper over references.</span>例として、参照の上にラッパーである型を考えてみましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Recall the <code>RefCell&lt;T&gt;</code> type from the “ <code>RefCell&lt;T&gt;</code> and the Interior Mutability Pattern” section in Chapter 15: its <code>borrow</code> and <code>borrow_mut</code> methods return the types <code>Ref</code> and <code>RefMut</code> , respectively.</span>思い出して<code>RefCell&lt;T&gt;</code> 「からタイプを<code>RefCell&lt;T&gt;</code>第15章及びインテリア可変性パターン」セクション：その<code>borrow</code>と<code>borrow_mut</code>方法は種類戻り<code>Ref</code>及び<code>RefMut</code>それぞれ。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These types are wrappers over references that keep track of the borrowing rules at runtime.</span>これらの型は、実行時に借用ルールを追跡する参照の上のラッパーです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The definition of the <code>Ref</code> struct is shown in Listing 19-16, without lifetime bounds for now.</span> <code>Ref</code>構造体の定義は、リスト19-16に示されていますが、現在は生涯の境界はありません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/lib.rs</span></span> <span class=filename>ファイル名：src / lib.rs</span></span> </p><br><div data-lang=rust,ignore><div data-l="struct Ref&lt;'a, T&gt;(&amp;'a T);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 19-16: Defining a struct to wrap a reference to a generic type, without lifetime bounds</span></span> <span class=caption>リスト19-16：生涯の境界を持たないジェネリック型への参照をラップする構造体の定義</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Without explicitly constraining the lifetime <code>&#39;a</code> in relation to the generic parameter <code>T</code> , Rust will error because it doesn&#39;t know how long the generic type <code>T</code> will live:</span>明示的にジェネリックパラメータ<code>T</code>に関連して生存時間<code>&#39;a</code>制約することなく、ジェネリック型<code>T</code>がどれくらい長く存続するかを知らないため、Rustはエラーになります：</span> </p><br><div data-lang=text><div data-l="error[E0309]: the parameter type `T` may not live long enough"></div><div data-l=" --&gt; src/lib.rs:1:19"></div><div data-l="  |"></div><div data-l="1 | struct Ref&lt;'a, T&gt;(&amp;'a T);"></div><div data-l="  |                   ^^^^^^"></div><div data-l="  |"></div><div data-l="  = help: consider adding an explicit lifetime bound `T: 'a`..."></div><div data-l="note: ...so that the reference type `&amp;'a T` does not outlive the data it points at"></div><div data-l=" --&gt; src/lib.rs:1:19"></div><div data-l="  |"></div><div data-l="1 | struct Ref&lt;'a, T&gt;(&amp;'a T);"></div><div data-l="  |                   ^^^^^^"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because <code>T</code> can be any type, <code>T</code> could be a reference or a type that holds one or more references, each of which could have their own lifetimes.</span> <code>T</code>は任意の型であることができるので、 <code>T</code>は参照または1つ以上の参照を保持する型であり、それぞれが独自の生存期間を持つことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust can&#39;t be sure <code>T</code> will live as long as <code>&#39;a</code> .</span>錆は、 <code>T</code>が<code>&#39;a</code>ように生き続けることを確信することはできません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Fortunately, the error provides helpful advice on how to specify the lifetime bound in this case:</span>幸いにも、このエラーは、この場合に生存期間を指定する方法に関する有用なアドバイスを提供します：</span> </p><br><div data-lang=text><div data-l="consider adding an explicit lifetime bound `T: 'a` so that the reference type"></div><div data-l="`&amp;'a T` does not outlive the data it points at"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 19-17 shows how to apply this advice by specifying the lifetime bound when we declare the generic type <code>T</code> .</span>リスト19-17は、ジェネリック・タイプ<code>T</code>を宣言したときに存続時間を指定することによって、このアドバイスを適用する方法を示しています。</span> </p><br><div data-lang=rust><div data-l="struct Ref&lt;'a, T: 'a&gt;(&amp;'a T);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 19-17: Adding lifetime bounds on <code>T</code> to specify that any references in <code>T</code> live at least as long as <code>&#39;a</code></span></span> <span class=caption>リスト19-17： <code>T</code>に生涯の境界を追加して、 <code>T</code>内のすべての参照が少なくとも<code>&#39;a</code></span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This code now compiles because the <code>T: &#39;a</code> syntax specifies that <code>T</code> can be any type, but if it contains any references, the references must live at least as long as <code>&#39;a</code> .</span>このコードはコンパイルされるようになりました。なぜなら、 <code>T: &#39;a</code>構文では<code>T</code>は任意の型であることが指定されていますが、参照が含まれていれば、参照は少なくとも<code>&#39;a</code> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We could solve this problem in a different way, as shown in the definition of a <code>StaticRef</code> struct in Listing 19-18, by adding the <code>&#39;static</code> lifetime bound on <code>T</code> .</span>リスト19-18の<code>StaticRef</code>構造体の定義で示されているように、 <code>T</code>バインドされた<code>&#39;static</code>有効期間を追加することで、この問題を別の方法で解決できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This means if <code>T</code> contains any references, they must have the <code>&#39;static</code> lifetime.</span>つまり、 <code>T</code>に参照が含まれている場合は、 <code>&#39;static</code>有効期間が必要です。</span> </p><br><div data-lang=rust><div data-l="struct StaticRef&lt;T: 'static&gt;(&amp;'static T);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 19-18: Adding a <code>&#39;static</code> lifetime bound to <code>T</code> to constrain <code>T</code> to types that have only <code>&#39;static</code> references or no references</span></span> <span class=caption>リスト19-18： <code>&#39;static</code> <code>T</code>にバインドされた<code>&#39;static</code>有効期間を追加して、 <code>T</code>を<code>&#39;static</code>参照のみを持つ型または参照を持たない型に制約する</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because <code>&#39;static</code> means the reference must live as long as the entire program, a type that contains no references meets the criteria of all references living as long as the entire program (because there are no references).</span> <code>&#39;static</code>意味は、プログラム全体の長さである必要があります。参照が含まれていないタイプは、参照番号がないため、すべての参照の基準を満たしています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For the borrow checker concerned about references living long enough, there is no real distinction between a type that has no references and a type that has references that live forever: both are the same for determining whether or not a reference has a shorter lifetime than what it refers to.</span>十分な長さの生存参照に関するボローチェッカーについては、参照を持たない型と、永遠に生存する参照を持つ型との間には実質的な区別はない。参照が何よりも寿命が短いかどうかを判定するために同じであるそれは参照してください。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Inference of Trait Object Lifetimes</span>特性オブジェクトの寿命の推論</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In Chapter 17 in the “Using Trait Objects that Allow for Values of Different Types” section, we discussed trait objects, consisting of a trait behind a reference, that allow us to use dynamic dispatch.</span>第17章「異なる型の値を可能にする特性オブジェクトの使用」の項では、動的ディスパッチを使用できるようにする、参照の後ろの特性からなる特性オブジェクトについて説明しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We haven&#39;t yet discussed what happens if the type implementing the trait in the trait object has a lifetime of its own.</span>私たちは、特性オブジェクトの特性を実装する型がそれ自身の存続期間を有する場合に、何が起こるかについてまだ議論していない。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Consider Listing 19-19 where we have a trait <code>Red</code> and a struct <code>Ball</code> .</span>リスト19-19を考えてみましょう。ここでは、特性<code>Red</code>と構造<code>Ball</code>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Ball</code> struct holds a reference (and thus has a lifetime parameter) and also implements trait <code>Red</code> .</span> <code>Ball</code>構造体は参照を保持する（したがって寿命パラメータを持つ）とともに、特性<code>Red</code>実装します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We want to use an instance of <code>Ball</code> as the trait object <code>Box&lt;Red&gt;</code> .</span>私たちは、特性オブジェクト<code>Box&lt;Red&gt;</code>として<code>Ball</code>インスタンスを使用したいと考えています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="trait Red { }"></div><div data-l=""></div><div data-l="struct Ball&lt;'a&gt; {"></div><div data-l="    diameter: &amp;'a i32,"></div><div data-l=}></div><div data-l=""></div><div data-l="impl&lt;'a&gt; Red for Ball&lt;'a&gt; { }"></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let num = 5;"></div><div data-l=""></div><div data-l="    let obj = Box::new(Ball { diameter: &amp;num }) as Box&lt;Red&gt;;"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 19-19: Using a type that has a lifetime parameter with a trait object</span></span> <span class=caption>リスト19-19：寿命オブジェクトと型オブジェクトを持つ型の使用</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This code compiles without any errors, even though we haven&#39;t explicitly annotated the lifetimes involved in <code>obj</code> .</span>このコードは、 <code>obj</code>関係するライフタイムに明示的に注釈を付けていないとしても、エラーなしでコンパイルされます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This code works because there are rules for working with lifetimes and trait objects:</span>このコードは、生存期間と特性オブジェクトを扱うためのルールがあるため機能します。</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The default lifetime of a trait object is <code>&#39;static</code> .</span>特性オブジェクトのデフォルトの有効期間は<code>&#39;static</code>です。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">With <code>&amp;&#39;a Trait</code> or <code>&amp;&#39;a mut Trait</code> , the default lifetime of the trait object is <code>&#39;a</code> .</span> <code>&amp;&#39;a Trait</code> or <code>&amp;&#39;a mut Trait</code> traitを使うと、traitオブジェクトのデフォルトの有効期間は<code>&#39;a</code>ます。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">With a single <code>T: &#39;a</code> clause, the default lifetime of the trait object is <code>&#39;a</code> .</span> 1つの<code>T: &#39;a</code>句では、traitオブジェクトのデフォルトの有効期間は<code>&#39;a</code>です。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">With multiple clauses like <code>T: &#39;a</code> , there is no default lifetime;</span> <code>T: &#39;a</code>ような複数の句では、デフォルトの有効期間はありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">we must be explicit.</span>我々は明示的でなければならない。</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When we must be explicit, we can add a lifetime bound on a trait object like <code>Box&lt;Red&gt;</code> using the syntax <code>Box&lt;Red + &#39;static&gt;</code> or <code>Box&lt;Red + &#39;a&gt;</code> , depending on whether the reference lives for the entire program or not.</span>明示的にする必要がある場合、 <code>Box&lt;Red&gt;</code>ようなTraitオブジェクトに生存時間を追加するには、 <code>Box&lt;Red + &#39;static&gt;</code>または<code>Box&lt;Red + &#39;a&gt;</code>構文を使用します。か否か。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As with the other bounds, the syntax adding a lifetime bound means that any implementor of the <code>Red</code> trait that has references inside the type must have the same lifetime specified in the trait object bounds as those references.</span>他の境界と同様に、生涯の境界を追加する構文は、その型の中の参照を持つ<code>Red</code>型の実装者は、それらの参照と同じ型のオブジェクト境界で指定された同じ生存期間を持たなければならないことを意味します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Next, let&#39;s look at some other advanced features that manage traits.</span>次に、特性を管理するその他の高度な機能を見てみましょう。</span> </p><script>_addload(function(){_setupIW('com');_csi('en','ja','ch19-02-advanced-lifetimes.html');});</script>