<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180709_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=ch11-03-test-organization.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Test Organization</span>試験機関</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As mentioned at the start of the chapter, testing is a complex discipline, and different people use different terminology and organization.</span>この章の冒頭で述べたように、テストは複雑な規律であり、異なる人々は異なる用語と組織を使用します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The Rust community thinks about tests in terms of two main categories: <i>unit tests</i> and <i>integration tests</i> .</span> Rustコミュニティでは、 <i>ユニットテスト</i>と<i>インテグレーションテスト</i>という2つの主要カテゴリの観点からテストについて考えてい<i>ます</i> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Unit tests are small and more focused, testing one module in isolation at a time, and can test private interfaces.</span>単体テストは、小さくて集中的で、一度に1つのモジュールを単独でテストし、プライベートインタフェースをテストできます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Integration tests are entirely external to your library and use your code in the same way any other external code would, using only the public interface and potentially exercising multiple modules per test.</span>統合テストは完全にあなたのライブラリの外部にあり、他の外部コードと同じ方法でコードを使用します。パブリックインターフェイスのみを使用し、テストごとに複数のモジュールを実行する可能性があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Writing both kinds of tests is important to ensure that the pieces of your library are doing what you expect them to, separately and together.</span>両方の種類のテストを書くことは、あなたのライブラリの断片があなたが期待することを、個別に、そして一緒に行うことを確実にするために重要です。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Unit Tests</span>単体テスト</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The purpose of unit tests is to test each unit of code in isolation from the rest of the code to quickly pinpoint where code is and isn&#39;t working as expected.</span>単体テストの目的は、コードの各単位を他のコードと孤立してテストして、コードがどこにあるかを素早く特定し、期待どおりに動作しないようにすることです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You&#39;ll put unit tests in the <i>src</i> directory in each file with the code that they&#39;re testing.</span>それぞれのファイルの<i>src</i>ディレクトリに単体テストを、テストしているコードとともに入れます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The convention is to create a module named <code>tests</code> in each file to contain the test functions and to annotate the module with <code>cfg(test)</code> .</span>大会は、名前のモジュールを作成することです<code>tests</code>テスト機能を含むようにしてでモジュールに注釈を付けるために、各ファイル内<code>cfg(test)</code> 。</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The Tests Module and <code>#[cfg(test)]</code></span>テストモジュールと<code>#[cfg(test)]</code></span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>#[cfg(test)]</code> annotation on the tests module tells Rust to compile and run the test code only when you run <code>cargo test</code> , not when you run <code>cargo build</code> .</span>テストモジュールの<code>#[cfg(test)]</code>注釈は、 <code>cargo build</code>を実行するときではなく、 <code>cargo test</code>を実行するときにのみテストコードをコンパイルして実行するようRustに指示します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This saves compile time when you only want to build the library and saves space in the resulting compiled artifact because the tests are not included.</span>これにより、ライブラリが構築され、結果としてコンパイルされた成果物にスペースが節約されるだけで、テストが含まれないためコンパイル時間が節約されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You&#39;ll see that because integration tests go in a different directory, they don&#39;t need the <code>#[cfg(test)]</code> annotation.</span>統合テストは別のディレクトリにあるので、 <code>#[cfg(test)]</code>注釈は必要ありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, because unit tests go in the same files as the code, you&#39;ll use <code>#[cfg(test)]</code> to specify that they shouldn&#39;t be included in the compiled result.</span>しかし、単体テストはコードと同じファイルに格納されるため、 <code>#[cfg(test)]</code>を使用してコンパイル結果に含めないように指定します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Recall that when we generated the new <code>adder</code> project in the first section of this chapter, Cargo generated this code for us:</span>この章の最初のセクションで新しい<code>adder</code>プロジェクトを生成したとき、Cargoがこのコードを生成したことを思い出してください：</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/lib.rs</span></span> <span class=filename>ファイル名：src / lib.rs</span></span> </p><br><div data-lang=rust><div data-l=#[cfg(test)]></div><div data-l="mod tests {"></div><div data-l="    #[test]"></div><div data-l="    fn it_works() {"></div><div data-l="        assert_eq!(2 + 2, 4);"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This code is the automatically generated test module.</span>このコードは自動的に生成されたテストモジュールです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The attribute <code>cfg</code> stands for <i>configuration</i> and tells Rust that the following item should only be included given a certain configuration option.</span>属性<code>cfg</code>は<i>構成</i>を表しており、特定の構成オプションを指定した場合にのみ、次の項目を含める<i>よう</i>に指示します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this case, the configuration option is <code>test</code> , which is provided by Rust for compiling and running tests.</span>この場合、構成オプションは<code>test</code> 。これは、 <code>test</code>コンパイルと実行のためにRustによって提供されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">By using the <code>cfg</code> attribute, Cargo compiles our test code only if we actively run the tests with <code>cargo test</code> .</span>使用することにより<code>cfg</code>属性を、カーゴは、我々は積極的にテストを実行する場合にのみ、我々のテストコードをコンパイルする<code>cargo test</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This includes any helper functions that might be within this module, in addition to the functions annotated with <code>#[test]</code> .</span>これには、 <code>#[test]</code>注釈を付けられた関数に加えて、このモジュール内にある任意のヘルパー関数が含まれます。</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Testing Private Functions</span>プライベート関数のテスト</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There&#39;s debate within the testing community about whether or not private functions should be tested directly, and other languages make it difficult or impossible to test private functions.</span>プライベート機能を直接テストする必要があるかどうか、また他の言語ではプライベート機能をテストすることが困難または不可能になるかどうかは、テストコミュニティ内で議論されています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Regardless of which testing ideology you adhere to, Rust&#39;s privacy rules do allow you to test private functions.</span>どのテストイデオロギーを遵守しているかに関係なく、Rustのプライバシールールではプライベート機能をテストできます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Consider the code in Listing 11-12 with the private function <code>internal_adder</code> .</span>リスト11-12のコードをprivate関数<code>internal_adder</code>使って考えてみましょう。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/lib.rs</span></span> <span class=filename>ファイル名：src / lib.rs</span></span> </p><br><div data-lang=rust><div data-l="pub fn add_two(a: i32) -&gt; i32 {"></div><div data-l="    internal_adder(a, 2)"></div><div data-l=}></div><div data-l=""></div><div data-l="fn internal_adder(a: i32, b: i32) -&gt; i32 {"></div><div data-l="    a + b"></div><div data-l=}></div><div data-l=""></div><div data-l=#[cfg(test)]></div><div data-l="mod tests {"></div><div data-l="    use super::*;"></div><div data-l=""></div><div data-l="    #[test]"></div><div data-l="    fn internal() {"></div><div data-l="        assert_eq!(4, internal_adder(2, 2));"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 11-12: Testing a private function</span></span> <span class=caption>リスト11-12：プライベート関数のテスト</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that the <code>internal_adder</code> function is not marked as <code>pub</code> , but because tests are just Rust code and the <code>tests</code> module is just another module, you can import and call <code>internal_adder</code> in a test just fine.</span> <code>internal_adder</code>関数は<code>pub</code>としてマークされて<code>pub</code>ませんが、テストは錆コードだけで、 <code>tests</code>モジュールは単なる別のモジュールなので、 <code>internal_adder</code>をインポートして呼び出しても問題ありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you don&#39;t think private functions should be tested, there&#39;s nothing in Rust that will compel you to do so.</span>私的機能がテストされるべきだと思っていないなら、そうするように強制するRustには何もありません。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Integration Tests</span>統合テスト</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In Rust, integration tests are entirely external to your library.</span> Rustでは、統合テストは完全にあなたのライブラリの外部にあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">They use your library in the same way any other code would, which means they can only call functions that are part of your library&#39;s public API.</span>他のコードと同じ方法でライブラリを使用します。つまり、ライブラリの公開APIの一部である関数のみを呼び出すことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Their purpose is to test whether many parts of your library work together correctly.</span>その目的は、図書館の多くの部分が正しく連携しているかどうかをテストすることです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Units of code that work correctly on their own could have problems when integrated, so test coverage of the integrated code is important as well.</span>独自に正しく動作するコード単位では、統合されたときに問題が発生する可能性があるため、統合コードのテストカバレッジも重要です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To create integration tests, you first need a <i>tests</i> directory.</span>統合テストを作成するには、まず<i>テスト</i>ディレクトリが必要です。</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <i>tests</i> Directory</span> <i>テスト</i>ディレクトリ</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We create a <i>tests</i> directory at the top level of our project directory, next to <i>src</i> .</span>私たちはプロジェクトディレクトリの最上位に<i>srcの</i>隣に<i>tests</i>ディレクトリを作成し<i>ます</i> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Cargo knows to look for integration test files in this directory.</span> Cargoはこのディレクトリに統合テストファイルを探すことを知っています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can then make as many test files as we want to in this directory, and Cargo will compile each of the files as an individual crate.</span>次に、このディレクトリにいくつでもテストファイルを作成することができ、Cargoはそれぞれのファイルを個々のクレートとしてコンパイルします。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s create an integration test.</span>統合テストを作成しましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">With the code in Listing 11-12 still in the <i>src/lib.rs</i> file, make a <i>tests</i> directory, create a new file named <i>tests/integration_test.rs</i> , and enter the code in Listing 11-13.</span>リスト11-12のコードを<i>src / lib.rs</i>ファイルに<i>残し</i>て、 <i>tests</i>ディレクトリを作成し、 <i>tests / integration_test.rs</i>という名前の新しいファイルを作成し、リスト11-13のコードを入力します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: tests/integration_test.rs</span></span> <span class=filename>ファイル名：tests / integration_test.rs</span></span> </p><br><div data-lang=rust,ignore><div data-l="extern crate adder;"></div><div data-l=""></div><div data-l=#[test]></div><div data-l="fn it_adds_two() {"></div><div data-l="    assert_eq!(4, adder::add_two(2));"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 11-13: An integration test of a function in the <code>adder</code> crate</span></span> <span class=caption>リスト11-13： <code>adder</code>枠内の関数の統合テスト</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ve added <code>extern crate adder</code> at the top of the code, which we didn&#39;t need in the unit tests.</span>私たちはコードの先頭に<code>extern crate adder</code>を追加しました。これは単体テストでは不要でした。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The reason is that each test in the <code>tests</code> directory is a separate crate, so we need to import our library into each of them.</span>その理由は、 <code>tests</code>ディレクトリ内の各テストは個別のクレートであるため、それぞれにライブラリをインポートする必要があるからです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We don&#39;t need to annotate any code in <i>tests/integration_test.rs</i> with <code>#[cfg(test)]</code> .</span> <i>tests / integration_test.rs</i>内のコードに<code>#[cfg(test)]</code>注釈を付ける必要はありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Cargo treats the <code>tests</code> directory specially and compiles files in this directory only when we run <code>cargo test</code> .</span> Cargoは<code>tests</code>ディレクトリを特別に扱い、 <code>cargo test</code>を実行するときにのみこのディレクトリのファイルをコンパイルします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Run <code>cargo test</code> now:</span>今すぐ<code>cargo test</code>実行してください：</span> </p><br><div data-lang=text><div data-l="$ cargo test"></div><div data-l="   Compiling adder v0.1.0 (file:///projects/adder)"></div><div data-l="    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs"></div><div data-l="     Running target/debug/deps/adder-abcabcabc"></div><div data-l=""></div><div data-l="running 1 test"></div><div data-l="test tests::internal ... ok"></div><div data-l=""></div><div data-l="test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out"></div><div data-l=""></div><div data-l="     Running target/debug/deps/integration_test-ce99bcc2479f4607"></div><div data-l=""></div><div data-l="running 1 test"></div><div data-l="test it_adds_two ... ok"></div><div data-l=""></div><div data-l="test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out"></div><div data-l=""></div><div data-l="   Doc-tests adder"></div><div data-l=""></div><div data-l="running 0 tests"></div><div data-l=""></div><div data-l="test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The three sections of output include the unit tests, the integration test, and the doc tests.</span>出力の3つのセクションには、ユニットテスト、統合テスト、およびドキュメントテストが含まれます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The first section for the unit tests is the same as we&#39;ve been seeing: one line for each unit test (one named <code>internal</code> that we added in Listing 11-12) and then a summary line for the unit tests.</span>単体テストの最初のセクションは、見てきたものと同じです：単体テストごとに1行（リスト11-12で追加した名前の<code>internal</code> ）と単体テストの要約行。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The integration tests section starts with the line <code>Running target/debug/deps/integration-test-ce99bcc2479f4607</code> (the hash at the end of your output will be different).</span>統合テストセクションは、 <code>Running target/debug/deps/integration-test-ce99bcc2479f4607</code>という行で始まります（出力の最後のハッシュは異なります）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Next, there is a line for each test function in that integration test and a summary line for the results of the integration test just before the <code>Doc-tests adder</code> section starts.</span>次に、その統合テストの各テスト関数の行と、 <code>Doc-tests adder</code>セクションが開始する直前の統合テストの結果の要約行があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Similarly to how adding more unit test functions adds more result lines to the unit tests section, adding more test functions to the integration test file adds more result lines to this integration test file&#39;s section.</span>より多くの単体テスト機能を追加することでユニットテストセクションに結果ラインが追加されるのと同様に、より多くのテスト機能を統合テストファイルに追加することで、この統合テストファイルのセクションに多くの結果ラインが追加されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Each integration test file has its own section, so if we add more files in the <i>tests</i> directory, there will be more integration test sections.</span>各統合テストファイルには独自のセクションがあります。したがって、 <i>tests</i>ディレクトリにファイルを追加すると、より多くの統合テストセクションが作成されます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can still run a particular integration test function by specifying the test function&#39;s name as an argument to <code>cargo test</code> .</span> <code>cargo test</code>引数としてテスト関数の名前を指定することで、特定の統合テスト関数を実行することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To run all the tests in a particular integration test file, use the <code>--test</code> argument of <code>cargo test</code> followed by the name of the file:</span>特定の統合テストファイル内のすべてのテストを実行するには、 <code>cargo test</code> <code>--test</code>引数の後にファイルの名前を指定します。</span> </p><br><div data-lang=text><div data-l="$ cargo test --test integration_test"></div><div data-l="    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs"></div><div data-l="     Running target/debug/integration_test-952a27e0126bb565"></div><div data-l=""></div><div data-l="running 1 test"></div><div data-l="test it_adds_two ... ok"></div><div data-l=""></div><div data-l="test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This command runs only the tests in the <i>tests/integration_test.rs</i> file.</span>このコマンドは、 <i>tests / integration_test.rs</i>ファイル内の<i>テスト</i>のみを実行します。</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Submodules in Integration Tests</span>統合テストにおけるサブモジュール</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As you add more integration tests, you might want to make more than one file in the <i>tests</i> directory to help organize them;</span>より多くの統合テストを追加すると、 <i>テスト</i>ディレクトリに複数のファイルを作成して整理するのに役立つ場合があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">for example, you can group the test functions by the functionality they&#39;re testing.</span>たとえば、テスト機能をテストしている機能でグループ化できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As mentioned earlier, each file in the <i>tests</i> directory is compiled as its own separate crate.</span>先に述べたように、 <i>tests</i>ディレクトリ内の各ファイルは独自の別のクレートとしてコンパイルされます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Treating each integration test file as its own crate is useful to create separate scopes that are more like the way end users will be using your crate.</span>各統合テストファイルを独自のクレートとして扱うことは、エンドユーザーがあなたのクレートを使用する方法に似た別のスコープを作成するのに便利です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, this means files in the <i>tests</i> directory don&#39;t share the same behavior as files in <i>src</i> do, as you learned in Chapter 7 regarding how to separate code into modules and files.</span>しかし、これは、コードをモジュールとファイルに分割する方法については、第7章で学習したように、 <i>tests</i>ディレクトリのファイルは<i>srcの</i>ファイルと同じ動作を共有しないことを意味します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The different behavior of files in the <i>tests</i> directory is most noticeable when you have a set of helper functions that would be useful in multiple integration test files and you try to follow the steps in the “Moving Modules to Other Files” section of Chapter 7 to extract them into a common module.</span> <i>tests</i>ディレクトリ内のファイルの動作が異なるのは、複数の統合テストファイルで役立つ一連のヘルパ関数があり、第7章の「モジュールを他のファイルに移動する」の手順を実行しようとすると最も顕著になります。それらを共通のモジュールに抽出する。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, if we create <i>tests/common.rs</i> and place a function named <code>setup</code> in it, we can add some code to <code>setup</code> that we want to call from multiple test functions in multiple test files:</span>我々は<i>テスト/ common.rsを</i>作成し、という名前の関数配置する場合たとえば、 <code>setup</code>それには、我々はいくつかのコードを追加することができ<code>setup</code>我々は、複数のテストファイル内に複数のテスト関数から呼び出したいです：</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: tests/common.rs</span></span> <span class=filename>ファイル名：tests / common.rs</span></span> </p><br><div data-lang=rust><div data-l="pub fn setup() {"></div><div data-l="#    // setup code specific to your library's tests would go here"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">setup code specific to your library&#39;s tests would go here</span>あなたのライブラリのテストに固有のセットアップコードがここに入ります</span> </div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When we run the tests again, we&#39;ll see a new section in the test output for the <i>common.rs</i> file, even though this file doesn&#39;t contain any test functions nor did we call the <code>setup</code> function from anywhere:</span>テストをもう一度実行すると、 <i>common.rs</i>ファイルのテスト出力に新しいセクションが表示されます。ただし、このファイルにはテスト関数が含まれていなくても、どこからでも<code>setup</code>関数を呼び出すことはできません。</span> </p><br><div data-lang=text><div data-l="running 1 test"></div><div data-l="test tests::internal ... ok"></div><div data-l=""></div><div data-l="test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out"></div><div data-l=""></div><div data-l="     Running target/debug/deps/common-b8b07b6f1be2db70"></div><div data-l=""></div><div data-l="running 0 tests"></div><div data-l=""></div><div data-l="test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out"></div><div data-l=""></div><div data-l="     Running target/debug/deps/integration_test-d993c68b431d39df"></div><div data-l=""></div><div data-l="running 1 test"></div><div data-l="test it_adds_two ... ok"></div><div data-l=""></div><div data-l="test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out"></div><div data-l=""></div><div data-l="   Doc-tests adder"></div><div data-l=""></div><div data-l="running 0 tests"></div><div data-l=""></div><div data-l="test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Having <code>common</code> appear in the test results with <code>running 0 tests</code> displayed for it is not what we wanted.</span> <code>running 0 tests</code>表示し<code>running 0 tests</code>テスト結果に<code>common</code>表示させることは、私たちが望むものではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We just wanted to share some code with the other integration test files.</span>他の統合テストファイルといくつかのコードを共有したかっただけです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To avoid having <code>common</code> appear in the test output, instead of creating <i>tests/common.rs</i> , we&#39;ll create <i>tests/common/mod.rs</i> .</span> <i>tests / common.rs</i>を作成するのではなく、テスト出力に<code>common</code>表示させないために、 <i>tests / common / mod.rsを</i>作成し<i>ます</i> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In the “Rules of Module Filesystems” section of Chapter 7, we used the naming convention <i>module_name/mod.rs</i> for files of modules that have submodules.</span>第7章の「モジュールファイルシステムの規則」セクションでは、サブモジュールを持つモジュールのファイルに<i>module_name / mod.rs</i>という命名規則を使用しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We don&#39;t have submodules for <code>common</code> here, but naming the file this way tells Rust not to treat the <code>common</code> module as an integration test file.</span>ここでは<code>common</code>サブモジュールはありませんが、このようにファイルを命名すると、Rustは<code>common</code>モジュールを統合テストファイルとして扱わないように指示します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When we move the <code>setup</code> function code into <i>tests/common/mod.rs</i> and delete the <i>tests/common.rs</i> file, the section in the test output will no longer appear.</span> <code>setup</code>関数のコードを<i>tests / common / mod.rs</i>に移動して<i>tests / common.rs</i>ファイルを削除すると、テスト出力のセクションは表示されなくなります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Files in subdirectories of the <i>tests</i> directory don&#39;t get compiled as separate crates or have sections in the test output.</span> <i>tests</i>ディレクトリのサブディレクトリにあるファイルは、別々のファイルとしてコンパイルされたり、テスト出力にセクションがありません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">After we&#39;ve created <i>tests/common/mod.rs</i> , we can use it from any of the integration test files as a module.</span> <i>tests / common / mod.rs</i>を作成し<i>たら</i> 、これをモジュールとして統合テストファイルから使用できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here&#39;s an example of calling the <code>setup</code> function from the <code>it_adds_two</code> test in <i>tests/integration_test.rs</i> :</span>次に、 <i>tests / integration_test.rsの</i> <code>it_adds_two</code>テストから<code>setup</code>関数を呼び出す例を示し<code>setup</code> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: tests/integration_test.rs</span></span> <span class=filename>ファイル名：tests / integration_test.rs</span></span> </p><br><div data-lang=rust,ignore><div data-l="extern crate adder;"></div><div data-l=""></div><div data-l="mod common;"></div><div data-l=""></div><div data-l=#[test]></div><div data-l="fn it_adds_two() {"></div><div data-l="    common::setup();"></div><div data-l="    assert_eq!(4, adder::add_two(2));"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that the <code>mod common;</code></span>注意してください<code>mod common;</code></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">declaration is the same as the module declarations we demonstrated in Listing 7-4.</span>宣言はリスト7-4で示したモジュール宣言と同じです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then in the test function, we can call the <code>common::setup()</code> function.</span>次に、テスト関数では、 <code>common::setup()</code>関数を呼び出すことができます。</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Integration Tests for Binary Crates</span>バイナリクレートの統合テスト</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If our project is a binary crate that only contains a <i>src/main.rs</i> file and doesn&#39;t have a <i>src/lib.rs</i> file, we can&#39;t create integration tests in the <i>tests</i> directory and use <code>extern crate</code> to import functions defined in the <i>src/main.rs</i> file.</span>私たちのプロジェクトが<i>src / main.rs</i>ファイルのみを含み、 <i>src / lib.rs</i>ファイルを持たないバイナリの箱であれば、 <i>tests</i>ディレクトリに統合テストを作成し、 <code>extern crate</code> <i>crate</i>を使用して定義された関数をインポートすることはできません<i>src / main.rs</i>ファイル。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Only library crates expose functions that other crates can call and use;</span>ライブラリークレートのみが、他のクレートが呼び出して使用できる機能を公開します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">binary crates are meant to be run on their own.</span>バイナリ・クレートは、単独で実行されることを意図しています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is one of the reasons Rust projects that provide a binary have a straightforward <i>src/main.rs</i> file that calls logic that lives in the <i>src/lib.rs</i> file.</span>これは、バイナリを提供錆プロジェクトは<i>、SRC / lib.rsファイル</i>に住んでいるロジックを呼び出す簡単な<i>のsrc / main.rsファイル</i>を持っている理由の一つです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Using that structure, integration tests <i>can</i> test the library crate by using <code>extern crate</code> to exercise the important functionality.</span>その構造を使用して、インテグレーションテストで<i>は</i> 、 <code>extern crate</code>を使用して重要な機能を実行することによってライブラリクレートをテスト<i>でき</i>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If the important functionality works, the small amount of code in the <i>src/main.rs</i> file will work as well, and that small amount of code doesn&#39;t need to be tested.</span>重要な機能が動作する場合は、 <i>src / main.rs</i>ファイルの少量のコードも同様に動作し、少量のコードをテストする必要はありません。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Summary</span>概要</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust&#39;s testing features provide a way to specify how code should function to ensure it continues to work as you expect, even as you make changes.</span> Rustのテスト機能は、たとえ変更を加えたとしても、コードがどのように機能して期待通りに機能するかを指定する方法を提供します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Unit tests exercise different parts of a library separately and can test private implementation details.</span>単体テストはライブラリの別々の部分を個別に実行し、プライベートな実装の詳細をテストできます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Integration tests check that many parts of the library work together correctly, and they use the library&#39;s public API to test the code in the same way external code will use it.</span>統合テストでは、ライブラリの多くの部分が正しく連携していることを確認し、ライブラリのパブリックAPIを使用して、外部コードが使用するのと同じ方法でコードをテストします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Even though Rust&#39;s type system and ownership rules help prevent some kinds of bugs, tests are still important to reduce logic bugs having to do with how your code is expected to behave.</span> Rustのタイプのシステムと所有権のルールはいくつかの種類のバグを防ぐのに役立ちますが、テストがロジックバグを減らすためには、コードがどのように動作することが予想されるかに関係しています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s combine the knowledge you learned in this chapter and in previous chapters to work on a project!</span>この章で学んだ知識とこれまでの章で学んだ知識を組み合わせてプロジェクトを進めましょう！</span> </p><script>_addload(function(){_setupIW('com');_csi('en','ja','ch11-03-test-organization.html');});</script>