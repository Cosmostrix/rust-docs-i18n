<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180709_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=ch15-04-rc.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>Rc&lt;T&gt;</code> , the Reference Counted Smart Pointer</span> <code>Rc&lt;T&gt;</code> 、参照カウントされたスマートポインタ</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In the majority of cases, ownership is clear: you know exactly which variable owns a given value.</span>ほとんどの場合、所有権は明らかです。特定の変数がどの変数に属しているか正確に把握しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, there are cases when a single value might have multiple owners.</span>ただし、単一の値に複数の所有者が存在する場合があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, in graph data structures, multiple edges might point to the same node, and that node is conceptually owned by all of the edges that point to it.</span>例えば、グラフデータ構造では、複数のエッジが同じノードを指し、そのノードは、それを指すすべてのエッジによって概念的に所有される。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A node shouldn&#39;t be cleaned up unless it doesn&#39;t have any edges pointing to it.</span>エッジが指し示されていない限り、ノードをクリーンアップしないでください。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To enable multiple ownership, Rust has a type called <code>Rc&lt;T&gt;</code> , which is an abbreviation for <i>reference counting</i> .</span>複数の所有権を有効にするために、Rustには<code>Rc&lt;T&gt;</code>というタイプがあり<i>ます</i> 。これは<i>参照カウントの</i>略です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Rc&lt;T&gt;</code> type keeps track of the number of references to a value which determines whether or not a value is still in use.</span> <code>Rc&lt;T&gt;</code>型は、値がまだ使用されているかどうかを決定する値への参照の数を追跡します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If there are zero references to a value, the value can be cleaned up without any references becoming invalid.</span>値への参照がゼロの場合、参照が無効になることなく値をクリーンアップすることができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Imagine <code>Rc&lt;T&gt;</code> as a TV in a family room.</span>ファミリールームのテレビとして<code>Rc&lt;T&gt;</code>を想像してみてください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When one person enters to watch TV, they turn it on.</span>一人の人がテレビを見るために入ると、彼らはそれをオンにする。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Others can come into the room and watch the TV.</span>他の人が部屋に入ってテレビを見ることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When the last person leaves the room, they turn off the TV because it&#39;s no longer being used.</span>最後の人が部屋を離れると、もう使用されていないので、テレビがオフになります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If someone turns off the TV while others are still watching it, there would be uproar from the remaining TV watchers!</span>他の人がそれを見ている間に誰かがテレビをオフにすると、残りのテレビウォッチャーから騒ぎになるでしょう！</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We use the <code>Rc&lt;T&gt;</code> type when we want to allocate some data on the heap for multiple parts of our program to read and we can&#39;t determine at compile time which part will finish using the data last.</span>プログラムの複数の部分がヒープにあるデータを読み込みたいときは<code>Rc&lt;T&gt;</code>型を使い、最後にデータを使う部分をコンパイル時に決めることはできません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we knew which part would finish last, we could just make that part the data&#39;s owner, and the normal ownership rules enforced at compile time would take effect.</span>最後に終了する部分が分かっていれば、その部分をデータの所有者にして、コンパイル時に適用される通常の所有権ルールが有効になります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that <code>Rc&lt;T&gt;</code> is only for use in single-threaded scenarios.</span> <code>Rc&lt;T&gt;</code>はシングルスレッドのシナリオでのみ使用されることに注意してください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When we discuss concurrency in Chapter 16, we&#39;ll cover how to do reference counting in multithreaded programs.</span>第16章で並行性について議論するときは、マルチスレッドプログラムで参照カウントを行う方法について説明します。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Using <code>Rc&lt;T&gt;</code> to Share Data</span> <code>Rc&lt;T&gt;</code>を使用したデータの共有</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s return to our cons list example in Listing 15-5.</span>リスト15-5のconsリストの例に戻りましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Recall that we defined it using <code>Box&lt;T&gt;</code> .</span> <code>Box&lt;T&gt;</code>を使って定義したことを思い出してください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This time, we&#39;ll create two lists that both share ownership of a third list.</span>今回は、2つのリストを作成し、両方とも3つ目のリストの所有権を共有します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Conceptually, this looks similar to Figure 15-3:</span>概念的には、これは図15-3のようになります。</span> </p><br><p><img alt="3番目のリストの所有権を共有する2つのリスト" src=img/trpl15-03.svg class=center /></p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Figure 15-3: Two lists, <code>b</code> and <code>c</code> , sharing ownership of a third list, <code>a</code></span></span> <span class=caption>図15-3：3つのリストの所有権を共有する2つのリスト、 <code>b</code>と<code>c</code> 、 <code>a</code></span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll create list <code>a</code> that contains 5 and then 10. Then we&#39;ll make two more lists: <code>b</code> that starts with 3 and <code>c</code> that starts with 4. Both <code>b</code> and <code>c</code> lists will then continue on to the first <code>a</code> list containing 5 and 10. In other words, both lists will share the first list containing 5 and 10.</span>私たちは、リスト作成します<code>a</code> ：5、その後、10が含まれていますその後、我々はさらに2つのリストを作ってあげる<code>b</code> 3で始まり、 <code>c</code> 4両で始まり<code>b</code>と<code>c</code>リストは、最初に進みます5を含むリスト<code>a</code>つまり、両方のリストは、5と10を含む最初のリストを共有します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Trying to implement this scenario using our definition of <code>List</code> with <code>Box&lt;T&gt;</code> won&#39;t work, as shown in Listing 15-17:</span>リスト15-17に示すように、 <code>List</code> with <code>Box&lt;T&gt;</code>定義を使用してこのシナリオを実装しようとするとうまくいきません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust,ignore><div data-l="enum List {"></div><div data-l="    Cons(i32, Box&lt;List&gt;),"></div><div data-l="    Nil,"></div><div data-l=}></div><div data-l=""></div><div data-l="use List::{Cons, Nil};"></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let a = Cons(5,"></div><div data-l="        Box::new(Cons(10,"></div><div data-l="            Box::new(Nil))));"></div><div data-l="    let b = Cons(3, Box::new(a));"></div><div data-l="    let c = Cons(4, Box::new(a));"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 15-17: Demonstrating we&#39;re not allowed to have two lists using <code>Box&lt;T&gt;</code> that try to share ownership of a third list</span></span> <span class=caption>リスト15-17：3番目のリストの所有権を共有しようとする<code>Box&lt;T&gt;</code>を使って2つのリストを持つことができないことを示す</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When we compile this code, we get this error:</span>このコードをコンパイルすると、次のエラーが発生します。</span> </p><br><div data-lang=text><div data-l="error[E0382]: use of moved value: `a`"></div><div data-l="  --&gt; src/main.rs:13:30"></div><div data-l="   |"></div><div data-l="12 |     let b = Cons(3, Box::new(a));"></div><div data-l="   |                              - value moved here"></div><div data-l="13 |     let c = Cons(4, Box::new(a));"></div><div data-l="   |                              ^ value used here after move"></div><div data-l="   |"></div><div data-l="   = note: move occurs because `a` has type `List`, which does not implement"></div><div data-l="   the `Copy` trait"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Cons</code> variants own the data they hold, so when we create the <code>b</code> list, <code>a</code> is moved into <code>b</code> and <code>b</code> owns <code>a</code> .</span> <code>Cons</code>変異体は、彼らが保持するデータを所有しているので、私たちが作成したとき<code>b</code>リストを、 <code>a</code>に移動され<code>b</code>と<code>b</code>所有しています。 <code>a</code></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then, when we try to use <code>a</code> again when creating <code>c</code> , we&#39;re not allowed to because <code>a</code> has been moved.</span>我々が使用しようとすると、次に、作成するときに再び<code>a</code> <code>c</code>ので、我々はに許可されていない移動されました。 <code>a</code></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We could change the definition of <code>Cons</code> to hold references instead, but then we would have to specify lifetime parameters.</span> <code>Cons</code>の定義を代わりに参照を保持するように変更することもできますが、次に寿命パラメータを指定する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">By specifying lifetime parameters, we would be specifying that every element in the list will live at least as long as the entire list.</span>ライフタイムパラメータを指定することで、リスト内のすべての要素が少なくともリスト全体の長さで存続するように指定します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The borrow checker wouldn&#39;t let us compile <code>let a = Cons(10, &amp;Nil);</code></span>貸借チェッカーは、私たちにコンパイルを<code>let a = Cons(10, &amp;Nil);</code>ませんでし<code>let a = Cons(10, &amp;Nil);</code></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">for example, because the temporary <code>Nil</code> value would be dropped before <code>a</code> could take a reference to it.</span>たとえば、一時的な<code>Nil</code>値が削除されてから<code>a</code>がその値を参照<code>a</code>可能性があるからです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Instead, we&#39;ll change our definition of <code>List</code> to use <code>Rc&lt;T&gt;</code> in place of <code>Box&lt;T&gt;</code> , as shown in Listing 15-18.</span>リスト15-18に示すように、 <code>Box&lt;T&gt;</code>代わりに<code>Rc&lt;T&gt;</code>を使用するように<code>List</code>定義を変更します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Each <code>Cons</code> variant will now hold a value and an <code>Rc&lt;T&gt;</code> pointing to a <code>List</code> .</span>各<code>Cons</code>変形は、値を保持し、 <code>List</code>指す<code>Rc&lt;T&gt;</code>保持するようになりました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When we create <code>b</code> , instead of taking ownership of <code>a</code> , we&#39;ll clone the <code>Rc&lt;List&gt;</code> that <code>a</code> is holding, thereby increasing the number of references from one to two and letting <code>a</code> and <code>b</code> share ownership of the data in that <code>Rc&lt;List&gt;</code> .</span>私たちが作成した場合<code>b</code> 、代わりの所有権取る、我々はクローンます<code>a</code> <code>Rc&lt;List&gt;</code>こと、それによって1から2に参照の数を増やすとさせる、保持していると<code>a</code> <code>a</code> <code>b</code>点でのデータの共有所有権<code>Rc&lt;List&gt;</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll also clone <code>a</code> when creating <code>c</code> , increasing the number of references from two to three.</span> <code>c</code>作成<code>a</code>ときにもクローンを作成し、参照数を2から3に増やします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Every time we call <code>Rc::clone</code> , the reference count to the data within the <code>Rc&lt;List&gt;</code> will increase, and the data won&#39;t be cleaned up unless there are zero references to it.</span> <code>Rc::clone</code>を呼び出すたびに、 <code>Rc&lt;List&gt;</code>内のデータへの参照カウントが増加し、参照がゼロでない限りデータはクリーンアップされません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="enum List {"></div><div data-l="    Cons(i32, Rc&lt;List&gt;),"></div><div data-l="    Nil,"></div><div data-l=}></div><div data-l=""></div><div data-l="use List::{Cons, Nil};"></div><div data-l="use std::rc::Rc;"></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));"></div><div data-l="    let b = Cons(3, Rc::clone(&amp;a));"></div><div data-l="    let c = Cons(4, Rc::clone(&amp;a));"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 15-18: A definition of <code>List</code> that uses <code>Rc&lt;T&gt;</code></span></span> <span class=caption>リスト15-18： <code>Rc&lt;T&gt;</code>を使う<code>List</code>の定義</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We need to add a <code>use</code> statement to bring <code>Rc&lt;T&gt;</code> into scope because it&#39;s not in the prelude.</span> <code>Rc&lt;T&gt;</code>がプレリュードにないので、スコープに入れるために<code>use</code>ステートメントを追加する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In <code>main</code> , we create the list holding 5 and 10 and store it in a new <code>Rc&lt;List&gt;</code> in <code>a</code> .</span>では<code>main</code> 、我々は5と10を保持するリストを作成し、新しいに保管<code>Rc&lt;List&gt;</code>に。 <code>a</code></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then when we create <code>b</code> and <code>c</code> , we call the <code>Rc::clone</code> function and pass a reference to the <code>Rc&lt;List&gt;</code> in <code>a</code> as an argument.</span>私たちが作成するときに<code>b</code>と<code>c</code> 、我々は呼んで<code>Rc::clone</code>機能をとへの参照渡し<code>Rc&lt;List&gt;</code>に引数として。 <code>a</code></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We could have called <code>a.clone()</code> rather than <code>Rc::clone(&amp;a)</code> , but Rust&#39;s convention is to use <code>Rc::clone</code> in this case.</span> <code>Rc::clone(&amp;a)</code> <code>a.clone()</code>ではなく<code>a.clone()</code>ことができましたが、Rustのコンベンションはこの場合<code>Rc::clone</code>を使用することです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The implementation of <code>Rc::clone</code> doesn&#39;t make a deep copy of all the data like most types&#39; implementations of <code>clone</code> do.</span> <code>Rc::clone</code>の実装は、ほとんどのタイプのクローンドの実装のように、すべてのデータの完全なコピーを<code>clone</code>しません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The call to <code>Rc::clone</code> only increments the reference count, which doesn&#39;t take much time.</span> <code>Rc::clone</code>の呼び出しは参照カウントをインクリメントしますが、時間がかかりません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Deep copies of data can take a lot of time.</span>データの深いコピーには多くの時間がかかります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">By using <code>Rc::clone</code> for reference counting, we can visually distinguish between the deep-copy kinds of clones and the kinds of clones that increase the reference count.</span>リファレンスカウントに<code>Rc::clone</code>を使用することで、ディープコピーの種類のクローンと参照カウントを増加させるクローンの種類を視覚的に区別することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When looking for performance problems in the code, we only need to consider the deep-copy clones and can disregard calls to <code>Rc::clone</code> .</span>コード内のパフォーマンスの問題を探すときは、深いコピーのクローンを考慮するだけで、 <code>Rc::clone</code>への呼び出しを無視できます。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Cloning an <code>Rc&lt;T&gt;</code> Increases the Reference Count</span> <code>Rc&lt;T&gt;</code>クローンすると参照カウントが増加する</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s change our working example in Listing 15-18 so we can see the reference counts changing as we create and drop references to the <code>Rc&lt;List&gt;</code> in <code>a</code> .</span>リスト15-18の作業例を変更して、 <code>a</code> <code>Rc&lt;List&gt;</code>への参照を作成して削除するときに参照カウントが変化するのを見てみましょう。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In Listing 15-19, we&#39;ll change <code>main</code> so it has an inner scope around list <code>c</code> ;</span>リスト15-19では、 <code>main</code>を変更してリスト<code>c</code>内側にスコープを設定し<code>c</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">then we can see how the reference count changes when <code>c</code> goes out of scope.</span> <code>c</code>が範囲外になったときに参照カウントがどのように変化するかを見ることができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust><div data-l="# enum List {"></div><div data-l="#     Cons(i32, Rc&lt;List&gt;),"></div><div data-l="#     Nil,"></div><div data-l="# }"></div><div data-l=#></div><div data-l="# use List::{Cons, Nil};"></div><div data-l="# use std::rc::Rc;"></div><div data-l=#></div><div data-l="fn main() {"></div><div data-l="    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));"></div><div data-l="    println!(&quot;count after creating a = {}&quot;, Rc::strong_count(&amp;a));"></div><div data-l="    let b = Cons(3, Rc::clone(&amp;a));"></div><div data-l="    println!(&quot;count after creating b = {}&quot;, Rc::strong_count(&amp;a));"></div><div data-l="    {"></div><div data-l="        let c = Cons(4, Rc::clone(&amp;a));"></div><div data-l="        println!(&quot;count after creating c = {}&quot;, Rc::strong_count(&amp;a));"></div><div data-l="    }"></div><div data-l="    println!(&quot;count after c goes out of scope = {}&quot;, Rc::strong_count(&amp;a));"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 15-19: Printing the reference count</span></span> <span class=caption>リスト15-19：参照カウントを出力する</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">At each point in the program where the reference count changes, we print the reference count, which we can get by calling the <code>Rc::strong_count</code> function.</span>参照カウントが変化するプログラム内の各ポイントで、 <code>Rc::strong_count</code>関数を呼び出すことによって得られる参照カウントを<code>Rc::strong_count</code>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This function is named <code>strong_count</code> rather than <code>count</code> because the <code>Rc&lt;T&gt;</code> type also has a <code>weak_count</code> ;</span>この関数は、 <code>Rc&lt;T&gt;</code>型にも<code>weak_count</code>があるため、 <code>count</code>ではなく<code>strong_count</code>という名前に<code>weak_count</code>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">we&#39;ll see what <code>weak_count</code> is used for in the “Preventing Reference Cycles” section.</span> 「参照サイクルの防止」のセクションで<code>weak_count</code>がどのように使用されているのかが<code>weak_count</code>ます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This code prints the following:</span>このコードは、以下を出力します。</span> </p><br><div data-lang=text><div data-l="count after creating a = 1"></div><div data-l="count after creating b = 2"></div><div data-l="count after creating c = 3"></div><div data-l="count after c goes out of scope = 2"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can see that the <code>Rc&lt;List&gt;</code> in <code>a</code> has an initial reference count of 1;</span> <code>a</code> <code>Rc&lt;List&gt;</code>には初期参照カウントが1であることがわかります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">then each time we call <code>clone</code> , the count goes up by 1. When <code>c</code> goes out of scope, the count goes down by 1. We don&#39;t have to call a function to decrease the reference count like we have to call <code>Rc::clone</code> to increase the reference count: the implementation of the <code>Drop</code> trait decreases the reference count automatically when an <code>Rc&lt;T&gt;</code> value goes out of scope.</span> <code>clone</code>を呼び出すたびに、カウントは1ずつ増加します<code>c</code>が範囲外になると、カウントは1だけ下がります。参照カウントを減らす関数を呼び出す必要はありません<code>Rc::clone</code>を<code>Rc::clone</code>して参照カウントを増やす： <code>Rc&lt;T&gt;</code>値が有効範囲外になると、 <code>Drop</code>特性の実装によって参照カウントが自動的に減少します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">What we can&#39;t see in this example is that when <code>b</code> and then <code>a</code> go out of scope at the end of <code>main</code> , the count is then 0, and the <code>Rc&lt;List&gt;</code> is cleaned up completely at that point.</span>私たちは、この例では見ることができないことが行われているときに<code>b</code> 、その後の最後でスコープ外に行く<code>a</code> <code>main</code> 、カウントはその後、0であり、 <code>Rc&lt;List&gt;</code>その時点で完全にクリーンアップされます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Using <code>Rc&lt;T&gt;</code> allows a single value to have multiple owners, and the count ensures that the value remains valid as long as any of the owners still exist.</span> <code>Rc&lt;T&gt;</code>使用すると、単一の値に複数の所有者が存在することが可能になり、所有者が存在する限り、その値が有効であることが保証されます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Via immutable references, <code>Rc&lt;T&gt;</code> allows you to share data between multiple parts of your program for reading only.</span>不変の参照を介して、 <code>Rc&lt;T&gt;</code>はあなたのプログラムの複数の部分の間でデータを読んで共有することを可能にします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If <code>Rc&lt;T&gt;</code> allowed you to have multiple mutable references too, you might violate one of the borrowing rules discussed in Chapter 4: multiple mutable borrows to the same place can cause data races and inconsistencies.</span> <code>Rc&lt;T&gt;</code>にも複数の可変参照がある場合、第4章で説明した借用規則の1つに違反する可能性があります。同じ場所への複数の可変借用によってデータ競合と矛盾が発生する可能性があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But being able to mutate data is very useful!</span>しかし、データを突然変異させることは非常に便利です！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In the next section, we&#39;ll discuss the interior mutability pattern and the <code>RefCell&lt;T&gt;</code> type that you can use in conjunction with an <code>Rc&lt;T&gt;</code> to work with this immutability restriction.</span>次のセクションでは、この不変性の制約を<code>RefCell&lt;T&gt;</code>ために<code>Rc&lt;T&gt;</code>と共に使用できる内部変異パターンと<code>RefCell&lt;T&gt;</code>タイプについて説明します。</span> </p><script>_addload(function(){_setupIW('com');_csi('en','ja','ch15-04-rc.html');});</script>