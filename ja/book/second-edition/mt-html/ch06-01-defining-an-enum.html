<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180709_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=ch06-01-defining-an-enum.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Defining an Enum</span>列挙型の定義</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s look at a situation we might want to express in code and see why enums are useful and more appropriate than structs in this case.</span>この例では、コードで表現したいと思う状況を見て、列挙型が構造体よりも有用で適切な理由を見てみましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Say we need to work with IP addresses.</span> IPアドレスで作業する必要があるとします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Currently, two major standards are used for IP addresses: version four and version six.</span>現在、IPアドレスには、バージョン4とバージョン6の2つの主要な標準が使用されています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These are the only possibilities for an IP address that our program will come across: we can <i>enumerate</i> all possible values, which is where enumeration gets its name.</span>これらは、私たちのプログラムが遭遇するIPアドレスのための唯一の可能性です：列挙がその名前を取得するところのすべての可能な値を<i>列挙</i>することができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Any IP address can be either a version four or a version six address, but not both at the same time.</span>どのIPアドレスも、バージョン4またはバージョン6のいずれかのアドレスにすることができますが、同時に両方を使用することはできません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That property of IP addresses makes the enum data structure appropriate, because enum values can only be one of the variants.</span>列挙型の値は変種の1つに過ぎないため、IPアドレスのそのプロパティは列挙型のデータ構造を適切にします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Both version four and version six addresses are still fundamentally IP addresses, so they should be treated as the same type when the code is handling situations that apply to any kind of IP address.</span>バージョン4とバージョン6の両方のアドレスは、基本的にはIPアドレスなので、コードがあらゆる種類のIPアドレスに適用される状況を処理する場合、同じタイプとして扱う必要があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can express this concept in code by defining an <code>IpAddrKind</code> enumeration and listing the possible kinds an IP address can be, <code>V4</code> and <code>V6</code> .</span> <code>IpAddrKind</code>列挙を定義し、IPアドレスが<code>V4</code>と<code>V6</code>の可能な種類を列挙することで、この概念をコードで表現できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These are known as the <i>variants</i> of the enum:</span>これらは列挙<i>型の変種</i>として知られてい<i>ます</i> 。</span> </p><br><div data-lang=rust><div data-l="enum IpAddrKind {"></div><div data-l="    V4,"></div><div data-l="    V6,"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>IpAddrKind</code> is now a custom data type that we can use elsewhere in our code.</span> <code>IpAddrKind</code>は、コード内の他の場所でも使用できるカスタムデータ型になりました。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Enum Values</span>列挙型の値</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can create instances of each of the two variants of <code>IpAddrKind</code> like this:</span> <code>IpAddrKind</code>ように、 <code>IpAddrKind</code>の2つの変種それぞれのインスタンスを作成できます。</span> </p><br><div data-lang=rust><div data-l="# enum IpAddrKind {"></div><div data-l="#     V4,"></div><div data-l="#     V6,"></div><div data-l="# }"></div><div data-l=#></div><div data-l="let four = IpAddrKind::V4;"></div><div data-l="let six = IpAddrKind::V6;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that the variants of the enum are namespaced under its identifier, and we use a double colon to separate the two.</span>列挙型の変種はその識別子の下に名前空間があり、二重のコロンを使用してそれらを区切ることに注意してください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The reason this is useful is that now both values <code>IpAddrKind::V4</code> and <code>IpAddrKind::V6</code> are of the same type: <code>IpAddrKind</code> .</span>これが便利な理由は、 <code>IpAddrKind::V4</code>と<code>IpAddrKind::V6</code>両方の値が同じ型である<code>IpAddrKind</code>です。 <code>IpAddrKind</code>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can then, for instance, define a function that takes any <code>IpAddrKind</code> :</span>たとえば、 <code>IpAddrKind</code>をとる関数を定義することができ<code>IpAddrKind</code> 。</span> </p><br><div data-lang=rust><div data-l="# enum IpAddrKind {"></div><div data-l="#     V4,"></div><div data-l="#     V6,"></div><div data-l="# }"></div><div data-l=#></div><div data-l="fn route(ip_type: IpAddrKind) { }"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">And we can call this function with either variant:</span>そして、この関数をどちらかのバリエーションで呼び出すことができます：</span> </p><br><div data-lang=rust><div data-l="# enum IpAddrKind {"></div><div data-l="#     V4,"></div><div data-l="#     V6,"></div><div data-l="# }"></div><div data-l=#></div><div data-l="# fn route(ip_type: IpAddrKind) { }"></div><div data-l=#></div><div data-l=route(IpAddrKind::V4);></div><div data-l=route(IpAddrKind::V6);></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Using enums has even more advantages.</span>列挙型を使用するとさらに利点があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Thinking more about our IP address type, at the moment we don&#39;t have a way to store the actual IP address <i>data</i> ;</span>私たちのIPアドレスの種類についてもっと考えてみると、現時点では実際のIPアドレスの<i>データ</i>を格納する方法はありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">we only know what <i>kind</i> it is.</span>私たちはそれがどんな<i>種類</i>であるかだけを知っている。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Given that you just learned about structs in Chapter 5, you might tackle this problem as shown in Listing 6-1.</span>第5章で構造体について学んだことを考えると、リスト6-1に示すように、この問題に取り組む可能性があります。</span> </p><br><div data-lang=rust><div data-l="enum IpAddrKind {"></div><div data-l="    V4,"></div><div data-l="    V6,"></div><div data-l=}></div><div data-l=""></div><div data-l="struct IpAddr {"></div><div data-l="    kind: IpAddrKind,"></div><div data-l="    address: String,"></div><div data-l=}></div><div data-l=""></div><div data-l="let home = IpAddr {"></div><div data-l="    kind: IpAddrKind::V4,"></div><div data-l="    address: String::from(&quot;127.0.0.1&quot;),"></div><div data-l=};></div><div data-l=""></div><div data-l="let loopback = IpAddr {"></div><div data-l="    kind: IpAddrKind::V6,"></div><div data-l="    address: String::from(&quot;::1&quot;),"></div><div data-l=};></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 6-1: Storing the data and <code>IpAddrKind</code> variant of an IP address using a <code>struct</code></span></span> <span class=caption>リスト6-1： <code>struct</code>を使用してIPアドレスのdataおよび<code>IpAddrKind</code>バリアントを格納する</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here, we&#39;ve defined a struct <code>IpAddr</code> that has two fields: a <code>kind</code> field that is of type <code>IpAddrKind</code> (the enum we defined previously) and an <code>address</code> field of type <code>String</code> .</span>ここでは、構造体の定義した<code>IpAddr</code> 2つのフィールドを持っている<code>kind</code>のタイプであるフィールド<code>IpAddrKind</code> （私たちは前に定義された列挙型）と<code>address</code>タイプのフィールド<code>String</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We have two instances of this struct.</span>この構造体には2つのインスタンスがあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The first, <code>home</code> , has the value <code>IpAddrKind::V4</code> as its <code>kind</code> with associated address data of <code>127.0.0.1</code> .</span>最初の<code>home</code>は、その<code>kind</code>として<code>IpAddrKind::V4</code>という値を持ち、関連付けられたアドレスデータは<code>127.0.0.1</code>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The second instance, <code>loopback</code> , has the other variant of <code>IpAddrKind</code> as its <code>kind</code> value, <code>V6</code> , and has address <code>::1</code> associated with it.</span> 2番目のインスタンス<code>loopback</code>は、その<code>kind</code>値<code>V6</code>として<code>IpAddrKind</code>の別のバリアントを持ち、アドレス<code>::1</code>関連付けています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ve used a struct to bundle the <code>kind</code> and <code>address</code> values together, so now the variant is associated with the value.</span>構造体を使用して<code>kind</code>と<code>address</code>値をまとめて束縛しました。そのため、バリアントは値に関連付けられます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can represent the same concept in a more concise way using just an enum, rather than an enum inside a struct, by putting data directly into each enum variant.</span>構造体内の列挙型ではなく、単に列挙型を使用して、各列挙型バリアントに直接データを入れて、同じ概念をより簡潔な方法で表現できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This new definition of the <code>IpAddr</code> enum says that both <code>V4</code> and <code>V6</code> variants will have associated <code>String</code> values:</span> <code>IpAddr</code>列挙型のこの新しい定義によれば、 <code>V4</code>と<code>V6</code>両方のバリアントには、関連付けられた<code>String</code>値があります。</span> </p><br><div data-lang=rust><div data-l="enum IpAddr {"></div><div data-l="    V4(String),"></div><div data-l="    V6(String),"></div><div data-l=}></div><div data-l=""></div><div data-l="let home = IpAddr::V4(String::from(&quot;127.0.0.1&quot;));"></div><div data-l=""></div><div data-l="let loopback = IpAddr::V6(String::from(&quot;::1&quot;));"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We attach data to each variant of the enum directly, so there is no need for an extra struct.</span>列挙型の各変種にデータを直接添付するので、余分な構造体は必要ありません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There&#39;s another advantage to using an enum rather than a struct: each variant can have different types and amounts of associated data.</span>構造体ではなく、列挙型を使用することには別の利点があります。それぞれのバリアントは、関連するデータのタイプと量を異ならせることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Version four type IP addresses will always have four numeric components that will have values between 0 and 255. If we wanted to store <code>V4</code> addresses as four <code>u8</code> values but still express <code>V6</code> addresses as one <code>String</code> value, we wouldn&#39;t be able to with a struct.</span>バージョン4種類のIPアドレスは、常に我々が保存したい場合は0〜255の値を持つことになります4つの数字のコンポーネントがあります<code>V4</code> 4つのとしてアドレスを<code>u8</code>値が、それでも表現<code>V6</code>一つとして、アドレスを<code>String</code>値を、我々は持つことができないだろう構造体。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Enums handle this case with ease:</span>列挙型はこのケースを簡単に処理します。</span> </p><br><div data-lang=rust><div data-l="enum IpAddr {"></div><div data-l="    V4(u8, u8, u8, u8),"></div><div data-l="    V6(String),"></div><div data-l=}></div><div data-l=""></div><div data-l="let home = IpAddr::V4(127, 0, 0, 1);"></div><div data-l=""></div><div data-l="let loopback = IpAddr::V6(String::from(&quot;::1&quot;));"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ve shown several different ways to define data structures to store version four and version six IP addresses.</span>バージョン4とバージョン6のIPアドレスを格納するためにデータ構造を定義するいくつかの異なる方法を示しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, as it turns out, wanting to store IP addresses and encode which kind they are is so common that <a href=#3IpAddr>the standard library has a definition we can use!</a></span>しかし、明らかになったように、IPアドレスを格納して、どのような種類のものをエンコードしたいのかは、よくあることです<a href=#3IpAddr>。標準ライブラリには、使用できる定義があります。</a></span> <!-- ignore --> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s look at how the standard library defines <code>IpAddr</code> : it has the exact enum and variants that we&#39;ve defined and used, but it embeds the address data inside the variants in the form of two different structs, which are defined differently for each variant:</span>標準ライブラリが<code>IpAddr</code>をどのように定義しているかを見てみましょう：それは私たちが定義し使用した正確な列挙型と変種を持っていますが、変種ごとに異なって定義された2つの異なる構造体の形で、</span> </p><br> <a class=notranslate href=#1../../std/net/enum.IpAddr.html>IpAddr</a> <br> <div data-lang=rust><div data-l="struct Ipv4Addr {"></div><div data-l="#    // --snip--"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">--snip--</span> --snip--</span> </div><div data-l=}></div><div data-l=""></div><div data-l="struct Ipv6Addr {"></div><div data-l="#    // --snip--"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">--snip--</span> --snip--</span> </div><div data-l=}></div><div data-l=""></div><div data-l="enum IpAddr {"></div><div data-l="    V4(Ipv4Addr),"></div><div data-l="    V6(Ipv6Addr),"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This code illustrates that you can put any kind of data inside an enum variant: strings, numeric types, or structs, for example.</span>このコードは、列挙型の内部に任意の種類のデータ（文字列、数値型、または構造体など）を入れることができることを示しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can even include another enum!</span>別の列挙型を含めることもできます！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Also, standard library types are often not much more complicated than what you might come up with.</span>また、標準的なライブラリタイプは、あなたが思いつくよりもはるかに複雑ではありません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that even though the standard library contains a definition for <code>IpAddr</code> , we can still create and use our own definition without conflict because we haven&#39;t brought the standard library&#39;s definition into our scope.</span>標準ライブラリに<code>IpAddr</code>定義が含まれていても、標準ライブラリの定義をスコープに持たないため、独自の定義を作成して使用することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll talk more about bringing types into scope in Chapter 7.</span>第7章では、型をスコープ内に持ち込む方法について詳しく説明します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s look at another example of an enum in Listing 6-2: this one has a wide variety of types embedded in its variants.</span>リスト6-2の別のenumの例を見てみましょう。これは、そのバリエーションにさまざまな型が埋め込まれています。</span> </p><br><div data-lang=rust><div data-l="enum Message {"></div><div data-l="    Quit,"></div><div data-l="    Move { x: i32, y: i32 },"></div><div data-l="    Write(String),"></div><div data-l="    ChangeColor(i32, i32, i32),"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 6-2: A <code>Message</code> enum whose variants each store different amounts and types of values</span></span> <span class=caption>コードリスト6-2： <code>Message</code>列挙型で、それぞれが異なる金額と型の値を格納する</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This enum has four variants with different types:</span>この列挙型には、さまざまな種類の4つのバリアントがあります。</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>Quit</code> has no data associated with it at all.</span> <code>Quit</code>は、それに関連するデータはまったくありません。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>Move</code> includes an anonymous struct inside it.</span> <code>Move</code>は、内部に匿名の構造体が含まれます。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>Write</code> includes a single <code>String</code> .</span> <code>Write</code>には単一の<code>String</code>含まれます。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>ChangeColor</code> includes three <code>i32</code> values.</span> <code>ChangeColor</code>は、3つの<code>i32</code>値が含まれます。</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Defining an enum with variants such as the ones in Listing 6-2 is similar to defining different kinds of struct definitions, except the enum doesn&#39;t use the <code>struct</code> keyword and all the variants are grouped together under the <code>Message</code> type.</span>コードリスト6-2のようなバリアントを持つ列挙型を定義することは、enumが<code>struct</code>キーワードを使用せず、すべてのバリアントが<code>Message</code>型で一緒にグループ化されることを除いて、異なる種類の構造体定義を定義することと似ています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The following structs could hold the same data that the preceding enum variants hold:</span>次の構造体は、前の列挙型が保持するデータと同じデータを保持できます。</span> </p><br><div data-lang=rust><div data-l="#//struct QuitMessage; // unit struct"></div><div data-l="struct QuitMessage; // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">unit struct</span>単位構造</span> </div><div data-l="struct MoveMessage {"></div><div data-l="    x: i32,"></div><div data-l="    y: i32,"></div><div data-l=}></div><div data-l="#//struct WriteMessage(String); // tuple struct"></div><div data-l="struct WriteMessage(String); // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">tuple struct</span>タプル構造体</span> </div><div data-l="#//struct ChangeColorMessage(i32, i32, i32); // tuple struct"></div><div data-l="struct ChangeColorMessage(i32, i32, i32); // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">tuple struct</span>タプル構造体</span> </div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But if we used the different structs, which each have their own type, we couldn&#39;t as easily define a function to take any of these kinds of messages as we could with the <code>Message</code> enum defined in Listing 6-2, which is a single type.</span>しかし、それぞれ独自の型を持つ異なる構造体を使用した場合、リスト6-2で定義されている<code>Message</code> enumと同様に、これらのメッセージのいずれかを取る関数を簡単に定義することはできません。タイプ。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There is one more similarity between enums and structs: just as we&#39;re able to define methods on structs using <code>impl</code> , we&#39;re also able to define methods on enums.</span> enumとstructの間にはもう1つの類似点があります。 <code>impl</code> 、 <code>impl</code>を使って構造体のメソッドを定義できるように、enumでメソッドを定義することもできます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here&#39;s a method named <code>call</code> that we could define on our <code>Message</code> enum:</span> <code>Message</code> enumで定義できる<code>call</code>というメソッドがあります：</span> </p><br><div data-lang=rust><div data-l="# enum Message {"></div><div data-l="#     Quit,"></div><div data-l="#     Move { x: i32, y: i32 },"></div><div data-l="#     Write(String),"></div><div data-l="#     ChangeColor(i32, i32, i32),"></div><div data-l="# }"></div><div data-l=#></div><div data-l="impl Message {"></div><div data-l="    fn call(&amp;self) {"></div><div data-l="#        // method body would be defined here"></div><div data-l="        // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">method body would be defined here</span>メソッド本体はここで定義されます</span> </div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="let m = Message::Write(String::from(&quot;hello&quot;));"></div><div data-l=m.call();></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The body of the method would use <code>self</code> to get the value that we called the method on.</span>メソッドの本体は<code>self</code>を使用して、メソッドを呼び出した値を取得します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this example, we&#39;ve created a variable <code>m</code> that has the value <code>Message::Write(String::from(&quot;hello&quot;))</code> , and that is what <code>self</code> will be in the body of the <code>call</code> method when <code>m.call()</code> runs.</span>この例では、値<code>Message::Write(String::from(&quot;hello&quot;))</code>を持つ変数<code>m</code>を作成しました。これは、 <code>call</code>メソッドの本体で<code>self</code>が<code>m.call()</code>が実行されます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s look at another enum in the standard library that is very common and useful: <code>Option</code> .</span>非常に一般的で便利な標準ライブラリの別の列挙型を見てみましょう： <code>Option</code> 。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Option</code> Enum and Its Advantages Over Null Values</span> <code>Option</code>列挙型とそのヌル値に対する利点</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In the previous section, we looked at how the <code>IpAddr</code> enum let us use Rust&#39;s type system to encode more information than just the data into our program.</span>前のセクションでは、 <code>IpAddr</code>列挙型がRustの型システムを使用して、プログラムのデータだけでなく、より多くの情報をエンコードする方法を見てきました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This section explores a case study of <code>Option</code> , which is another enum defined by the standard library.</span>このセクションでは、標準ライブラリによって定義された別の列挙型である<code>Option</code>ケーススタディについて説明します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Option</code> type is used in many places because it encodes the very common scenario in which a value could be something or it could be nothing.</span> <code>Option</code>型は、値が何かになる可能性がある、または何もできないという非常に一般的なシナリオをエンコードするため、多くの場所で使用されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Expressing this concept in terms of the type system means the compiler can check whether you&#39;ve handled all the cases you should be handling;</span>この概念を型システムの観点から表現すると、コンパイラは処理する必要があるすべてのケースを処理したかどうかをチェックできます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">this functionality can prevent bugs that are extremely common in other programming languages.</span>この機能により、他のプログラミング言語で非常に一般的なバグを防ぐことができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Programming language design is often thought of in terms of which features you include, but the features you exclude are important too.</span>プログラミング言語の設計は、どの機能を含むかという点ではよく考えられますが、除外する機能も重要です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust doesn&#39;t have the null feature that many other languages have.</span>錆には他の多くの言語が持つヌル機能はありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><i>Null</i> is a value that means there is no value there.</span> <i>Null</i>は値がないことを意味する値です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In languages with null, variables can always be in one of two states: null or not-null.</span> nullを持つ言語では、変数は常にnullまたはnot-nullの2つの状態のいずれかになります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In his 2009 presentation “Null References: The Billion Dollar Mistake,” Tony Hoare, the inventor of null, has this to say:</span> 2009年のプレゼンテーション「Null References：The 10億ドルの間違い」では、nullの発明者であるTony Hoareがこう言っています。</span> </p><br><blockquote><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">I call it my billion-dollar mistake.</span>私はそれを億ドルの間違いと呼ぶ。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">At that time, I was designing the first comprehensive type system for references in an object-oriented language.</span>当時、私はオブジェクト指向言語での参照のための最初の包括的型システムを設計していました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">My goal was to ensure that all use of references should be absolutely safe, with checking performed automatically by the compiler.</span>私の目標は、参照のすべての使用が完全に安全であることと、コンパイラによって自動的にチェックが行われることを確実にすることでした。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But I couldn&#39;t resist the temptation to put in a null reference, simply because it was so easy to implement.</span>しかし、簡単に実装することができたからといって、ヌル参照を入れるという誘惑に抵抗することはできませんでした。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years.</span>これにより、おそらく過去40年間に10億ドルの苦痛と損害を引き起こした無数のエラー、脆弱性、システムクラッシュが発生しました。</span> </p></blockquote><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The problem with null values is that if you try to use a null value as a not-null value, you&#39;ll get an error of some kind.</span>ヌル値の問題は、ヌル値をヌル値として使用しようとすると、何らかのエラーが発生することです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because this null or not-null property is pervasive, it&#39;s extremely easy to make this kind of error.</span>このnullまたはnot-nullプロパティは広く使用されているため、この種のエラーは非常に簡単です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, the concept that null is trying to express is still a useful one: a null is a value that is currently invalid or absent for some reason.</span>しかし、nullが表現しようとしている概念は、まだ有用なものです。nullは、何らかの理由で現在無効であるか存在しない値です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The problem isn&#39;t really with the concept but with the particular implementation.</span>問題は実際にはコンセプトではなく、特定の実装である。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As such, Rust does not have nulls, but it does have an enum that can encode the concept of a value being present or absent.</span>そのため、Rustにはnullはありませんが、値の存在または不在をエンコードできる列挙型があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This enum is <code>Option&lt;T&gt;</code> , and it is <a href=#3option>defined by the standard library</a></span>この列挙型は<code>Option&lt;T&gt;</code>であり<a href=#3option>、標準ライブラリによって定義されています</a></span> <!-- ignore --> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">as follows:</span>次のように：</span> </p><br> <a class=notranslate href=#1../../std/option/enum.Option.html>option</a> <br> <div data-lang=rust><div data-l="enum Option&lt;T&gt; {"></div><div data-l="    Some(T),"></div><div data-l="    None,"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Option&lt;T&gt;</code> enum is so useful that it&#39;s even included in the prelude;</span> <code>Option&lt;T&gt;</code>列挙型は非常に有用であり、それは前奏曲にも含まれています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">you don&#39;t need to bring it into scope explicitly.</span>それを明示的に有効範囲に入れる必要はありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In addition, so are its variants: you can use <code>Some</code> and <code>None</code> directly without the <code>Option::</code> prefix.</span>さらに、その亜種もそうです： <code>Some</code>と<code>None</code>を<code>Option::</code>プリフィックス<code>None</code>直接使うことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Option&lt;T&gt;</code> enum is still just a regular enum, and <code>Some(T)</code> and <code>None</code> are still variants of type <code>Option&lt;T&gt;</code> .</span> <code>Option&lt;T&gt;</code>列挙型は依然として通常の列挙型であり、 <code>Some(T)</code>と<code>None</code>はまだ<code>Option&lt;T&gt;</code>型のバリアントです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>&lt;T&gt;</code> syntax is a feature of Rust we haven&#39;t talked about yet.</span> <code>&lt;T&gt;</code>構文は、まだ説明していないRustの機能です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It&#39;s a generic type parameter, and we&#39;ll cover generics in more detail in Chapter 10. For now, all you need to know is that <code>&lt;T&gt;</code> means the <code>Some</code> variant of the <code>Option</code> enum can hold one piece of data of any type.</span>これはジェネリック型のパラメータであり、第10章でジェネリックについて詳しく説明します。今のところ、 <code>&lt;T&gt;</code>は<code>Option</code> enumの<code>Some</code> variantが任意のタイプのデータを保持できることを意味します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here are some examples of using <code>Option</code> values to hold number types and string types:</span> <code>Option</code>値を使用して数値型と文字列型を保持する例をいくつか示します。</span> </p><br><div data-lang=rust><div data-l="let some_number = Some(5);"></div><div data-l="let some_string = Some(&quot;a string&quot;);"></div><div data-l=""></div><div data-l="let absent_number: Option&lt;i32&gt; = None;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we use <code>None</code> rather than <code>Some</code> , we need to tell Rust what type of <code>Option&lt;T&gt;</code> we have, because the compiler can&#39;t infer the type that the <code>Some</code> variant will hold by looking only at a <code>None</code> value.</span> <code>Some</code>ではなく<code>None</code>を使用する場合、コンパイラは<code>Some</code>型が<code>None</code>値だけを見て保持する型を推論することができないため、Rustにどの型の<code>Option&lt;T&gt;</code>渡す必要があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When we have a <code>Some</code> value, we know that a value is present and the value is held within the <code>Some</code> .</span> <code>Some</code>値があるときは、ある値が存在し、その値が<code>Some</code>値内に保持されていることがわかります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When we have a <code>None</code> value, in some sense, it means the same thing as null: we don&#39;t have a valid value.</span> <code>None</code>値がある場合、ある意味ではnullと同じ意味を持ちます。有効な値がありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So why is having <code>Option&lt;T&gt;</code> any better than having null?</span>なぜ、 <code>Option&lt;T&gt;</code>がnullを持つよりも優れているのですか？</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In short, because <code>Option&lt;T&gt;</code> and <code>T</code> (where <code>T</code> can be any type) are different types, the compiler won&#39;t let us use an <code>Option&lt;T&gt;</code> value as if it were definitely a valid value.</span>要するに、 <code>Option&lt;T&gt;</code>と<code>T</code> （ <code>T</code>は任意の型とすることができる）は異なる型であるため、コンパイラは<code>Option&lt;T&gt;</code>値をあたかも正当な値であるかのように使用しません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, this code won&#39;t compile because it&#39;s trying to add an <code>i8</code> to an <code>Option&lt;i8&gt;</code> :</span>たとえば、このコードは<code>i8</code>を<code>Option&lt;i8&gt;</code>に追加しようとしているためコンパイルされません。</span> </p><br><div data-lang=rust,ignore><div data-l="let x: i8 = 5;"></div><div data-l="let y: Option&lt;i8&gt; = Some(5);"></div><div data-l=""></div><div data-l="let sum = x + y;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we run this code, we get an error message like this:</span>このコードを実行すると、次のようなエラーメッセージが表示されます。</span> </p><br><div data-lang=text><div data-l="error[E0277]: the trait bound `i8: std::ops::Add&lt;std::option::Option&lt;i8&gt;&gt;` is"></div><div data-l="not satisfied"></div><div data-l=" --&gt;"></div><div data-l="  |"></div><div data-l="5 |     let sum = x + y;"></div><div data-l="  |                 ^ no implementation for `i8 + std::option::Option&lt;i8&gt;`"></div><div data-l="  |"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Intense!</span>激しい！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In effect, this error message means that Rust doesn&#39;t understand how to add an <code>i8</code> and an <code>Option&lt;i8&gt;</code> , because they&#39;re different types.</span>実際、このエラーメッセージは、異なるタイプのため、Rustは<code>i8</code>と<code>Option&lt;i8&gt;</code>追加方法を理解していないことを意味します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When we have a value of a type like <code>i8</code> in Rust, the compiler will ensure that we always have a valid value.</span>私たちがRustの<code>i8</code>ような型の値を持つとき、コンパイラは常に正しい値を持つことを保証します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can proceed confidently without having to check for null before using that value.</span>その値を使用する前に、nullをチェックする必要はありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Only when we have an <code>Option&lt;i8&gt;</code> (or whatever type of value we&#39;re working with) do we have to worry about possibly not having a value, and the compiler will make sure we handle that case before using the value.</span> <code>Option&lt;i8&gt;</code> （またはそれが働いている値の種類）を持っている場合にのみ、値を持たない可能性について心配する必要があります。コンパイラは値を使用する前にそのケースを処理するようにします。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In other words, you have to convert an <code>Option&lt;T&gt;</code> to a <code>T</code> before you can perform <code>T</code> operations with it.</span>言い換えれば、あなたは変換する必要があります<code>Option&lt;T&gt;</code>する<code>T</code>あなたが実行する前に<code>T</code>それとの動作を制御します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Generally, this helps catch one of the most common issues with null: assuming that something isn&#39;t null when it actually is.</span>一般に、これはヌルに関する最も一般的な問題の1つをキャッチするのに役立ちます。実際には何かがnullではないと仮定します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Not having to worry about incorrectly assuming a not-null value helps you to be more confident in your code.</span>値がNULLではないと誤って心配する必要はなく、コードに自信を持たせることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In order to have a value that can possibly be null, you must explicitly opt in by making the type of that value <code>Option&lt;T&gt;</code> .</span> nullになる可能性のある値を持つためには、その値の型を<code>Option&lt;T&gt;</code>明示的にオプトインする必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then, when you use that value, you are required to explicitly handle the case when the value is null.</span>次に、その値を使用するときは、値がnullの場合に明示的に処理する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Everywhere that a value has a type that isn&#39;t an <code>Option&lt;T&gt;</code> , you <i>can</i> safely assume that the value isn&#39;t null.</span>どこでも値がないタイプがあることを<code>Option&lt;T&gt;</code> 、あなたは安全に値がnullでないと仮定<i>することができ</i>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This was a deliberate design decision for Rust to limit null&#39;s pervasiveness and increase the safety of Rust code.</span>これは、Rustがnullの普及を制限し、Rustコードの安全性を高めるための意図的な設計決定でした。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So, how do you get the <code>T</code> value out of a <code>Some</code> variant when you have a value of type <code>Option&lt;T&gt;</code> so you can use that value?</span>だから、 <code>Option&lt;T&gt;</code>型の値を持つときに<code>T</code>値を<code>Some</code>型からどのように取得すると、その値を使うことができるのですか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Option&lt;T&gt;</code> enum has a large number of methods that are useful in a variety of situations;</span> <code>Option&lt;T&gt;</code>列挙型は、さまざまな状況で便利な多数のメソッドを持っています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">you can check them out in <a href=#3docs>its documentation</a></span> <a href=#3docs>そのドキュメントで</a>それらをチェックすることができ<a href=#3docs>ます</a></span> <!-- ignore --> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">.</span> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Becoming familiar with the methods on <code>Option&lt;T&gt;</code> will be extremely useful in your journey with Rust.</span> <code>Option&lt;T&gt;</code>メソッドに慣れると、Rustの旅に非常に役立ちます。</span> </p><br> <a class=notranslate href=#1../../std/option/enum.Option.html>docs</a> <br> <p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In general, in order to use an <code>Option&lt;T&gt;</code> value, you want to have code that will handle each variant.</span>一般的に、 <code>Option&lt;T&gt;</code>値を使用するには、各バリアントを処理するコードを用意する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You want some code that will run only when you have a <code>Some(T)</code> value, and this code is allowed to use the inner <code>T</code> .</span> <code>Some(T)</code>値があるときにのみ実行されるいくつかのコードが必要です。このコードは内部<code>T</code>を使用することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You want some other code to run if you have a <code>None</code> value, and that code doesn&#39;t have a <code>T</code> value available.</span> <code>None</code>値があり、そのコードに利用可能な<code>T</code>値がない場合、他のコードを実行する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>match</code> expression is a control flow construct that does just this when used with enums: it will run different code depending on which variant of the enum it has, and that code can use the data inside the matching value.</span> <code>match</code>式は、列挙型で使用されている場合にのみこれを行うコントロールフロー構造です。列挙型の変種に応じて異なるコードを実行し、一致する値内のデータを使用することができます。</span> </p><script>_addload(function(){_setupIW('com');_csi('en','ja','ch06-01-defining-an-enum.html');});</script>