<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180709_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=ch17-02-trait-objects.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Using Trait Objects that Allow for Values of Different Types</span>異なる型の値を許容する特性オブジェクトの使用</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In Chapter 8, we mentioned that one limitation of vectors is that they can store elements of only one type.</span>第8章では、ベクトルの1つの制限は、1つのタイプの要素だけを格納できるということです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We created a workaround in Listing 8-10 where we defined a <code>SpreadsheetCell</code> enum that had variants to hold integers, floats, and text.</span>リスト8-10では、整数、浮動小数点数、およびテキストを格納するバリアントを持つ<code>SpreadsheetCell</code>列挙型を定義しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This meant we could store different types of data in each cell and still have a vector that represented a row of cells.</span>これは、各セルに異なるタイプのデータを格納することができ、セルの行を表すベクトルを保持できることを意味していました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is a perfectly good solution when our interchangeable items are a fixed set of types that we know when our code is compiled.</span>これは、互換性のあるアイテムが、コードのコンパイル時にわかっている固定セットのタイプである場合に、完全に良い解決策です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, sometimes we want our library user to be able to extend the set of types that are valid in a particular situation.</span>しかし、時々、私たちのライブラリユーザは、特定の状況で有効なタイプのセットを拡張できるようにしたいことがあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To show how we might achieve this, we&#39;ll create an example graphical user interface (GUI) tool that iterates through a list of items, calling a <code>draw</code> method on each one to draw it to the screen—a common technique for GUI tools.</span>これをどのように実現するかを示すために、アイテムのリストを反復し、それぞれを描画するために<code>draw</code>メソッドを呼び出して、GUIツールの一般的なテクニックであるグラフィカルユーザーインターフェイス（GUI）ツールを作成します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll create a library crate called <code>gui</code> that contains the structure of a GUI library.</span>私たちは、と呼ばれるライブラリのクレート作成します<code>gui</code> GUIライブラリの構造が含まれています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This crate might include some types for people to use, such as <code>Button</code> or <code>TextField</code> .</span>このクレートには、 <code>Button</code>や<code>TextField</code>など、人々が使用するいくつかのタイプが含まれている場合があり<code>TextField</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In addition, <code>gui</code> users will want to create their own types that can be drawn: for instance, one programmer might add an <code>Image</code> and another might add a <code>SelectBox</code> .</span>さらに、 <code>gui</code>ユーザーは描画できる独自の型を作成する必要があります。たとえば、1つのプログラマーが<code>Image</code>を追加し、別のプログラマーが<code>SelectBox</code>追加する<code>SelectBox</code>ます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We won&#39;t implement a fully fledged GUI library for this example but will show how the pieces would fit together.</span>この例では、本格的なGUIライブラリーを実装することはしませんが、どのように組み合わせるかを示します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">At the time of writing the library, we can&#39;t know and define all the types other programmers might want to create.</span>ライブラリの作成時には、他のプログラマが作成したいと思うすべてのタイプを知り、定義することはできません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But we do know that <code>gui</code> needs to keep track of many values of different types, and it needs to call a <code>draw</code> method on each of these differently typed values.</span>しかし、我々は<code>gui</code>がさまざまな型の多くの値を追跡する必要があることを知っています。そして、これらの型付けされた値のそれぞれについて<code>draw</code>メソッドを呼び出す必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It doesn&#39;t need to know exactly what will happen when we call the <code>draw</code> method, just that the value will have that method available for us to call.</span>私たちが<code>draw</code>メソッドを呼び出すときに何が起こるかを正確に知る必要はありません。ただ、そのメソッドが呼び出し可能なメソッドを持つだけです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To do this in a language with inheritance, we might define a class named <code>Component</code> that has a method named <code>draw</code> on it.</span>継承と言語でこれを行うために、我々は、という名前のクラス定義することができます<code>Component</code>名前のメソッドがある<code>draw</code> 、その上に。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The other classes, such as <code>Button</code> , <code>Image</code> , and <code>SelectBox</code> , would inherit from <code>Component</code> and thus inherit the <code>draw</code> method.</span> <code>Button</code> 、 <code>Image</code> 、 <code>SelectBox</code>などの他のクラスは、 <code>Component</code>から継承し、 <code>draw</code>メソッドを継承します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">They could each override the <code>draw</code> method to define their custom behavior, but the framework could treat all of the types as if they were <code>Component</code> instances and call <code>draw</code> on them.</span>彼らはそれぞれ独自のビヘイビアを定義するために<code>draw</code>メソッドをオーバーライドすることができますが、フレームワークはすべてのタイプを<code>Component</code>インスタンスとして扱い、それらを<code>draw</code>します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But because Rust doesn&#39;t have inheritance, we need another way to structure the <code>gui</code> library to allow users to extend it with new types.</span>しかし、Rustには継承がないため、ユーザーが新しいタイプで拡張できるように<code>gui</code>ライブラリを構築する別の方法が必要です。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Defining a Trait for Common Behavior</span>共通行動のための特性の定義</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To implement the behavior we want <code>gui</code> to have, we&#39;ll define a trait named <code>Draw</code> that will have one method named <code>draw</code> .</span> <code>gui</code>に必要な振る舞いを実装するために、 <code>draw</code>という名前の1つのメソッドを持つ<code>Draw</code>という名前の<code>Draw</code>を定義します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then we can define a vector that takes a <i>trait object</i> .</span>次に、 <i>traitオブジェクト</i>をとるベクトルを定義することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A trait object points to an instance of a type that implements the trait we specify.</span>特性オブジェクトは、指定した特性を実装するタイプのインスタンスを指します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We create a trait object by specifying some sort of pointer, such as a <code>&amp;</code> reference or a <code>Box&lt;T&gt;</code> smart pointer, and then specifying the relevant trait.</span>我々は、 <code>&amp;</code> referenceや<code>Box&lt;T&gt;</code>スマートポインタのような何らかのポインタを指定し、関連する特性を指定することによって特性オブジェクトを作成する。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">(We&#39;ll talk about the reason trait objects must use a pointer in Chapter 19 in the section “Dynamically Sized Types &amp; Sized”.) We can use trait objects in place of a generic or concrete type.</span> （特性オブジェクトは、19章の「動的にサイズが指定された型とサイズ」の節でポインタを使用する必要がある理由について話します。）汎用オブジェクトまたは具体的な型の代わりに特性オブジェクトを使用できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Wherever we use a trait object, Rust&#39;s type system will ensure at compile time that any value used in that context will implement the trait object&#39;s trait.</span> Rustの型システムは、特性オブジェクトを使用するたびに、コンパイル時に、そのコンテキストで使用されるすべての値が特性オブジェクトの特性を実装することを保証します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Consequently, we don&#39;t need to know all the possible types at compile time.</span>したがって、コンパイル時にすべての型を知る必要はありません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ve mentioned that in Rust, we refrain from calling structs and enums “objects” to distinguish them from other languages&#39; objects.</span>私たちは、Rustでは、他の言語のオブジェクトと区別するために構造体と列挙型を呼び出すことを控えています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In a struct or enum, the data in the struct fields and the behavior in <code>impl</code> blocks are separated, whereas in other languages, the data and behavior combined into one concept is often labeled an object.</span>構造体または列挙型では、structフィールドのデータと<code>impl</code>ブロックの動作は分離されていますが、他の言語では、データとビヘイビアが1つのコンセプトに結合されてオブジェクトにラベル付けされることがよくあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, trait objects <i>are</i> more like objects in other languages in the sense that they combine data and behavior.</span>しかし、特性オブジェクト<i>は</i> 、データと動作を組み合わせる意味で、他の言語のオブジェクトによく似ています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But trait objects differ from traditional objects in that we can&#39;t add data to a trait object.</span>しかし、形質オブジェクトは、形質オブジェクトにデータを追加できないという点で、従来のオブジェクトとは異なります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Trait objects aren&#39;t as generally useful as objects in other languages: their specific purpose is to allow abstraction across common behavior.</span>特性オブジェクトは、他の言語のオブジェクトとして一般的には有用ではありません。具体的な目的は、共通の動作を超えた抽象化を可能にすることです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 17-3 shows how to define a trait named <code>Draw</code> with one method named <code>draw</code> :</span>リスト17-3は、 <code>draw</code>という名前の1つのメソッドで<code>Draw</code>という名前の特性を定義する方法を示しています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/lib.rs</span></span> <span class=filename>ファイル名：src / lib.rs</span></span> </p><br><div data-lang=rust><div data-l="pub trait Draw {"></div><div data-l="    fn draw(&amp;self);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 17-3: Definition of the <code>Draw</code> trait</span></span> <span class=caption>リスト17-3： <code>Draw</code>特性の定義</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This syntax should look familiar from our discussions on how to define traits in Chapter 10. Next comes some new syntax: Listing 17-4 defines a struct named <code>Screen</code> that holds a vector named <code>components</code> .</span>この構文は、第10章で特性を定義する方法に関する議論から慣れているはずです。次に、新しい構文があります。リスト17-4は、 <code>components</code>という名前のベクトルを保持する<code>Screen</code>という名前の構造体を定義してい<code>components</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This vector is of type <code>Box&lt;Draw&gt;</code> , which is a trait object;</span>このベクトルは、型オブジェクトである<code>Box&lt;Draw&gt;</code>型です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">it&#39;s a stand-in for any type inside a <code>Box</code> that implements the <code>Draw</code> trait.</span>これは、 <code>Draw</code>特性を実装する<code>Box</code>内のあらゆるタイプのスタンドインです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/lib.rs</span></span> <span class=filename>ファイル名：src / lib.rs</span></span> </p><br><div data-lang=rust><div data-l="# pub trait Draw {"></div><div data-l="#     fn draw(&amp;self);"></div><div data-l="# }"></div><div data-l=#></div><div data-l="pub struct Screen {"></div><div data-l="    pub components: Vec&lt;Box&lt;Draw&gt;&gt;,"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 17-4: Definition of the <code>Screen</code> struct with a <code>components</code> field holding a vector of trait objects that implement the <code>Draw</code> trait</span></span> <span class=caption>リスト17-4： <code>Draw</code>特性を実装するtraitオブジェクトのベクトルを保持する<code>components</code>フィールドを持つ<code>Screen</code>構造体の定義</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">On the <code>Screen</code> struct, we&#39;ll define a method named <code>run</code> that will call the <code>draw</code> method on each of its <code>components</code> , as shown in Listing 17-5:</span> <code>Screen</code>構造体では、 <code>run</code>という名前のメソッドを定義します。このメソッドは、リスト17-5に示すように、各<code>components</code>で<code>draw</code>メソッドを呼び出します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/lib.rs</span></span> <span class=filename>ファイル名：src / lib.rs</span></span> </p><br><div data-lang=rust><div data-l="# pub trait Draw {"></div><div data-l="#     fn draw(&amp;self);"></div><div data-l="# }"></div><div data-l=#></div><div data-l="# pub struct Screen {"></div><div data-l="#     pub components: Vec&lt;Box&lt;Draw&gt;&gt;,"></div><div data-l="# }"></div><div data-l=#></div><div data-l="impl Screen {"></div><div data-l="    pub fn run(&amp;self) {"></div><div data-l="        for component in self.components.iter() {"></div><div data-l="            component.draw();"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 17-5: A <code>run</code> method on <code>Screen</code> that calls the <code>draw</code> method on each component</span></span> <span class=caption>リスト17-5：各コンポーネントの<code>draw</code>メソッドを呼び出す<code>Screen</code>上の<code>run</code>メソッド</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This works differently than defining a struct that uses a generic type parameter with trait bounds.</span>これは、特性の境界でジェネリック型のパラメータを使用する構造体を定義する方法とは異なります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A generic type parameter can only be substituted with one concrete type at a time, whereas trait objects allow for multiple concrete types to fill in for the trait object at runtime.</span>ジェネリック型パラメータは、一度に1つの具体的な型にのみ置き換えることができますが、traitオブジェクトでは、実行時に複数の具象型をtraitオブジェクトに埋め込むことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, we could have defined the <code>Screen</code> struct using a generic type and a trait bound as in Listing 17-6:</span>たとえば、リスト17-6のようにジェネリック型と特性バインドを使用して<code>Screen</code>構造体を定義できました。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/lib.rs</span></span> <span class=filename>ファイル名：src / lib.rs</span></span> </p><br><div data-lang=rust><div data-l="# pub trait Draw {"></div><div data-l="#     fn draw(&amp;self);"></div><div data-l="# }"></div><div data-l=#></div><div data-l="pub struct Screen&lt;T: Draw&gt; {"></div><div data-l="    pub components: Vec&lt;T&gt;,"></div><div data-l=}></div><div data-l=""></div><div data-l="impl&lt;T&gt; Screen&lt;T&gt;"></div><div data-l="    where T: Draw {"></div><div data-l="    pub fn run(&amp;self) {"></div><div data-l="        for component in self.components.iter() {"></div><div data-l="            component.draw();"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 17-6: An alternate implementation of the <code>Screen</code> struct and its <code>run</code> method using generics and trait bounds</span></span> <span class=caption>リスト17-6：Genericと特性境界を使った<code>Screen</code>構造体とその<code>run</code>メソッドの別の実装</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This restricts us to a <code>Screen</code> instance that has a list of components all of type <code>Button</code> or all of type <code>TextField</code> .</span>これにより、 <code>Button</code>タイプのすべてのコンポーネントまたは<code>TextField</code>タイプのすべてのコンポーネントのリストを持つ<code>Screen</code>インスタンスに制限され<code>TextField</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you&#39;ll only ever have homogeneous collections, using generics and trait bounds is preferable because the definitions will be monomorphized at compile time to use the concrete types.</span>同種のコレクションしか持たない場合は、ジェネリックと特性の境界を使用する方が望ましいです。コンクリート型を使用するためにコンパイル時に定義が単一化されるからです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">On the other hand, with the method using trait objects, one <code>Screen</code> instance can hold a <code>Vec&lt;T&gt;</code> that contains a <code>Box&lt;Button&gt;</code> as well as a <code>Box&lt;TextField&gt;</code> .</span>一方、traitオブジェクトを使用するメソッドでは、1つの<code>Screen</code>インスタンスは、 <code>Box&lt;Button&gt;</code>と<code>Box&lt;TextField&gt;</code>を含む<code>Vec&lt;T&gt;</code>を保持できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s look at how this works, and then we&#39;ll talk about the runtime performance implications.</span>これがどのように動作するかを見てみましょう。次にランタイムパフォーマンスの影響について説明します。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Implementing the Trait</span>特性の実装</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now we&#39;ll add some types that implement the <code>Draw</code> trait.</span>ここで、 <code>Draw</code>特性を実装するいくつかの型を追加します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll provide the <code>Button</code> type.</span> <code>Button</code>タイプを提供します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Again, actually implementing a GUI library is beyond the scope of this book, so the <code>draw</code> method won&#39;t have any useful implementation in its body.</span> GUIライブラリを実際に実装することはこの本の範囲を超えているので、 <code>draw</code>メソッドはその本体に便利な実装を持たないでしょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To imagine what the implementation might look like, a <code>Button</code> struct might have fields for <code>width</code> , <code>height</code> , and <code>label</code> , as shown in Listing 17-7:</span>実装がどのように見えるかを想像すると、リスト17-7に示すように、 <code>Button</code>構造体に<code>width</code> 、 <code>height</code> 、および<code>label</code>フィールドがあります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/lib.rs</span></span> <span class=filename>ファイル名：src / lib.rs</span></span> </p><br><div data-lang=rust><div data-l="# pub trait Draw {"></div><div data-l="#     fn draw(&amp;self);"></div><div data-l="# }"></div><div data-l=#></div><div data-l="pub struct Button {"></div><div data-l="    pub width: u32,"></div><div data-l="    pub height: u32,"></div><div data-l="    pub label: String,"></div><div data-l=}></div><div data-l=""></div><div data-l="impl Draw for Button {"></div><div data-l="    fn draw(&amp;self) {"></div><div data-l="#        // code to actually draw a button"></div><div data-l="        // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">code to actually draw a button</span>ボタンを実際に描画するコード</span> </div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 17-7: A <code>Button</code> struct that implements the <code>Draw</code> trait</span></span> <span class=caption>リスト17-7： <code>Draw</code>特性を実装する<code>Button</code>構造体</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>width</code> , <code>height</code> , and <code>label</code> fields on <code>Button</code> will differ from the fields on other components, such as a <code>TextField</code> type, that might have those fields plus a <code>placeholder</code> field instead.</span> <code>Button</code>の<code>width</code> 、 <code>height</code> 、および<code>label</code>フィールドは、 <code>TextField</code>タイプなど、他のコンポーネントのフィールドとは異なります。これらのフィールドには、代わりに<code>placeholder</code>フィールドが追加されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Each of the types we want to draw on the screen will implement the <code>Draw</code> trait but will use different code in the <code>draw</code> method to define how to draw that particular type, as <code>Button</code> has here (without the actual GUI code, which is beyond the scope of this chapter).</span>我々が実装する画面に描画したい種類の各<code>Draw</code>形質をしかしに異なるコードを使用する<code>draw</code>として、その特定のタイプを描画する方法を定義する方法<code>Button</code>ここに持っている範囲を超えており、実際のGUIコードなし（この章の）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Button</code> type, for instance, might have an additional <code>impl</code> block containing methods related to what happens when a user clicks the button.</span>たとえば、 <code>Button</code>型には、ユーザーがボタンをクリックしたときの処理に関連するメソッドを含む<code>impl</code>ブロックが追加されている場合があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These kinds of methods won&#39;t apply to types like <code>TextField</code> .</span>これらの種類のメソッドは、 <code>TextField</code>ような型には適用されません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If someone using our library decides to implement a <code>SelectBox</code> struct that has <code>width</code> , <code>height</code> , and <code>options</code> fields, they implement the <code>Draw</code> trait on the <code>SelectBox</code> type as well, as shown in Listing 17-8:</span>私たちのライブラリを使用している人が、 <code>width</code> 、 <code>height</code> 、および<code>options</code>フィールドを持つ<code>SelectBox</code>構造体を実装することを決定した場合、リスト17-8で示すように、 <code>SelectBox</code>型の<code>Draw</code>特性も実装し<code>options</code> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust,ignore><div data-l="extern crate gui;"></div><div data-l="use gui::Draw;"></div><div data-l=""></div><div data-l="struct SelectBox {"></div><div data-l="    width: u32,"></div><div data-l="    height: u32,"></div><div data-l="    options: Vec&lt;String&gt;,"></div><div data-l=}></div><div data-l=""></div><div data-l="impl Draw for SelectBox {"></div><div data-l="    fn draw(&amp;self) {"></div><div data-l="#        // code to actually draw a select box"></div><div data-l="        // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">code to actually draw a select box</span>選択ボックスを実際に描画するコード</span> </div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 17-8: Another crate using <code>gui</code> and implementing the <code>Draw</code> trait on a <code>SelectBox</code> struct</span></span> <span class=caption>リスト17-8： <code>SelectBox</code>構造体に<code>gui</code>を使って<code>Draw</code>特性を実装する別の木枠</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Our library&#39;s user can now write their <code>main</code> function to create a <code>Screen</code> instance.</span>私たちの図書館のユーザーは、 <code>Screen</code>インスタンスを作成するための<code>main</code>機能を書くことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To the <code>Screen</code> instance, they can add a <code>SelectBox</code> and a <code>Button</code> by putting each in a <code>Box&lt;T&gt;</code> to become a trait object.</span> <code>Screen</code>インスタンスに対しては、それぞれを<code>Box&lt;T&gt;</code>に配置して<code>SelectBox</code>と<code>Button</code>追加して、 <code>SelectBox</code>することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">They can then call the <code>run</code> method on the <code>Screen</code> instance, which will call <code>draw</code> on each of the components.</span>次に、それぞれのコンポーネントで<code>draw</code>を呼び出す<code>Screen</code>インスタンスで<code>run</code>メソッドを呼び出すことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Listing 17-9 shows this implementation:</span>リスト17-9にこの実装を示します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust,ignore><div data-l="use gui::{Screen, Button};"></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let screen = Screen {"></div><div data-l="        components: vec!["></div><div data-l="            Box::new(SelectBox {"></div><div data-l="                width: 75,"></div><div data-l="                height: 10,"></div><div data-l="                options: vec!["></div><div data-l="                    String::from(&quot;Yes&quot;),"></div><div data-l="                    String::from(&quot;Maybe&quot;),"></div><div data-l="                    String::from(&quot;No&quot;)"></div><div data-l="                ],"></div><div data-l="            }),"></div><div data-l="            Box::new(Button {"></div><div data-l="                width: 50,"></div><div data-l="                height: 10,"></div><div data-l="                label: String::from(&quot;OK&quot;),"></div><div data-l="            }),"></div><div data-l="        ],"></div><div data-l="    };"></div><div data-l=""></div><div data-l="    screen.run();"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 17-9: Using trait objects to store values of different types that implement the same trait</span></span> <span class=caption>リスト17-9：特性オブジェクトを使用して、同じ特性を実装する異なるタイプの値を格納する</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When we wrote the library, we didn&#39;t know that someone might add the <code>SelectBox</code> type, but our <code>Screen</code> implementation was able to operate on the new type and draw it because <code>SelectBox</code> implements the <code>Draw</code> type, which means it implements the <code>draw</code> method.</span>私たちは、ライブラリを書いたとき、私たちは誰かが追加される場合がありますことを知らなかった<code>SelectBox</code>種類を、私たちの<code>Screen</code>実装は、新しいタイプで動作しているため、それを描くことができた<code>SelectBox</code>実装<code>Draw</code> 、それが実装さを意味し、タイプを<code>draw</code>する方法を。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This concept—of being concerned only with the messages a value responds to rather than the value&#39;s concrete type—is similar to the concept <i>duck typing</i> in dynamically typed languages: if it walks like a duck and quacks like a duck, then it must be a duck!</span>このコンセプトは、値が具体的なタイプではなく応答するメッセージにのみ関係しているということです。これは、動的に型指定された言語での<i>ダックタイピング</i>のコンセプトに似てい<i>ます。アヒルの</i>ように歩き、アヒルのように倒れた場合、アヒル！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In the implementation of <code>run</code> on <code>Screen</code> in Listing 17-5, <code>run</code> doesn&#39;t need to know what the concrete type of each component is.</span>リスト17-5の<code>run</code> on <code>Screen</code>実装では、 <code>run</code>は各コンポーネントの具体的なタイプが何であるかを知る必要はありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It doesn&#39;t check whether a component is an instance of a <code>Button</code> or a <code>SelectBox</code> , it just calls the <code>draw</code> method on the component.</span>コンポーネントが<code>Button</code>か<code>SelectBox</code>インスタンスかどうかはチェックされず、コンポーネントの<code>draw</code>メソッドが呼び出されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">By specifying <code>Box&lt;Draw&gt;</code> as the type of the values in the <code>components</code> vector, we&#39;ve defined <code>Screen</code> to need values that we can call the <code>draw</code> method on.</span>指定することにより、 <code>Box&lt;Draw&gt;</code>の値の型として<code>components</code>ベクトル、我々が定義した<code>Screen</code> 、我々は呼び出すことができます値必要に<code>draw</code>に方法を。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The advantage of using trait objects and Rust&#39;s type system to write code similar to code using duck typing is that we never have to check whether a value implements a particular method at runtime or worry about getting errors if a value doesn&#39;t implement a method but we call it anyway.</span>ダックタイピングを使用してコードに似たコードを書くために特性オブジェクトとRustの型システムを使用する利点は、値が実行時に特定のメソッドを実装するかどうかをチェックする必要はなく、とにかくそれを呼びます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust won&#39;t compile our code if the values don&#39;t implement the traits that the trait objects need.</span>値が特性オブジェクトが必要とする特性を実装していない場合、Rustはコードをコンパイルしません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, Listing 17-10 shows what happens if we try to create a <code>Screen</code> with a <code>String</code> as a component:</span>たとえば、リスト17-10は、 <code>String</code>をコンポーネントとして<code>Screen</code>を作成しようとするとどうなるかを示しています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=filename>Filename: src/main.rs</span></span> <span class=filename>ファイル名：src / main.rs</span></span> </p><br><div data-lang=rust,ignore><div data-l="extern crate gui;"></div><div data-l="use gui::Screen;"></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let screen = Screen {"></div><div data-l="        components: vec!["></div><div data-l="            Box::new(String::from(&quot;Hi&quot;)),"></div><div data-l="        ],"></div><div data-l="    };"></div><div data-l=""></div><div data-l="    screen.run();"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><span class=caption>Listing 17-10: Attempting to use a type that doesn&#39;t implement the trait object&#39;s trait</span></span> <span class=caption>リスト17-10：traitオブジェクトの特性を実装していない型の使用を試みる</span></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll get this error because <code>String</code> doesn&#39;t implement the <code>Draw</code> trait:</span> <code>String</code>は<code>Draw</code>特性を実装していないため、このエラーが発生します：</span> </p><br><div data-lang=text><div data-l="error[E0277]: the trait bound `std::string::String: gui::Draw` is not satisfied"></div><div data-l="  --&gt; src/main.rs:7:13"></div><div data-l="   |"></div><div data-l=" 7 |             Box::new(String::from(&quot;Hi&quot;)),"></div><div data-l="   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait gui::Draw is not"></div><div data-l="   implemented for `std::string::String`"></div><div data-l="   |"></div><div data-l="   = note: required for the cast to the object type `gui::Draw`"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This error lets us know that either we&#39;re passing something to <code>Screen</code> we didn&#39;t mean to pass and we should pass a different type or we should implement <code>Draw</code> on <code>String</code> so that <code>Screen</code> is able to call <code>draw</code> on it.</span>このエラーは、私たちはどちらか私たちがして何かを渡していることを知ることができます<code>Screen</code>我々が合格するという意味ではありませんでしたし、私たちはさまざまな型を渡す必要があるか、私たちが実装する必要が<code>Draw</code>上で<code>String</code>ように<code>Screen</code>呼び出すことができるで<code>draw</code>ことに。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Trait Objects Perform Dynamic Dispatch</span>特性オブジェクトは動的ディスパッチを実行する</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Recall in the “Performance of Code Using Generics” section in Chapter 10 our discussion on the monomorphization process performed by the compiler when we use trait bounds on generics: the compiler generates nongeneric implementations of functions and methods for each concrete type that we use in place of a generic type parameter.</span>第10章の「Genericを使用したコードのパフォーマンス」のセクションで、ジェネリックの特性境界を使用するときにコンパイラによって実行される単体化プロセスについての議論を行います。コンパイラは、使用する具体的なタイプごとに、ジェネリック型パラメータの</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The code that results from monomorphization is doing <i>static dispatch</i> , which is when the compiler knows what method you&#39;re calling at compile time.</span>単一形化に起因するコードは、コンパイル時に呼び出すメソッドをコンパイラが知っているときに<i>静的なディスパッチを</i>実行しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is opposed to <i>dynamic dispatch</i> , which is when the compiler can&#39;t tell at compile time which method you&#39;re calling.</span>これは<i>動的ディスパッチ</i>とは対照的です。コンパイル時に呼び出すメソッドをコンパイル時に通知できない場合です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In dynamic dispatch cases, the compiler emits code that at runtime will figure out which method to call.</span>動的ディスパッチの場合、コンパイラは実行時に呼び出すメソッドを特定するコードを発行します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When we use trait objects, Rust must use dynamic dispatch.</span>特性オブジェクトを使用する場合、Rustは動的ディスパッチを使用する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The compiler doesn&#39;t know all the types that might be used with the code that is using trait objects, so it doesn&#39;t know which method implemented on which type to call.</span>コンパイラは、traitオブジェクトを使用しているコードで使用される可能性があるすべての型を認識しないため、呼び出す型の実装されているメソッドがわかりません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Instead, at runtime, Rust uses the pointers inside the trait object to know which method to call.</span>代わりに、実行時に、Rustはtraitオブジェクト内のポインタを使用して、呼び出すメソッドを知ります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There is a runtime cost when this lookup happens that doesn&#39;t occur with static dispatch.</span>静的ディスパッチでは発生しないこのルックアップが発生すると、ランタイムコストが発生します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Dynamic dispatch also prevents the compiler from choosing to inline a method&#39;s code, which in turn prevents some optimizations.</span>動的ディスパッチはまた、コンパイラがメソッドのコードをインライン化することを選択できないようにします。これにより、いくつかの最適化が妨げられます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, we did get extra flexibility in the code that we wrote in Listing 17-5 and were able to support in Listing 17-9, so it&#39;s a trade-off to consider.</span>しかし、リスト17-5で書いたコードでは柔軟性があり、リスト17-9でサポートすることができたので、考慮する必要はありません。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Object Safety Is Required for Trait Objects</span>特性オブジェクトにはオブジェクトの安全性が必要です</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can only make <i>object-safe</i> traits into trait objects.</span> <i>オブジェクトセーフな</i>形質は、形質オブジェクトにのみ作成できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Some complex rules govern all the properties that make a trait object safe, but in practice, only two rules are relevant.</span>複雑なルールの中には、特性オブジェクトを安全にするすべてのプロパティを管理するものがありますが、実際には2つのルールのみが適切です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A trait is object safe if all the methods defined in the trait have the following properties:</span>特性に定義されているすべてのメソッドが次のプロパティを持つ場合、特性はオブジェクトセーフです。</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The return type isn&#39;t <code>Self</code> .</span>戻り値の型は<code>Self</code>はありません。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There are no generic type parameters.</span>ジェネリック型パラメータはありません。</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Self</code> keyword is an alias for the type we&#39;re implementing the traits or methods on.</span> <code>Self</code>キーワードは、特性やメソッドを実装するタイプのエイリアスです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Trait objects must be object safe because once you&#39;ve used a trait object, Rust no longer knows the concrete type that&#39;s implementing that trait.</span>特性オブジェクトを使用すると、Rustはその特性を実装している具体的なタイプを認識していないため、特性オブジェクトはオブジェクトセーフでなければなりません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If a trait method returns the concrete <code>Self</code> type, but a trait object forgets the exact type that <code>Self</code> is, there is no way the method can use the original concrete type.</span> traitメソッドが具体的な<code>Self</code>型を返すが、Traitオブジェクトが<code>Self</code>と同じ型を忘れた場合、メソッドが元の具象型を使用する方法はありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The same is true of generic type parameters that are filled in with concrete type parameters when the trait is used: the concrete types become part of the type that implements the trait.</span>これは、形質が使用されるときに具体的な型パラメータで埋められるジェネリック型のパラメータにも当てはまります。具体的な型は、その型を実装する型の一部になります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When the type is forgotten through the use of a trait object, there is no way to know what types to fill in the generic type parameters with.</span>型オブジェクトを使用して型を忘れると、汎用型のパラメータでどの型を埋めるべきかを知る方法がありません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">An example of a trait whose methods are not object safe is the standard library&#39;s <code>Clone</code> trait.</span>メソッドがオブジェクトセーフではない形質の例は、標準ライブラリの<code>Clone</code>特性です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The signature for the <code>clone</code> method in the <code>Clone</code> trait looks like this:</span> <code>Clone</code>特性の<code>clone</code>メソッドのシグネチャは次のようになります。</span> </p><br><div data-lang=rust><div data-l="pub trait Clone {"></div><div data-l="    fn clone(&amp;self) -&gt; Self;"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>String</code> type implements the <code>Clone</code> trait, and when we call the <code>clone</code> method on an instance of <code>String</code> we get back an instance of <code>String</code> .</span> <code>String</code>型が実装<code>Clone</code>形質を、そして私たちが呼ぶとき<code>clone</code>のインスタンスでメソッドを<code>String</code>我々はバックのインスタンスを取得<code>String</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Similarly, if we call <code>clone</code> on an instance of <code>Vec&lt;T&gt;</code> , we get back an instance of <code>Vec&lt;T&gt;</code> .</span>私たちが呼ぶならば同様に、 <code>clone</code>のインスタンスに<code>Vec&lt;T&gt;</code>我々は戻ってのインスタンスを取得<code>Vec&lt;T&gt;</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The signature of <code>clone</code> needs to know what type will stand in for <code>Self</code> , because that&#39;s the return type.</span> <code>clone</code>のシグネチャは、戻り値の型であるため、 <code>Self</code>にどのタイプが含まれるかを知る必要があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The compiler will indicate when you&#39;re trying to do something that violates the rules of object safety in regard to trait objects.</span>コンパイラは、特性オブジェクトに関してオブジェクトの安全性のルールに違反する何かをしようとしているときにそれを表示します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, let&#39;s say we tried to implement the <code>Screen</code> struct in Listing 17-4 to hold types that implement the <code>Clone</code> trait instead of the <code>Draw</code> trait, like this:</span>たとえば、リスト17-4の<code>Screen</code>構造体を実装して、 <code>Draw</code>特性の代わりに<code>Clone</code>特性を実装するタイプを保持しようとしたとしましょう。</span> </p><br><div data-lang=rust,ignore><div data-l="pub struct Screen {"></div><div data-l="    pub components: Vec&lt;Box&lt;Clone&gt;&gt;,"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We would get this error:</span>このエラーが発生します：</span> </p><br><div data-lang=text><div data-l="error[E0038]: the trait `std::clone::Clone` cannot be made into an object"></div><div data-l=" --&gt; src/lib.rs:2:5"></div><div data-l="  |"></div><div data-l="2 |     pub components: Vec&lt;Box&lt;Clone&gt;&gt;,"></div><div data-l="  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::clone::Clone` cannot be"></div><div data-l="made into an object"></div><div data-l="  |"></div><div data-l="  = note: the trait cannot require that `Self : Sized`"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This error means you can&#39;t use this trait as a trait object in this way.</span>このエラーは、この方法でこの特性を形質オブジェクトとして使用できないことを意味します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you&#39;re interested in more details on object safety, see <a class=notranslate href="#4Rust RFC 255">Rust RFC 255</a> .</span>オブジェクトの安全性の詳細については、 <a class=notranslate href="#4Rust RFC 255">Rust RFC 255</a>参照してください。</span> </p><br> <a class=notranslate href=#1https://github.com/rust-lang/rfcs/blob/master/text/0255-object-safety.md>Rust RFC 255</a><script>_addload(function(){_setupIW('com');_csi('en','ja','ch17-02-trait-objects.html');});</script>