<!DOCTYPE html>
<h1>Final Project: Building a Multithreaded Web Server</h1>
<br>
<p>It’s been a long journey, but we’ve reached the end of the book. In this
chapter, we’ll build one more project together to demonstrate some of the
concepts we covered in the final chapters, as well as recap some earlier
lessons.</p>
<br>
<p>For our final project, we’ll make a web server that says “hello” and looks like
Figure 20-1 in a web browser.</p>
<br>
<p>!<a href="#2img/trpl20-01.png">hello from rust</a></p>
<br>
<p><span class="caption">Figure 20-1: Our final shared project</span></p>
<br>
<p>Here is the plan to build the web server:</p>
<br>
<div data-b="1.">Learn a bit about TCP and HTTP.</div>
<div data-b="2.">Listen for TCP connections on a socket.</div>
<div data-b="3.">Parse a small number of HTTP requests.</div>
<div data-b="4.">Create a proper HTTP response.</div>
<div data-b="5.">Improve the throughput of our server with a thread pool.</div>
<br>
<p>But before we get started, we should mention one detail: the method we’ll use
won’t be the best way to build a web server with Rust. A number of
production-ready crates are available on <i>https://crates.io/</i> that provide more
complete web server and thread pool implementations than we’ll build.</p>
<br>
<p>However, our intention in this chapter is to help you learn, not to take the
easy route. Because Rust is a systems programming language, we can choose the
level of abstraction we want to work with and can go to a lower level than is
possible or practical in other languages. We’ll write the basic HTTP server and
thread pool manually so you can learn the general ideas and techniques behind
the crates you might use in the future.</p>