<!DOCTYPE html>
<h1>Using Modules to Reuse and Organize Code</h1>
<br>
<p>When you start writing programs in Rust, your code might live solely in the
<code>main</code> function. As your code grows, you’ll eventually move functionality into
other functions for reuse and better organization. By splitting your code into
smaller chunks, you make each chunk easier to understand on its own. But what
happens if you have too many functions? Rust has a module system that enables
the reuse of code in an organized fashion.</p>
<br>
<p>In the same way that you extract lines of code into a function, you can extract
functions (and other code, like structs and enums) into different modules. A
<i>module</i> is a namespace that contains definitions of functions or types, and
you can choose whether those definitions are visible outside their module
(public) or not (private). Here’s an overview of how modules work:</p>
<br>
<div data-b="*">The <code>mod</code> keyword declares a new module. Code within the module appears
either immediately following this declaration within curly brackets or in
another file.</div>
<div data-b="*">By default, functions, types, constants, and modules are private. The <code>pub</code>
keyword makes an item public and therefore visible outside its namespace.</div>
<div data-b="*">The <code>use</code> keyword brings modules, or the definitions inside modules, into
scope so it’s easier to refer to them.</div>
<br>
<p>We’ll look at each of these parts to see how they fit into the whole.</p>