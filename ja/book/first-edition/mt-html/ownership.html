<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180709_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=ownership.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Ownership</span>所有</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is the first of three sections presenting Rust&#39;s ownership system.</span>これは、Rustの所有システムを提示する3つのセクションのうちの最初のものです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is one of Rust&#39;s most distinct and compelling features, with which Rust developers should become quite acquainted.</span>これは、Rustの最も顕著で魅力的な機能の1つで、Rustの開発者はかなり知り合いになるはずです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Ownership is how Rust achieves its largest goal, memory safety.</span>所有権とは、Rustが最大の目標であるメモリの安全性を達成する方法です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There are a few distinct concepts, each with its own chapter:</span>いくつかの異なる概念があり、それぞれ独自の章があります。</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">ownership, which you&#39;re reading now</span>あなたが今読んでいる所有権</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a class=notranslate href=#3borrowing>borrowing</a> , and their associated feature &#39;references&#39;</span> <a class=notranslate href=#3borrowing>borrowing</a> 、およびそれらの関連するフィーチャ &#39;参照&#39;</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a class=notranslate href=#3lifetimes>lifetimes</a> , an advanced concept of borrowing</span> <a class=notranslate href=#3lifetimes>lifetimes</a> 、高度な借入概念</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These three chapters are related, and in order.</span>これら3つの章は関連しており、順番に説明されています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You&#39;ll need all three to fully understand the ownership system.</span>所有権システムを完全に理解するには、3つすべてが必要です。</span> </p><br> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a class=notranslate href=#1references-and-borrowing.html>borrowing</a> <a class=notranslate href=#1lifetimes.html>lifetimes</a></span> <a class=notranslate href=#1lifetimes.html>lifetimes</a> <a class=notranslate href=#1references-and-borrowing.html>borrowing</a></span> <br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Meta</span>メタ</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Before we get to the details, two important notes about the ownership system.</span>詳細を知る前に、オーナーシップシステムに関する2つの重要な注意事項。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust has a focus on safety and speed.</span>錆は安全性とスピードに焦点を当てています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It accomplishes these goals through many &#39;zero-cost abstractions&#39;, which means that in Rust, abstractions cost as little as possible in order to make them work.</span>これは、多くの「ゼロコスト抽象化」によってこれらの目標を達成します。つまり、Rustでは抽象化のコストをできるだけ少なくして機能させることを意味します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The ownership system is a prime example of a zero-cost abstraction.</span>所有権システムは、ゼロコスト抽象化の主要な例です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">All of the analysis we&#39;ll talk about in this guide is <s>done at compile time</s> .</span>このガイド<s>で説明する</s>すべての分析は<s>、コンパイル時に行われます</s> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You do not pay any run-time cost for any of these features.</span>これらの機能のランタイムコストを支払うことはありません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, this system does have a certain cost: learning curve.</span>しかし、このシステムには一定のコストがあります：学習曲線。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Many new users to Rust experience something we like to call &#39;fighting with the borrow checker&#39;, where the Rust compiler refuses to compile a program that the author thinks is valid.</span> Rustの新しいユーザーの多くは、Rustコンパイラが作成者が有効だと思うプログラムをコンパイルすることを拒否する「borrow checkerとの戦い」と呼ばれることを経験しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This often happens because the programmer&#39;s mental model of how ownership should work doesn&#39;t match the actual rules that Rust implements.</span>これは、所有者がどのように動作するかについてのプログラマーの精神モデルが、Rustが実装する実際のルールと一致しないためによく発生します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You probably will experience similar things at first.</span>最初は似たようなことを経験するでしょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There is good news, however: more experienced Rust developers report that once they work with the rules of the ownership system for a period of time, they fight the borrow checker less and less.</span>ただし、経験豊かなRustデベロッパーは、所有システムのルールを一定期間使用すると、借りチェッカーとの競争が少なくなることを報告しています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">With that in mind, let&#39;s learn about ownership.</span>そのことを念頭に置いて、所有権について学びましょう。</span> </p><br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Ownership</span>所有</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a href=#3bindings>Variable bindings</a> have a property in Rust: they &#39;have ownership&#39; of what they&#39;re bound to.</span> <a href=#3bindings>変数バインディング</a>はRustのプロパティを持っています。バインドされているものの所有権を持っています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This means that when a binding goes out of scope, Rust will free the bound resources.</span>つまり、バインディングが有効範囲外になると、Rustはバインドされたリソースを解放します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example:</span>例えば：</span> </p><br><div data-lang=rust><div data-l="fn foo() {"></div><div data-l="    let v = vec![1, 2, 3];"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When <code>v</code> comes into scope, a new <a class=notranslate href=#3vectors>vector</a> is created on <a href=#3stack>the stack</a> , and it allocates space on <a href=#3heap>the heap</a> for its elements.</span> <code>v</code>が有効になると<a href=#3stack>、スタック</a>上に新しい<a class=notranslate href=#3vectors>vector</a>が作成され<a href=#3heap>、ヒープ上</a>にその要素のためのスペースが割り当てられます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When <code>v</code> goes out of scope at the end of <code>foo()</code> , Rust will clean up everything related to the vector, even the heap-allocated memory.</span> <code>v</code>が<code>foo()</code>終わりにスコープから外れると、Rustはベクトルに関連するすべてのもの、ヒープ割り当てメモリさえもクリーンアップします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This happens deterministically, at the end of the scope.</span>これは、スコープの最後に確定的に発生します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We covered <a class=notranslate href=#4vectors>vectors</a> in the previous chapter;</span>前の章で<a class=notranslate href=#4vectors>vectors</a>ました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">we use them here as an example of a type that allocates space on the heap at runtime.</span>実行時にヒープ上に領域を割り当てる型の例としてここで使用します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">They behave like <a class=notranslate href=#4arrays>arrays</a> , except their size may change by <code>push()</code> ing more elements onto them.</span>それらは<a class=notranslate href=#4arrays>arrays</a>ように振る舞い<a class=notranslate href=#4arrays>arrays</a> 、それらの要素に<code>push()</code>することでサイズが変わることがあります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Vectors have a <a href=#3generics>generic type</a> <code>Vec&lt;T&gt;</code> , so in this example <code>v</code> will have type <code>Vec&lt;i32&gt;</code> .</span>ベクタは<a href=#3generics>汎用型</a> <code>Vec&lt;T&gt;</code>を持つため、この例では<code>v</code>は<code>Vec&lt;i32&gt;</code>型になります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll cover <a class=notranslate href=#4generics>generics</a> in detail in a later chapter.</span> <a class=notranslate href=#4generics>generics</a>については、後の章で詳しく説明します。</span> </p><br> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a class=notranslate href=#1primitive-types.html#arrays>arrays</a> <a class=notranslate href=#1vectors.html>vectors</a> <a class=notranslate href=#1the-stack-and-the-heap.html#the-heap>heap</a> <a class=notranslate href=#1the-stack-and-the-heap.html#the-stack>stack</a> <a class=notranslate href=#1variable-bindings.html>bindings</a> <a class=notranslate href=#1generics.html>generics</a></span> <a class=notranslate href=#1primitive-types.html#arrays>arrays</a> <a class=notranslate href=#1vectors.html>vectors</a> <a class=notranslate href=#1the-stack-and-the-heap.html#the-heap>heap</a> <a class=notranslate href=#1the-stack-and-the-heap.html#the-stack>stack</a> <a class=notranslate href=#1variable-bindings.html>bindings</a> <a class=notranslate href=#1generics.html>generics</a></span> <br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Move semantics</span>セマンティクスを移動する</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There&#39;s some more subtlety here, though: Rust ensures that there is <s>exactly one</s> binding to any given resource.</span>しかし、ここではさらに細かいことがあります：Rustは、特定のリソースへのバインディングが<s>1つだけ</s>であることを保証します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, if we have a vector, we can assign it to another binding:</span>たとえば、ベクターがある場合は、それを別のバインディングに割り当てることができます。</span> </p><br><div data-lang=rust><div data-l="let v = vec![1, 2, 3];"></div><div data-l=""></div><div data-l="let v2 = v;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But, if we try to use <code>v</code> afterwards, we get an error:</span>しかし、 <code>v</code>後で使用しようとすると、エラーが発生します。</span> </p><br><div data-lang=rust,ignore><div data-l="let v = vec![1, 2, 3];"></div><div data-l=""></div><div data-l="let v2 = v;"></div><div data-l=""></div><div data-l="println!(&quot;v[0] is: {}&quot;, v[0]);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It looks like this:</span>これは次のようになります。</span> </p><br><div data-lang=text><div data-l="error: use of moved value: `v`"></div><div data-l="println!(&quot;v[0] is: {}&quot;, v[0]);"></div><div data-l="                        ^"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A similar thing happens if we define a function which takes ownership, and try to use something after we&#39;ve passed it as an argument:</span>所有権を取得する関数を定義し、それを引数として渡した後に何かを使用しようとすると、同様のことが起こります。</span> </p><br><div data-lang=rust,ignore><div data-l="fn take(v: Vec&lt;i32&gt;) {"></div><div data-l="#    // What happens here isn’t important."></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">What happens here isn&#39;t important.</span>ここで起こることは重要ではありません。</span> </div><div data-l=}></div><div data-l=""></div><div data-l="let v = vec![1, 2, 3];"></div><div data-l=""></div><div data-l=take(v);></div><div data-l=""></div><div data-l="println!(&quot;v[0] is: {}&quot;, v[0]);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Same error: &#39;use of moved value&#39;.</span>同じエラー： &#39;移動値の使用&#39;。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When we transfer ownership to something else, we say that we&#39;ve &#39;moved&#39; the thing we refer to.</span>所有権を他のものに移すと、私たちが参照するものを「移動」したと言います。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You don&#39;t need some sort of special annotation here, it&#39;s the default thing that Rust does.</span>特別な注釈は必要ありません.Rustが行うデフォルトのものです。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The details</span>詳細</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The reason that we cannot use a binding after we&#39;ve moved it is subtle, but important.</span>私たちが移動した後にバインディングを使用できない理由は微妙ですが、重要です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When we write code like this:</span>このようなコードを書くときは：</span> </p><br><div data-lang=rust><div data-l="let x = 10;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust allocates memory for an integer <a class=notranslate href=#4i32>i32</a> on the <a class=notranslate href=#3sh>stack</a> , copies the bit pattern representing the value of 10 to the allocated memory and binds the variable name x to this memory region for future reference.</span> Rustは<a class=notranslate href=#3sh>stack</a>上の整数<a class=notranslate href=#4i32>i32</a>メモリを割り当て、10の値を表すビットパターンを割り当てられたメモリにコピーし、将来の参照のために変数名xをこのメモリ領域にバインドします。</span> </p><br> <a class=notranslate href=#1primitive-types.html#numeric-types>i32</a> <br> <p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now consider the following code fragment:</span>ここで、次のコード断片を考えてみましょう。</span> </p><br><div data-lang=rust><div data-l="let v = vec![1, 2, 3];"></div><div data-l=""></div><div data-l="let mut v2 = v;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The first line allocates memory for the vector object <code>v</code> on the stack like it does for <code>x</code> above.</span>最初の行は、上記の<code>x</code>場合と同様に、ベクトルオブジェクト<code>v</code>メモリをスタックに割り当てます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But in addition to that it also allocates some memory on the <a class=notranslate href=#3sh>heap</a> for the actual data ( <code>[1, 2, 3]</code> ).</span>しかしそれに加えて、 <a class=notranslate href=#3sh>heap</a>上に実際のデータ（ <code>[1, 2, 3]</code> ）のためにいくらかのメモリも割り当て<a class=notranslate href=#3sh>heap</a> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust copies the address of this heap allocation to an internal pointer, which is part of the vector object placed on the stack (let&#39;s call it the data pointer).</span>錆は、このヒープ割り当てのアドレスを内部ポインタにコピーします。内部ポインタは、スタックに配置されたベクタオブジェクトの一部です（データポインタと呼ばせてください）。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It is worth pointing out (even at the risk of stating the obvious) that the vector object and its data live in separate memory regions instead of being a single contiguous memory allocation (due to reasons we will not go into at this point of time).</span>ベクトルオブジェクトとそのデータは、単一の連続したメモリ割り当てではなく、別々のメモリ領域に存在することを指摘する価値があります（この時点では取り上げない理由による） 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These two parts of the vector (the one on the stack and one on the heap) must agree with each other at all times with regards to things like the length, capacity, etc.</span>ベクトルの2つの部分（スタック上のものとヒープ上のもの）は、長さ、容量などの点で常に一致しなければなりません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When we move <code>v</code> to <code>v2</code> , Rust actually does a bitwise copy of the vector object <code>v</code> into the stack allocation represented by <code>v2</code> .</span> <code>v</code>を<code>v2</code>に移動すると、Rustは実際にベクトルオブジェクト<code>v</code>ビット単位のコピーを<code>v2</code>表されるスタック割り当てに行います。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This shallow copy does not create a copy of the heap allocation containing the actual data.</span>この浅いコピーは、実際のデータを含むヒープ割り当てのコピーを作成しません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Which means that there would be two pointers to the contents of the vector both pointing to the same memory allocation on the heap.</span>これは、ベクトルの内容に対する2つのポインタが、ヒープ上の同じメモリ割り当てを指し示すことを意味する。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It would violate Rust&#39;s safety guarantees by introducing a data race if one could access both <code>v</code> and <code>v2</code> at the same time.</span> <code>v</code>と<code>v2</code>両方に同時にアクセスできる場合、データ競争を導入することでRustの安全保証に違反することになります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example if we truncated the vector to just two elements through <code>v2</code> :</span>たとえば、ベクトルを<code>v2</code>から2つの要素に切り捨てた場合、</span> </p><br><div data-lang=rust><div data-l="# let v = vec![1, 2, 3];"></div><div data-l="# let mut v2 = v;"></div><div data-l=v2.truncate(2);></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">and <code>v</code> were still accessible we&#39;d end up with an invalid vector since <code>v</code> would not know that the heap data has been truncated.</span>そして<code>v</code>以来、私たちは、無効なベクトルで終わるだろうまだアクセスした<code>v</code> 、ヒープデータが切り捨てられたことを知ることはできません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now, the part of the vector <code>v</code> on the stack does not agree with the corresponding part on the heap.</span>さて、スタック上のベクトル<code>v</code>部分は、ヒープ上の対応する部分と一致しません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>v</code> still thinks there are three elements in the vector and will happily let us access the non existent element <code>v[2]</code> but as you might already know this is a recipe for disaster.</span> <code>v</code>まだベクトルに3つの要素があると思っていて、幸せには存在しない要素<code>v[2]</code>アクセスできるようになりますが、これは災害のためのレシピです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Especially because it might lead to a segmentation fault or worse allow an unauthorized user to read from memory to which they don&#39;t have access.</span>特に、セグメンテーションフォールトにつながる可能性があるか、悪化すると、権限のないユーザーがアクセスできないメモリから読み取ることができるためです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is why Rust forbids using <code>v</code> after we&#39;ve done the move.</span>これは、Rustが私たちが移動を行った後に<code>v</code>を使用することを禁じている理由です。</span> </p><br> <a class=notranslate href=#1the-stack-and-the-heap.html>sh</a> <br> <p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It&#39;s also important to note that optimizations may remove the actual copy of the bytes on the stack, depending on circumstances.</span>状況によっては、最適化によってスタック上のバ​​イトの実際のコピーが削除されることに注意することも重要です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So it may not be as inefficient as it initially seems.</span>だから最初のように非効率的ではないかもしれません。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>Copy</code> types</span> <code>Copy</code>タイプ</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ve established that when ownership is transferred to another binding, you cannot use the original binding.</span>所有権が別のバインディングに転送されると、元のバインディングを使用することはできません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, there&#39;s a <a class=notranslate href=#3traits>trait</a> that changes this behavior, and it&#39;s called <code>Copy</code> .</span>しかし、この振る舞いを変える<a class=notranslate href=#3traits>trait</a>があり、 <code>Copy</code>と呼ばれています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We haven&#39;t discussed traits yet, but for now, you can think of them as an annotation to a particular type that adds extra behavior.</span>私たちはまだ特性について議論していませんが、今のところ特別な動作を追加する特定のタイプの注釈と考えることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example:</span>例えば：</span> </p><br><div data-lang=rust><div data-l="let v = 1;"></div><div data-l=""></div><div data-l="let v2 = v;"></div><div data-l=""></div><div data-l="println!(&quot;v is: {}&quot;, v);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this case, <code>v</code> is an <code>i32</code> , which implements the <code>Copy</code> trait.</span>この場合、 <code>v</code>は<code>i32</code> 、これは<code>Copy</code>特性を実装します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This means that, just like a move, when we assign <code>v</code> to <code>v2</code> , a copy of the data is made.</span>つまり、移動と同様に、 <code>v</code>を<code>v2</code>に代入すると、データのコピーが作成されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But, unlike a move, we can still use <code>v</code> afterward.</span>しかし、移動とは違って、私たちは後で<code>v</code>使うことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is because an <code>i32</code> has no pointers to data somewhere else, copying it is a full copy.</span>これは、 <code>i32</code>は他の場所へのデータへのポインタがないため、コピーは完全なコピーであるためです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">All primitive types implement the <code>Copy</code> trait and their ownership is therefore not moved like one would assume, following the &#39;ownership rules&#39;.</span>すべてのプリミティブ型は<code>Copy</code>特性を実装しているため、その所有権は &#39;所有権ルール&#39;に従うと想定されるように移動されません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To give an example, the two following snippets of code only compile because the <code>i32</code> and <code>bool</code> types implement the <code>Copy</code> trait.</span>例を挙げると、コードの2つのスニペットは、 <code>i32</code>と<code>bool</code>タイプが<code>Copy</code>特性を実装しているため、コンパイルするだけです。</span> </p><br><div data-lang=rust><div data-l="fn main() {"></div><div data-l="    let a = 5;"></div><div data-l=""></div><div data-l="    let _y = double(a);"></div><div data-l="    println!(&quot;{}&quot;, a);"></div><div data-l=}></div><div data-l=""></div><div data-l="fn double(x: i32) -&gt; i32 {"></div><div data-l="    x * 2"></div><div data-l=}></div></div><br><div data-lang=rust><div data-l="fn main() {"></div><div data-l="    let a = true;"></div><div data-l=""></div><div data-l="    let _y = change_truth(a);"></div><div data-l="    println!(&quot;{}&quot;, a);"></div><div data-l=}></div><div data-l=""></div><div data-l="fn change_truth(x: bool) -&gt; bool {"></div><div data-l="    !x"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we had used types that do not implement the <code>Copy</code> trait, we would have gotten a compile error because we tried to use a moved value.</span> <code>Copy</code>特性を実装していない型を使用した場合、移動した値を使用しようとしたためコンパイルエラーが発生していました。</span> </p><br><div data-lang=text><div data-l="error: use of moved value: `a`"></div><div data-l="println!(&quot;{}&quot;, a);"></div><div data-l="               ^"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We will discuss how to make your own types <code>Copy</code> in the <a class=notranslate href=#3traits>traits</a> section.</span>私たちは、あなた自身の型が作成する方法について説明します<code>Copy</code>に<a class=notranslate href=#3traits>traits</a>セクション。</span> </p><br> <a class=notranslate href=#1traits.html>traits</a> <br> <h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">More than ownership</span>所有権以上</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Of course, if we had to hand ownership back with every function we wrote:</span>もちろん、私たちが書いたすべての機能を所有権に戻さなければならない場合は、</span> </p><br><div data-lang=rust><div data-l="fn foo(v: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {"></div><div data-l="#    // Do stuff with `v`."></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Do stuff with <code>v</code> .</span> <code>v</code>物をしなさい。</span> </div><div data-l=""></div><div data-l="#    // Hand back ownership."></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Hand back ownership.</span>所有権を手渡す。</span> </div><div data-l="    v"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This would get very tedious.</span>これは非常に退屈になるでしょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It gets worse the more things we want to take ownership of:</span>所有権を取得したいことが増えれば悪化します：</span> </p><br><div data-lang=rust><div data-l="fn foo(v1: Vec&lt;i32&gt;, v2: Vec&lt;i32&gt;) -&gt; (Vec&lt;i32&gt;, Vec&lt;i32&gt;, i32) {"></div><div data-l="#    // Do stuff with `v1` and `v2`."></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Do stuff with <code>v1</code> and <code>v2</code> .</span> <code>v1</code>と<code>v2</code>ものを使ってください。</span> </div><div data-l=""></div><div data-l="#    // Hand back ownership, and the result of our function."></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Hand back ownership, and the result of our function.</span>手持ちの所有権と私たちの機能の結果。</span> </div><div data-l="    (v1, v2, 42)"></div><div data-l=}></div><div data-l=""></div><div data-l="let v1 = vec![1, 2, 3];"></div><div data-l="let v2 = vec![1, 2, 3];"></div><div data-l=""></div><div data-l="let (v1, v2, answer) = foo(v1, v2);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Ugh!</span>うん！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The return type, return line, and calling the function gets way more complicated.</span>戻り値の型、返り値、関数を呼び出すことはもっと複雑になります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Luckily, Rust offers a feature which helps us solve this problem.</span>幸運にも、Rustはこの問題を解決するのに役立つ機能を提供しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It&#39;s called borrowing and is the topic of the next section!</span>それは借用と呼ばれ、次のセクションのトピックです！</span> </p><br><script>_addload(function(){_setupIW('com');_csi('en','ja','ownership.html');});</script>