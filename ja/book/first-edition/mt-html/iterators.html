<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180709_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=iterators.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Iterators</span>イテレータ</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s talk about loops.</span>ループについて話しよう。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Remember Rust&#39;s <code>for</code> loop?</span> Rust&#39;s <code>for</code>ループを覚え<code>for</code>ますか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here&#39;s an example:</span>ここに例があります：</span> </p><br><div data-lang=rust><div data-l="for x in 0..10 {"></div><div data-l="    println!(&quot;{}&quot;, x);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now that you know more Rust, we can talk in detail about how this works.</span>あなたがRustをもっと知るようになったので、我々はこれがどのように機能するかについて詳しく話すことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Ranges (the <code>0..10</code> ) are &#39;iterators&#39;.</span>範囲（ <code>0..10</code> ）は「反復子」です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">An iterator is something that we can call the <code>.next()</code> method on repeatedly, and it gives us a sequence of things.</span>イテレータは、 <code>.next()</code>メソッドを繰り返し呼び出すことができるものであり、一連の処理を行います。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A range with two dots like <code>0..10</code> is inclusive on the left (so it starts at 0) and exclusive on the right (so it ends at 9).</span> <code>0..10</code>ような2つの点がある範囲は、左に（0から始まるように）含まれ、右にのみ（したがって9で終わります）です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A mathematician would write &quot;[0, 10)&quot;.</span>数学者は &quot;[0、10]&quot;と書く。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Like this:</span>このような：</span> </p><br><div data-lang=rust><div data-l="let mut range = 0..10;"></div><div data-l=""></div><div data-l="loop {"></div><div data-l="    match range.next() {"></div><div data-l="        Some(x) =&gt; {"></div><div data-l="            println!(&quot;{}&quot;, x);"></div><div data-l="        },"></div><div data-l="        None =&gt; { break }"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We make a mutable binding to the range, which is our iterator.</span>我々は反復子である範囲に対して可変バインディングを行います。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We then <code>loop</code> , with an inner <code>match</code> .</span>次に内側の<code>match</code> <code>loop</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This <code>match</code> is used on the result of <code>range.next()</code> , which gives us a reference to the next value of the iterator.</span>この<code>match</code>は、 <code>range.next()</code>結果に使用され、イテレータの次の値への参照を与えます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>next</code> returns an <code>Option&lt;i32&gt;</code> , in this case, which will be <code>Some(i32)</code> when we have a value and <code>None</code> once we run out.</span> <code>next</code> 、 <code>Option&lt;i32&gt;</code>返します。この場合、値がある場合は<code>Some(i32)</code> 、なくなると<code>None</code>になります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we get <code>Some(i32)</code> , we print it out, and if we get <code>None</code> , we <code>break</code> out of the loop.</span>私たちが出た場合<code>Some(i32)</code> 、我々はそれをプリントアウトして、我々は取得しない場合は<code>None</code> 、我々は<code>break</code>ループの外に。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This code sample is basically the same as our <code>for</code> loop version.</span>このコードサンプルは、基本的に<code>for</code>ループバージョンと同じです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>for</code> loop is a handy way to write this <code>loop</code> / <code>match</code> / <code>break</code> construct.</span> <code>for</code>ループは、この<code>loop</code> / <code>match</code> / <code>break</code>構造を書く便利な方法です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>for</code> loops aren&#39;t the only thing that uses iterators, however.</span> <code>for</code>ループはイテレータを使用する唯一のものではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Writing your own iterator involves implementing the <code>Iterator</code> trait.</span>独自のイテレータを書くには、 <code>Iterator</code>特性を実装する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">While doing that is outside of the scope of this guide, Rust provides a number of useful iterators to accomplish various tasks.</span>これを行うのはこのガイドの範囲外ですが、Rustはさまざまなタスクを達成するための数多くの有用なイテレータを提供しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But first, a few notes about limitations of ranges.</span>しかし、まず、範囲の限界についてのいくつかの注意。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Ranges are very primitive, and we often can use better alternatives.</span>範囲は非常に原始的であり、我々はしばしばより良い選択肢を使用することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Consider the following Rust anti-pattern: using ranges to emulate a C-style <code>for</code> loop.</span>以下のRustアンチパターンを考えてみましょう。範囲を使用してCスタイル<code>for</code>ループをエミュレート<code>for</code>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s suppose you needed to iterate over the contents of a vector.</span>ベクトルの内容を繰り返し処理する必要があるとしましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You may be tempted to write this:</span>あなたはこれを書くように誘惑されるかもしれません：</span> </p><br><div data-lang=rust><div data-l="let nums = vec![1, 2, 3];"></div><div data-l=""></div><div data-l="for i in 0..nums.len() {"></div><div data-l="    println!(&quot;{}&quot;, nums[i]);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is strictly worse than using an actual iterator.</span>これは、実際のイテレータを使用するよりも厳密に悪いことです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can iterate over vectors directly, so write this:</span>ベクトルを直接反復処理することができますので、これを書いてください：</span> </p><br><div data-lang=rust><div data-l="let nums = vec![1, 2, 3];"></div><div data-l=""></div><div data-l="for num in &amp;nums {"></div><div data-l="    println!(&quot;{}&quot;, num);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There are two reasons for this.</span>これには2つの理由があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">First, this more directly expresses what we mean.</span>まず、これは我々が意味するものをより直接的に表しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We iterate through the entire vector, rather than iterating through indexes, and then indexing the vector.</span>インデックス全体を反復処理するのではなく、ベクトル全体を反復処理し、ベクトルをインデックス化します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Second, this version is more efficient: the first version will have extra bounds checking because it used indexing, <code>nums[i]</code> .</span>第2に、このバージョンがより効率的です。最初のバージョンでは、インデックス<code>nums[i]</code>使用しているため、余分な境界チェックが行われます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But since we yield a reference to each element of the vector in turn with the iterator, there&#39;s no bounds checking in the second example.</span>しかし、イテレータでベクトルの各要素への参照を順番に生成するので、2番目の例では境界チェックはありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is very common with iterators: we can ignore unnecessary bounds checks, but still know that we&#39;re safe.</span>これはイテレータでは非常に一般的です。不要な境界チェックを無視できますが、まだ安全であることはわかります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There&#39;s another detail here that&#39;s not 100% clear because of how <code>println€</code> works.</span> <code>println€</code>がどのように動作するかによって100％明確ではない別の詳細がここにあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>num</code> is actually of type <code>&amp;i32</code> .</span> <code>num</code>は実際には<code>&amp;i32</code>型です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That is, it&#39;s a reference to an <code>i32</code> , not an <code>i32</code> itself.</span>つまり、それはへの参照です<code>i32</code> 、ない<code>i32</code>そのもの。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>println€</code> handles the dereferencing for us, so we don&#39;t see it.</span> <code>println€</code>は私たちの参照解除を処理するので、表示されません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This code works fine too:</span>このコードもうまくいきます：</span> </p><br><div data-lang=rust><div data-l="let nums = vec![1, 2, 3];"></div><div data-l=""></div><div data-l="for num in &amp;nums {"></div><div data-l="    println!(&quot;{}&quot;, *num);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now we&#39;re explicitly dereferencing <code>num</code> .</span>今我々は<code>num</code>明示的に逆参照している。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Why does <code>&amp;nums</code> give us references?</span>なぜ<code>&amp;nums</code>は私たちに参照を与えるのですか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Firstly, because we explicitly asked it to with <code>&amp;</code> .</span>まず、 <code>&amp;</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Secondly, if it gave us the data itself, we would have to be its owner, which would involve making a copy of the data and giving us the copy.</span>第二に、それがデータそのものを私たちに与えたならば、データのコピーを作成して私たちにそれを与えることを含む所有者でなければなりません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">With references, we&#39;re only borrowing a reference to the data, and so it&#39;s only passing a reference, without needing to do the move.</span>参考文献では、データへの参照のみを借用しているため、参照を渡すだけで、移動する必要はありません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So, now that we&#39;ve established that ranges are often not what you want, let&#39;s talk about what you do want instead.</span>それで、範囲がしばしばあなたが望むものではないことを確立したので、代わりにあなたがしたいことについて話しましょう。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There are three broad classes of things that are relevant here: iterators, <i>iterator adaptors</i> , and <i>consumers</i> .</span>ここでは、 <i>イテレーター</i> 、 <i>イテレーター・アダプター</i> 、および<i>コンシューマーの</i> 3つのクラスに大別できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here&#39;s some definitions:</span>いくつかの定義があります：</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><i>iterators</i> give you a sequence of values.</span> <i>イテレータ</i>は一連の値を<i>返し</i>ます。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><i>iterator adaptors</i> operate on an iterator, producing a new iterator with a different output sequence.</span> <i>イテレータアダプタ</i>はイテレータ上で動作し、異なる出力シーケンスを持つ新しいイテレータを生成します。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><i>consumers</i> operate on an iterator, producing some final set of values.</span> <i>消費者</i>はイテレータ上で動作し、最終的な値セットを生成します。</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s talk about consumers first, since you&#39;ve already seen an iterator, ranges.</span>すでにイテレータ、範囲を見てきたので、最初に消費者について話しましょう。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Consumers</span>消費者</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A <i>consumer</i> operates on an iterator, returning some kind of value or values.</span> <i>消費者</i>はイテレータで動作し、ある種の値や値を返します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The most common consumer is <code>collect()</code> .</span>最も一般的なコンシューマーは<code>collect()</code>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This code doesn&#39;t quite compile, but it shows the intention:</span>このコードはあまりコンパイルされませんが、意図を示しています：</span> </p><br><div data-lang=rust,ignore><div data-l="let one_to_one_hundred = (1..101).collect();"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As you can see, we call <code>collect()</code> on our iterator.</span>ご覧のとおり、イテレータの<code>collect()</code>を呼び出します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>collect()</code> takes as many values as the iterator will give it, and returns a collection of the results.</span> <code>collect()</code>はイテレータが与える多くの値をとり、結果のコレクションを返します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So why won&#39;t this compile?</span>だから、なぜこれはコンパイルされませんか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust can&#39;t determine what type of things you want to collect, and so you need to let it know.</span>錆は、あなたが収集したいもののタイプを決定することができないので、それを知らせる必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here&#39;s the version that does compile:</span>コンパイルするバージョンは次のとおりです。</span> </p><br><div data-lang=rust><div data-l="let one_to_one_hundred = (1..101).collect::&lt;Vec&lt;i32&gt;&gt;();"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you remember, the <a href=#2generics.html#resolving-ambiguities><code>::&lt;&gt;</code> syntax</a> allows us to give a type hint that tells the compiler we want a vector of integers.</span>覚えていれば、 <a href=#2generics.html#resolving-ambiguities><code>::&lt;&gt;</code>構文</a>は、コンパイラに整数のベクトルが必要なことを伝えるヒントを与えることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You don&#39;t always need to use the whole type, though.</span>しかし、必ずしも全体の型を使う必要はありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Using a <code>_</code> will let you provide a partial hint:</span> <code>_</code>を使用すると、部分的なヒントを提供できます：</span> </p><br><div data-lang=rust><div data-l="let one_to_one_hundred = (1..101).collect::&lt;Vec&lt;_&gt;&gt;();"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This says &quot;Collect into a <code>Vec&lt;T&gt;</code> , please, but infer what the <code>T</code> is for me.&quot;</span>これは「 <code>Vec&lt;T&gt;</code>に集めてください。しかし、 <code>T</code>が私のためにあると推測してください」と言います。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>_</code> is sometimes called a &quot;type placeholder&quot; for this reason.</span> <code>_</code>は、このため「タイププレースホルダ」と呼ばれることがあります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>collect()</code> is the most common consumer, but there are others too.</span> <code>collect()</code>は最も一般的な消費者ですが、他にもあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>find()</code> is one:</span> <code>find()</code>は1つです：</span> </p><br><div data-lang=rust><div data-l="let greater_than_forty_two = (0..100)"></div><div data-l="                             .find(|x| *x &gt; 42);"></div><div data-l=""></div><div data-l="match greater_than_forty_two {"></div><div data-l="    Some(_) =&gt; println!(&quot;Found a match!&quot;),"></div><div data-l="    None =&gt; println!(&quot;No match found :(&quot;),"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>find</code> takes a closure, and works on a reference to each element of an iterator.</span> <code>find</code>はクロージャ<code>find</code>とり、イテレータの各要素への参照で動作します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This closure returns <code>true</code> if the element is the element we&#39;re looking for, and <code>false</code> otherwise.</span>この閉鎖は返し<code>true</code>要素は、私たちが探している要素であり、そして場合<code>false</code>そう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>find</code> returns the first element satisfying the specified predicate.</span> <code>find</code>は、指定された述語を満たす最初の要素を返します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because we might not find a matching element, <code>find</code> returns an <code>Option</code> rather than the element itself.</span>一致する要素が<code>find</code>ない可能性があるため、 <code>find</code>は要素自体ではなく<code>Option</code> <code>find</code>返します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Another important consumer is <code>fold</code> .</span>もう一つの重要な消費者は<code>fold</code>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here&#39;s what it looks like:</span>以下はその様子です：</span> </p><br><div data-lang=rust><div data-l="let sum = (1..4).fold(0, |sum, x| sum + x);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>fold()</code> is a consumer that looks like this: <code>fold(base, |accumulator, element| ...)</code> .</span> <code>fold()</code>は<code>fold(base, |accumulator, element| ...)</code>ようなコンシューマ<code>fold(base, |accumulator, element| ...)</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It takes two arguments: the first is an element called the <i>base</i> .</span>これには2つの引数があります。最初の要素は<i>ベース</i>と呼ばれる要素です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The second is a closure that itself takes two arguments: the first is called the <i>accumulator</i> , and the second is an <i>element</i> .</span> 2つ目はクロージャーで、2つの引数をとります。最初は<i>アキュムレータ</i> 、2つ目は<i>要素</i>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Upon each iteration, the closure is called, and the result is the value of the accumulator on the next iteration.</span>各反復で、クロージャが呼び出され、結果が次の反復でのアキュムレータの値になります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">On the first iteration, the base is assigned the value of the accumulator.</span>最初の反復では、ベースにアキュムレータの値が割り当てられます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Okay, that&#39;s a bit confusing.</span>さて、それは少し混乱しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s examine the values of all of these things in this iterator:</span>このイテレータでこれらのすべての値を調べてみましょう：</span> </p><br><div data-tbl> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">base |</span>ベース|</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">accumulator |</span>アキュムレータ|</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">element |</span>要素|</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">closure result |</span>閉鎖の結果|</span> </div><div data-tbl> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">------|-------------|---------|----------------|</span> ------ | ------------- | --------- | ---------------- |</span> </div><div data-tbl> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">0 |</span> 0 |</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">0 |</span> 0 |</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">1 |</span> 1 |</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">1 |</span> 1 |</span> </div><div data-tbl> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">0 |</span> 0 |</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">1 |</span> 1 |</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">2 |</span> 2 |</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">3 |</span> 3 |</span> </div><div data-tbl> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">0 |</span> 0 |</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">3 |</span> 3 |</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">3 |</span> 3 |</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">6 |</span> 6 |</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We called <code>fold()</code> with these arguments:</span> <code>fold()</code>は次の引数で呼び出されました。</span> </p><br><div data-lang=rust><div data-l="# (1..4)"></div><div data-l=".fold(0, |sum, x| sum + x);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So, <code>0</code> is our base, <code>sum</code> is our accumulator, and <code>x</code> is our element.</span>したがって、 <code>0</code>はベース、 <code>sum</code>はアキュムレータ、 <code>x</code>は要素です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">On the first iteration, we set <code>sum</code> to <code>0</code> , and <code>x</code> is the first element of <code>nums</code> , <code>1</code> .</span>最初の反復では、 <code>sum</code>を<code>0</code>に設定し、 <code>x</code>は<code>nums</code> 、 <code>1</code>最初の要素です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We then add <code>sum</code> and <code>x</code> , which gives us <code>0 + 1 = 1</code> .</span>次に、 <code>sum</code>と<code>x</code>を<code>sum</code> 、 <code>0 + 1 = 1</code>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">On the second iteration, that value becomes our accumulator, <code>sum</code> , and the element is the second element of the array, <code>2</code> .</span>第2の反復で、その値は、我々のアキュムレータとなる<code>sum</code> 、及び要素は、アレイの第二の要素である<code>2</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>1 + 2 = 3</code> , and so that becomes the value of the accumulator for the last iteration.</span> <code>1 + 2 = 3</code>となるので、最後の反復のアキュムレータの値になります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">On that iteration, <code>x</code> is the last element, <code>3</code> , and <code>3 + 3 = 6</code> , which is our final result for our sum.</span>その反復では、 <code>x</code>は最後の要素<code>3</code>と<code>3 + 3 = 6</code> 。これは最終的な結果です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>1 + 2 + 3 = 6</code> , and that&#39;s the result we got.</span> <code>1 + 2 + 3 = 6</code>となり、これが結果です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Whew.</span>ホウ</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>fold</code> can be a bit strange the first few times you see it, but once it clicks, you can use it all over the place.</span> <code>fold</code>あなたはそれを参照してください最初の数回少し奇妙なことができますが、それはクリックすると、あなたはあらゆる場所にそれを使用することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Any time you have a list of things, and you want a single result, <code>fold</code> is appropriate.</span>あなたが物事のリストを持っていて、あなたが一つの結果を望む時はいつでも、 <code>fold</code>は適切です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Consumers are important due to one additional property of iterators we haven&#39;t talked about yet: laziness.</span>消費者は、私たちがまだ話していないイテレータのもう一つの特性、すなわち怠惰のために重要です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s talk some more about iterators, and you&#39;ll see why consumers matter.</span>イテレーターについてもう少し詳しく説明しましょう。消費者がなぜ重要であるかを理解してください。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Iterators</span>イテレータ</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As we&#39;ve said before, an iterator is something that we can call the <code>.next()</code> method on repeatedly, and it gives us a sequence of things.</span>前にも述べたように、イテレータは<code>.next()</code>メソッドを繰り返し呼び出すことができ、一連の処理を行います。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because you need to call the method, this means that iterators can be <i>lazy</i> and not generate all of the values upfront.</span>メソッドを呼び出す必要があるため、イテレータは<i>遅延</i>していて、すべての値を前もって生成することはできません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This code, for example, does not actually generate the numbers <code>1-99</code> , instead creating a value that merely represents the sequence:</span>たとえば、このコードでは、実際には数字<code>1-99</code>が生成されるのではなく、単にシーケンスを表す値が作成されます。</span> </p><br><div data-lang=rust><div data-l="let nums = 1..100;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Since we didn&#39;t do anything with the range, it didn&#39;t generate the sequence.</span>範囲で何もしなかったので、シーケンスを生成しませんでした。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s add the consumer:</span>消費者を追加しましょう：</span> </p><br><div data-lang=rust><div data-l="let nums = (1..100).collect::&lt;Vec&lt;i32&gt;&gt;();"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now, <code>collect()</code> will require that the range gives it some numbers, and so it will do the work of generating the sequence.</span>さて、 <code>collect()</code>は、その範囲にいくつかの数値を与える必要があるので、シーケンスを生成する作業を行います。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Ranges are one of two basic iterators that you&#39;ll see.</span>範囲は、2つの基本的な反復子のうちの1つです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The other is <code>iter()</code> .</span>もう一つは<code>iter()</code>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>iter()</code> can turn a vector into a simple iterator that gives you each element in turn:</span> <code>iter()</code>は、ベクトルを順番に各要素を与える単純なイテレータに変えることができます：</span> </p><br><div data-lang=rust><div data-l="let nums = vec![1, 2, 3];"></div><div data-l=""></div><div data-l="for num in nums.iter() {"></div><div data-l="   println!(&quot;{}&quot;, num);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These two basic iterators should serve you well.</span>これらの2つの基本的なイテレータは、あなたにうまく役立つはずです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There are some more advanced iterators, including ones that are infinite.</span>無限大を含むいくつかの高度なイテレータがあります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That&#39;s enough about iterators.</span> iteratorsについては十分です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Iterator adaptors are the last concept we need to talk about with regards to iterators.</span>イテレーターアダプターはイテレーターに関して最後に私たちが話す必要がある概念です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s get to it!</span>それに行きましょう！</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Iterator adaptors</span>イテレータアダプタ</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><i>Iterator adaptors</i> take an iterator and modify it somehow, producing a new iterator.</span> <i>イテレータアダプタ</i>はイテレータを受け取り、それを何らかの形で変更して、新しいイテレータを生成します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The simplest one is called <code>map</code> :</span>最も簡単なものは<code>map</code>と呼ばれ<code>map</code> ：</span> </p><br><div data-lang=rust,ignore><div data-l="(1..100).map(|x| x + 1);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>map</code> is called upon another iterator, and produces a new iterator where each element reference has the closure it&#39;s been given as an argument called on it.</span> <code>map</code>は別のイテレーターで呼び出され、新しいイテレーターを生成します。ここで、各エレメント参照は、呼び出された引数として与えられたクロージャーを持ちます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So this would give us the numbers from <code>2-100</code> .</span>これで<code>2-100</code>の数字が得られます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Well, almost!</span>よくほとんど！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you compile the example, you&#39;ll get a warning:</span>この例をコンパイルすると、警告が表示されます。</span> </p><br><div data-lang=text><div data-l="warning: unused result which must be used: iterator adaptors are lazy and"></div><div data-l="         do nothing unless consumed, #[warn(unused_must_use)] on by default"></div><div data-l="(1..100).map(|x| x + 1);"></div><div data-l=" ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Laziness strikes again!</span>怠惰が再び襲う！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That closure will never execute.</span>その閉鎖は決して実行されません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This example doesn&#39;t print any numbers:</span>この例では数値は表示されません。</span> </p><br><div data-lang=rust,ignore><div data-l="(1..100).map(|x| println!(&quot;{}&quot;, x));"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you are trying to execute a closure on an iterator for its side effects, use <code>for</code> instead.</span>副作用のために反復子でクロージャを実行しようとしている場合は<code>for</code>代わりに<code>for</code>を使用<code>for</code>ます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There are tons of interesting iterator adaptors.</span>興味深いイテレーターアダプターがたくさんあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>take(n)</code> will return an iterator over the next <code>n</code> elements of the original iterator.</span> <code>take(n)</code>は、元のイテレータの次の<code>n</code>要素<code>n</code>イテレータを返します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s try it out with an infinite iterator:</span>無限のイテレータで試してみましょう：</span> </p><br><div data-lang=rust><div data-l="for i in (1..).take(5) {"></div><div data-l="    println!(&quot;{}&quot;, i);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This will print</span>これは印刷されます</span> </p><br><div data-lang=text><div data-l=1></div><div data-l=2></div><div data-l=3></div><div data-l=4></div><div data-l=5></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>filter()</code> is an adapter that takes a closure as an argument.</span> <code>filter()</code>は、引数としてクロージャをとるアダプタです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This closure returns <code>true</code> or <code>false</code> .</span>このクロージャは<code>true</code>または<code>false</code>返し<code>true</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The new iterator <code>filter()</code> produces only the elements that the closure returns <code>true</code> for:</span>新しい反復子<code>filter()</code>は、クロージャが<code>true</code>を返す要素のみを生成します。</span> </p><br><div data-lang=rust><div data-l="for i in (1..100).filter(|&amp;x| x % 2 == 0) {"></div><div data-l="    println!(&quot;{}&quot;, i);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This will print all of the even numbers between one and a hundred.</span>これは、1と100の間のすべての偶数を印刷します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">(Note that, unlike <code>map</code> , the closure passed to <code>filter</code> is passed a reference to the element instead of the element itself. The filter predicate here uses the <code>&amp;x</code> pattern to extract the integer. The filter closure is passed a reference because it returns <code>true</code> or <code>false</code> instead of the element, so the <code>filter</code> implementation must retain ownership to put the elements into the newly constructed iterator.)</span> （とは異なり、なお<code>map</code>に渡さ閉鎖<code>filter</code>代わり素子自体の要素への参照を渡される。ここで、フィルタ述語が使用<code>&amp;x</code>整数を抽出するパターンをそれが返すためのフィルタ閉鎖基準を渡される<code>true</code>又は要素の代わりに<code>false</code>使用するため、 <code>filter</code>実装は、新しく構築されたイテレータに要素を入れるために所有権を保持する必要があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can chain all three things together: start with an iterator, adapt it a few times, and then consume the result.</span> 3つの要素を1つにまとめることができます。イテレータから始め、数回それを適用してから、結果を消費します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Check it out:</span>見てみな：</span> </p><br><div data-lang=rust><div data-l=(1..)></div><div data-l="    .filter(|&amp;x| x % 2 == 0)"></div><div data-l="    .filter(|&amp;x| x % 3 == 0)"></div><div data-l="    .take(5)"></div><div data-l="    .collect::&lt;Vec&lt;i32&gt;&gt;();"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This will give you a vector containing <code>6</code> , <code>12</code> , <code>18</code> , <code>24</code> , and <code>30</code> .</span>これは、あなたを含むベクター与える<code>6</code> 、 <code>12</code> 、 <code>18</code> 、 <code>24</code> 、および<code>30</code> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is just a small taste of what iterators, iterator adaptors, and consumers can help you with.</span>これは、イテレーター、イテレーターアダプター、および消費者があなたを助けることができるもののほんの少しの味です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There are a number of really useful iterators, and you can write your own as well.</span>本当に便利なイテレータは数多くあり、独自のイテレータを書くこともできます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Iterators provide a safe, efficient way to manipulate all kinds of lists.</span>イテレータは、あらゆる種類のリストを操作するための安全で効率的な方法を提供します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">They&#39;re a little unusual at first, but if you play with them, you&#39;ll get hooked.</span>彼らは最初は少し珍しいですが、もしあなたがそれらと遊ぶなら、あなたは夢中になるでしょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For a full list of the different iterators and consumers, check out the <a href=#2../../std/iter/index.html>iterator module documentation</a> .</span>異なるイテレータとコンシューマの完全なリストについては、 <a href=#2../../std/iter/index.html>イテレータモジュールのドキュメントを参照してください</a> 。</span> </p><script>_addload(function(){_setupIW('com');_csi('en','ja','iterators.html');});</script>