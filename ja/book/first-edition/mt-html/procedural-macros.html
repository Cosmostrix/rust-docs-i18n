<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180709_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=procedural-macros.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Procedural Macros (and custom Derive)</span>手続き型マクロ（およびカスタム生成）</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As you&#39;ve seen throughout the rest of the book, Rust provides a mechanism called &quot;derive&quot; that lets you implement traits easily.</span>本書の他の部分で見てきたように、Rustは「派生」と呼ばれるメカニズムを提供しています。これにより、容易に形質を実装できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example,</span>例えば、</span> </p><br><div data-lang=rust><div data-l=#[derive(Debug)]></div><div data-l="struct Point {"></div><div data-l="    x: i32,"></div><div data-l="    y: i32,"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">is a lot simpler than</span>より簡単です</span> </p><br><div data-lang=rust><div data-l="struct Point {"></div><div data-l="    x: i32,"></div><div data-l="    y: i32,"></div><div data-l=}></div><div data-l=""></div><div data-l="use std::fmt;"></div><div data-l=""></div><div data-l="impl fmt::Debug for Point {"></div><div data-l="    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {"></div><div data-l="        write!(f, &quot;Point {{ x: {}, y: {} }}&quot;, self.x, self.y)"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust includes several traits that you can derive, but it also lets you define your own.</span>錆にはいくつかの特質がありますが、独自のものを定義することもできます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can accomplish this task through a feature of Rust called &quot;procedural macros.&quot;</span>この作業は、「手続き型マクロ」と呼ばれるRustの機能によって実現できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Eventually, procedural macros will allow for all sorts of advanced metaprogramming in Rust, but today, they&#39;re only for custom derive.</span>最終的には、手続き型マクロはRustのあらゆる高度なメタプログラミングを可能にしますが、今日はカスタムの派生のためだけです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s build a very simple trait, and derive it with custom derive.</span>非常に単純な特性を構築して、それを派生させて派生させましょう。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Hello World</span>こんにちは世界</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So the first thing we need to do is start a new crate for our project.</span>だから最初にやるべきことは、私たちのプロジェクトのために新しいクレートを始めることです。</span> </p><br><div data-lang=bash><div data-l="$ cargo new --bin hello-world"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">All we want is to be able to call <code>hello_world()</code> on a derived type.</span>派生型に対して<code>hello_world()</code>を呼び出すだけです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Something like this:</span>このようなもの：</span> </p><br><div data-lang=rust,ignore><div data-l=#[derive(HelloWorld)]></div><div data-l="struct Pancakes;"></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    Pancakes::hello_world();"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">With some kind of nice output, like <code>Hello, World€ My name is Pancakes.</code></span> <code>Hello, World€ My name is Pancakes.</code>ような素敵な出力で<code>Hello, World€ My name is Pancakes.</code></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">.</span> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s go ahead and write up what we think our macro will look like from a user perspective.</span>私たちのマクロがユーザーの視点から見えるものを書き留めておきましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In <code>src/main.rs</code> we write:</span> <code>src/main.rs</code>に次のように記述します。</span> </p><br><div data-lang=rust,ignore><div data-l=#[macro_use]></div><div data-l="extern crate hello_world_derive;"></div><div data-l=""></div><div data-l="trait HelloWorld {"></div><div data-l="    fn hello_world();"></div><div data-l=}></div><div data-l=""></div><div data-l=#[derive(HelloWorld)]></div><div data-l="struct FrenchToast;"></div><div data-l=""></div><div data-l=#[derive(HelloWorld)]></div><div data-l="struct Waffles;"></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    FrenchToast::hello_world();"></div><div data-l="    Waffles::hello_world();"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Great.</span>すばらしいです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So now we just need to actually write the procedural macro.</span>これで、手続き型マクロを実際に書くだけです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">At the moment, procedural macros need to be in their own crate.</span>現時点では、手続き型マクロは独自の枠組みに入れる必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Eventually, this restriction may be lifted, but for now, it&#39;s required.</span>最終的には、この制限が解除される可能性がありますが、今のところそれが必要です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As such, there&#39;s a convention;</span>このように、規約があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">for a crate named <code>foo</code> , a custom derive procedural macro is called <code>foo-derive</code> .</span> <code>foo</code>という名前の木枠の場合、カスタム派生手続きマクロは<code>foo-derive</code>と呼ばれ<code>foo-derive</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s start a new crate called <code>hello-world-derive</code> inside our <code>hello-world</code> project.</span>私たちの<code>hello-world</code>プロジェクトの中で新しい<code>hello-world-derive</code>作り出しましょう。</span> </p><br><div data-lang=bash><div data-l="$ cargo new hello-world-derive"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To make sure that our <code>hello-world</code> crate is able to find this new crate we&#39;ve created, we&#39;ll add it to our toml:</span>私たちのことを確認する<code>hello-world</code>クレートは、我々が作成したこの新しいクレートを見つけることができ、私たちはtomlにそれを追加します：</span> </p><br><div data-lang=toml><div data-l=[dependencies]></div><div data-l="hello-world-derive = { path = &quot;hello-world-derive&quot; }"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As for the source of our <code>hello-world-derive</code> crate, here&#39;s an example:</span> <code>hello-world-derive</code>木箱の源については、ここに例があります：</span> </p><br><div data-lang=rust,ignore><div data-l="extern crate proc_macro;"></div><div data-l="extern crate syn;"></div><div data-l=#[macro_use]></div><div data-l="extern crate quote;"></div><div data-l=""></div><div data-l="use proc_macro::TokenStream;"></div><div data-l=""></div><div data-l=#[proc_macro_derive(HelloWorld)]></div><div data-l="pub fn hello_world(input: TokenStream) -&gt; TokenStream {"></div><div data-l="#    // Construct a string representation of the type definition"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Construct a string representation of the type definition</span>型定義の文字列表現を構築します。</span> </div><div data-l="    let s = input.to_string();"></div><div data-l="    "></div><div data-l="#    // Parse the string representation"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Parse the string representation</span>文字列表現を解析する</span> </div><div data-l="    let ast = syn::parse_derive_input(&amp;s).unwrap();"></div><div data-l=""></div><div data-l="#    // Build the impl"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Build the impl</span>インプラントを構築する</span> </div><div data-l="    let gen = impl_hello_world(&amp;ast);"></div><div data-l="    "></div><div data-l="#    // Return the generated impl"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Return the generated impl</span>生成されたimplを返す</span> </div><div data-l="    gen.parse().unwrap()"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So there is a lot going on here.</span>だからここにはたくさんのことがあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We have introduced two new crates: <a class=notranslate href="#4`syn`">`syn`</a> and <a class=notranslate href="#4`quote`">`quote`</a> .</span> <a class=notranslate href="#4`syn`">`syn`</a>と<a class=notranslate href="#4`quote`">`quote`</a> 2つの新しい箱を導入し<a class=notranslate href="#4`quote`">`quote`</a> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As you may have noticed, <code>input: TokenSteam</code> is immediately converted to a <code>String</code> .</span> <code>input: TokenSteam</code>ように、 <code>input: TokenSteam</code>はすぐに<code>String</code>に変換されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This <code>String</code> is a string representation of the Rust code for which we are deriving <code>HelloWorld</code> .</span>この<code>String</code>は、 <code>HelloWorld</code>を派生させている錆コードの文字列表現です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">At the moment, the only thing you can do with a <code>TokenStream</code> is convert it to a string.</span>現時点では、 <code>TokenStream</code>行うことができるのは文字列に変換することだけです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A richer API will exist in the future.</span>将来、豊富なAPIが存在するでしょう。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So what we really need is to be able to <s>parse</s> Rust code into something usable.</span>だから私たちが本当に必要とするのは、錆コードを利用可能なものに<s>解析</s>できることです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is where <code>syn</code> comes to play.</span>これは<code>syn</code>が再生する場所です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>syn</code> is a crate for parsing Rust code.</span> <code>syn</code>は、錆コードを解析するためのクレートです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The other crate we&#39;ve introduced is <code>quote</code> .</span>私たちが紹介したもう一つのクレートは<code>quote</code>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It&#39;s essentially the dual of <code>syn</code> as it will make generating Rust code really easy.</span>これは本質的に<code>syn</code>のデュアルですので、Rustコードを生成するのは簡単です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We could write this stuff on our own, but it&#39;s much simpler to use these libraries.</span>このようなものは私たち自身で書くことができますが、これらのライブラリを使う方がはるかに簡単です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Writing a full parser for Rust code is no simple task.</span>錆コードの完全なパーサを書くことは簡単なことではありません。</span> </p><br> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a class=notranslate href=#1https://crates.io/crates/syn>`syn`</a> <a class=notranslate href=#1https://crates.io/crates/quote>`quote`</a></span> <a class=notranslate href=#1https://crates.io/crates/syn>`syn`</a> <a class=notranslate href=#1https://crates.io/crates/quote>`quote`</a></span> <br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The comments seem to give us a pretty good idea of our overall strategy.</span>このコメントは、私たちの全体的な戦略の良いアイデアを与えるように思われます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We are going to take a <code>String</code> of the Rust code for the type we are deriving, parse it using <code>syn</code> , construct the implementation of <code>hello_world</code> (using <code>quote</code> ), then pass it back to Rust compiler.</span>我々が取るしようとしている<code>String</code> 、我々が導出されているタイプの錆コードのを使用してそれを解析<code>syn</code> 、実装の構築<code>hello_world</code> （使用<code>quote</code> ）、その後、バック錆コンパイラに渡します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">One last note: you&#39;ll see some <code>unwrap()</code> s there.</span>最後のひとつ： <code>unwrap()</code>いくつか見えます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you want to provide an error for a procedural macro, then you should <code>panic€</code> with the error message.</span>手続き型マクロにエラーを指定する場合は、エラーメッセージとともに<code>panic€</code>を<code>panic€</code>なければなりません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this case, we&#39;re keeping it as simple as possible.</span>この場合、できるだけシンプルにしています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Great, so let&#39;s write <code>impl_hello_world(&amp;ast)</code> .</span> <code>impl_hello_world(&amp;ast)</code>書いてみましょう。</span> </p><br><div data-lang=rust,ignore><div data-l="fn impl_hello_world(ast: &amp;syn::DeriveInput) -&gt; quote::Tokens {"></div><div data-l="    let name = &amp;ast.ident;"></div><div data-l="    quote! {"></div><div data-l="        impl HelloWorld for #name {"></div><div data-l="            fn hello_world() {"></div><div data-l="                println!(&quot;Hello, World! My name is {}&quot;, stringify!(#name));"></div><div data-l="            }"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So this is where quotes comes in. The <code>ast</code> argument is a struct that gives us a representation of our type (which can be either a <code>struct</code> or an <code>enum</code> ).</span>これは引用符が入るところです<code>ast</code>引数は、型（ <code>struct</code>または<code>enum</code>型のいずれか）を表す<code>struct</code>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Check out the <a class=notranslate href=#2https://docs.rs/syn/0.11.11/syn/struct.DeriveInput.html>docs</a> , there is some useful information there.</span> <a class=notranslate href=#2https://docs.rs/syn/0.11.11/syn/struct.DeriveInput.html>docs</a>チェックすると、そこにいくつかの有益な情報があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We are able to get the name of the type using <code>ast.ident</code> .</span>私たちは<code>ast.ident</code>を使ってタイプの名前を得ることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>quote€</code> macro lets us write up the Rust code that we wish to return and convert it into <code>Tokens</code> .</span> <code>quote€</code>マクロを使用すると、返却したい錆のコードを書き込んで、 <code>Tokens</code>変換することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>quote€</code> lets us use some really cool templating mechanics;</span> <code>quote€</code>では、本当にクールなテンプレート機構を使用できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">we simply write <code>#name</code> and <code>quote€</code> will replace it with the variable named <code>name</code> .</span> <code>#name</code>と<code>quote€</code>書くと、変数<code>name</code>置き換えられ<code>name</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can even do some repetition similar to regular macros work.</span>あなたは、通常のマクロ作業と同様にいくつかの繰り返しを行うことさえできます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You should check out the <a class=notranslate href=#2https://docs.rs/quote>docs</a> for a good introduction.</span>あなたは良い紹介については、 <a class=notranslate href=#2https://docs.rs/quote>docs</a>をチェックアウトする必要があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So I think that&#39;s it.</span>だから私はそうだと思う。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Oh, well, we do need to add dependencies for <code>syn</code> and <code>quote</code> in the <code>Cargo.toml</code> for <code>hello-world-derive</code> .</span>ああ、私たちは、 <code>hello-world-derive</code> <code>Cargo.toml</code>ために<code>Cargo.toml</code> <code>syn</code>と<code>quote</code>依存関係を追加する必要があり<code>hello-world-derive</code> 。</span> </p><br><div data-lang=toml><div data-l=[dependencies]></div><div data-l="syn = &quot;0.11.11&quot;"></div><div data-l="quote = &quot;0.3.15&quot;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That should be it.</span>それがそれであるはずです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s try to compile <code>hello-world</code> .</span> <code>hello-world</code>をコンパイルしようとしましょう。</span> </p><br><div data-lang=bash><div data-l="error: the `#[proc_macro_derive]` attribute is only usable with crates of the `proc-macro` crate type"></div><div data-l=" --&gt; hello-world-derive/src/lib.rs:8:3"></div><div data-l="  |"></div><div data-l="8 | #[proc_macro_derive(HelloWorld)]"></div><div data-l="  |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Oh, so it appears that we need to declare that our <code>hello-world-derive</code> crate is a <code>proc-macro</code> crate type.</span>ああ、それでは、われわれ<code>hello-world-derive</code>箱は、 <code>proc-macro</code>クレート型であると宣言する必要があるようです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">How do we do this?</span>これをどうやってやるの？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Like this:</span>このような：</span> </p><br><div data-lang=toml><div data-l=[lib]></div><div data-l="proc-macro = true"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Ok so now, let&#39;s compile <code>hello-world</code> .</span>さて、今、 <code>hello-world</code>コンパイルしましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Executing <code>cargo run</code> now yields:</span> <code>cargo run</code>ようになります。</span> </p><br><div data-lang=bash><div data-l="Hello, World! My name is FrenchToast"></div><div data-l="Hello, World! My name is Waffles"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ve done it!</span>我々はそれをやった！</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Custom Attributes</span>カスタム属性</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In some cases it might make sense to allow users some kind of configuration.</span>場合によっては、ユーザーに何らかの構成を許可することが理にかなっている場合があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, the user might want to overwrite the name that is printed in the <code>hello_world()</code> method.</span>たとえば、 <code>hello_world()</code>メソッドで出力された名前を上書きすることができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This can be achieved with custom attributes:</span>カスタム属性でこれを実現できます。</span> </p><br><div data-lang=rust,ignore><div data-l=#[derive(HelloWorld)]></div><div data-l="#[HelloWorldName = &quot;the best Pancakes&quot;]"></div><div data-l="struct Pancakes;"></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    Pancakes::hello_world();"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we try to compile this though, the compiler will respond with an error:</span>コンパイルしようとすると、コンパイラはエラーで応答します：</span> </p><br><div data-lang=bash><div data-l="error: The attribute `HelloWorldName` is currently unknown to the compiler and may have meaning added to it in the future (see issue #29642)"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The compiler needs to know that we&#39;re handling this attribute and to not respond with an error.</span>コンパイラはこの属性を処理していることを知り、エラーで応答しないようにする必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is done in the <code>hello-world-derive</code> crate by adding <code>attributes</code> to the <code>proc_macro_derive</code> attribute:</span>これは、 <code>proc_macro_derive</code>属性に<code>attributes</code>を追加<code>attributes</code>ことによって、 <code>hello-world-derive</code> <code>proc_macro_derive</code>ます。</span> </p><br><div data-lang=rust,ignore><div data-l="#[proc_macro_derive(HelloWorld, attributes(HelloWorldName))]"></div><div data-l="pub fn hello_world(input: TokenStream) -&gt; TokenStream "></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Multiple attributes can be specified that way.</span>複数の属性をそのように指定できます。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Raising Errors</span>エラーの発生</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s assume that we do not want to accept enums as input to our custom derive method.</span>列挙型をカスタム導出メソッドの入力として受け入れたくないと仮定しましょう。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This condition can be easily checked with the help of <code>syn</code> .</span>この条件は<code>syn</code>の助けを借りて簡単に確認できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But how do we tell the user, that we do not accept enums?</span>しかし、私たちはenumを受け入れないことをユーザーにどのように伝えますか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The idiomatic way to report errors in procedural macros is to panic:</span>手続き型マクロのエラーを報告する慣用的な方法は、パニックに陥ることです。</span> </p><br><div data-lang=rust,ignore><div data-l="fn impl_hello_world(ast: &amp;syn::DeriveInput) -&gt; quote::Tokens {"></div><div data-l="    let name = &amp;ast.ident;"></div><div data-l="#    // Check if derive(HelloWorld) was specified for a struct"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Check if derive(HelloWorld) was specified for a struct</span> structに派生（HelloWorld）が指定されているかどうかを確認する</span> </div><div data-l="    if let syn::Body::Struct(_) = ast.body {"></div><div data-l="#        // Yes, this is a struct"></div><div data-l="        // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Yes, this is a struct</span>はい、これは構造体です</span> </div><div data-l="        quote! {"></div><div data-l="            impl HelloWorld for #name {"></div><div data-l="                fn hello_world() {"></div><div data-l="                    println!(&quot;Hello, World! My name is {}&quot;, stringify!(#name));"></div><div data-l="                }"></div><div data-l="            }"></div><div data-l="        }"></div><div data-l="    } else {"></div><div data-l="#        // Nope. This is an Enum. We cannot handle these!"></div><div data-l="        // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Nope.</span>いいえ。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is an Enum.</span>これは列挙型です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We cannot handle these!</span>私たちはこれらを扱うことができません！</span> </div><div data-l="        panic!(&quot;#[derive(HelloWorld)] is only defined for structs, not for enums!&quot;);"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If a user now tries to derive <code>HelloWorld</code> from an enum they will be greeted with following, hopefully helpful, error:</span>ユーザーが列挙から<code>HelloWorld</code>を派生させようとすると、次のように歓迎されるでしょう。</span> </p><br><div data-lang=bash><div data-l="error: custom derive attribute panicked"></div><div data-l="  --&gt; src/main.rs"></div><div data-l="   |"></div><div data-l="   | #[derive(HelloWorld)]"></div><div data-l="   |          ^^^^^^^^^^"></div><div data-l="   |"></div><div data-l="   = help: message: #[derive(HelloWorld)] is only defined for structs, not for enums!"></div></div><script>_addload(function(){_setupIW('com');_csi('en','ja','procedural-macros.html');});</script>