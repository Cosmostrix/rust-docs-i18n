<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180709_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=traits.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Traits</span>形質</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A trait is a language feature that tells the Rust compiler about functionality a type must provide.</span>特性とは、型が提供しなければならない機能についてRustコンパイラに知らせる言語機能です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Recall the <code>impl</code> keyword, used to call a function with <a class=notranslate href=#3methodsyntax>method syntax</a> :</span> <a class=notranslate href=#3methodsyntax>method syntax</a>関数を呼び出すために使用される<code>impl</code>キーワードを思い出してください：</span> </p><br><div data-lang=rust><div data-l="struct Circle {"></div><div data-l="    x: f64,"></div><div data-l="    y: f64,"></div><div data-l="    radius: f64,"></div><div data-l=}></div><div data-l=""></div><div data-l="impl Circle {"></div><div data-l="    fn area(&amp;self) -&gt; f64 {"></div><div data-l="        std::f64::consts::PI * (self.radius * self.radius)"></div><div data-l="    }"></div><div data-l=}></div></div><br> <a class=notranslate href=#1method-syntax.html>methodsyntax</a> <br> <p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Traits are similar, except that we first define a trait with a method signature, then implement the trait for a type.</span>形質は似ていますが、最初にメソッドシグネチャで形質を定義してから、型の特性を実装します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this example, we implement the trait <code>HasArea</code> for <code>Circle</code> :</span>この例では、 <code>Circle</code>特性<code>HasArea</code>を実装します。</span> </p><br><div data-lang=rust><div data-l="struct Circle {"></div><div data-l="    x: f64,"></div><div data-l="    y: f64,"></div><div data-l="    radius: f64,"></div><div data-l=}></div><div data-l=""></div><div data-l="trait HasArea {"></div><div data-l="    fn area(&amp;self) -&gt; f64;"></div><div data-l=}></div><div data-l=""></div><div data-l="impl HasArea for Circle {"></div><div data-l="    fn area(&amp;self) -&gt; f64 {"></div><div data-l="        std::f64::consts::PI * (self.radius * self.radius)"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As you can see, the <code>trait</code> block looks very similar to the <code>impl</code> block, but we don&#39;t define a body, only a type signature.</span>あなたが見ることができるように、 <code>trait</code>ブロックは、と非常によく似ています<code>impl</code>ブロックが、我々は、唯一の型シグネチャを体を定義していません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When we <code>impl</code> a trait, we use <code>impl Trait for Item</code> , rather than only <code>impl Item</code> .</span>私たちが形質を<code>impl</code>とき、 <code>impl Item</code>だけでなく、 <code>impl Trait for Item</code>を使用します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>Self</code> may be used in a type annotation to refer to an instance of the type implementing this trait passed as a parameter.</span> <code>Self</code>型名で使用して、パラメータとして渡されたこの特性を実装する型のインスタンスを参照することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>Self</code> , <code>&amp;Self</code> or <code>&amp;mut Self</code> may be used depending on the level of ownership required.</span> <code>Self</code> 、 <code>&amp;Self</code> 、 <code>&amp;mut Self</code>は、必要な所有権のレベルに応じて使用できます。</span> </p><br><div data-lang=rust><div data-l="struct Circle {"></div><div data-l="    x: f64,"></div><div data-l="    y: f64,"></div><div data-l="    radius: f64,"></div><div data-l=}></div><div data-l=""></div><div data-l="trait HasArea {"></div><div data-l="    fn area(&amp;self) -&gt; f64;"></div><div data-l=""></div><div data-l="    fn is_larger(&amp;self, &amp;Self) -&gt; bool;"></div><div data-l=}></div><div data-l=""></div><div data-l="impl HasArea for Circle {"></div><div data-l="    fn area(&amp;self) -&gt; f64 {"></div><div data-l="        std::f64::consts::PI * (self.radius * self.radius)"></div><div data-l="    }"></div><div data-l=""></div><div data-l="    fn is_larger(&amp;self, other: &amp;Self) -&gt; bool {"></div><div data-l="        self.area() &gt; other.area()"></div><div data-l="    }"></div><div data-l=}></div></div><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Trait bounds on generic functions</span>ジェネリック関数の特性境界</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Traits are useful because they allow a type to make certain promises about its behavior.</span>形質は、型がその振る舞いについて一定の約束をすることができるので有益です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Generic functions can exploit this to constrain, or <a class=notranslate href=#3bounds>bound</a> , the types they accept.</span>汎用関数は、これを利用して、受け入れる型を制約したり、 <a class=notranslate href=#3bounds>bound</a>たりすることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Consider this function, which does not compile:</span>コンパイルされないこの関数を考えてみましょう：</span> </p><br> <a class=notranslate href=#1glossary.html#bounds>bounds</a> <br> <div data-lang=rust,ignore><div data-l="fn print_area&lt;T&gt;(shape: T) {"></div><div data-l="    println!(&quot;This shape has an area of {}&quot;, shape.area());"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust complains:</span>錆は文句を言う：</span> </p><br><div data-lang=text><div data-l="error: no method named `area` found for type `T` in the current scope"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because <code>T</code> can be any type, we can&#39;t be sure that it implements the <code>area</code> method.</span> <code>T</code>はどのような型でも構いませんので、それが<code>area</code>メソッドを実装しているかどうかは確かではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But we can add a trait bound to our generic <code>T</code> , ensuring that it does:</span>しかし、ジェネリック<code>T</code>特徴的なものを追加して、以下のことを保証することができます：</span> </p><br><div data-lang=rust><div data-l="# trait HasArea {"></div><div data-l="#     fn area(&amp;self) -&gt; f64;"></div><div data-l="# }"></div><div data-l="fn print_area&lt;T: HasArea&gt;(shape: T) {"></div><div data-l="    println!(&quot;This shape has an area of {}&quot;, shape.area());"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The syntax <code>&lt;T: HasArea&gt;</code> means “any type that implements the <code>HasArea</code> trait.” Because traits define function type signatures, we can be sure that any type which implements <code>HasArea</code> will have an <code>.area()</code> method.</span>構文<code>&lt;T: HasArea&gt;</code> 「実装する任意の型の意味<code>HasArea</code>形質を。」形質は、関数型シグネチャを定義しているので、我々は実装する任意の型のことを確認することができます<code>HasArea</code>あります<code>.area()</code>メソッドを。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here&#39;s an extended example of how this works:</span>これはどのように動作するかの拡張例です：</span> </p><br><div data-lang=rust><div data-l="trait HasArea {"></div><div data-l="    fn area(&amp;self) -&gt; f64;"></div><div data-l=}></div><div data-l=""></div><div data-l="struct Circle {"></div><div data-l="    x: f64,"></div><div data-l="    y: f64,"></div><div data-l="    radius: f64,"></div><div data-l=}></div><div data-l=""></div><div data-l="impl HasArea for Circle {"></div><div data-l="    fn area(&amp;self) -&gt; f64 {"></div><div data-l="        std::f64::consts::PI * (self.radius * self.radius)"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="struct Square {"></div><div data-l="    x: f64,"></div><div data-l="    y: f64,"></div><div data-l="    side: f64,"></div><div data-l=}></div><div data-l=""></div><div data-l="impl HasArea for Square {"></div><div data-l="    fn area(&amp;self) -&gt; f64 {"></div><div data-l="        self.side * self.side"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="fn print_area&lt;T: HasArea&gt;(shape: T) {"></div><div data-l="    println!(&quot;This shape has an area of {}&quot;, shape.area());"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let c = Circle {"></div><div data-l="        x: 0.0f64,"></div><div data-l="        y: 0.0f64,"></div><div data-l="        radius: 1.0f64,"></div><div data-l="    };"></div><div data-l=""></div><div data-l="    let s = Square {"></div><div data-l="        x: 0.0f64,"></div><div data-l="        y: 0.0f64,"></div><div data-l="        side: 1.0f64,"></div><div data-l="    };"></div><div data-l=""></div><div data-l="    print_area(c);"></div><div data-l="    print_area(s);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This program outputs:</span>このプログラムは、</span> </p><br><div data-lang=text><div data-l="This shape has an area of 3.141593"></div><div data-l="This shape has an area of 1"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As you can see, <code>print_area</code> is now generic, but also ensures that we have passed in the correct types.</span>お分かりのように、 <code>print_area</code>は一般的なものですが、正しいタイプで渡されていることを保証します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we pass in an incorrect type:</span>間違った型を渡すと：</span> </p><br><div data-lang=rust,ignore><div data-l=print_area(5);></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We get a compile-time error:</span>コンパイル時にエラーが発生する：</span> </p><br><div data-lang=text><div data-l="error: the trait bound `_ : HasArea` is not satisfied [E0277]"></div></div><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Trait bounds on generic structs</span>ジェネリック構造体の特性境界</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Your generic structs can also benefit from trait bounds.</span>ジェネリック構造体は、特性境界の恩恵を受けることもできます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">All you need to do is append the bound when you declare type parameters.</span>型パラメータを宣言するときに、バインドを追加するだけです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here is a new type <code>Rectangle&lt;T&gt;</code> and its operation <code>is_square()</code> :</span>新しい型の<code>Rectangle&lt;T&gt;</code>とその演算<code>is_square()</code>ます：</span> </p><br><div data-lang=rust><div data-l="struct Rectangle&lt;T&gt; {"></div><div data-l="    x: T,"></div><div data-l="    y: T,"></div><div data-l="    width: T,"></div><div data-l="    height: T,"></div><div data-l=}></div><div data-l=""></div><div data-l="impl&lt;T: PartialEq&gt; Rectangle&lt;T&gt; {"></div><div data-l="    fn is_square(&amp;self) -&gt; bool {"></div><div data-l="        self.width == self.height"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let mut r = Rectangle {"></div><div data-l="        x: 0,"></div><div data-l="        y: 0,"></div><div data-l="        width: 47,"></div><div data-l="        height: 47,"></div><div data-l="    };"></div><div data-l=""></div><div data-l="    assert!(r.is_square());"></div><div data-l=""></div><div data-l="    r.height = 42;"></div><div data-l="    assert!(!r.is_square());"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>is_square()</code> needs to check that the sides are equal, so the sides must be of a type that implements the <a class=notranslate href=#3PartialEq><code>core::cmp::PartialEq</code></a> trait:</span> <code>is_square()</code>は、辺が等しいことをチェックする必要があるので、辺は<a class=notranslate href=#3PartialEq><code>core::cmp::PartialEq</code></a>特性を実装する型でなければなりません：</span> </p><br><div data-lang=rust,ignore><div data-l="impl&lt;T: PartialEq&gt; Rectangle&lt;T&gt; { ... }"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now, a rectangle can be defined in terms of any type that can be compared for equality.</span>さて、矩形は、等しいかどうか比較することができる任意の型に関して定義することができます。</span> </p><br> <a class=notranslate href=#1../../core/cmp/trait.PartialEq.html>PartialEq</a> <br> <p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here we defined a new struct <code>Rectangle</code> that accepts numbers of any precision—really, objects of pretty much any type—as long as they can be compared for equality.</span>ここでは、等価性を比較できる限り、すべての精度（実際にはほとんどすべての型のオブジェクト）の数を受け入れる新しいstruct <code>Rectangle</code>を定義しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Could we do the same for our <code>HasArea</code> structs, <code>Square</code> and <code>Circle</code> ?</span> <code>HasArea</code>構造体である<code>Square</code>と<code>Circle</code>についても同じことができますか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Yes, but they need multiplication, and to work with that we need to know more about <a href=#3operators-and-overloading>operator traits</a> .</span>はい、しかし乗算が必要です。そのためには<a href=#3operators-and-overloading>演算子の特性</a>についてもっと知る必要があります。</span> </p><br> <a class=notranslate href=#1operators-and-overloading.html>operators-and-overloading</a> <br> <h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rules for implementing traits</span>形質を実装するためのルール</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So far, we&#39;ve only added trait implementations to structs, but you can implement a trait for any type such as <code>f32</code> :</span>これまでは、traitの実装を構造体に追加しただけですが、 <code>f32</code>などの任意の型の特性を実装できます：</span> </p><br><div data-lang=rust><div data-l="trait ApproxEqual {"></div><div data-l="    fn approx_equal(&amp;self, other: &amp;Self) -&gt; bool;"></div><div data-l=}></div><div data-l="impl ApproxEqual for f32 {"></div><div data-l="    fn approx_equal(&amp;self, other: &amp;Self) -&gt; bool {"></div><div data-l="#        // Appropriate for `self` and `other` being close to 1.0."></div><div data-l="        // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Appropriate for <code>self</code> and <code>other</code> being close to 1.0.</span> 1.0に近い<code>self</code>と<code>other</code>に適しています。</span> </div><div data-l="        (self - other).abs() &lt;= ::std::f32::EPSILON"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="println!(&quot;{}&quot;, 1.0.approx_equal(&amp;1.00000001));"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This may seem like the Wild West, but there are two restrictions around implementing traits that prevent this from getting out of hand.</span>これはワイルド・ウェストのように見えるかもしれませんが、これを妨げてしまう特性を実現するには2つの制限があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The first is that if the trait isn&#39;t defined in your scope, it doesn&#39;t apply.</span>最初に、その特性があなたの範囲に定義されていない場合、それは適用されないということです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here&#39;s an example: the standard library provides a <a class=notranslate href=#3write><code>Write</code></a> trait which adds extra functionality to <code>File</code> s, for doing file I/O.</span>標準ライブラリには、 <code>File</code> I / Oを実行するために<code>File</code>特別な機能を追加する<a class=notranslate href=#3write><code>Write</code></a>特性があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">By default, a <code>File</code> won&#39;t have its methods:</span>デフォルトでは、 <code>File</code>はそのメソッドを持ちません：</span> </p><br> <a class=notranslate href=#1../../std/io/trait.Write.html>write</a> <br> <div data-lang=rust,ignore><div data-l="let mut f = std::fs::File::create(&quot;foo.txt&quot;).expect(&quot;Couldn’t create foo.txt&quot;);"></div><div data-l="#//let buf = b&quot;whatever&quot;; // buf: &amp;[u8; 8], a byte string literal."></div><div data-l="let buf = b&quot;whatever&quot;; // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">buf: &amp; <a class=notranslate href="#4u8; 8">u8; 8</a></span> buf：＆ <a class=notranslate href="#4u8; 8">u8; 8</a></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a class=notranslate href="#4u8; 8">u8; 8</a> , a byte string literal.</span> <a class=notranslate href="#4u8; 8">u8; 8</a> 、バイト文字列リテラル。</span> </div><div data-l="let result = f.write(buf);"></div><div data-l="#//# result.unwrap(); // Ignore the error."></div><div data-l="# result.unwrap(); // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Ignore the error.</span>エラーを無視します。</span> </div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here&#39;s the error:</span>ここにエラーがあります：</span> </p><br><div data-lang=text><div data-l="error: type `std::fs::File` does not implement any method in scope named `write`"></div><div data-l="let result = f.write(buf);"></div><div data-l="               ^~~~~~~~~~"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We need to <code>use</code> the <code>Write</code> trait first:</span>まず<code>Write</code>特性を<code>use</code>する必要があり<code>use</code> 。</span> </p><br><div data-lang=rust,no_run><div data-l="use std::io::Write;"></div><div data-l=""></div><div data-l="let mut f = std::fs::File::create(&quot;foo.txt&quot;).expect(&quot;Couldn’t create foo.txt&quot;);"></div><div data-l="let buf = b&quot;whatever&quot;;"></div><div data-l="let result = f.write(buf);"></div><div data-l="#//# result.unwrap(); // Ignore the error."></div><div data-l="# result.unwrap(); // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Ignore the error.</span>エラーを無視します。</span> </div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This will compile without error.</span>これはエラーなしでコンパイルされます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This means that even if someone does something bad like add methods to <code>i32</code> , it won&#39;t affect you, unless you <code>use</code> that trait.</span>これは、たとえ誰かが<code>i32</code>にメソッドを追加するような何か悪いことをしても、あなた<code>use</code>その特性を<code>use</code>しない限り、あなたに影響を与えないこと<code>use</code>意味します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There&#39;s one more restriction on implementing traits: either the trait or the type you&#39;re implementing it for must be defined by you.</span>形質の導入にはさらに1つの制限があります。形質または導入するタイプのいずれかを定義する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Or more precisely, one of them must be defined in the same crate as the <code>impl</code> you&#39;re writing.</span>より正確に言えば、それらのうちの1つは、あなたが書いている<code>impl</code>と同じクレートに定義されなければなりません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For more on Rust&#39;s module and package system, see the chapter on <a href=#3cm>crates and modules</a> .</span> Rustのモジュールとパッケージシステムの詳細については、 <a href=#3cm>クレートとモジュールの</a>章を参照してください。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So, we could implement the <code>HasArea</code> type for <code>i32</code> , because we defined <code>HasArea</code> in our code.</span>したがって、私たちのコードに<code>HasArea</code>を定義した<code>HasArea</code> 、私たちは<code>HasArea</code>型を<code>i32</code>実装することができました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But if we tried to implement <code>ToString</code> , a trait provided by Rust, for <code>i32</code> , we could not, because neither the trait nor the type are defined in our crate.</span>しかし、私たちがRustによって提供された特性である<code>ToString</code>を<code>i32</code>ために実装しようとした場合、私たちはできませんでした。なぜなら、特性も型も私たちの箱に定義されていないからです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">One last thing about traits: generic functions with a trait bound use &#39;monomorphization&#39; (mono: one, morph: form), so they are statically dispatched.</span>形質についての最後のこと：特性結合されたジェネリック関数は、「モノモーフ化」（モノ：1、モーフ：フォーム）を使用するため、静的にディスパッチされます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">What&#39;s that mean?</span>どう言う意味ですか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Check out the chapter on <a href=#3to>trait objects</a> for more details.</span>詳細は、 <a href=#3to>特性オブジェクト</a>の章を参照してください。</span> </p><br> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a class=notranslate href=#1crates-and-modules.html>cm</a> <a class=notranslate href=#1trait-objects.html>to</a></span> <a class=notranslate href=#1crates-and-modules.html>cm</a> <a class=notranslate href=#1trait-objects.html>to</a></span> <br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Multiple trait bounds</span>複数の特性境界</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You&#39;ve seen that you can bound a generic type parameter with a trait:</span>あなたは、ジェネリック型パラメータを特性と結びつけることができます：</span> </p><br><div data-lang=rust><div data-l="fn foo&lt;T: Clone&gt;(x: T) {"></div><div data-l="    x.clone();"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you need more than one bound, you can use <code>+</code> :</span>複数の境界が必要な場合は、 <code>+</code>を使用できます。</span> </p><br><div data-lang=rust><div data-l="use std::fmt::Debug;"></div><div data-l=""></div><div data-l="fn foo&lt;T: Clone + Debug&gt;(x: T) {"></div><div data-l="    x.clone();"></div><div data-l="    println!(&quot;{:?}&quot;, x);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>T</code> now needs to be both <code>Clone</code> as well as <code>Debug</code> .</span> <code>T</code>現在、 <code>Debug</code>と同様に<code>Clone</code>必要があります。</span> </p><br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Where clause</span> Where節</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Writing functions with only a few generic types and a small number of trait bounds isn&#39;t too bad, but as the number increases, the syntax gets increasingly awkward:</span>少数のジェネリック型と少数の特性限界を持つ関数を書くことはそれほど悪くはありませんが、数が増えるにつれて構文がますます厄介になります：</span> </p><br><div data-lang=rust><div data-l="use std::fmt::Debug;"></div><div data-l=""></div><div data-l="fn foo&lt;T: Clone, K: Clone + Debug&gt;(x: T, y: K) {"></div><div data-l="    x.clone();"></div><div data-l="    y.clone();"></div><div data-l="    println!(&quot;{:?}&quot;, y);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The name of the function is on the far left, and the parameter list is on the far right.</span>関数の名前は一番左にあり、パラメータリストは一番右にあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The bounds are getting in the way.</span>境界線が途切れています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust has a solution, and it&#39;s called a &#39; <code>where</code> clause&#39;:</span>錆には解決策があり、それは &#39; <code>where</code>句&#39;と呼ばれています。</span> </p><br><div data-lang=rust><div data-l="use std::fmt::Debug;"></div><div data-l=""></div><div data-l="fn foo&lt;T: Clone, K: Clone + Debug&gt;(x: T, y: K) {"></div><div data-l="    x.clone();"></div><div data-l="    y.clone();"></div><div data-l="    println!(&quot;{:?}&quot;, y);"></div><div data-l=}></div><div data-l=""></div><div data-l="fn bar&lt;T, K&gt;(x: T, y: K) where T: Clone, K: Clone + Debug {"></div><div data-l="    x.clone();"></div><div data-l="    y.clone();"></div><div data-l="    println!(&quot;{:?}&quot;, y);"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    foo(&quot;Hello&quot;, &quot;world&quot;);"></div><div data-l="    bar(&quot;Hello&quot;, &quot;world&quot;);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>foo()</code> uses the syntax we showed earlier, and <code>bar()</code> uses a <code>where</code> clause.</span> <code>foo()</code>は以前示した構文を使用し、 <code>bar()</code>は<code>where</code>句を使用します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">All you need to do is leave off the bounds when defining your type parameters, and then add <code>where</code> after the parameter list.</span>型パラメーターを定義するときには境界を去り、パラメーター・リストの後ろに<code>where</code>を追加するだけです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For longer lists, whitespace can be added:</span>長いリストの場合は、空白を追加することができます：</span> </p><br><div data-lang=rust><div data-l="use std::fmt::Debug;"></div><div data-l=""></div><div data-l="fn bar&lt;T, K&gt;(x: T, y: K)"></div><div data-l="    where T: Clone,"></div><div data-l="          K: Clone + Debug {"></div><div data-l=""></div><div data-l="    x.clone();"></div><div data-l="    y.clone();"></div><div data-l="    println!(&quot;{:?}&quot;, y);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This flexibility can add clarity in complex situations.</span>この柔軟性は、複雑な状況では明瞭さを増すことができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>where</code> is also more powerful than the simpler syntax.</span> <code>where</code>にも簡単な構文よりも強力です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example:</span>例えば：</span> </p><br><div data-lang=rust><div data-l="trait ConvertTo&lt;Output&gt; {"></div><div data-l="    fn convert(&amp;self) -&gt; Output;"></div><div data-l=}></div><div data-l=""></div><div data-l="impl ConvertTo&lt;i64&gt; for i32 {"></div><div data-l="    fn convert(&amp;self) -&gt; i64 { *self as i64 }"></div><div data-l=}></div><div data-l=""></div><div data-l="#// Can be called with T == i32."></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Can be called with T == i32.</span> T == i32で呼び出すことができます。</span> </div><div data-l="fn convert_t_to_i64&lt;T: ConvertTo&lt;i64&gt;&gt;(x: T) -&gt; i64 {"></div><div data-l="    x.convert()"></div><div data-l=}></div><div data-l=""></div><div data-l="#// Can be called with T == i64."></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Can be called with T == i64.</span> T == i64で呼び出すことができます。</span> </div><div data-l="fn convert_i32_to_t&lt;T&gt;(x: i32) -&gt; T"></div><div data-l="#        // This is using ConvertTo as if it were &quot;ConvertTo&lt;i64&gt;&quot;."></div><div data-l="        // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is using ConvertTo as if it were &quot;ConvertTo</span>これは、ConvertToを &quot;ConvertTo&quot;のように使用しています</span> <i64> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">&quot;.</span> &quot;</span> </div><div data-l="        where i32: ConvertTo&lt;T&gt; {"></div><div data-l="    x.convert()"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This shows off the additional feature of <code>where</code> clauses: they allow bounds on the left-hand side not only of type parameters <code>T</code> , but also of types ( <code>i32</code> in this case).</span>これは<code>where</code>句の追加機能を示しています。これは型パラメータ<code>T</code>だけでなく型（この場合は<code>i32</code> ）の左側に境界を許します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this example, <code>i32</code> must implement <code>ConvertTo&lt;T&gt;</code> .</span>この例では、 <code>i32</code>は<code>ConvertTo&lt;T&gt;</code>実装する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rather than defining what <code>i32</code> is (since that&#39;s obvious), the <code>where</code> clause here constrains <code>T</code> .</span> <code>i32</code>が何であるかを定義するのではなく（ここから明らかです）、 <code>where</code>節は<code>T</code>制約します。</span> </p><br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Default methods</span>デフォルトのメソッド</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A default method can be added to a trait definition if it is already known how a typical implementor will define a method.</span>典型的な実装者がどのようにメソッドを定義するかが既にわかっている場合、デフォルトメソッドを特性定義に追加することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, <code>is_invalid()</code> is defined as the opposite of <code>is_valid()</code> :</span>例えば、 <code>is_invalid()</code>の逆のように定義される<code>is_valid()</code></span> </p><br><div data-lang=rust><div data-l="trait Foo {"></div><div data-l="    fn is_valid(&amp;self) -&gt; bool;"></div><div data-l=""></div><div data-l="    fn is_invalid(&amp;self) -&gt; bool { !self.is_valid() }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Implementors of the <code>Foo</code> trait need to implement <code>is_valid()</code> but not <code>is_invalid()</code> due to the added default behavior.</span> <code>Foo</code>特性の実装者は、追加されたデフォルト動作のために<code>is_invalid()</code>を実装する必要がありますが、 <code>is_valid()</code>実装する必要はありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This default behavior can still be overridden as in:</span>このデフォルトの動作は、次のようにオーバーライドできます。</span> </p><br><div data-lang=rust><div data-l="# trait Foo {"></div><div data-l="#     fn is_valid(&amp;self) -&gt; bool;"></div><div data-l=#></div><div data-l="#     fn is_invalid(&amp;self) -&gt; bool { !self.is_valid() }"></div><div data-l="# }"></div><div data-l="struct UseDefault;"></div><div data-l=""></div><div data-l="impl Foo for UseDefault {"></div><div data-l="    fn is_valid(&amp;self) -&gt; bool {"></div><div data-l="        println!(&quot;Called UseDefault.is_valid.&quot;);"></div><div data-l="        true"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="struct OverrideDefault;"></div><div data-l=""></div><div data-l="impl Foo for OverrideDefault {"></div><div data-l="    fn is_valid(&amp;self) -&gt; bool {"></div><div data-l="        println!(&quot;Called OverrideDefault.is_valid.&quot;);"></div><div data-l="        true"></div><div data-l="    }"></div><div data-l=""></div><div data-l="    fn is_invalid(&amp;self) -&gt; bool {"></div><div data-l="        println!(&quot;Called OverrideDefault.is_invalid!&quot;);"></div><div data-l="#//        true // Overrides the expected value of `is_invalid()`."></div><div data-l="        true // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Overrides the expected value of <code>is_invalid()</code> .</span> <code>is_invalid()</code>期待値をオーバーライドします。</span> </div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="let default = UseDefault;"></div><div data-l="#//assert!(!default.is_invalid()); // Prints &quot;Called UseDefault.is_valid.&quot;"></div><div data-l="assert!(!default.is_invalid()); // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Prints &quot;Called UseDefault.is_valid.&quot;</span> 「Called UseDefault.is_valid」を印刷します。</span> </div><div data-l=""></div><div data-l="let over = OverrideDefault;"></div><div data-l="#//assert!(over.is_invalid()); // Prints &quot;Called OverrideDefault.is_invalid!&quot;"></div><div data-l="assert!(over.is_invalid()); // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Prints &quot;Called OverrideDefault.is_invalid!&quot;</span> &quot;OverrideDefault.is_invalid！が呼び出されました！&quot;</span> </div></div><br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Inheritance</span>継承</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Sometimes, implementing a trait requires implementing another trait:</span>場合によっては、特性を実装するには別の特性を実装する必要があります。</span> </p><br><div data-lang=rust><div data-l="trait Foo {"></div><div data-l="    fn foo(&amp;self);"></div><div data-l=}></div><div data-l=""></div><div data-l="trait FooBar : Foo {"></div><div data-l="    fn foobar(&amp;self);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Implementors of <code>FooBar</code> must also implement <code>Foo</code> , like this:</span> <code>FooBar</code>実装者は、次のように<code>Foo</code>実装する必要があります。</span> </p><br><div data-lang=rust><div data-l="# trait Foo {"></div><div data-l="#     fn foo(&amp;self);"></div><div data-l="# }"></div><div data-l="# trait FooBar : Foo {"></div><div data-l="#     fn foobar(&amp;self);"></div><div data-l="# }"></div><div data-l="struct Baz;"></div><div data-l=""></div><div data-l="impl Foo for Baz {"></div><div data-l="    fn foo(&amp;self) { println!(&quot;foo&quot;); }"></div><div data-l=}></div><div data-l=""></div><div data-l="impl FooBar for Baz {"></div><div data-l="    fn foobar(&amp;self) { println!(&quot;foobar&quot;); }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we forget to implement <code>Foo</code> , Rust will tell us:</span> <code>Foo</code>実装を忘れた場合、Rustは次のように伝えます：</span> </p><br><div data-lang=text><div data-l="error: the trait bound `main::Baz : main::Foo` is not satisfied [E0277]"></div></div><br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Deriving</span>導く</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Implementing traits like <code>Debug</code> and <code>Default</code> repeatedly can become quite tedious.</span> <code>Debug</code>と<code>Default</code>ような特性を繰り返し実装することは非常に面倒なことになります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For that reason, Rust provides an <a class=notranslate href=#3attributes>attribute</a> that allows you to let Rust automatically implement traits for you:</span>そのため、Rustには、Rustが自動的に特性を実装できるようにする<a class=notranslate href=#3attributes>attribute</a>が用意されています。</span> </p><br><div data-lang=rust><div data-l=#[derive(Debug)]></div><div data-l="struct Foo;"></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    println!(&quot;{:?}&quot;, Foo);"></div><div data-l=}></div></div><br> <a class=notranslate href=#1attributes.html>attributes</a> <br> <p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, deriving is limited to a certain set of traits:</span>しかし、派生はある種の形質に限られています。</span> </p><br><div data-b=-> <a class=notranslate href=#2../../core/clone/trait.Clone.html><code>Clone</code></a> </div> <div data-b=-> <a class=notranslate href=#2../../core/marker/trait.Copy.html><code>Copy</code></a> </div> <div data-b=-> <a class=notranslate href=#2../../core/fmt/trait.Debug.html><code>Debug</code></a> </div> <div data-b=-> <a class=notranslate href=#2../../core/default/trait.Default.html><code>Default</code></a> </div> <div data-b=-> <a class=notranslate href=#2../../core/cmp/trait.Eq.html><code>Eq</code></a> </div> <div data-b=-> <a class=notranslate href=#2../../core/hash/trait.Hash.html><code>Hash</code></a> </div> <div data-b=-> <a class=notranslate href=#2../../core/cmp/trait.Ord.html><code>Ord</code></a> </div> <div data-b=-> <a class=notranslate href=#2../../core/cmp/trait.PartialEq.html><code>PartialEq</code></a> </div> <div data-b=-> <a class=notranslate href=#2../../core/cmp/trait.PartialOrd.html><code>PartialOrd</code></a> </div><script>_addload(function(){_setupIW('com');_csi('en','ja','traits.html');});</script>