<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180709_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=operators-and-overloading.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Operators and Overloading</span>演算子とオーバーロード</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust allows for a limited form of operator overloading.</span>錆は、限られた形式のオペレータ過負荷を可能にします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There are certain operators that are able to be overloaded.</span>過負荷になる可能性のある演算子があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To support a particular operator between types, there&#39;s a specific trait that you can implement, which then overloads the operator.</span>タイプ間で特定の演算子をサポートするには、実装できる特定の特性があり、演算子に過負荷がかかります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, the <code>+</code> operator can be overloaded with the <code>Add</code> trait:</span>たとえば、 <code>+</code>演算子は<code>Add</code>特性でオーバーロードすることができます。</span> </p><br><div data-lang=rust><div data-l="use std::ops::Add;"></div><div data-l=""></div><div data-l=#[derive(Debug)]></div><div data-l="struct Point {"></div><div data-l="    x: i32,"></div><div data-l="    y: i32,"></div><div data-l=}></div><div data-l=""></div><div data-l="impl Add for Point {"></div><div data-l="    type Output = Point;"></div><div data-l=""></div><div data-l="    fn add(self, other: Point) -&gt; Point {"></div><div data-l="        Point { x: self.x + other.x, y: self.y + other.y }"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let p1 = Point { x: 1, y: 0 };"></div><div data-l="    let p2 = Point { x: 2, y: 3 };"></div><div data-l=""></div><div data-l="    let p3 = p1 + p2;"></div><div data-l=""></div><div data-l="    println!(&quot;{:?}&quot;, p3);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In <code>main</code> , we can use <code>+</code> on our two <code>Point</code> s, since we&#39;ve implemented <code>Add&lt;Output=Point&gt;</code> for <code>Point</code> .</span>では<code>main</code> 、我々は使用することができます<code>+</code>我々の2つ上の<code>Point</code>私たちが実施してきたことから、sの<code>Add&lt;Output=Point&gt;</code>のための<code>Point</code> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There are a number of operators that can be overloaded this way, and all of their associated traits live in the <a class=notranslate href=#3stdops><code>std::ops</code></a> module.</span>この方法でオーバーロードすることができる多数の演算子があり、関連するすべての特性は<a class=notranslate href=#3stdops><code>std::ops</code></a>モジュールにあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Check out its documentation for the full list.</span>完全なリストについては、そのドキュメントを調べてください。</span> </p><br> <a class=notranslate href=#1../../std/ops/index.html>stdops</a> <br> <p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Implementing these traits follows a pattern.</span>これらの形質の実施にはパターンがあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s look at <a class=notranslate href=#3add><code>Add</code></a> in more detail:</span> <a class=notranslate href=#3add><code>Add</code></a>をもっと詳しく見てみましょう：</span> </p><br><div data-lang=rust><div data-l="# mod foo {"></div><div data-l="pub trait Add&lt;RHS = Self&gt; {"></div><div data-l="    type Output;"></div><div data-l=""></div><div data-l="    fn add(self, rhs: RHS) -&gt; Self::Output;"></div><div data-l=}></div><div data-l="# }"></div></div><br> <a class=notranslate href=#1../../std/ops/trait.Add.html>add</a> <br> <p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There&#39;s three types in total involved here: the type you <code>impl Add</code> for, <code>RHS</code> , which defaults to <code>Self</code> , and <code>Output</code> .</span>ここ<code>impl Add</code>は、 <code>impl Add</code> for <code>impl Add</code> 、 <code>RHS</code> 、 <code>Self</code>をデフォルトとするタイプ、 <code>Output</code> 3つのタイプがあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For an expression <code>let z = x + y</code> , <code>x</code> is the <code>Self</code> type, <code>y</code> is the RHS, and <code>z</code> is the <code>Self::Output</code> type.</span>式の場合、 <code>let z = x + y</code> 、 <code>x</code>は<code>Self</code>型、 <code>y</code>はRHS、 <code>z</code>は<code>Self::Output</code>型です。</span> </p><br><div data-lang=rust><div data-l="# struct Point;"></div><div data-l="# use std::ops::Add;"></div><div data-l="impl Add&lt;i32&gt; for Point {"></div><div data-l="    type Output = f64;"></div><div data-l=""></div><div data-l="    fn add(self, rhs: i32) -&gt; f64 {"></div><div data-l="#        // Add an i32 to a Point and get an f64."></div><div data-l="        // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Add an i32 to a Point and get an f64.</span> i32をポイントに追加し、f64を取得します。</span> </div><div data-l="# 1.0"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">will let you do this:</span>あなたにこれをさせるでしょう：</span> </p><br><div data-lang=rust,ignore><div data-l="#//let p: Point = // ..."></div><div data-l="let p: Point = // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">...</span> ...</span> </div><div data-l="let x: f64 = p + 2i32;"></div></div><br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Using operator traits in generic structs</span>ジェネリック構造体の演算子特性の使用</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now that we know how operator traits are defined, we can define our <code>HasArea</code> trait and <code>Square</code> struct from the <a href=#3traits>traits chapter</a> more generically:</span>演算子の特性がどのように定義されているかを知ったので、 <code>HasArea</code>特性と<code>Square</code>構造を<a href=#3traits>特性の章</a>からより一般的に定義できます。</span> </p><br> <a class=notranslate href=#1traits.html>traits</a> <br> <div data-lang=rust><div data-l="use std::ops::Mul;"></div><div data-l=""></div><div data-l="trait HasArea&lt;T&gt; {"></div><div data-l="    fn area(&amp;self) -&gt; T;"></div><div data-l=}></div><div data-l=""></div><div data-l="struct Square&lt;T&gt; {"></div><div data-l="    x: T,"></div><div data-l="    y: T,"></div><div data-l="    side: T,"></div><div data-l=}></div><div data-l=""></div><div data-l="impl&lt;T&gt; HasArea&lt;T&gt; for Square&lt;T&gt;"></div><div data-l="        where T: Mul&lt;Output=T&gt; + Copy {"></div><div data-l="    fn area(&amp;self) -&gt; T {"></div><div data-l="        self.side * self.side"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let s = Square {"></div><div data-l="        x: 0.0f64,"></div><div data-l="        y: 0.0f64,"></div><div data-l="        side: 12.0f64,"></div><div data-l="    };"></div><div data-l=""></div><div data-l="    println!(&quot;Area of s: {}&quot;, s.area());"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For <code>HasArea</code> and <code>Square</code> , we declare a type parameter <code>T</code> and replace <code>f64</code> with it.</span> <code>HasArea</code>と<code>Square</code>については、型パラメータ<code>T</code>を宣言し、 <code>f64</code>をそれに置き換えます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>impl</code> needs more involved modifications:</span> <code>impl</code>はより複雑な変更が必要です。</span> </p><br><div data-lang=rust,ignore><div data-l="impl&lt;T&gt; HasArea&lt;T&gt; for Square&lt;T&gt;"></div><div data-l="        where T: Mul&lt;Output=T&gt; + Copy { ... }"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>area</code> method requires that we can multiply the sides, so we declare that type <code>T</code> must implement <code>std::ops::Mul</code> .</span> <code>area</code>メソッドでは、辺を掛けることができるので、タイプ<code>T</code>は<code>std::ops::Mul</code>実装しなければならないと宣言します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Like <code>Add</code> , mentioned above, <code>Mul</code> itself takes an <code>Output</code> parameter: since we know that numbers don&#39;t change type when multiplied, we also set it to <code>T</code> .</span>前述の<code>Add</code>ように、 <code>Mul</code>自体は<code>Output</code>パラメーターをとります。数値は乗算されたときに型が変更されないことを知っているので、 <code>T</code>も設定します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>T</code> must also support copying, so Rust doesn&#39;t try to move <code>self.side</code> into the return value.</span> <code>T</code>もコピーをサポートしなければならないので、Rustは<code>self.side</code>を戻り値に移動しようとしません。</span> </p><script>_addload(function(){_setupIW('com');_csi('en','ja','operators-and-overloading.html');});</script>