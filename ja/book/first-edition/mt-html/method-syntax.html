<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180709_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=method-syntax.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Method Syntax</span>メソッドの構文</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Functions are great, but if you want to call a bunch of them on some data, it can be awkward.</span>関数は素晴らしいですが、いくつかのデータでそれらの束を呼びたい場合は、扱いにくいかもしれません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Consider this code:</span>このコードを考えてみましょう：</span> </p><br><div data-lang=rust,ignore><div data-l=baz(bar(foo));></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We would read this left-to-right, and so we see &#39;baz bar foo&#39;.</span>これを左から右に読むと、「baz bar foo」と表示されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But this isn&#39;t the order that the functions would get called in, that&#39;s inside-out: &#39;foo bar baz&#39;.</span>しかし、これは機能が呼び出される順番ではなく、それはインサイドアウトです： &#39;foo bar baz&#39;。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Wouldn&#39;t it be nice if we could do this instead?</span>代わりにこれを行うことができればいいのではないでしょうか？</span> </p><br><div data-lang=rust,ignore><div data-l=foo.bar().baz();></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Luckily, as you may have guessed with the leading question, you can!</span>幸いなことに、主な質問で推測したように、あなたはできます！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust provides the ability to use this &#39;method call syntax&#39; via the <code>impl</code> keyword.</span> Rustは、この &#39;メソッド呼び出し構文&#39;を<code>impl</code>キーワードで使用する機能を提供します。</span> </p><br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Method calls</span>メソッド呼び出し</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here&#39;s how it works:</span>それはどのように動作するのです：</span> </p><br><div data-lang=rust><div data-l="struct Circle {"></div><div data-l="    x: f64,"></div><div data-l="    y: f64,"></div><div data-l="    radius: f64,"></div><div data-l=}></div><div data-l=""></div><div data-l="impl Circle {"></div><div data-l="    fn area(&amp;self) -&gt; f64 {"></div><div data-l="        std::f64::consts::PI * (self.radius * self.radius)"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let c = Circle { x: 0.0, y: 0.0, radius: 2.0 };"></div><div data-l="    println!(&quot;{}&quot;, c.area());"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This will print <code>12.566371</code> .</span>これにより<code>12.566371</code>が印刷され<code>12.566371</code> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ve made a <code>struct</code> that represents a circle.</span>円を表す<code>struct</code>を作成しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We then write an <code>impl</code> block, and inside it, define a method, <code>area</code> .</span>次に、 <code>impl</code>ブロックを記述し、その内部にメソッド、 <code>area</code>定義します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Methods take a special first parameter, of which there are three variants: <code>self</code> , <code>&amp;self</code> , and <code>&amp;mut self</code> .</span>メソッドは特別な最初のパラメータをとります。その中に<code>self</code> 、 <code>&amp;self</code> 、および<code>&amp;mut self</code> 3つの変種があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can think of this first parameter as being the <code>foo</code> in <code>foo.bar()</code> .</span>この最初のパラメータは、 <code>foo.bar()</code> <code>foo</code>であると考えることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The three variants correspond to the three kinds of things <code>foo</code> could be: <code>self</code> if it&#39;s a value on the stack, <code>&amp;self</code> if it&#39;s a reference, and <code>&amp;mut self</code> if it&#39;s a mutable reference.</span> 3つの変種は<code>foo</code>ができる3つの種類に対応します： <code>self</code>はスタック上の値なら<code>&amp;self</code> 、それがリファレンスならば<code>&amp;mut self</code> 、それが可変参照の場合は<code>&amp;mut self</code>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because we took the <code>&amp;self</code> parameter to <code>area</code> , we can use it like any other parameter.</span> <code>&amp;self</code>パラメータを<code>area</code>に取ったので、他のパラメータと同様に使用できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because we know it&#39;s a <code>Circle</code> , we can access the <code>radius</code> like we would with any other <code>struct</code> .</span> <code>Circle</code>であることがわかっているので、他の<code>struct</code>と同様に<code>radius</code>アクセスできます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We should default to using <code>&amp;self</code> , as you should prefer borrowing over taking ownership, as well as taking immutable references over mutable ones.</span>所有権を借りることよりも借りることを望むべきであると同時に、変更可能なものよりも不変な参照を取ることを望むならば、 <code>&amp;self</code>を使うことをデフォルトにするべきです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here&#39;s an example of all three variants:</span>次の3つのバリアントの例を示します。</span> </p><br><div data-lang=rust><div data-l="struct Circle {"></div><div data-l="    x: f64,"></div><div data-l="    y: f64,"></div><div data-l="    radius: f64,"></div><div data-l=}></div><div data-l=""></div><div data-l="impl Circle {"></div><div data-l="    fn reference(&amp;self) {"></div><div data-l="       println!(&quot;taking self by reference!&quot;);"></div><div data-l="    }"></div><div data-l=""></div><div data-l="    fn mutable_reference(&amp;mut self) {"></div><div data-l="       println!(&quot;taking self by mutable reference!&quot;);"></div><div data-l="    }"></div><div data-l=""></div><div data-l="    fn takes_ownership(self) {"></div><div data-l="       println!(&quot;taking ownership of self!&quot;);"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can use as many <code>impl</code> blocks as you&#39;d like.</span>あなたは好きなだけ多くの<code>impl</code>ブロックを使うことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The previous example could have also been written like this:</span>前の例は次のように書かれているかもしれません：</span> </p><br><div data-lang=rust><div data-l="struct Circle {"></div><div data-l="    x: f64,"></div><div data-l="    y: f64,"></div><div data-l="    radius: f64,"></div><div data-l=}></div><div data-l=""></div><div data-l="impl Circle {"></div><div data-l="    fn reference(&amp;self) {"></div><div data-l="       println!(&quot;taking self by reference!&quot;);"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="impl Circle {"></div><div data-l="    fn mutable_reference(&amp;mut self) {"></div><div data-l="       println!(&quot;taking self by mutable reference!&quot;);"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="impl Circle {"></div><div data-l="    fn takes_ownership(self) {"></div><div data-l="       println!(&quot;taking ownership of self!&quot;);"></div><div data-l="    }"></div><div data-l=}></div></div><br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Chaining method calls</span>メソッド呼び出しの連鎖</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So, now we know how to call a method, such as <code>foo.bar()</code> .</span>そこで、 <code>foo.bar()</code>などのメソッドを呼び出す方法を知っています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But what about our original example, <code>foo.bar().baz()</code> ?</span>しかし、元の例<code>foo.bar().baz()</code>どうですか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is called &#39;method chaining&#39;.</span>これは「メソッド連鎖」と呼ばれます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s look at an example:</span>例を見てみましょう：</span> </p><br><div data-lang=rust><div data-l="struct Circle {"></div><div data-l="    x: f64,"></div><div data-l="    y: f64,"></div><div data-l="    radius: f64,"></div><div data-l=}></div><div data-l=""></div><div data-l="impl Circle {"></div><div data-l="    fn area(&amp;self) -&gt; f64 {"></div><div data-l="        std::f64::consts::PI * (self.radius * self.radius)"></div><div data-l="    }"></div><div data-l=""></div><div data-l="    fn grow(&amp;self, increment: f64) -&gt; Circle {"></div><div data-l="        Circle { x: self.x, y: self.y, radius: self.radius + increment }"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let c = Circle { x: 0.0, y: 0.0, radius: 2.0 };"></div><div data-l="    println!(&quot;{}&quot;, c.area());"></div><div data-l=""></div><div data-l="    let d = c.grow(2.0).area();"></div><div data-l="    println!(&quot;{}&quot;, d);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Check the return type:</span>戻り値の型を確認してください：</span> </p><br><div data-lang=rust><div data-l="# struct Circle;"></div><div data-l="# impl Circle {"></div><div data-l="fn grow(&amp;self, increment: f64) -&gt; Circle {"></div><div data-l="# Circle } }"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We say we&#39;re returning a <code>Circle</code> .</span>私たちは<code>Circle</code>返すと言います。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">With this method, we can grow a new <code>Circle</code> to any arbitrary size.</span>この方法では、新しい<code>Circle</code>を任意のサイズに拡大できます。</span> </p><br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Associated functions</span>関連する関数</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can also define associated functions that do not take a <code>self</code> parameter.</span> <code>self</code>パラメータを取らない関連する関数を定義することもできます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here&#39;s a pattern that&#39;s very common in Rust code:</span> Rustコードでよく見られるパターンは次のとおりです。</span> </p><br><div data-lang=rust><div data-l="struct Circle {"></div><div data-l="    x: f64,"></div><div data-l="    y: f64,"></div><div data-l="    radius: f64,"></div><div data-l=}></div><div data-l=""></div><div data-l="impl Circle {"></div><div data-l="    fn new(x: f64, y: f64, radius: f64) -&gt; Circle {"></div><div data-l="        Circle {"></div><div data-l="            x: x,"></div><div data-l="            y: y,"></div><div data-l="            radius: radius,"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let c = Circle::new(0.0, 0.0, 2.0);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This &#39;associated function&#39; builds a new <code>Circle</code> for us.</span>この「関連付けられた関数」は、新しい<code>Circle</code>を作成します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that associated functions are called with the <code>Struct::function()</code> syntax, rather than the <code>ref.method()</code> syntax.</span>関連する関数は、 <code>ref.method()</code>構文ではなく、 <code>Struct::function()</code>構文で呼び出されることに注意してください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Some other languages call associated functions &#39;static methods&#39;.</span>他の言語では、関連する関数「静的メソッド」を呼び出します。</span> </p><br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Builder Pattern</span>ビルダーパターン</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s say that we want our users to be able to create <code>Circle</code> s, but we will allow them to only set the properties they care about.</span>ユーザーが<code>Circle</code>を作成できるようにしたいと考えていますが、 <code>Circle</code>のあるプロパティのみを設定できるようにします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Otherwise, the <code>x</code> and <code>y</code> attributes will be <code>0.0</code> , and the <code>radius</code> will be <code>1.0</code> .</span>それ以外の場合、 <code>x</code>および<code>y</code>属性は<code>0.0</code>になり、 <code>radius</code>は<code>1.0</code>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust doesn&#39;t have method overloading, named arguments, or variable arguments.</span> Rustには、メソッドのオーバーロード、名前付き引数、または可変引数はありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We employ the builder pattern instead.</span>代わりにビルダーパターンを使用します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It looks like this:</span>これは次のようになります。</span> </p><br><div data-lang=rust><div data-l="struct Circle {"></div><div data-l="    x: f64,"></div><div data-l="    y: f64,"></div><div data-l="    radius: f64,"></div><div data-l=}></div><div data-l=""></div><div data-l="impl Circle {"></div><div data-l="    fn area(&amp;self) -&gt; f64 {"></div><div data-l="        std::f64::consts::PI * (self.radius * self.radius)"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="struct CircleBuilder {"></div><div data-l="    x: f64,"></div><div data-l="    y: f64,"></div><div data-l="    radius: f64,"></div><div data-l=}></div><div data-l=""></div><div data-l="impl CircleBuilder {"></div><div data-l="    fn new() -&gt; CircleBuilder {"></div><div data-l="        CircleBuilder { x: 0.0, y: 0.0, radius: 1.0, }"></div><div data-l="    }"></div><div data-l=""></div><div data-l="    fn x(&amp;mut self, coordinate: f64) -&gt; &amp;mut CircleBuilder {"></div><div data-l="        self.x = coordinate;"></div><div data-l="        self"></div><div data-l="    }"></div><div data-l=""></div><div data-l="    fn y(&amp;mut self, coordinate: f64) -&gt; &amp;mut CircleBuilder {"></div><div data-l="        self.y = coordinate;"></div><div data-l="        self"></div><div data-l="    }"></div><div data-l=""></div><div data-l="    fn radius(&amp;mut self, radius: f64) -&gt; &amp;mut CircleBuilder {"></div><div data-l="        self.radius = radius;"></div><div data-l="        self"></div><div data-l="    }"></div><div data-l=""></div><div data-l="    fn finalize(&amp;self) -&gt; Circle {"></div><div data-l="        Circle { x: self.x, y: self.y, radius: self.radius }"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let c = CircleBuilder::new()"></div><div data-l="                .x(1.0)"></div><div data-l="                .y(2.0)"></div><div data-l="                .radius(2.0)"></div><div data-l="                .finalize();"></div><div data-l=""></div><div data-l="    println!(&quot;area: {}&quot;, c.area());"></div><div data-l="    println!(&quot;x: {}&quot;, c.x);"></div><div data-l="    println!(&quot;y: {}&quot;, c.y);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">What we&#39;ve done here is make another <code>struct</code> , <code>CircleBuilder</code> .</span>私たちがここで行ったことは、別の<code>struct</code> <code>CircleBuilder</code>作ること<code>CircleBuilder</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ve defined our builder methods on it.</span>ビルダーメソッドを定義しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ve also defined our <code>area()</code> method on <code>Circle</code> .</span> <code>Circle</code> <code>area()</code>メソッドも定義しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We also made one more method on <code>CircleBuilder</code> : <code>finalize()</code> .</span> <code>CircleBuilder</code>もう一つのメソッド<code>finalize()</code>も作成しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This method creates our final <code>Circle</code> from the builder.</span>このメソッドは、ビルダーから最終的な<code>Circle</code>を作成します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now, we&#39;ve used the type system to enforce our concerns: we can use the methods on <code>CircleBuilder</code> to constrain making <code>Circle</code> s in any way we choose.</span>ここでは、型システムを使用して懸念を<code>CircleBuilder</code>ました<code>CircleBuilder</code>のメソッドを使用して、 <code>Circle</code>の選択を制限しています。</span> </p><script>_addload(function(){_setupIW('com');_csi('en','ja','method-syntax.html');});</script>