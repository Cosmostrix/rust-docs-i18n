<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180709_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=closures.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Closures</span>閉鎖</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Sometimes it is useful to wrap up a function and <s>free variables</s> for better clarity and reuse.</span>時には、より明確で再利用<s>できる</s>ように、関数と<s>変数</s>をまとめておくと便利です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The free variables that can be used come from the enclosing scope and are &#39;closed over&#39; when used in the function.</span>使用可能なフリー変数は、囲みスコープから来ており、関数で使用されているときは「クローズ」されています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">From this, we get the name &#39;closures&#39; and Rust provides a really great implementation of them, as we&#39;ll see.</span>これから、「クロージャー」という名前が付けられました。そして、Rustは、それらの本当に素晴らしい実装を提供します。</span> </p><br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Syntax</span>構文</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Closures look like this:</span>クロージャは次のようになります。</span> </p><br><div data-lang=rust><div data-l="let plus_one = |x: i32| x + 1;"></div><div data-l=""></div><div data-l="assert_eq!(2, plus_one(1));"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We create a binding, <code>plus_one</code> , and assign it to a closure.</span>バインディング<code>plus_one</code>を作成し、クロージャに割り当てます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The closure&#39;s arguments go between the pipes ( <code>|</code> ), and the body is an expression, in this case, <code>x + 1</code> .</span>クロージャの引数はパイプ（ <code>|</code> ）の間にあり、ボディは式（この場合は<code>x + 1</code>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Remember that <code>{ }</code> is an expression, so we can have multi-line closures too:</span> <code>{ }</code>は式なので、複数行のクロージャーを使用することもできます。</span> </p><br><div data-lang=rust><div data-l="let plus_two = |x| {"></div><div data-l="    let mut result: i32 = x;"></div><div data-l=""></div><div data-l="    result += 1;"></div><div data-l="    result += 1;"></div><div data-l=""></div><div data-l="    result"></div><div data-l=};></div><div data-l=""></div><div data-l="assert_eq!(4, plus_two(2));"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You&#39;ll notice a few things about closures that are a bit different from regular named functions defined with <code>fn</code> .</span> <code>fn</code>定義された通常の名前付き関数とは少し違うクロージャについては、いくつか気づくでしょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The first is that we did not need to annotate the types of arguments the closure takes or the values it returns.</span> 1つ目は、クロージャーが取る引数の型や、それが返す値に注釈を付ける必要がないことです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can:</span>私たちはできる：</span> </p><br><div data-lang=rust><div data-l="let plus_one = |x: i32| -&gt; i32 { x + 1 };"></div><div data-l=""></div><div data-l="assert_eq!(2, plus_one(1));"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But we don&#39;t have to.</span>しかし、私たちはする必要はありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Why is this?</span>どうしてこれなの？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Basically, it was chosen for ergonomic reasons.</span>基本的には人間工学的理由から選ばれたものです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">While specifying the full type for named functions is helpful with things like documentation and type inference, the full type signatures of closures are rarely documented since they&#39;re anonymous, and they don&#39;t cause the kinds of error-at-a-distance problems that inferring named function types can.</span>名前付き関数の完全型を指定すると、ドキュメントや型推論などに役立ちますが、クロージャの完全型署名は匿名であるためほとんど記述されません。名前付き関数型を推論することができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The second is that the syntax is similar, but a bit different.</span> 2つ目は、構文が似ていますが、少し異なります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">I&#39;ve added spaces here for easier comparison:</span>ここでは比較を簡単にするためにスペースを追加しました。</span> </p><br><div data-lang=rust><div data-l="fn  plus_one_v1   (x: i32) -&gt; i32 { x + 1 }"></div><div data-l="let plus_one_v2 = |x: i32| -&gt; i32 { x + 1 };"></div><div data-l="let plus_one_v3 = |x: i32|          x + 1  ;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Small differences, but they&#39;re similar.</span>小さな違いですが、似ています。</span> </p><br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Closures and their environment</span>閉鎖とその環境</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The environment for a closure can include bindings from its enclosing scope in addition to parameters and local bindings.</span>クロージャの環境には、パラメータとローカルバインディングに加えて、囲みスコープからのバインディングを含めることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It looks like this:</span>これは次のようになります。</span> </p><br><div data-lang=rust><div data-l="let num = 5;"></div><div data-l="let plus_num = |x: i32| x + num;"></div><div data-l=""></div><div data-l="assert_eq!(10, plus_num(5));"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This closure, <code>plus_num</code> , refers to a <code>let</code> binding in its scope: <code>num</code> .</span>この閉鎖は、 <code>plus_num</code>を指し、 <code>let</code>その範囲にバインディング： <code>num</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">More specifically, it borrows the binding.</span>具体的には、バインディングを借用します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we do something that would conflict with that binding, we get an error.</span>その拘束力と矛盾する何かをすると、私たちは誤りを犯します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Like this one:</span>このように：</span> </p><br><div data-lang=rust,ignore><div data-l="let mut num = 5;"></div><div data-l="let plus_num = |x: i32| x + num;"></div><div data-l=""></div><div data-l="let y = &amp;mut num;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Which errors with:</span>どのエラーで</span> </p><br><div data-lang=text><div data-l="error: cannot borrow `num` as mutable because it is also borrowed as immutable"></div><div data-l="    let y = &amp;mut num;"></div><div data-l="                 ^~~"></div><div data-l="note: previous borrow of `num` occurs here due to use in closure; the immutable"></div><div data-l="  borrow prevents subsequent moves or mutable borrows of `num` until the borrow"></div><div data-l="  ends"></div><div data-l="    let plus_num = |x| x + num;"></div><div data-l="                   ^~~~~~~~~~~"></div><div data-l="note: previous borrow ends here"></div><div data-l="fn main() {"></div><div data-l="    let mut num = 5;"></div><div data-l="    let plus_num = |x| x + num;"></div><div data-l=""></div><div data-l="    let y = &amp;mut num;"></div><div data-l=}></div><div data-l=^></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A verbose yet helpful error message!</span>冗長で役に立つエラーメッセージです！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As it says, we can&#39;t take a mutable borrow on <code>num</code> because the closure is already borrowing it.</span>それが言っているように、クロージャーが既にそれを借りているので、私たちは<code>num</code>可変の借りをすることはできません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we let the closure go out of scope, we can:</span>クロージャを範囲外にすると、次のことが可能になります。</span> </p><br><div data-lang=rust><div data-l="let mut num = 5;"></div><div data-l={></div><div data-l="    let plus_num = |x: i32| x + num;"></div><div data-l=""></div><div data-l="#//} // `plus_num` goes out of scope; borrow of `num` ends."></div><div data-l="} // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>plus_num</code> goes out of scope;</span> <code>plus_num</code>は範囲外になります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">borrow of <code>num</code> ends.</span> <code>num</code>借りは終了する。</span> </div><div data-l=""></div><div data-l="let y = &amp;mut num;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If your closure requires it, however, Rust will take ownership and move the environment instead.</span>しかし、クロージャがそれを必要とする場合、Rustは所有権を取り、代わりに環境を移動します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This doesn&#39;t work:</span>これは動作しません：</span> </p><br><div data-lang=rust,ignore><div data-l="let nums = vec![1, 2, 3];"></div><div data-l=""></div><div data-l="let takes_nums = || nums;"></div><div data-l=""></div><div data-l="println!(&quot;{:?}&quot;, nums);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We get this error:</span>このエラーが発生します：</span> </p><br><div data-lang=text><div data-l="note: `nums` moved into closure environment here because it has type"></div><div data-l="  `[closure(()) -&gt; collections::vec::Vec&lt;i32&gt;]`, which is non-copyable"></div><div data-l="let takes_nums = || nums;"></div><div data-l="                 ^~~~~~~"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>Vec&lt;T&gt;</code> has ownership over its contents, and therefore, when we refer to it in our closure, we have to take ownership of <code>nums</code> .</span> <code>Vec&lt;T&gt;</code>はその内容よりも所有権があるため、終了時に参照するときは<code>nums</code>所有権を取得する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It&#39;s the same as if we&#39;d passed <code>nums</code> to a function that took ownership of it.</span>それは、私たちが所有権を取得した関数に<code>nums</code>を渡した場合と同じです。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>move</code> closures</span>クロージャを<code>move</code>する</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can force our closure to take ownership of its environment with the <code>move</code> keyword:</span> <code>move</code>キーワードを使用して、閉鎖を強制的に環境の所有権にすることができます。</span> </p><br><div data-lang=rust><div data-l="let num = 5;"></div><div data-l=""></div><div data-l="let owns_num = move |x: i32| x + num;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now, even though the keyword is <code>move</code> , the variables follow normal move semantics.</span>現在、キーワードが<code>move</code>であっても、変数は通常の移動セマンティクスに従います。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this case, <code>5</code> implements <code>Copy</code> , and so <code>owns_num</code> takes ownership of a copy of <code>num</code> .</span>この場合、 <code>5</code>は<code>Copy</code>実装するため、 <code>owns_num</code>は<code>num</code>コピーの所有権を取得します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So what&#39;s the difference?</span>違いは何ですか？</span> </p><br><div data-lang=rust><div data-l="let mut num = 5;"></div><div data-l=""></div><div data-l={></div><div data-l="    let mut add_num = |x: i32| num += x;"></div><div data-l=""></div><div data-l="    add_num(5);"></div><div data-l=}></div><div data-l=""></div><div data-l="assert_eq!(10, num);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So in this case, our closure took a mutable reference to <code>num</code> , and then when we called <code>add_num</code> , it mutated the underlying value, as we&#39;d expect.</span>だから、このケースでは、クロージャが<code>num</code>への参照を変更し、 <code>add_num</code> 、元の値に突然変異が<code>add_num</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We also needed to declare <code>add_num</code> as <code>mut</code> too, because we&#39;re mutating its environment.</span>また、環境を変更しているので、 <code>add_num</code>も<code>mut</code>として宣言する必要がありました。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we change to a <code>move</code> closure, it&#39;s different:</span> <code>move</code>クロージャに変更した場合、それは異なります。</span> </p><br><div data-lang=rust><div data-l="let mut num = 5;"></div><div data-l=""></div><div data-l={></div><div data-l="    let mut add_num = move |x: i32| num += x;"></div><div data-l=""></div><div data-l="    add_num(5);"></div><div data-l=}></div><div data-l=""></div><div data-l="assert_eq!(5, num);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We only get <code>5</code> .</span>我々は<code>5</code>を得る。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rather than taking a mutable borrow out on our <code>num</code> , we took ownership of a copy.</span>私たちの<code>num</code>変更可能な借用を取るのではなく、コピーの所有権を取った。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Another way to think about <code>move</code> closures: they give a closure its own stack frame.</span> <code>move</code>クロージャについて考えるもう一つの方法は、クロージャに独自のスタックフレームを与えます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Without <code>move</code> , a closure may be tied to the stack frame that created it, while a <code>move</code> closure is self-contained.</span> <code>move</code>なければ、クロージャはそれを作成したスタックフレームに結びつけられ、 <code>move</code>クロージャは自己完結型です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This means that you cannot generally return a non- <code>move</code> closure from a function, for example.</span>つまり、一般的に、関数から非<code>move</code>クロージャを返すことはできません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But before we talk about taking and returning closures, we should talk some more about the way that closures are implemented.</span>しかし、クロージャを受け取り、返すことについて話す前に、クロージャが実装される方法についてもう少し話してください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As a systems language, Rust gives you tons of control over what your code does, and closures are no different.</span>システムの言語として、Rustはコードが行うことを何トンも制御し、クロージャも変わりません。</span> </p><br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Closure implementation</span>閉鎖の実装</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust&#39;s implementation of closures is a bit different than other languages.</span> Rustのクロージャの実装は、他の言語とは少し異なります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">They are effectively syntax sugar for traits.</span>彼らは事実上、形質のためのシンタックスシュガーです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You&#39;ll want to make sure to have read the <a class=notranslate href=#3traits>traits</a> section before this one, as well as the section on <a class=notranslate href=#3trait-objects>trait objects</a> .</span>あなたは読み持っていることを確認したいと思う<a class=notranslate href=#3traits>traits</a>この1の前のセクションを、だけでなく、上のセクション<a class=notranslate href=#3trait-objects>trait objects</a> 。</span> </p><br> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a class=notranslate href=#1traits.html>traits</a> <a class=notranslate href=#1trait-objects.html>trait-objects</a></span> <a class=notranslate href=#1traits.html>traits</a> <a class=notranslate href=#1trait-objects.html>trait-objects</a></span> <br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Got all that?</span>すべては？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Good.</span>良い。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The key to understanding how closures work under the hood is something a bit strange: Using <code>()</code> to call a function, like <code>foo()</code> , is an overloadable operator.</span>フックでクロージャがどのように動作するかを理解するための鍵はちょっと変わったことです：Using <code>()</code>を使って<code>foo()</code>ような関数を呼び出すことは、オーバーロード可能な演算子です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">From this, everything else clicks into place.</span>これ以降、他のすべてがクリックされます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In Rust, we use the trait system to overload operators.</span> Rustでは、特性システムを使用してオペレータを過負荷にします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Calling functions is no different.</span>関数の呼び出しも変わりません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We have three separate traits to overload with:</span>私たちには3つの異なる特性があります。</span> </p><br><div data-b=*> <code>Fn</code> </div> <div data-b=*> <code>FnMut</code> </div> <div data-b=*> <code>FnOnce</code> </div> <br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There are a few differences between these traits, but a big one is <code>self</code> : <code>Fn</code> takes <code>&amp;self</code> , <code>FnMut</code> takes <code>&amp;mut self</code> , and <code>FnOnce</code> takes <code>self</code> .</span>これらの特徴にはいくつかの違いがありますが、大きなものは<code>self</code>です： <code>Fn</code>は<code>&amp;self</code> 、 <code>FnMut</code>は<code>&amp;mut self</code> 、 <code>FnOnce</code>は<code>self</code>取ります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This covers all three kinds of <code>self</code> via the usual method call syntax.</span>これは、通常のメソッド呼び出し構文を使って、3種類の<code>self</code>すべてをカバーします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But we&#39;ve split them up into three traits, rather than having a single one.</span>しかし、私たちは1つのものを持つよりも、3つの特性に分割しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This gives us a large amount of control over what kind of closures we can take.</span>これにより、どのような種類の閉鎖を取ることができるかを大量に制御することができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>|| {}</code></span> <code>|| {}</code></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>|| {}</code> syntax for closures is sugar for these three traits.</span>クロージャーのための<code>|| {}</code>構文は、これらの3つの特性のための砂糖です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust will generate a struct for the environment, <code>impl</code> the appropriate trait, and then use it.</span> Rustは環境の構造体を生成し、適切な特性を<code>impl</code>使用します。</span> </p><br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Taking closures as arguments</span>クロージャを引数として取る</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now that we know that closures are traits, we already know how to accept and return closures: the same as any other trait!</span>クロージャーが特色であることを知ったので、クロージャを受け入れて返す方法は既に知っています。他の特性と同じです！</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This also means that we can choose static vs dynamic dispatch as well.</span>これは、静的対動的ディスパッチも選択できることを意味します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">First, let&#39;s write a function which takes something callable, calls it, and returns the result:</span>まず、呼び出し可能なものをとり、呼び出して結果を返す関数を記述しましょう：</span> </p><br><div data-lang=rust><div data-l="fn call_with_one&lt;F&gt;(some_closure: F) -&gt; i32"></div><div data-l="    where F: Fn(i32) -&gt; i32 {"></div><div data-l=""></div><div data-l="    some_closure(1)"></div><div data-l=}></div><div data-l=""></div><div data-l="let answer = call_with_one(|x| x + 2);"></div><div data-l=""></div><div data-l="assert_eq!(3, answer);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We pass our closure, <code>|x| x + 2</code></span>私たちは閉包を渡します、 <code>|x| x + 2</code></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>|x| x + 2</code> , to <code>call_with_one</code> .</span> <code>|x| x + 2</code>で、 <code>call_with_one</code>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It does what it suggests: it calls the closure, giving it <code>1</code> as an argument.</span>それは、それが示唆していることを行います：それは引数として<code>1</code>を与えるクロージャを呼び出します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s examine the signature of <code>call_with_one</code> in more depth:</span> <code>call_with_one</code>のシグネチャをさらに詳しく調べてみましょう。</span> </p><br><div data-lang=rust><div data-l="fn call_with_one&lt;F&gt;(some_closure: F) -&gt; i32"></div><div data-l="#    where F: Fn(i32) -&gt; i32 {"></div><div data-l="#    some_closure(1) }"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We take one parameter, and it has the type <code>F</code> .</span> 1つのパラメータを取り、タイプ<code>F</code>持ちます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We also return an <code>i32</code> .</span>私たちは<code>i32</code>も返します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This part isn&#39;t interesting.</span>この部分は興味深いものではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The next part is:</span>次の部分は次のとおりです。</span> </p><br><div data-lang=rust><div data-l="# fn call_with_one&lt;F&gt;(some_closure: F) -&gt; i32"></div><div data-l="    where F: Fn(i32) -&gt; i32 {"></div><div data-l="#   some_closure(1) }"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because <code>Fn</code> is a trait, we can use it as a bound for our generic type.</span> <code>Fn</code>は形質なので、ジェネリック型の境界として使うことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this case, our closure takes an <code>i32</code> as an argument and returns an <code>i32</code> , and so the generic bound we use is <code>Fn(i32) -&gt; i32</code> .</span>この場合、私たちの閉鎖がかかる<code>i32</code>引数としてと返し<code>i32</code> 、そして私たちが使用するので、一般的な束縛がある<code>Fn(i32) -&gt; i32</code> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There&#39;s one other key point here: because we&#39;re bounding a generic with a trait, this will get monomorphized, and therefore, we&#39;ll be doing static dispatch into the closure.</span>もう1つの重要な点があります：特性を持つジェネリックを囲んでいるため、これは単体化されるため、クロージャに静的なディスパッチを行います。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That&#39;s pretty neat.</span>それはかなりきれいです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In many languages, closures are inherently heap allocated, and will always involve dynamic dispatch.</span>多くの言語では、クロージャは本質的にヒープに割り当てられ、常に動的ディスパッチを伴います。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In Rust, we can stack allocate our closure environment, and statically dispatch the call.</span> Rustでは、クロージャ環境をスタックして静的に呼び出すことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This happens quite often with iterators and their adapters, which often take closures as arguments.</span>これはイテレータとそのアダプタで頻繁に起こります。これは引数としてクロージャを使用することがよくあります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Of course, if we want dynamic dispatch, we can get that too.</span>もちろん、動的ディスパッチが必要な場合は、それを取得することもできます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A trait object handles this case, as usual:</span> traitオブジェクトは、通常どおりこのケースを処理します。</span> </p><br><div data-lang=rust><div data-l="fn call_with_one(some_closure: &amp;Fn(i32) -&gt; i32) -&gt; i32 {"></div><div data-l="    some_closure(1)"></div><div data-l=}></div><div data-l=""></div><div data-l="let answer = call_with_one(&amp;|x| x + 2);"></div><div data-l=""></div><div data-l="assert_eq!(3, answer);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now we take a trait object, a <code>&amp;Fn</code> .</span>今度は、 <code>&amp;Fn</code>という特性オブジェクトを取り<code>&amp;Fn</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">And we have to make a reference to our closure when we pass it to <code>call_with_one</code> , so we use <code>&amp;||</code></span> <code>call_with_one</code>に渡すときにクロージャの参照をする<code>call_with_one</code>があるので、 <code>&amp;||</code>を使用します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">.</span> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A quick note about closures that use explicit lifetimes.</span>明示的な存続期間を使用するクロージャについての簡単なメモ。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Sometimes you might have a closure that takes a reference like so:</span>場合によっては、次のような参照をとるクロージャーを使用することがあります。</span> </p><br><div data-lang=rust><div data-l="fn call_with_ref&lt;F&gt;(some_closure:F) -&gt; i32"></div><div data-l="    where F: Fn(&amp;i32) -&gt; i32 {"></div><div data-l=""></div><div data-l="    let value = 0;"></div><div data-l="    some_closure(&amp;value)"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Normally you can specify the lifetime of the parameter to our closure.</span>通常、クロージャに対するパラメータの有効期間を指定することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We could annotate it on the function declaration:</span>関数宣言に注釈を付けることができます：</span> </p><br><div data-lang=rust,ignore><div data-l="fn call_with_ref&lt;'a, F&gt;(some_closure:F) -&gt; i32"></div><div data-l="    where F: Fn(&amp;'a i32) -&gt; i32 {"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, this presents a problem in our case.</span>しかしながら、これは我々の場合に問題を提示する。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When a function has an explicit lifetime parameter, that lifetime must be at least as long as the <i>entire</i> call to that function.</span>ある関数に明示的な存続時間パラメータがある場合、その存続時間は、少なくともその関数への呼び出し<i>全体の</i>長さと同じでなければなりません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The borrow checker will complain that <code>value</code> doesn&#39;t live long enough, because it is only in scope after its declaration inside the function body.</span>貸借チェッカーは、関数本体内で宣言された後にのみスコープ内にあるため、 <code>value</code>が十分長く存続しないと不満を<code>value</code> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">What we need is a closure that can borrow its argument only for its own invocation scope, not for the outer function&#39;s scope.</span>私たちが必要とするのは、外部関数のスコープではなく、独自の呼び出しスコープに対してのみ引数を借りることができるクロージャです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In order to say that, we can use Higher-Ranked Trait Bounds with the <code>for&lt;...&gt;</code> syntax:</span>それを言うには、 <code>for&lt;...&gt;</code>構文でHigher-Rank Trait Boundsを使うことができます：</span> </p><br><div data-lang=ignore><div data-l="fn call_with_ref&lt;F&gt;(some_closure:F) -&gt; i32"></div><div data-l="    where F: for&lt;'a&gt; Fn(&amp;'a i32) -&gt; i32 {"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This lets the Rust compiler find the minimum lifetime to invoke our closure and satisfy the borrow checker&#39;s rules.</span>これにより、Rustコンパイラは、クロージャを呼び出し、借用チェッカーのルールを満たすための最小有効期間を見つけることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Our function then compiles and executes as we expect.</span>私たちの機能は、コンパイルし、期待通りに実行します。</span> </p><br><div data-lang=rust><div data-l="fn call_with_ref&lt;F&gt;(some_closure:F) -&gt; i32"></div><div data-l="    where F: for&lt;'a&gt; Fn(&amp;'a i32) -&gt; i32 {"></div><div data-l=""></div><div data-l="    let value = 0;"></div><div data-l="    some_closure(&amp;value)"></div><div data-l=}></div></div><br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Function pointers and closures</span>関数ポインタとクロージャ</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A function pointer is kind of like a closure that has no environment.</span>関数ポインタは、環境を持たないクロージャのようなものです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As such, you can pass a function pointer to any function expecting a closure argument, and it will work:</span>したがって、クロージャ引数を期待する関数に関数ポインタを渡すことができます。</span> </p><br><div data-lang=rust><div data-l="fn call_with_one(some_closure: &amp;Fn(i32) -&gt; i32) -&gt; i32 {"></div><div data-l="    some_closure(1)"></div><div data-l=}></div><div data-l=""></div><div data-l="fn add_one(i: i32) -&gt; i32 {"></div><div data-l="    i + 1"></div><div data-l=}></div><div data-l=""></div><div data-l="let f = add_one;"></div><div data-l=""></div><div data-l="let answer = call_with_one(&amp;f);"></div><div data-l=""></div><div data-l="assert_eq!(2, answer);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this example, we don&#39;t strictly need the intermediate variable <code>f</code> , the name of the function works just fine too:</span>この例では、厳密に中間変数<code>f</code>必要とせず、関数の名前もうまくいきます：</span> </p><br><div data-lang=rust,ignore><div data-l="let answer = call_with_one(&amp;add_one);"></div></div><br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Returning closures</span>クロージャを返す</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It&#39;s very common for functional-style code to return closures in various situations.</span>ファンクションスタイルのコードでは、さまざまな状況でクロージャを返すのが一般的です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you try to return a closure, you may run into an error.</span>クロージャを返そうとすると、エラーが発生する可能性があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">At first, it may seem strange, but we&#39;ll figure it out.</span>最初は奇妙に見えるかもしれませんが、わかります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here&#39;s how you&#39;d probably try to return a closure from a function:</span>おそらく、関数からクロージャを返そうとすると、次のようになります。</span> </p><br><div data-lang=rust,ignore><div data-l="fn factory() -&gt; (Fn(i32) -&gt; i32) {"></div><div data-l="    let num = 5;"></div><div data-l=""></div><div data-l="    |x| x + num"></div><div data-l=}></div><div data-l=""></div><div data-l="let f = factory();"></div><div data-l=""></div><div data-l="let answer = f(1);"></div><div data-l="assert_eq!(6, answer);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This gives us these long, related errors:</span>これにより、これらの長くて関連したエラーが発生します。</span> </p><br><div data-lang=text><div data-l="error: the trait bound `core::ops::Fn(i32) -&gt; i32 : core::marker::Sized` is not satisfied [E0277]"></div><div data-l="fn factory() -&gt; (Fn(i32) -&gt; i32) {"></div><div data-l="                ^~~~~~~~~~~~~~~~"></div><div data-l="note: `core::ops::Fn(i32) -&gt; i32` does not have a constant size known at compile-time"></div><div data-l="fn factory() -&gt; (Fn(i32) -&gt; i32) {"></div><div data-l="                ^~~~~~~~~~~~~~~~"></div><div data-l="error: the trait bound `core::ops::Fn(i32) -&gt; i32 : core::marker::Sized` is not satisfied [E0277]"></div><div data-l="let f = factory();"></div><div data-l="    ^"></div><div data-l="note: `core::ops::Fn(i32) -&gt; i32` does not have a constant size known at compile-time"></div><div data-l="let f = factory();"></div><div data-l="    ^"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In order to return something from a function, Rust needs to know what size the return type is.</span>関数から何かを返すために、Rustは戻り値の型がどれくらいのサイズかを知る必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But since <code>Fn</code> is a trait, it could be various things of various sizes: many different types can implement <code>Fn</code> .</span>しかし、 <code>Fn</code>は特性であるため、さまざまなサイズのさまざまなものがあり<code>Fn</code> 。多くの異なるタイプが<code>Fn</code>を実装でき<code>Fn</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">An easy way to give something a size is to take a reference to it, as references have a known size.</span>参照用のサイズが既知であるため、サイズを指定する簡単な方法は、参照を行うことです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So we&#39;d write this:</span>だから我々はこれを書くだろう：</span> </p><br><div data-lang=rust,ignore><div data-l="fn factory() -&gt; &amp;(Fn(i32) -&gt; i32) {"></div><div data-l="    let num = 5;"></div><div data-l=""></div><div data-l="    |x| x + num"></div><div data-l=}></div><div data-l=""></div><div data-l="let f = factory();"></div><div data-l=""></div><div data-l="let answer = f(1);"></div><div data-l="assert_eq!(6, answer);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But we get another error:</span>しかし、別のエラーが発生します。</span> </p><br><div data-lang=text><div data-l="error: missing lifetime specifier [E0106]"></div><div data-l="fn factory() -&gt; &amp;(Fn(i32) -&gt; i32) {"></div><div data-l="                ^~~~~~~~~~~~~~~~~"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Right.</span>右。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because we have a reference, we need to give it a lifetime.</span>私たちは参照を持っているので、それを生涯与える必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But our <code>factory()</code> function takes no arguments, so <a class=notranslate href=#2lifetimes.html#lifetime-elision>elision</a> doesn&#39;t kick in here.</span>しかし、私たちの<code>factory()</code>関数は引数を取らないので、 <a class=notranslate href=#2lifetimes.html#lifetime-elision>elision</a>はここでは<a class=notranslate href=#2lifetimes.html#lifetime-elision>elision</a>しません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then what choices do we have?</span>それから、どんな選択肢がありますか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Try <code>&#39;static</code> :</span> <code>&#39;static</code>試してください：</span> </p><br><div data-lang=rust,ignore><div data-l="fn factory() -&gt; &amp;'static (Fn(i32) -&gt; i32) {"></div><div data-l="    let num = 5;"></div><div data-l=""></div><div data-l="    |x| x + num"></div><div data-l=}></div><div data-l=""></div><div data-l="let f = factory();"></div><div data-l=""></div><div data-l="let answer = f(1);"></div><div data-l="assert_eq!(6, answer);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But we get another error:</span>しかし、別のエラーが発生します。</span> </p><br><div data-lang=text><div data-l="error: mismatched types:"></div><div data-l=" expected `&amp;'static core::ops::Fn(i32) -&gt; i32`,"></div><div data-l="    found `[closure@&lt;anon&gt;:7:9: 7:20]`"></div><div data-l="(expected &amp;-ptr,"></div><div data-l="    found closure) [E0308]"></div><div data-l="         |x| x + num"></div><div data-l="         ^~~~~~~~~~~"></div><div data-l=""></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This error is letting us know that we don&#39;t have a <code>&amp;&#39;static Fn(i32) -&gt; i32</code> , we have a <code>[closure@&lt;anon&gt;:7:9: 7:20]</code> .</span>このエラーは、私たちに<code>&amp;&#39;static Fn(i32) -&gt; i32</code>がないことを知らせるものです。私たちは<code>[closure@&lt;anon&gt;:7:9: 7:20]</code>を持っています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Wait, what?</span>待って、何？</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because each closure generates its own environment <code>struct</code> and implementation of <code>Fn</code> and friends, these types are anonymous.</span>各クロージャは<code>Fn</code>やフレンドの独自の環境<code>struct</code>と実装を生成するため、これらのタイプは匿名です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">They exist solely for this closure.</span>彼らはこの閉鎖のためだけに存在します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So Rust shows them as <code>closure@&lt;anon&gt;</code> , rather than some autogenerated name.</span>そこで、Rustは自動生成された名前ではなく、 <code>closure@&lt;anon&gt;</code>として表示します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The error also points out that the return type is expected to be a reference, but what we are trying to return is not.</span>このエラーは、戻り値の型が参照であると予想されていることも指摘していますが、返す値は返されません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Further, we cannot directly assign a <code>&#39;static</code> lifetime to an object.</span>さらに、オブジェクトに<code>&#39;static</code>寿命を直接割り当てることはできません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So we&#39;ll take a different approach and return a &#39;trait object&#39; by <code>Box</code> ing up the <code>Fn</code> .</span>だから私たちは<code>Fn</code> <code>Box</code>使って別のアプローチを取って &#39;trait object&#39;を返し<code>Fn</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This <s>almost</s> works:</span>これは<s>ほとんど</s>動作します：</span> </p><br><div data-lang=rust,ignore><div data-l="fn factory() -&gt; Box&lt;Fn(i32) -&gt; i32&gt; {"></div><div data-l="    let num = 5;"></div><div data-l=""></div><div data-l="    Box::new(|x| x + num)"></div><div data-l=}></div><div data-l=""></div><div data-l="let f = factory();"></div><div data-l=""></div><div data-l="let answer = f(1);"></div><div data-l="assert_eq!(6, answer);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There&#39;s just one last problem:</span>最後の問題は1つだけです：</span> </p><br><div data-lang=text><div data-l="error: closure may outlive the current function, but it borrows `num`,"></div><div data-l="which is owned by the current function [E0373]"></div><div data-l="Box::new(|x| x + num)"></div><div data-l="         ^~~~~~~~~~~"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Well, as we discussed before, closures borrow their environment.</span>さて、前に議論したように、閉鎖は環境を借りる。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">And in this case, our environment is based on a stack-allocated <code>5</code> , the <code>num</code> variable binding.</span>この場合、私たちの環境は、変数<code>num</code>バインドされたスタック割り当て<code>5</code>に基づいています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So the borrow has a lifetime of the stack frame.</span>したがって、借用にはスタックフレームの寿命があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So if we returned this closure, the function call would be over, the stack frame would go away, and our closure is capturing an environment of garbage memory!</span>したがって、このクロージャを返すと、関数呼び出しが終了し、スタックフレームがなくなり、クロージャがゴミメモリの環境をキャプチャしています！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">With one last fix, we can make this work:</span> 1つの最後の修正で、この作業を行うことができます：</span> </p><br><div data-lang=rust><div data-l="fn factory() -&gt; Box&lt;Fn(i32) -&gt; i32&gt; {"></div><div data-l="    let num = 5;"></div><div data-l=""></div><div data-l="    Box::new(move |x| x + num)"></div><div data-l=}></div><div data-l=""></div><div data-l="let f = factory();"></div><div data-l=""></div><div data-l="let answer = f(1);"></div><div data-l="assert_eq!(6, answer);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">By making the inner closure a <code>move Fn</code> , we create a new stack frame for our closure.</span>内側のクロージャを<code>move Fn</code>にすることで、クロージャ用の新しいスタックフレームを作成します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">By <code>Box</code> ing it up, we&#39;ve given it a known size, allowing it to escape our stack frame.</span> <code>Box</code>アップすることで、スタックフレームから脱出できるように、既知のサイズを与えました。</span> </p><script>_addload(function(){_setupIW('com');_csi('en','ja','closures.html');});</script>