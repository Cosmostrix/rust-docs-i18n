<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180709_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=functions.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Functions</span>機能</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Every Rust program has at least one function, the <code>main</code> function:</span>すべてのRustプログラムには、少なくとも1つの関数<code>main</code>関数があります。</span> </p><br><div data-lang=rust><div data-l="fn main() {"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is the simplest possible function declaration.</span>これは、可能な限り単純な関数宣言です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As we mentioned before, <code>fn</code> says &#39;this is a function&#39;, followed by the name, some parentheses because this function takes no arguments, and then some curly braces to indicate the body.</span>前に述べたように、 <code>fn</code>は &#39;this is a function&#39;と名前の後にいくつかのカッコがあり、この関数は引数をとりません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here&#39;s a function named <code>foo</code> :</span> <code>foo</code>という名前の関数があります：</span> </p><br><div data-lang=rust><div data-l="fn foo() {"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So, what about taking arguments?</span>それで、議論をするのはどうですか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here&#39;s a function that prints a number:</span>数値を出力する関数は次のとおりです。</span> </p><br><div data-lang=rust><div data-l="fn print_number(x: i32) {"></div><div data-l="    println!(&quot;x is: {}&quot;, x);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here&#39;s a complete program that uses <code>print_number</code> :</span> <code>print_number</code>を使用する完全なプログラムを<code>print_number</code>ます。</span> </p><br><div data-lang=rust><div data-l="fn main() {"></div><div data-l="    print_number(5);"></div><div data-l=}></div><div data-l=""></div><div data-l="fn print_number(x: i32) {"></div><div data-l="    println!(&quot;x is: {}&quot;, x);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As you can see, function arguments work very similar to <code>let</code> declarations: you add a type to the argument name, after a colon.</span>ご覧のとおり、関数の引数は<code>let</code>宣言と非常によく似ています。引数名にコロンの後に型を追加します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here&#39;s a complete program that adds two numbers together and prints them:</span>ここでは、2つの数字を一緒に追加して印刷する完全なプログラムがあります：</span> </p><br><div data-lang=rust><div data-l="fn main() {"></div><div data-l="    print_sum(5, 6);"></div><div data-l=}></div><div data-l=""></div><div data-l="fn print_sum(x: i32, y: i32) {"></div><div data-l="    println!(&quot;sum is: {}&quot;, x + y);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You separate arguments with a comma, both when you call the function, as well as when you declare it.</span>関数を呼び出すときも、宣言するときも、引数をカンマで区切ります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Unlike <code>let</code> , you <s>must</s> declare the types of function arguments.</span> <code>let</code>とは異なり、関数の引数の型を宣言する<s>必要</s>が<s>あり</s>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This does not work:</span>これは動作しません：</span> </p><br><div data-lang=rust,ignore><div data-l="fn print_sum(x, y) {"></div><div data-l="    println!(&quot;sum is: {}&quot;, x + y);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You get this error:</span>あなたはこのエラーを受け取ります：</span> </p><br><div data-lang=text><div data-l="expected one of `!`, `:`, or `@`, found `)`"></div><div data-l="fn print_sum(x, y) {"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is a deliberate design decision.</span>これは意図的な設計上の決定です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">While full-program inference is possible, languages which have it, like Haskell, often suggest that documenting your types explicitly is a best-practice.</span>フルプログラム推論が可能ですが、Haskellのように、あなたの型を明示的に文書化することがベストプラクティスであることをしばしば示唆しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We agree that forcing functions to declare types while allowing for inference inside of function bodies is a wonderful sweet spot between full inference and no inference.</span>関数本体の内部で推論を可能にしながら関数を型宣言することは、完全な推論と推論なしの間のすばらしい場所です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">What about returning a value?</span>値を返すのはどうですか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here&#39;s a function that adds one to an integer:</span> 1つを整数に追加する関数は次のとおりです。</span> </p><br><div data-lang=rust><div data-l="fn add_one(x: i32) -&gt; i32 {"></div><div data-l="    x + 1"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust functions return exactly one value, and you declare the type after an &#39;arrow&#39;, which is a dash ( <code>-</code> ) followed by a greater-than sign ( <code>&gt;</code> ).</span> Rust関数はちょうど1つの値を返し、ダッシュ（ <code>-</code> ）の後に大なり記号（ <code>&gt;</code> ）が続く &#39;矢&#39;の後に型を宣言します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The last line of a function determines what it returns.</span>関数の最後の行は、関数が返すものを決定します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You&#39;ll note the lack of a semicolon here.</span>ここでセミコロンがないことに気づくでしょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we added it in:</span>それを追加した場合：</span> </p><br><div data-lang=rust,ignore><div data-l="fn add_one(x: i32) -&gt; i32 {"></div><div data-l="    x + 1;"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We would get an error:</span>エラーが発生する：</span> </p><br><div data-lang=text><div data-l="error: not all control paths return a value"></div><div data-l="fn add_one(x: i32) -&gt; i32 {"></div><div data-l="     x + 1;"></div><div data-l=}></div><div data-l=""></div><div data-l="help: consider removing this semicolon:"></div><div data-l="     x + 1;"></div><div data-l="          ^"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This reveals two interesting things about Rust: it is an expression-based language, and semicolons are different from semicolons in other &#39;curly brace and semicolon&#39;-based languages.</span>これは、Rustに関する2つの面白いことを示しています。表現ベースの言語であり、セミコロンはセミコロンとは異なる中括弧とセミコロンの言語では異なります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These two things are related.</span>これらの2つのことは関連しています。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Expressions vs. Statements</span>式とステートメント</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust is primarily an expression-based language.</span>錆は、主に表現ベースの言語です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There are only two kinds of statements, and everything else is an expression.</span>ステートメントは2種類しかありません。その他はすべて式です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So what&#39;s the difference?</span>違いは何ですか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Expressions return a value, and statements do not.</span>式は値を返し、ステートメントは値を返しません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That&#39;s why we end up with &#39;not all control paths return a value&#39; here: the statement <code>x + 1;</code></span>そのため、ここでは、すべての制御パスが値を返すわけではありません<code>x + 1;</code>ステートメント<code>x + 1;</code></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">doesn&#39;t return a value.</span>値を返しません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There are two kinds of statements in Rust: &#39;declaration statements&#39; and &#39;expression statements&#39;.</span> Rustには、「宣言文」と「表現文」の2種類の文があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Everything else is an expression.</span>他のすべては表現です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s talk about declaration statements first.</span>最初に宣言文について説明しましょう。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In some languages, variable bindings can be written as expressions, not statements.</span>言語によっては、変数バインディングを文ではなく式として書くことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Like Ruby:</span> Rubyのように：</span> </p><br><div data-lang=ruby><div data-l="x = y = 5"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In Rust, however, using <code>let</code> to introduce a binding is <s>not</s> an expression.</span>しかし、Rustでは<code>let</code>を使ってバインディングを導入することは表現ではあり<s>ません</s> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The following will produce a compile-time error:</span>以下は、コンパイル時エラーを生成します：</span> </p><br><div data-lang=rust,ignore><div data-l="#//let x = (let y = 5); // Expected identifier, found keyword `let`."></div><div data-l="let x = (let y = 5); // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Expected identifier, found keyword <code>let</code> .</span>予想される識別子、found keyword <code>let</code> 。</span> </div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The compiler is telling us here that it was expecting to see the beginning of an expression, and a <code>let</code> can only begin a statement, not an expression.</span>コンパイラは、式の始まりを見て期待していたことを、ここで私たちに語っている、と<code>let</code>唯一の文ではなく、式を開始することができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that assigning to an already-bound variable (eg <code>y = 5</code> ) is still an expression, although its value is not particularly useful.</span>既にバインドされた変数（例えば<code>y = 5</code> ）に代入することはまだ式であるが、その値は特に有用ではないことに留意されたい。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Unlike other languages where an assignment evaluates to the assigned value (eg <code>5</code> in the previous example), in Rust the value of an assignment is an empty tuple <code>()</code> because the assigned value can have <a href=#2ownership.html>only one owner</a> , and any other returned value would be too surprising:</span>代入が割り当てられた値（たとえば前の例では<code>5</code>に評価される他の言語とは異なり、代入の値は空のタプル<code>()</code>です。割り当てられた値に<a href=#2ownership.html>所有者</a>が<a href=#2ownership.html>1人しかなく</a> 、他の戻り値はあまりにも驚くべきこと：</span> </p><br><div data-lang=rust><div data-l="let mut y = 5;"></div><div data-l=""></div><div data-l="#//let x = (y = 6);  // `x` has the value `()`, not `6`."></div><div data-l="let x = (y = 6);  // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>x</code> has the value <code>()</code> , not <code>6</code> .</span> <code>x</code>は<code>6</code>ではなく、値<code>()</code>持ちます。</span> </div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The second kind of statement in Rust is the <i>expression statement</i> .</span> Rustの2番目の種類の文は<i>式文</i>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Its purpose is to turn any expression into a statement.</span>その目的は、任意の式をステートメントに変換することです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In practical terms, Rust&#39;s grammar expects statements to follow other statements.</span>実際の言葉で言えば、Rustの文法は、ステートメントが他のステートメントに従うことを期待しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This means that you use semicolons to separate expressions from each other.</span>つまり、セミコロンを使用して式を互いに区切ります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This means that Rust looks a lot like most other languages that require you to use semicolons at the end of every line, and you will see semicolons at the end of almost every line of Rust code you see.</span>これは、Rustは、すべての行の最後にセミコロンを使用する必要がある他の多くの言語とよく似ていることを意味し、Rustコードのほぼすべての行の最後にセミコロンが表示されます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">What is this exception that makes us say &quot;almost&quot;?</span>この例外は、私たちを「ほとんど」と言いますか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You saw it already, in this code:</span>あなたはすでにこのコードでそれを見た：</span> </p><br><div data-lang=rust><div data-l="fn add_one(x: i32) -&gt; i32 {"></div><div data-l="    x + 1"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Our function claims to return an <code>i32</code> , but with a semicolon, it would return <code>()</code> instead.</span>私たちの関数は<code>i32</code>を返すと主張していますが、セミコロンでは代わりに<code>()</code>が返されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust realizes this probably isn&#39;t what we want, and suggests removing the semicolon in the error we saw before.</span> Rustはこれがおそらく私たちが望むものではないことを認識し、前に見たエラーのセミコロンを削除することを提案します。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Early returns</span>早期返品</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But what about early returns?</span>しかし早期返品はどうですか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust does have a keyword for that, <code>return</code> :</span>錆は、そのためのキーワードを持っている、 <code>return</code> ：</span> </p><br><div data-lang=rust><div data-l="fn foo(x: i32) -&gt; i32 {"></div><div data-l="    return x;"></div><div data-l=""></div><div data-l="#    // We never run this code!"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We never run this code!</span>私たちは決してこのコードを実行しません！</span> </div><div data-l="    x + 1"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Using a <code>return</code> as the last line of a function works, but is considered poor style:</span>関数の最後の行として<code>return</code>を使用するが、貧弱なスタイルとみなされます：</span> </p><br><div data-lang=rust><div data-l="fn foo(x: i32) -&gt; i32 {"></div><div data-l="    return x + 1;"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The previous definition without <code>return</code> may look a bit strange if you haven&#39;t worked in an expression-based language before, but it becomes intuitive over time.</span>これまでの表現ベースの言語で作業していない場合、前の定義は<code>return</code>なしには少し奇妙に見えるかもしれませんが、時間の経過と共に直感的になります。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Diverging functions</span>機能の分散</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust has some special syntax for &#39;diverging functions&#39;, which are functions that do not return:</span> Rustには、 &#39;diverging functions&#39;のための特別な構文があります。これは返さない関数です：</span> </p><br><div data-lang=rust><div data-l="fn diverges() -&gt; ! {"></div><div data-l="    panic!(&quot;This function never returns!&quot;);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>panic€</code> is a macro, similar to <code>println€()</code> that we&#39;ve already seen.</span> <code>panic€</code>はすでに見た<code>println€()</code>と同様のマクロです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Unlike <code>println€()</code> , <code>panic€()</code> causes the current thread of execution to crash with the given message.</span> <code>println€()</code>とは異なり、 <code>panic€()</code>は現在の実行スレッドを指定のメッセージでクラッシュさせます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because this function will cause a crash, it will never return, and so it has the type &#39; <code>€</code> &#39;, which is read &#39;diverges&#39;.</span>この関数はクラッシュを引き起こすので、それは決して戻ってこないので、 &#39; <code>€</code> &#39;は &#39;diverges&#39;と読み込まれます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you add a main function that calls <code>diverges()</code> and run it, you&#39;ll get some output that looks like this:</span> <code>diverges()</code>を呼び出すmain関数を追加して実行すると、次のような出力が得られます：</span> </p><br><div data-lang=text><div data-l="thread ‘main’ panicked at ‘This function never returns!’, hello.rs:2"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you want more information, you can get a backtrace by setting the <code>RUST_BACKTRACE</code> environment variable:</span>さらに詳しい情報が必要な場合は、 <code>RUST_BACKTRACE</code>環境変数を設定してバックトレースを取得することができます。</span> </p><br><div data-lang=text><div data-l="$ RUST_BACKTRACE=1 ./diverges"></div><div data-l="thread 'main' panicked at 'This function never returns!', hello.rs:2"></div><div data-l="Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace."></div><div data-l="stack backtrace:"></div><div data-l="  hello::diverges"></div><div data-l="        at ./hello.rs:2"></div><div data-l="  hello::main"></div><div data-l="        at ./hello.rs:6"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you want the complete backtrace and filenames:</span>完全なバックトレースとファイル名が必要な場合：</span> </p><br><div data-lang=text><div data-l="$ RUST_BACKTRACE=full ./diverges"></div><div data-l="thread 'main' panicked at 'This function never returns!', hello.rs:2"></div><div data-l="stack backtrace:"></div><div data-l="   1:     0x7f402773a829 - sys::backtrace::write::h0942de78b6c02817K8r"></div><div data-l="   2:     0x7f402773d7fc - panicking::on_panic::h3f23f9d0b5f4c91bu9w"></div><div data-l="   3:     0x7f402773960e - rt::unwind::begin_unwind_inner::h2844b8c5e81e79558Bw"></div><div data-l="   4:     0x7f4027738893 - rt::unwind::begin_unwind::h4375279447423903650"></div><div data-l="   5:     0x7f4027738809 - diverges::h2266b4c4b850236beaa"></div><div data-l="   6:     0x7f40277389e5 - main::h19bb1149c2f00ecfBaa"></div><div data-l="   7:     0x7f402773f514 - rt::unwind::try::try_fn::h13186883479104382231"></div><div data-l="   8:     0x7f402773d1d8 - __rust_try"></div><div data-l="   9:     0x7f402773f201 - rt::lang_start::ha172a3ce74bb453aK5w"></div><div data-l="  10:     0x7f4027738a19 - main"></div><div data-l="  11:     0x7f402694ab44 - __libc_start_main"></div><div data-l="  12:     0x7f40277386c8 - &lt;unknown&gt;"></div><div data-l="  13:                0x0 - &lt;unknown&gt;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you need to override an already set <code>RUST_BACKTRACE</code> , in cases when you cannot just unset the variable, then set it to <code>0</code> to avoid getting a backtrace.</span>すでに設定されている<code>RUST_BACKTRACE</code>を上書きする必要がある場合は、変数を設定解除できない場合はバックトレースを取得しないように<code>0</code>に設定します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Any other value (even no value at all) turns on backtrace.</span>その他の値（値がまったくない場合）は、バックトレースをオンにします。</span> </p><br><div data-lang=text><div data-l="$ export RUST_BACKTRACE=1"></div><div data-l=...></div><div data-l="$ RUST_BACKTRACE=0 ./diverges "></div><div data-l="thread 'main' panicked at 'This function never returns!', hello.rs:2"></div><div data-l="note: Run with `RUST_BACKTRACE=1` for a backtrace."></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>RUST_BACKTRACE</code> also works with Cargo&#39;s <code>run</code> command:</span> <code>RUST_BACKTRACE</code>は、Cargoの<code>run</code>コマンドでも動作し<code>run</code> 。</span> </p><br><div data-lang=text><div data-l="$ RUST_BACKTRACE=full cargo run"></div><div data-l="     Running `target/debug/diverges`"></div><div data-l="thread 'main' panicked at 'This function never returns!', hello.rs:2"></div><div data-l="stack backtrace:"></div><div data-l="   1:     0x7f402773a829 - sys::backtrace::write::h0942de78b6c02817K8r"></div><div data-l="   2:     0x7f402773d7fc - panicking::on_panic::h3f23f9d0b5f4c91bu9w"></div><div data-l="   3:     0x7f402773960e - rt::unwind::begin_unwind_inner::h2844b8c5e81e79558Bw"></div><div data-l="   4:     0x7f4027738893 - rt::unwind::begin_unwind::h4375279447423903650"></div><div data-l="   5:     0x7f4027738809 - diverges::h2266b4c4b850236beaa"></div><div data-l="   6:     0x7f40277389e5 - main::h19bb1149c2f00ecfBaa"></div><div data-l="   7:     0x7f402773f514 - rt::unwind::try::try_fn::h13186883479104382231"></div><div data-l="   8:     0x7f402773d1d8 - __rust_try"></div><div data-l="   9:     0x7f402773f201 - rt::lang_start::ha172a3ce74bb453aK5w"></div><div data-l="  10:     0x7f4027738a19 - main"></div><div data-l="  11:     0x7f402694ab44 - __libc_start_main"></div><div data-l="  12:     0x7f40277386c8 - &lt;unknown&gt;"></div><div data-l="  13:                0x0 - &lt;unknown&gt;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A diverging function can be used as any type:</span>分岐関数は、任意の型として使用できます。</span> </p><br><div data-lang=rust,should_panic><div data-l="# fn diverges() -&gt; ! {"></div><div data-l="#    panic!(&quot;This function never returns!&quot;);"></div><div data-l="# }"></div><div data-l="let x: i32 = diverges();"></div><div data-l="let x: String = diverges();"></div></div><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Function pointers</span>関数ポインタ</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can also create variable bindings which point to functions:</span>関数を指す変数バインディングを作成することもできます。</span> </p><br><div data-lang=rust><div data-l="let f: fn(i32) -&gt; i32;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>f</code> is a variable binding which points to a function that takes an <code>i32</code> as an argument and returns an <code>i32</code> .</span> <code>f</code>かかる機能を指す結合可変である<code>i32</code>引数として戻る<code>i32</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example:</span>例えば：</span> </p><br><div data-lang=rust><div data-l="fn plus_one(i: i32) -&gt; i32 {"></div><div data-l="    i + 1"></div><div data-l=}></div><div data-l=""></div><div data-l="#// Without type inference:"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Without type inference:</span>型推論なし：</span> </div><div data-l="let f: fn(i32) -&gt; i32 = plus_one;"></div><div data-l=""></div><div data-l="#// With type inference:"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">With type inference:</span>型推論の場合：</span> </div><div data-l="let f = plus_one;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can then use <code>f</code> to call the function:</span> <code>f</code>を使って<code>f</code>を呼び出すことができます：</span> </p><br><div data-lang=rust><div data-l="# fn plus_one(i: i32) -&gt; i32 { i + 1 }"></div><div data-l="# let f = plus_one;"></div><div data-l="let six = f(5);"></div></div><script>_addload(function(){_setupIW('com');_csi('en','ja','functions.html');});</script>