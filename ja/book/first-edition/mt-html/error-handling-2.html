<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180709_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=error-handling-2.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Error</code> trait</span> <code>Error</code>特性</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Error</code> trait is <a href=#2../../std/error/trait.Error.html>defined in the standard library</a> :</span> <code>Error</code>特性は<a href=#2../../std/error/trait.Error.html>標準ライブラリで定義されています</a> ：</span> </p><br><div data-lang=rust><div data-l="use std::fmt::{Debug, Display};"></div><div data-l=""></div><div data-l="trait Error: Debug + Display {"></div><div data-l="#//  /// The lower level cause of this error, if any."></div><div data-l="  /// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The lower level cause of this error, if any.</span>このエラーが発生した場合は、その原因を示します。</span> </div><div data-l="  fn cause(&amp;self) -&gt; Option&lt;&amp;Error&gt; { None }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This trait is super generic because it is meant to be implemented for <i>all</i> types that represent errors.</span>この特性は、エラーを表す<i>すべての</i>タイプに対して実装されるため、スーパージェネリックです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This will prove useful for writing composable code as we&#39;ll see later.</span>これは、後で見るように、合成可能なコードを記述するのに便利です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Otherwise, the trait allows you to do at least the following things:</span>それ以外の場合は、少なくとも以下のことを行うことができます。</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Obtain a <code>Debug</code> representation of the error.</span>エラーの<code>Debug</code>表現を取得します。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Obtain a user-facing <code>Display</code> representation of the error.</span>エラーのユーザー側の<code>Display</code>表現を取得します。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Inspect the causal chain of an error, if one exists (via the <code>cause</code> method).</span>エラーの因果連鎖が存在する場合（ <code>cause</code>メソッドを使用して）、因果連鎖を検査します。</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The first two are a result of <code>Error</code> requiring impls for both <code>Debug</code> and <code>Display</code> .</span>最初の2つは、 <code>Debug</code>と<code>Display</code>両方にimplを必要とする<code>Error</code>結果です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The latter two are from the two methods defined on <code>Error</code> .</span>後者の2つは<code>Error</code>定義された2つのメソッドからのものです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The power of <code>Error</code> comes from the fact that all error types impl <code>Error</code> , which means errors can be existentially quantified as a <a href=#2trait-objects.html>trait object</a> .</span> <code>Error</code>の威力は、すべてのエラータイプが<code>Error</code>になるという事実から来<a href=#2trait-objects.html>ます</a> 。これは、エラーが現実的に<a href=#2trait-objects.html>特性オブジェクト</a>として定量化できることを意味し<a href=#2trait-objects.html>ます</a> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This manifests as either <code>Box&lt;Error&gt;</code> or <code>&amp;Error</code> .</span>これは、 <code>Box&lt;Error&gt;</code>または<code>&amp;Error</code>いずれかとして現れます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Indeed, the <code>cause</code> method returns an <code>&amp;Error</code> , which is itself a trait object.</span>実際、 <code>cause</code>メソッドは<code>&amp;Error</code>返します。これはそれ自体が特性オブジェクトです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll revisit the <code>Error</code> trait&#39;s utility as a trait object later.</span> <code>Error</code> traitのユーティリティを後で特性オブジェクトとして再訪します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For now, it suffices to show an example implementing the <code>Error</code> trait.</span>今のところ、 <code>Error</code>特性を実装する例を示すだけで十分です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s use the error type we defined in the <a href=#2#defining-your-own-error-type>previous section</a> :</span> <a href=#2#defining-your-own-error-type>前のセクションで</a>定義したエラータイプを使用しましょう：</span> </p><br><div data-lang=rust><div data-l="use std::io;"></div><div data-l="use std::num;"></div><div data-l=""></div><div data-l="#// We derive `Debug` because all types should probably derive `Debug`."></div><div data-l="#// This gives us a reasonable human-readable description of `CliError` values."></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We derive <code>Debug</code> because all types should probably derive <code>Debug</code> .</span>私たちは、派生<code>Debug</code>すべての種類は、おそらく派生する必要があるため<code>Debug</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This gives us a reasonable human-readable description of <code>CliError</code> values.</span>これは<code>CliError</code>値を人が読めるように説明して<code>CliError</code>ます。</span> </div><div data-l=#[derive(Debug)]></div><div data-l="enum CliError {"></div><div data-l="    Io(io::Error),"></div><div data-l="    Parse(num::ParseIntError),"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This particular error type represents the possibility of two types of errors occurring: an error dealing with I/O or an error converting a string to a number.</span>この特定のエラータイプは、I / Oを処理するエラーまたは文字列を数値に変換するエラーの2種類のエラーが発生する可能性を表します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The error could represent as many error types as you want by adding new variants to the <code>enum</code> definition.</span>このエラーは、新しいバリアントを<code>enum</code>定義に追加することで、必要な数のエラータイプを表現できます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Implementing <code>Error</code> is pretty straight-forward.</span>実装<code>Error</code>はかなり簡単です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It&#39;s mostly going to be a lot explicit case analysis.</span>ほとんどの場合、明示的なケース分析が行われます。</span> </p><br><div data-lang=rust,ignore><div data-l="use std::error;"></div><div data-l="use std::fmt;"></div><div data-l=""></div><div data-l="impl fmt::Display for CliError {"></div><div data-l="    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {"></div><div data-l="        match *self {"></div><div data-l="#            // Both underlying errors already impl `Display`, so we defer to"></div><div data-l="#            // their implementations."></div><div data-l="            // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Both underlying errors already impl <code>Display</code> , so we defer to their implementations.</span>両方の根底にあるエラーは既に<code>Display</code>を暗示しているので、実装に遅れをとっています。</span> </div><div data-l="            CliError::Io(ref err) =&gt; write!(f, &quot;IO error: {}&quot;, err),"></div><div data-l="            CliError::Parse(ref err) =&gt; write!(f, &quot;Parse error: {}&quot;, err),"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="impl error::Error for CliError {"></div><div data-l="    fn cause(&amp;self) -&gt; Option&lt;&amp;error::Error&gt; {"></div><div data-l="        match *self {"></div><div data-l="#            // N.B. Both of these implicitly cast `err` from their concrete"></div><div data-l="#            // types (either `&amp;io::Error` or `&amp;num::ParseIntError`)"></div><div data-l="#            // to a trait object `&amp;Error`. This works because both error types"></div><div data-l="#            // implement `Error`."></div><div data-l="            // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">NB Both of these implicitly cast <code>err</code> from their concrete types (either <code>&amp;io::Error</code> or <code>&amp;num::ParseIntError</code> ) to a trait object <code>&amp;Error</code> .</span> NBこれらの暗黙的キャストの両方<code>err</code>その具体的な種類から（どちらか<code>&amp;io::Error</code>または<code>&amp;num::ParseIntError</code>形質オブジェクトへの） <code>&amp;Error</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This works because both error types implement <code>Error</code> .</span>これは両方のエラータイプが<code>Error</code>実装しているために機能します。</span> </div><div data-l="            CliError::Io(ref err) =&gt; Some(err),"></div><div data-l="            CliError::Parse(ref err) =&gt; Some(err),"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We note that this is a very typical implementation of <code>Error</code> : match on your different error types and satisfy the contracts defined for <code>cause</code> .</span>これは非常に典型的な<code>Error</code> ：matchの実装であり、さまざまな種類のエラーに対応し、 <code>cause</code>に対して定義されたコントラクトを満たしてい<code>cause</code> 。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>From</code> trait</span> <code>From</code>特性</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>std::convert::From</code> trait is <a href=#2../../std/convert/trait.From.html>defined in the standard library</a> :</span> <code>std::convert::From</code> traitは<a href=#2../../std/convert/trait.From.html>標準ライブラリで定義されています</a> ：</span> </p><br><p><span id=code-from-def></span></p><br><div data-lang=rust><div data-l="trait From&lt;T&gt; {"></div><div data-l="    fn from(T) -&gt; Self;"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Deliciously simple, yes?</span>おいしいシンプルな、はい？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>From</code> is very useful because it gives us a generic way to talk about conversion <i>from</i> a particular type <code>T</code> to some other type (in this case, “some other type” is the subject of the impl, or <code>Self</code> ).</span>それは私たちに、特定の型<i>から</i>の変換について話をする汎用的な方法与えるので、非常に便利である<code>T</code> （この場合は、「他のいくつかのタイプが」IMPL、またはの対象である他のいくつかのタイプに<code>Self</code> ）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The crux of <code>From</code> is the <a href=#2../../std/convert/trait.From.html>set of implementations provided by the standard library</a> .</span> <code>From</code>の要点は<a href=#2../../std/convert/trait.From.html>、標準ライブラリによって提供される一連の実装</a>です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here are a few simple examples demonstrating how <code>From</code> works:</span> <code>From</code>仕組みを示す簡単な例がいくつかあります：</span> </p><br><div data-lang=rust><div data-l="let string: String = From::from(&quot;foo&quot;);"></div><div data-l="let bytes: Vec&lt;u8&gt; = From::from(&quot;foo&quot;);"></div><div data-l="let cow: ::std::borrow::Cow&lt;str&gt; = From::from(&quot;foo&quot;);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">OK, so <code>From</code> is useful for converting between strings.</span> OK、 <code>From</code>は文字列間の変換に便利です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But what about errors?</span>しかし、エラーはどうですか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It turns out, there is one critical impl:</span>それは、1つの重要なインプリケーションがあることが判明しました。</span> </p><br><div data-lang=rust,ignore><div data-l="impl&lt;'a, E: Error + 'a&gt; From&lt;E&gt; for Box&lt;Error + 'a&gt;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This impl says that for <i>any</i> type that impls <code>Error</code> , we can convert it to a trait object <code>Box&lt;Error&gt;</code> .</span>これは、 <code>Error</code>を意味する<i>任意の</i>型に対して、それを特性オブジェクト<code>Box&lt;Error&gt;</code>変換できることを意味します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This may not seem terribly surprising, but it is useful in a generic context.</span>これはひどく驚くようなことではないかもしれませんが、一般的な文脈では役に立ちます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Remember the two errors we were dealing with previously?</span>以前に扱っていた2つのエラーを覚えていますか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Specifically, <code>io::Error</code> and <code>num::ParseIntError</code> .</span>具体的には、 <code>io::Error</code>と<code>num::ParseIntError</code>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Since both impl <code>Error</code> , they work with <code>From</code> :</span>両方ともimpl <code>Error</code>であるため、 <code>From</code>と動作します：</span> </p><br><div data-lang=rust><div data-l="use std::error::Error;"></div><div data-l="use std::fs;"></div><div data-l="use std::io;"></div><div data-l="use std::num;"></div><div data-l=""></div><div data-l="#// We have to jump through some hoops to actually get error values:"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We have to jump through some hoops to actually get error values:</span>実際にエラー値を取得するには、いくつかのフープを飛ばしなければなりません。</span> </div><div data-l="let io_err: io::Error = io::Error::last_os_error();"></div><div data-l="let parse_err: num::ParseIntError = &quot;not a number&quot;.parse::&lt;i32&gt;().unwrap_err();"></div><div data-l=""></div><div data-l="#// OK, here are the conversions:"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">OK, here are the conversions:</span>はい、コンバージョンは次のとおりです。</span> </div><div data-l="let err1: Box&lt;Error&gt; = From::from(io_err);"></div><div data-l="let err2: Box&lt;Error&gt; = From::from(parse_err);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There is a really important pattern to recognize here.</span>ここで本当に重要なパターンがあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Both <code>err1</code> and <code>err2</code> have the <i>same type</i> .</span> <code>err1</code>と<code>err2</code>が<i>同じタイプ</i>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is because they are existentially quantified types, or trait objects.</span>これは、それらが現存する定量化された型または形質オブジェクトであるためです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In particular, their underlying type is <i>erased</i> from the compiler&#39;s knowledge, so it truly sees <code>err1</code> and <code>err2</code> as exactly the same.</span>特に、その基礎となる型はコンパイラの知識から<i>消去さ</i>れるため、まったく同じものとして<code>err1</code>と<code>err2</code>真に見えます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Additionally, we constructed <code>err1</code> and <code>err2</code> using precisely the same function call: <code>From::from</code> .</span>さらに、正確に同じ関数呼び出し、 <code>From::from</code>を使用して<code>err1</code>と<code>err2</code>を構築<code>From::from</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is because <code>From::from</code> is overloaded on both its argument and its return type.</span>これは、 <code>From::from</code>がその引数とその戻り型の両方でオーバーロードされているためです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This pattern is important because it solves a problem we had earlier: it gives us a way to reliably convert errors to the same type using the same function.</span>このパターンは、以前の問題を解決するため重要です。同じ関数を使用してエラーを同じタイプに確実に変換する方法を提供します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Time to revisit an old friend;</span>古い友達を再訪する時間。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">the <code>try€</code> macro.</span> <code>try€</code>マクロ。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The real <code>try€</code> macro</span>本当の<code>try€</code>マクロ</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Previously, we presented this definition of <code>try€</code> :</span>これまで、私たちは<code>try€</code>この定義を提示しました：</span> </p><br><div data-lang=rust><div data-l="macro_rules! try {"></div><div data-l="    ($e:expr) =&gt; (match $e {"></div><div data-l="        Ok(val) =&gt; val,"></div><div data-l="        Err(err) =&gt; return Err(err),"></div><div data-l="    });"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is not its real definition.</span>これは実際の定義ではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Its real definition is <a href=#2../../std/macro.try.html>in the standard library</a> :</span>その実際の定義は<a href=#2../../std/macro.try.html>標準ライブラリにあります</a> ：</span> </p><br><p><span id=code-try-def></span></p><br><div data-lang=rust><div data-l="macro_rules! try {"></div><div data-l="    ($e:expr) =&gt; (match $e {"></div><div data-l="        Ok(val) =&gt; val,"></div><div data-l="        Err(err) =&gt; return Err(::std::convert::From::from(err)),"></div><div data-l="    });"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There&#39;s one tiny but powerful change: the error value is passed through <code>From::from</code> .</span>小さくても強力な変更が1つあります。エラー値は<code>From::from</code>渡さ<code>From::from</code>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This makes the <code>try€</code> macro much more powerful because it gives you automatic type conversion for free.</span>これにより、 <code>try€</code>マクロをより強力にすることができます。これは、自動的に型変換を行うためです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Armed with our more powerful <code>try€</code> macro, let&#39;s take a look at code we wrote previously to read a file and convert its contents to an integer:</span>より強力な<code>try€</code>マクロを用意して、ファイルを読み込んでその内容を整数に変換するために以前書いたコードを見てみましょう：</span> </p><br><div data-lang=rust><div data-l="use std::fs::File;"></div><div data-l="use std::io::Read;"></div><div data-l="use std::path::Path;"></div><div data-l=""></div><div data-l="fn file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;i32, String&gt; {"></div><div data-l="    let mut file = try!(File::open(file_path).map_err(|e| e.to_string()));"></div><div data-l="    let mut contents = String::new();"></div><div data-l="    try!(file.read_to_string(&amp;mut contents).map_err(|e| e.to_string()));"></div><div data-l="    let n = try!(contents.trim().parse::&lt;i32&gt;().map_err(|e| e.to_string()));"></div><div data-l="    Ok(2 * n)"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Earlier, we promised that we could get rid of the <code>map_err</code> calls.</span>以前は、 <code>map_err</code>呼び出しを取り除くことができると約束しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Indeed, all we have to do is pick a type that <code>From</code> works with.</span>確かに、私たちがしなければならないのは、 <code>From</code>作品を選ぶことだけです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As we saw in the previous section, <code>From</code> has an impl that lets it convert any error type into a <code>Box&lt;Error&gt;</code> :</span>前のセクションで見たように、 <code>From</code>は、あらゆるエラータイプを<code>Box&lt;Error&gt;</code>に変換するためのインプリメンテーションがあります。</span> </p><br><div data-lang=rust><div data-l="use std::error::Error;"></div><div data-l="use std::fs::File;"></div><div data-l="use std::io::Read;"></div><div data-l="use std::path::Path;"></div><div data-l=""></div><div data-l="fn file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;i32, Box&lt;Error&gt;&gt; {"></div><div data-l="    let mut file = try!(File::open(file_path));"></div><div data-l="    let mut contents = String::new();"></div><div data-l="    try!(file.read_to_string(&amp;mut contents));"></div><div data-l="    let n = try!(contents.trim().parse::&lt;i32&gt;());"></div><div data-l="    Ok(2 * n)"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We are getting very close to ideal error handling.</span>理想的なエラー処理に非常に近づいています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Our code has very little overhead as a result from error handling because the <code>try€</code> macro encapsulates three things simultaneously:</span> <code>try€</code>マクロは3つのものを同時にカプセル化するため、エラー処理の結果としてオーバーヘッドはほとんどありません。</span> </p><br><div data-b=1.> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Case analysis.</span>ケース分析。</span> </div><div data-b=2.> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Control flow.</span>制御フロー。</span> </div><div data-b=3.> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Error type conversion.</span>エラータイプ変換。</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When all three things are combined, we get code that is unencumbered by combinators, calls to <code>unwrap</code> or case analysis.</span> 3つのものがすべて結合されると、コンビネータ、 <code>unwrap</code>またはケース分析の呼び出しによって妨げられないコードが得られます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There&#39;s one little nit left: the <code>Box&lt;Error&gt;</code> type is <i>opaque</i> .</span>少し残っています： <code>Box&lt;Error&gt;</code>タイプは<i>不透明</i>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we return a <code>Box&lt;Error&gt;</code> to the caller, the caller can&#39;t (easily) inspect underlying error type.</span>呼び出し元に<code>Box&lt;Error&gt;</code>を返すと、呼び出し元は基になるエラータイプを（簡単に）検査できません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The situation is certainly better than <code>String</code> because the caller can call methods like <a class=notranslate href=#2../../std/error/trait.Error.html#method.cause><code>cause</code></a> , but the limitation remains: <code>Box&lt;Error&gt;</code> is opaque.</span>状況がより確かに優れている<code>String</code> 、発信者のようなメソッドを呼び出すことができますので<a class=notranslate href=#2../../std/error/trait.Error.html#method.cause><code>cause</code></a> 、しかし制限が残っています： <code>Box&lt;Error&gt;</code>不透明です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">(NB This isn&#39;t entirely true because Rust does have runtime reflection, which is useful in some scenarios that are <a href=#2https://crates.io/crates/error>beyond the scope of this section</a> .)</span> （これは完全に真実ではありません。なぜなら、Rustにはランタイムリフレクションがあるからです。 <a href=#2https://crates.io/crates/error>これは、このセクションの範囲を超えて</a>いるシナリオで便利です）。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It&#39;s time to revisit our custom <code>CliError</code> type and tie everything together.</span>今度は、カスタム<code>CliError</code>型を再訪し、すべてを結びつけるときです。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Composing custom error types</span>カスタムエラータイプの作成</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In the last section, we looked at the real <code>try€</code> macro and how it does automatic type conversion for us by calling <code>From::from</code> on the error value.</span>最後のセクションでは、実際の<code>try€</code>マクロと、エラー値の<code>From::from</code>を呼び出すことによって、自動型変換を行う方法を見てきました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In particular, we converted errors to <code>Box&lt;Error&gt;</code> , which works, but the type is opaque to callers.</span>特に、エラーを<code>Box&lt;Error&gt;</code>に変換しましたが、これは動作しますが、タイプは呼び出し元に対して不透明です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To fix this, we use the same remedy that we&#39;re already familiar with: a custom error type.</span>これを修正するには、既に慣れ親しんでいるのと同じ措置、すなわちカスタムエラータイプを使用します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Once again, here is the code that reads the contents of a file and converts it to an integer:</span>もう一度、ファイルの内容を読み取り、それを整数に変換するコードを次に示します。</span> </p><br><div data-lang=rust><div data-l="use std::fs::File;"></div><div data-l="use std::io::{self, Read};"></div><div data-l="use std::num;"></div><div data-l="use std::path::Path;"></div><div data-l=""></div><div data-l="#// We derive `Debug` because all types should probably derive `Debug`."></div><div data-l="#// This gives us a reasonable human-readable description of `CliError` values."></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We derive <code>Debug</code> because all types should probably derive <code>Debug</code> .</span>私たちは、派生<code>Debug</code>すべての種類は、おそらく派生する必要があるため<code>Debug</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This gives us a reasonable human-readable description of <code>CliError</code> values.</span>これは<code>CliError</code>値を人が読めるように説明して<code>CliError</code>ます。</span> </div><div data-l=#[derive(Debug)]></div><div data-l="enum CliError {"></div><div data-l="    Io(io::Error),"></div><div data-l="    Parse(num::ParseIntError),"></div><div data-l=}></div><div data-l=""></div><div data-l="fn file_double_verbose&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;i32, CliError&gt; {"></div><div data-l="    let mut file = try!(File::open(file_path).map_err(CliError::Io));"></div><div data-l="    let mut contents = String::new();"></div><div data-l="    try!(file.read_to_string(&amp;mut contents).map_err(CliError::Io));"></div><div data-l="    let n: i32 = try!(contents.trim().parse().map_err(CliError::Parse));"></div><div data-l="    Ok(2 * n)"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Notice that we still have the calls to <code>map_err</code> .</span> <code>map_err</code>の呼び出しがまだあることに注意して<code>map_err</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Why?</span>どうして？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Well, recall the definitions of <a class=notranslate href=#2#code-try-def><code>try€</code></a> and <a class=notranslate href=#2#code-from-def><code>From</code></a> .</span>まあ、 <a class=notranslate href=#2#code-try-def><code>try€</code></a>と<a class=notranslate href=#2#code-from-def><code>From</code></a>定義を思い出して<a class=notranslate href=#2#code-try-def><code>try€</code></a> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The problem is that there is no <code>From</code> impl that allows us to convert from error types like <code>io::Error</code> and <code>num::ParseIntError</code> to our own custom <code>CliError</code> .</span>問題は、 <code>io::Error</code>や<code>num::ParseIntError</code>ようなエラー型から私たちのカスタム<code>CliError</code>に変換することを可能にする<code>From</code> implは存在しないということ<code>CliError</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Of course, it is easy to fix this!</span>もちろん、これを修正するのは簡単です！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Since we defined <code>CliError</code> , we can impl <code>From</code> with it:</span>我々が定義されているので<code>CliError</code> 、我々はIMPLできる<code>From</code>それと：</span> </p><br><div data-lang=rust><div data-l="# #[derive(Debug)]"></div><div data-l="# enum CliError { Io(io::Error), Parse(num::ParseIntError) }"></div><div data-l="use std::io;"></div><div data-l="use std::num;"></div><div data-l=""></div><div data-l="impl From&lt;io::Error&gt; for CliError {"></div><div data-l="    fn from(err: io::Error) -&gt; CliError {"></div><div data-l="        CliError::Io(err)"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="impl From&lt;num::ParseIntError&gt; for CliError {"></div><div data-l="    fn from(err: num::ParseIntError) -&gt; CliError {"></div><div data-l="        CliError::Parse(err)"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">All these impls are doing is teaching <code>From</code> how to create a <code>CliError</code> from other error types.</span>これらのすべてのimplsを教えてやっている<code>From</code>作成方法<code>CliError</code>他のエラータイプからを。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In our case, construction is as simple as invoking the corresponding value constructor.</span>私たちの場合、構築は対応する値コンストラクタを呼び出すのと同じくらい簡単です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Indeed, it is <i>typically</i> this easy.</span>確かに、これは<i>通常</i>簡単です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can finally rewrite <code>file_double</code> :</span>最終的に<code>file_double</code>書き直すことができ<code>file_double</code> ：</span> </p><br><div data-lang=rust><div data-l="# use std::io;"></div><div data-l="# use std::num;"></div><div data-l="# enum CliError { Io(::std::io::Error), Parse(::std::num::ParseIntError) }"></div><div data-l="# impl From&lt;io::Error&gt; for CliError {"></div><div data-l="#     fn from(err: io::Error) -&gt; CliError { CliError::Io(err) }"></div><div data-l="# }"></div><div data-l="# impl From&lt;num::ParseIntError&gt; for CliError {"></div><div data-l="#     fn from(err: num::ParseIntError) -&gt; CliError { CliError::Parse(err) }"></div><div data-l="# }"></div><div data-l=""></div><div data-l="use std::fs::File;"></div><div data-l="use std::io::Read;"></div><div data-l="use std::path::Path;"></div><div data-l=""></div><div data-l="fn file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;i32, CliError&gt; {"></div><div data-l="    let mut file = try!(File::open(file_path));"></div><div data-l="    let mut contents = String::new();"></div><div data-l="    try!(file.read_to_string(&amp;mut contents));"></div><div data-l="    let n: i32 = try!(contents.trim().parse());"></div><div data-l="    Ok(2 * n)"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The only thing we did here was remove the calls to <code>map_err</code> .</span>ここで唯一行ったことは、 <code>map_err</code>への呼び出しを削除すること<code>map_err</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">They are no longer needed because the <code>try€</code> macro invokes <code>From::from</code> on the error value.</span> <code>try€</code>マクロがエラー値の<code>From::from</code>を呼び出すため、これらのマクロは不要になりました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This works because we&#39;ve provided <code>From</code> impls for all the error types that could appear.</span>これは、出現する可能性のあるすべてのエラータイプに対して、 <code>From</code>差し込み」 <code>From</code>提供されているために機能します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we modified our <code>file_double</code> function to perform some other operation, say, convert a string to a float, then we&#39;d need to add a new variant to our error type:</span> <code>file_double</code>関数を変更して、たとえば文字列を浮動小数点数に変換するなどの操作を実行した場合は、新しいバリアントをエラータイプに追加する必要があります。</span> </p><br><div data-lang=rust><div data-l="use std::io;"></div><div data-l="use std::num;"></div><div data-l=""></div><div data-l="enum CliError {"></div><div data-l="    Io(io::Error),"></div><div data-l="    ParseInt(num::ParseIntError),"></div><div data-l="    ParseFloat(num::ParseFloatError),"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">And add a new <code>From</code> impl:</span>新規追加<code>From</code>のimpl：</span> </p><br><div data-lang=rust><div data-l="# enum CliError {"></div><div data-l="#     Io(::std::io::Error),"></div><div data-l="#     ParseInt(num::ParseIntError),"></div><div data-l="#     ParseFloat(num::ParseFloatError),"></div><div data-l="# }"></div><div data-l=""></div><div data-l="use std::num;"></div><div data-l=""></div><div data-l="impl From&lt;num::ParseFloatError&gt; for CliError {"></div><div data-l="    fn from(err: num::ParseFloatError) -&gt; CliError {"></div><div data-l="        CliError::ParseFloat(err)"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">And that&#39;s it!</span>以上です！</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Advice for library writers</span>図書館の作家のためのアドバイス</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If your library needs to report custom errors, then you should probably define your own error type.</span>ライブラリでカスタムエラーをレポートする必要がある場合は、おそらく独自のエラータイプを定義する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It&#39;s up to you whether or not to expose its representation (like <a class=notranslate href=#2../../std/io/enum.ErrorKind.html><code>ErrorKind</code></a> ) or keep it hidden (like <a class=notranslate href=#2../../std/num/struct.ParseIntError.html><code>ParseIntError</code></a> ).</span>その表現（ <a class=notranslate href=#2../../std/io/enum.ErrorKind.html><code>ErrorKind</code></a> ）を公開するかどうか、または<a class=notranslate href=#2../../std/num/struct.ParseIntError.html><code>ParseIntError</code></a>ように非表示にするかどうかは、あなた次第です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Regardless of how you do it, it&#39;s usually good practice to at least provide some information about the error beyond its <code>String</code> representation.</span>それをどうしているかにかかわらず、少なくともエラーの情報を<code>String</code>表現を超えて提供することは、通常は良い方法です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But certainly, this will vary depending on use cases.</span>しかし、確かに、これはユースケースによって異なります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">At a minimum, you should probably implement the <a class=notranslate href=#2../../std/error/trait.Error.html><code>Error</code></a> trait.</span>少なくとも、 <a class=notranslate href=#2../../std/error/trait.Error.html><code>Error</code></a>特性を実装するべきです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This will give users of your library some minimum flexibility for <a href=#2#the-real-try-macro>composing errors</a> .</span>これにより、ライブラリのユーザーは<a href=#2#the-real-try-macro>エラー</a>を<a href=#2#the-real-try-macro>作成する</a>ための柔軟性が<a href=#2#the-real-try-macro>失われ</a>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Implementing the <code>Error</code> trait also means that users are guaranteed the ability to obtain a string representation of an error (because it requires impls for both <code>fmt::Debug</code> and <code>fmt::Display</code> ).</span> <code>Error</code>特性を実装することは、 <code>fmt::Debug</code>と<code>fmt::Display</code>両方にimplを必要とするため、ユーザーがエラーの文字列表現を取得することが保証されていることも意味します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Beyond that, it can also be useful to provide implementations of <code>From</code> on your error types.</span>それ以外にも、エラータイプの<code>From</code>実装を提供すると便利です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This allows you (the library author) and your users to <a href=#2#composing-custom-error-types>compose more detailed errors</a> .</span>これにより、あなた（ライブラリ作成者）とユーザーは<a href=#2#composing-custom-error-types>より詳細なエラー</a>を<a href=#2#composing-custom-error-types>作成することができ</a>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, <a class=notranslate href=#2http://burntsushi.net/rustdoc/csv/enum.Error.html><code>csv::Error</code></a> provides <code>From</code> impls for both <code>io::Error</code> and <code>byteorder::Error</code> .</span>例えば、 <a class=notranslate href=#2http://burntsushi.net/rustdoc/csv/enum.Error.html><code>csv::Error</code></a>は、 <code>io::Error</code>と<code>byteorder::Error</code>両方<code>From</code> implsを提供します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Finally, depending on your tastes, you may also want to define a <a href=#2#the-result-type-alias-idiom><code>Result</code> type alias</a> , particularly if your library defines a single error type.</span>最後に、あなたの好みに応じて、特にライブラリで単一のエラータイプが定義されている場合は、 <a href=#2#the-result-type-alias-idiom><code>Result</code>型のエイリアス</a>を定義することもできます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is used in the standard library for <a class=notranslate href=#2../../std/io/type.Result.html><code>io::Result</code></a> and <a class=notranslate href=#2../../std/fmt/type.Result.html><code>fmt::Result</code></a> .</span>これは、 <a class=notranslate href=#2../../std/io/type.Result.html><code>io::Result</code></a>と<a class=notranslate href=#2../../std/fmt/type.Result.html><code>fmt::Result</code></a>の標準ライブラリで使用されます。</span> </p><br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Case study: A program to read population data</span>ケーススタディ：人口データを読み込むプログラム</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This section was long, and depending on your background, it might be rather dense.</span>このセクションは長く、あなたの背景にもよるが、それはむしろ密であるかもしれない。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">While there is plenty of example code to go along with the prose, most of it was specifically designed to be pedagogical.</span>散文と一緒に行くためのサンプルコードはたくさんありますが、そのほとんどは教育的であるように特別に設計されています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So, we&#39;re going to do something new: a case study.</span>だから、我々は新しいことをするつもりです：事例研究。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For this, we&#39;re going to build up a command line program that lets you query world population data.</span>このために、世界の人口データを照会するコマンドラインプログラムを構築します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The objective is simple: you give it a location and it will tell you the population.</span>目的は簡単です：あなたはそれに場所を与え、人口を教えてくれるでしょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Despite the simplicity, there is a lot that can go wrong!</span>シンプルさにもかかわらず、間違っていることがたくさんあります！</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The data we&#39;ll be using comes from the <a href=#311>Data Science Toolkit</a> .</span>使用するデータは、 <a href=#311>Data Science Toolkitに</a>基づいています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">I&#39;ve prepared some data from it for this exercise.</span>この演習では、いくつかのデータを用意しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can either grab the <a href=#312>world population data</a> (41MB gzip compressed, 145MB uncompressed) or only the <a href=#313>US population data</a> (2.2MB gzip compressed, 7.2MB uncompressed).</span> <a href=#312>世界人口データ</a> （41MB gzip圧縮、145MB非圧縮）または<a href=#313>米国人口データ</a> （2.2MB gzip圧縮、7.2MB非圧縮）だけを<a href=#313>取得できます</a> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Up until now, we&#39;ve kept the code limited to Rust&#39;s standard library.</span>これまでは、コードをRustの標準ライブラリに限定していました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For a real task like this though, we&#39;ll want to at least use something to parse CSV data, parse the program arguments and decode that stuff into Rust types automatically.</span>このような実際のタスクでは、少なくともCSVデータを解析し、プログラムの引数を解析し、その情報をRust型に自動的にデコードする必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For that, we&#39;ll use the <a class=notranslate href=#2https://crates.io/crates/csv><code>csv</code></a> , and <a class=notranslate href=#2https://crates.io/crates/rustc-serialize><code>rustc-serialize</code></a> crates.</span>そのために、 <a class=notranslate href=#2https://crates.io/crates/csv><code>csv</code></a>と<a class=notranslate href=#2https://crates.io/crates/rustc-serialize><code>rustc-serialize</code></a>使用します。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Initial setup</span>初期設定</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;re not going to spend a lot of time on setting up a project with Cargo because it is already covered well in <a href=#2getting-started.html#hello-cargo>the Cargo section</a> and <a href=#314>Cargo&#39;s documentation</a> .</span> Cargoのプロジェクトでは、すでに<a href=#2getting-started.html#hello-cargo>Cargoセクション</a>と<a href=#314>Cargoのドキュメンテーションで</a>十分にカバーされているため、プロジェクトを立ち上げるのに多くの時間を費やすつもりはありません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To get started from scratch, run <code>cargo new --bin city-pop</code> and make sure your <code>Cargo.toml</code> looks something like this:</span>ゼロから始めるには、 <code>cargo new --bin city-pop</code>を実行し、 <code>Cargo.toml</code>が次のようになっていることを確認してください：</span> </p><br><div data-lang=text><div data-l=[package]></div><div data-l="name = &quot;city-pop&quot;"></div><div data-l="version = &quot;0.1.0&quot;"></div><div data-l="authors = [&quot;Andrew Gallant &lt;jamslam@gmail.com&gt;&quot;]"></div><div data-l=""></div><div data-l=[[bin]]></div><div data-l="name = &quot;city-pop&quot;"></div><div data-l=""></div><div data-l=[dependencies]></div><div data-l="csv = &quot;0.*&quot;"></div><div data-l="rustc-serialize = &quot;0.*&quot;"></div><div data-l="getopts = &quot;0.*&quot;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You should already be able to run:</span>あなたはすでに実行することができます：</span> </p><br><div data-lang=text><div data-l="cargo build --release"></div><div data-l=./target/release/city-pop></div><div data-l="# Outputs: Hello, world!"></div></div><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Argument parsing</span>引数の解析</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s get argument parsing out of the way.</span>引き分けに引数の解析をしましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We won&#39;t go into too much detail on Getopts, but there is <a href=#315>some good documentation</a> describing it.</span>私たちはGetoptsについて詳しく説明しませんが、それを記述する<a href=#315>良い文書</a>があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The short story is that Getopts generates an argument parser and a help message from a vector of options (The fact that it is a vector is hidden behind a struct and a set of methods).</span>短い話は、Getoptsがオプションのベクトルから引数パーザとヘルプメッセージを生成することです（ベクトルであるという事実は、構造体とメソッドのセットの背後に隠されています）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Once the parsing is done, the parser returns a struct that records matches for defined options, and remaining &quot;free&quot; arguments.</span>解析が完了すると、パーサは、定義されたオプションと残りの &quot;空き&quot;引数との一致を記録する構造体を返します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">From there, we can get information about the flags, for instance, whether they were passed in, and what arguments they had.</span>そこから、フラグの情報、例えば、渡されたかどうか、どのような引数があるかなどの情報を取得できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here&#39;s our program with the appropriate <code>extern crate</code> statements, and the basic argument setup for Getopts:</span>ここでは、適切な<code>extern crate</code> crateステートメントとGetoptsの基本引数設定を使って、プログラムを紹介します：</span> </p><br><div data-lang=rust,ignore><div data-l="extern crate getopts;"></div><div data-l="extern crate rustc_serialize;"></div><div data-l=""></div><div data-l="use getopts::Options;"></div><div data-l="use std::env;"></div><div data-l=""></div><div data-l="fn print_usage(program: &amp;str, opts: Options) {"></div><div data-l="    println!(&quot;{}&quot;, opts.usage(&amp;format!(&quot;Usage: {} [options] &lt;data-path&gt; &lt;city&gt;&quot;, program)));"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let args: Vec&lt;String&gt; = env::args().collect();"></div><div data-l="    let program = &amp;args[0];"></div><div data-l=""></div><div data-l="    let mut opts = Options::new();"></div><div data-l="    opts.optflag(&quot;h&quot;, &quot;help&quot;, &quot;Show this usage message.&quot;);"></div><div data-l=""></div><div data-l="    let matches = match opts.parse(&amp;args[1..]) {"></div><div data-l="        Ok(m)  =&gt; { m }"></div><div data-l="        Err(e) =&gt; { panic!(e.to_string()) }"></div><div data-l="    };"></div><div data-l="    if matches.opt_present(&quot;h&quot;) {"></div><div data-l="        print_usage(&amp;program, opts);"></div><div data-l="        return;"></div><div data-l="    }"></div><div data-l="    let data_path = &amp;matches.free[0];"></div><div data-l="    let city: &amp;str = &amp;matches.free[1];"></div><div data-l=""></div><div data-l="#    // Do stuff with information."></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Do stuff with information.</span>情報を詰め込む</span> </div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">First, we get a vector of the arguments passed into our program.</span>まず、プログラムに渡された引数のベクトルを取得します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We then store the first one, knowing that it is our program&#39;s name.</span>次に、プログラムの名前であることを認識して、最初のものを保存します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Once that&#39;s done, we set up our argument flags, in this case a simplistic help message flag.</span>これが終わると、引数フラグを設定します。この場合、単純なヘルプメッセージフラグです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Once we have the argument flags set up, we use <code>Options.parse</code> to parse the argument vector (starting from index one, because index 0 is the program name).</span>引数フラグが設定されると、 <code>Options.parse</code>を使用して引数ベクトルを解析します（インデックス0はプログラム名です）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If this was successful, we assign matches to the parsed object, if not, we panic.</span>これが成功した場合、解析されたオブジェクトにマッチを割り当てます。そうでなければ、パニックになります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Once past that, we test if the user passed in the help flag, and if so print the usage message.</span>それを過ぎると、ユーザーがヘルプフラグを渡したかどうかテストし、もしそうなら、使用法のメッセージを出力します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The option help messages are constructed by Getopts, so all we have to do to print the usage message is tell it what we want it to print for the program name and template.</span>オプションのヘルプメッセージはGetoptsによって構築されるので、使用法のメッセージを出力するために必要なことは、プログラム名とテンプレートのために印刷することだけです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If the user has not passed in the help flag, we assign the proper variables to their corresponding arguments.</span>ユーザーがヘルプフラグを渡さなかった場合、適切な変数を対応する引数に割り当てます。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Writing the logic</span>論理を書く</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We all write code differently, but error handling is usually the last thing we want to think about.</span>私たちはすべてコードを違って書いていますが、通常はエラー処理が考えています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This isn&#39;t great for the overall design of a program, but it can be useful for rapid prototyping.</span>これはプログラム全体の設計にはあまり適していませんが、ラピッドプロトタイピングには役立ちます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because Rust forces us to be explicit about error handling (by making us call <code>unwrap</code> ), it is easy to see which parts of our program can cause errors.</span> Rustはエラー処理を明示的に（強制的に<code>unwrap</code>呼び出すことによって）強制するので、プログラムのどの部分がエラーを引き起こすかを簡単に知ることができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this case study, the logic is really simple.</span>このケーススタディでは、ロジックは本当に簡単です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">All we need to do is parse the CSV data given to us and print out a field in matching rows.</span>必要なのは、私たちに与えられたCSVデータを解析して、一致する行にフィールドを印刷することだけです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s do it.</span>やってみましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">(Make sure to add <code>extern crate csv;</code> to the top of your file.)</span> （ <code>extern crate csv;</code>をファイルの先頭に追加してください）</span> </p><br><div data-lang=rust,ignore><div data-l="use std::fs::File;"></div><div data-l=""></div><div data-l="#// This struct represents the data in each row of the CSV file."></div><div data-l="#// Type based decoding absolves us of a lot of the nitty-gritty error"></div><div data-l="#// handling, like parsing strings as integers or floats."></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This struct represents the data in each row of the CSV file.</span>この構造体は、CSVファイルの各行のデータを表します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Type based decoding absolves us of a lot of the nitty-gritty error handling, like parsing strings as integers or floats.</span>型に基づくデコードでは、文字列を整数または浮動小数点として解析するような、きめ細かなエラー処理がたくさんあります。</span> </div><div data-l="#[derive(Debug, RustcDecodable)]"></div><div data-l="struct Row {"></div><div data-l="    country: String,"></div><div data-l="    city: String,"></div><div data-l="    accent_city: String,"></div><div data-l="    region: String,"></div><div data-l=""></div><div data-l="#    // Not every row has data for the population, latitude or longitude!"></div><div data-l="#    // So we express them as `Option` types, which admits the possibility of"></div><div data-l="#    // absence. The CSV parser will fill in the correct value for us."></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Not every row has data for the population, latitude or longitude!</span>すべての行に人口、緯度、経度のデータがあるわけではありません！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So we express them as <code>Option</code> types, which admits the possibility of absence.</span>だから私たちは<code>Option</code> typesとしてそれらを表現します。これは欠如の可能性を認めています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The CSV parser will fill in the correct value for us.</span> CSVパーサーが正しい値を入力します。</span> </div><div data-l="    population: Option&lt;u64&gt;,"></div><div data-l="    latitude: Option&lt;f64&gt;,"></div><div data-l="    longitude: Option&lt;f64&gt;,"></div><div data-l=}></div><div data-l=""></div><div data-l="fn print_usage(program: &amp;str, opts: Options) {"></div><div data-l="    println!(&quot;{}&quot;, opts.usage(&amp;format!(&quot;Usage: {} [options] &lt;data-path&gt; &lt;city&gt;&quot;, program)));"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let args: Vec&lt;String&gt; = env::args().collect();"></div><div data-l="    let program = &amp;args[0];"></div><div data-l=""></div><div data-l="    let mut opts = Options::new();"></div><div data-l="    opts.optflag(&quot;h&quot;, &quot;help&quot;, &quot;Show this usage message.&quot;);"></div><div data-l=""></div><div data-l="    let matches = match opts.parse(&amp;args[1..]) {"></div><div data-l="        Ok(m)  =&gt; { m }"></div><div data-l="        Err(e) =&gt; { panic!(e.to_string()) }"></div><div data-l="    };"></div><div data-l=""></div><div data-l="    if matches.opt_present(&quot;h&quot;) {"></div><div data-l="        print_usage(&amp;program, opts);"></div><div data-l="        return;"></div><div data-l="    }"></div><div data-l=""></div><div data-l="    let data_path = &amp;matches.free[0];"></div><div data-l="    let city: &amp;str = &amp;matches.free[1];"></div><div data-l=""></div><div data-l="    let file = File::open(data_path).unwrap();"></div><div data-l="    let mut rdr = csv::Reader::from_reader(file);"></div><div data-l=""></div><div data-l="    for row in rdr.decode::&lt;Row&gt;() {"></div><div data-l="        let row = row.unwrap();"></div><div data-l=""></div><div data-l="        if row.city == city {"></div><div data-l="            println!(&quot;{}, {}: {:?}&quot;,"></div><div data-l="                row.city, row.country,"></div><div data-l="                row.population.expect(&quot;population count&quot;));"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s outline the errors.</span>エラーの概要を説明しましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can start with the obvious: the three places that <code>unwrap</code> is called:</span>明白なことから始めることができます。 <code>unwrap</code>と呼ばれる3つの場所は、</span> </p><br><div data-b=1.> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a class=notranslate href=#2../../std/fs/struct.File.html#method.open><code>File::open</code></a> can return an <a class=notranslate href=#2../../std/io/struct.Error.html><code>io::Error</code></a> .</span> <a class=notranslate href=#2../../std/fs/struct.File.html#method.open><code>File::open</code></a>は<a class=notranslate href=#2../../std/io/struct.Error.html><code>io::Error</code></a>返すことができます。</span> </div><div data-b=2.> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a class=notranslate href=#2http://burntsushi.net/rustdoc/csv/struct.Reader.html#method.decode><code>csv::Reader::decode</code></a> decodes one record at a time, and <a href=#2http://burntsushi.net/rustdoc/csv/struct.DecodedRecords.html>decoding a record</a> (look at the <code>Item</code> associated type on the <code>Iterator</code> impl) can produce a <a class=notranslate href=#2http://burntsushi.net/rustdoc/csv/enum.Error.html><code>csv::Error</code></a> .</span> <a class=notranslate href=#2http://burntsushi.net/rustdoc/csv/struct.Reader.html#method.decode><code>csv::Reader::decode</code></a>は一度に一つのレコードを<a href=#2http://burntsushi.net/rustdoc/csv/struct.DecodedRecords.html>デコードし、レコード</a>を<a href=#2http://burntsushi.net/rustdoc/csv/struct.DecodedRecords.html>デコードする</a>と（ <code>Iterator</code> implで<code>Item</code>関連タイプを調べると）、 <a class=notranslate href=#2http://burntsushi.net/rustdoc/csv/enum.Error.html><code>csv::Error</code></a>が生成されます。</span> </div><div data-b=3.> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If <code>row.population</code> is <code>None</code> , then calling <code>expect</code> will panic.</span> <code>row.population</code>が<code>None</code>場合、 <code>expect</code>を呼び出すとパニックになります。</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Are there any others?</span>他に何かありますか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">What if we can&#39;t find a matching city?</span>一致する都市が見つからない場合はどうすればよいですか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Tools like <code>grep</code> will return an error code, so we probably should too.</span> <code>grep</code>ようなツールはエラーコードを返すので、おそらくそれも必要です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So we have logic errors specific to our problem, IO errors and CSV parsing errors.</span>だから我々の問題に固有の論理エラー、IOエラー、CSV解析エラーがある。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;re going to explore two different ways to approach handling these errors.</span>これらのエラーを処理するための2つの異なる方法を検討します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">I&#39;d like to start with <code>Box&lt;Error&gt;</code> .</span>私は<code>Box&lt;Error&gt;</code>から始めたいと思います。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Later, we&#39;ll see how defining our own error type can be useful.</span>後で、独自のエラータイプの定義がどのように役立つかを見ていきます。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Error handling with <code>Box&lt;Error&gt;</code></span> <code>Box&lt;Error&gt;</code>エラー処理<code>Box&lt;Error&gt;</code></span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>Box&lt;Error&gt;</code> is nice because it <i>just works</i> .</span> <code>Box&lt;Error&gt;</code>それ<i>だけで動作します</i>ので、いいです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You don&#39;t need to define your own error types and you don&#39;t need any <code>From</code> implementations.</span>独自のエラータイプを定義する必要はなく、 <code>From</code>実装は必要ありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The downside is that since <code>Box&lt;Error&gt;</code> is a trait object, it <i>erases the type</i> , which means the compiler can no longer reason about its underlying type.</span>欠点は、 <code>Box&lt;Error&gt;</code>が特性オブジェクトであるため<i>、型を消去する</i>ということです。つまり、コンパイラは根本的な型を理由に考えることができなくなります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a class=notranslate href=#2#the-limits-of-combinators>Previously</a> we started refactoring our code by changing the type of our function from <code>T</code> to <code>Result&lt;T, OurErrorType&gt;</code> .</span> <a class=notranslate href=#2#the-limits-of-combinators>Previously</a>は、関数の型を<code>T</code>から<code>Result&lt;T, OurErrorType&gt;</code>変更して、コードをリファクタリングし始めました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this case, <code>OurErrorType</code> is only <code>Box&lt;Error&gt;</code> .</span>この場合、 <code>OurErrorType</code>は<code>Box&lt;Error&gt;</code>のみです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But what&#39;s <code>T</code> ?</span>しかし、 <code>T</code>何ですか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">And can we add a return type to <code>main</code> ?</span> <code>main</code>戻り値型を追加できますか？</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The answer to the second question is no, we can&#39;t.</span> 2番目の質問に対する答えは「いいえ、できません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That means we&#39;ll need to write a new function.</span>つまり、新しい関数を書く必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But what is <code>T</code> ?</span>しかし、 <code>T</code>とは何ですか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The simplest thing we can do is to return a list of matching <code>Row</code> values as a <code>Vec&lt;Row&gt;</code> .</span>一番簡単なのは、一致する<code>Row</code>値のリストを<code>Vec&lt;Row&gt;</code>として返すことです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">(Better code would return an iterator, but that is left as an exercise to the reader.)</span> （より良いコードはイテレータを返しますが、それは読者の練習として残されています）。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s refactor our code into its own function, but keep the calls to <code>unwrap</code> .</span>私たちのコードを独自の関数にリファクタリングしましょうが、呼び出しを<code>unwrap</code>するようにしましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that we opt to handle the possibility of a missing population count by simply ignoring that row.</span>その行を無視するだけで、人口不足の可能性を処理することに注意してください。</span> </p><br><div data-lang=rust,ignore><div data-l="use std::path::Path;"></div><div data-l=""></div><div data-l="struct Row {"></div><div data-l="#    // This struct remains unchanged."></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This struct remains unchanged.</span>この構造体は変更されません。</span> </div><div data-l=}></div><div data-l=""></div><div data-l="struct PopulationCount {"></div><div data-l="    city: String,"></div><div data-l="    country: String,"></div><div data-l="#    // This is no longer an `Option` because values of this type are only"></div><div data-l="#    // constructed if they have a population count."></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is no longer an <code>Option</code> because values of this type are only constructed if they have a population count.</span>これは、もはや<code>Option</code>はない。なぜなら、このタイプの値は、人口数がある場合にのみ構築されるからである。</span> </div><div data-l="    count: u64,"></div><div data-l=}></div><div data-l=""></div><div data-l="fn print_usage(program: &amp;str, opts: Options) {"></div><div data-l="    println!(&quot;{}&quot;, opts.usage(&amp;format!(&quot;Usage: {} [options] &lt;data-path&gt; &lt;city&gt;&quot;, program)));"></div><div data-l=}></div><div data-l=""></div><div data-l="fn search&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P, city: &amp;str) -&gt; Vec&lt;PopulationCount&gt; {"></div><div data-l="    let mut found = vec![];"></div><div data-l="    let file = File::open(file_path).unwrap();"></div><div data-l="    let mut rdr = csv::Reader::from_reader(file);"></div><div data-l="    for row in rdr.decode::&lt;Row&gt;() {"></div><div data-l="        let row = row.unwrap();"></div><div data-l="        match row.population {"></div><div data-l="#//            None =&gt; { } // Skip it."></div><div data-l="            None =&gt; { } // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Skip it.</span>それをスキップします。</span> </div><div data-l="            Some(count) =&gt; if row.city == city {"></div><div data-l="                found.push(PopulationCount {"></div><div data-l="                    city: row.city,"></div><div data-l="                    country: row.country,"></div><div data-l="                    count: count,"></div><div data-l="                });"></div><div data-l="            },"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l="    found"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let args: Vec&lt;String&gt; = env::args().collect();"></div><div data-l="    let program = &amp;args[0];"></div><div data-l=""></div><div data-l="    let mut opts = Options::new();"></div><div data-l="    opts.optflag(&quot;h&quot;, &quot;help&quot;, &quot;Show this usage message.&quot;);"></div><div data-l=""></div><div data-l="    let matches = match opts.parse(&amp;args[1..]) {"></div><div data-l="        Ok(m)  =&gt; { m }"></div><div data-l="        Err(e) =&gt; { panic!(e.to_string()) }"></div><div data-l="    };"></div><div data-l=""></div><div data-l="    if matches.opt_present(&quot;h&quot;) {"></div><div data-l="        print_usage(&amp;program, opts);"></div><div data-l="        return;"></div><div data-l="    }"></div><div data-l=""></div><div data-l="    let data_path = &amp;matches.free[0];"></div><div data-l="    let city: &amp;str = &amp;matches.free[1];"></div><div data-l=""></div><div data-l="    for pop in search(data_path, city) {"></div><div data-l="        println!(&quot;{}, {}: {:?}&quot;, pop.city, pop.country, pop.count);"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">While we got rid of one use of <code>expect</code> (which is a nicer variant of <code>unwrap</code> ), we still should handle the absence of any search results.</span> <code>expect</code>使い方（ <code>unwrap</code>ほうが良い）を取り除いていますが、検索結果が存在しない場合は処理する必要があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To convert this to proper error handling, we need to do the following:</span>これを適切なエラー処理に変換するには、以下を実行する必要があります。</span> </p><br><div data-b=1.> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Change the return type of <code>search</code> to be <code>Result&lt;Vec&lt;PopulationCount&gt;, Box&lt;Error&gt;&gt;</code> .</span> <code>search</code>の戻り値の型を<code>Result&lt;Vec&lt;PopulationCount&gt;, Box&lt;Error&gt;&gt;</code>ます。</span> </div><div data-b=2.> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Use the <a href=#2#code-try-def><code>try€</code> macro</a> so that errors are returned to the caller instead of panicking the program.</span>プログラムをパニックするのではなく、エラーが呼び出し元に返されるように<a href=#2#code-try-def><code>try€</code>マクロを</a>使用して<a href=#2#code-try-def><code>try€</code></a> 。</span> </div><div data-b=3.> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Handle the error in <code>main</code> .</span> <code>main</code>のエラーを処理します。</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s try it:</span>試してみよう：</span> </p><br><div data-lang=rust,ignore><div data-l="use std::error::Error;"></div><div data-l=""></div><div data-l="#// The rest of the code before this is unchanged."></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The rest of the code before this is unchanged.</span>それ以前のコードの残りの部分は変更されていません。</span> </div><div data-l=""></div><div data-l="fn search&lt;P: AsRef&lt;Path&gt;&gt;"></div><div data-l="         (file_path: P, city: &amp;str)"></div><div data-l="         -&gt; Result&lt;Vec&lt;PopulationCount&gt;, Box&lt;Error&gt;&gt; {"></div><div data-l="    let mut found = vec![];"></div><div data-l="    let file = try!(File::open(file_path));"></div><div data-l="    let mut rdr = csv::Reader::from_reader(file);"></div><div data-l="    for row in rdr.decode::&lt;Row&gt;() {"></div><div data-l="        let row = try!(row);"></div><div data-l="        match row.population {"></div><div data-l="#//            None =&gt; { } // Skip it."></div><div data-l="            None =&gt; { } // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Skip it.</span>それをスキップします。</span> </div><div data-l="            Some(count) =&gt; if row.city == city {"></div><div data-l="                found.push(PopulationCount {"></div><div data-l="                    city: row.city,"></div><div data-l="                    country: row.country,"></div><div data-l="                    count: count,"></div><div data-l="                });"></div><div data-l="            },"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l="    if found.is_empty() {"></div><div data-l="        Err(From::from(&quot;No matching cities with a population were found.&quot;))"></div><div data-l="    } else {"></div><div data-l="        Ok(found)"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Instead of <code>x.unwrap()</code> , we now have <code>try€(x)</code> .</span> <code>x.unwrap()</code>代わりに<code>try€(x)</code>て<code>try€(x)</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Since our function returns a <code>Result&lt;T, E&gt;</code> , the <code>try€</code> macro will return early from the function if an error occurs.</span>関数が<code>Result&lt;T, E&gt;</code>返すので、エラーが発生した場合、 <code>try€</code>マクロは関数の早い段階で返されます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">At the end of <code>search</code> we also convert a plain string to an error type by using the <a href=#2../../std/convert/trait.From.html>corresponding <code>From</code> impls</a> :</span> <code>search</code>の終わりに、 <a href=#2../../std/convert/trait.From.html>対応する<code>From</code> impls</a>を使用してプレーン文字列をエラータイプに変換します。</span> </p><br><div data-lang=rust,ignore><div data-l="#// We are making use of this impl in the code above, since we call `From::from`"></div><div data-l="#// on a `&amp;'static str`."></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We are making use of this impl in the code above, since we call <code>From::from</code> on a <code>&amp;&#39;static str</code> .</span>我々は呼んで以来、私たちは、上記のコードでは、このIMPLを利用している<code>From::from</code>の<code>&amp;&#39;static str</code> 。</span> </div><div data-l="impl&lt;'a&gt; From&lt;&amp;'a str&gt; for Box&lt;Error&gt;"></div><div data-l=""></div><div data-l="#// But this is also useful when you need to allocate a new string for an"></div><div data-l="#// error message, usually with `format!`."></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But this is also useful when you need to allocate a new string for an error message, usually with <code>format€</code> .</span>しかしこれは、エラーメッセージに新しい文字列を割り当てる必要がある場合にも便利です（通常は<code>format€</code> 。</span> </div><div data-l="impl From&lt;String&gt; for Box&lt;Error&gt;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Since <code>search</code> now returns a <code>Result&lt;T, E&gt;</code> , <code>main</code> should use case analysis when calling <code>search</code> :</span>以来<code>search</code>今や返す<code>Result&lt;T, E&gt;</code> 、 <code>main</code>呼び出し時にケースの分析を使用する必要があります<code>search</code> ：</span> </p><br><div data-lang=rust,ignore><div data-l=...></div><div data-l="    match search(data_path, city) {"></div><div data-l="        Ok(pops) =&gt; {"></div><div data-l="            for pop in pops {"></div><div data-l="                println!(&quot;{}, {}: {:?}&quot;, pop.city, pop.country, pop.count);"></div><div data-l="            }"></div><div data-l="        }"></div><div data-l="        Err(err) =&gt; println!(&quot;{}&quot;, err)"></div><div data-l="    }"></div><div data-l=...></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now that we&#39;ve seen how to do proper error handling with <code>Box&lt;Error&gt;</code> , let&#39;s try a different approach with our own custom error type.</span> <code>Box&lt;Error&gt;</code>で適切なエラー処理を行う方法を見てきたので、独自のカスタムエラータイプで別のアプローチを試してみましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But first, let&#39;s take a quick break from error handling and add support for reading from <code>stdin</code> .</span>しかし、まず、エラー処理から簡単に休みを取り、 <code>stdin</code>からの読み込みのサポートを追加しましょう。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Reading from stdin</span>スタンダードから読む</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In our program, we accept a single file for input and do one pass over the data.</span>私たちのプログラムでは、入力用に1つのファイルを受け入れ、データを1つのファイルに渡します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This means we probably should be able to accept input on stdin.</span>つまり、stdinの入力を受け入れることができるはずです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But maybe we like the current format too—so let&#39;s have both!</span>しかし、現在のフォーマットも好きかもしれません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Adding support for stdin is actually quite easy.</span> stdinのサポートを追加することは、実際には非常に簡単です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There are only three things we have to do:</span>私たちがしなければならないことは3つしかありません：</span> </p><br><div data-b=1.> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Tweak the program arguments so that a single parameter—the city—can be accepted while the population data is read from stdin.</span>母集団のデータをstdinから読み込んでいる間に、単一のパラメータ（都市）を受け入れることができるように、プログラムの引数を調整します。</span> </div><div data-b=2.> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Modify the program so that an option <code>-f</code> can take the file, if it is not passed into stdin.</span> stdinに渡されない場合、オプション<code>-f</code>がファイルを取り出せるようにプログラムを変更します。</span> </div><div data-b=3.> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Modify the <code>search</code> function to take an <i>optional</i> file path.</span> <i>オプションの</i>ファイルパスを<i>使用</i>するように<code>search</code>機能を変更します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When <code>None</code> , it should know to read from stdin.</span> <code>None</code>ときは、stdinから読むことを知るべきです。</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">First, here&#39;s the new usage:</span>まず、新しい使用法を次に示します。</span> </p><br><div data-lang=rust,ignore><div data-l="fn print_usage(program: &amp;str, opts: Options) {"></div><div data-l="    println!(&quot;{}&quot;, opts.usage(&amp;format!(&quot;Usage: {} [options] &lt;city&gt;&quot;, program)));"></div><div data-l=}></div></div><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Of course we need to adapt the argument handling code:</span>もちろん引数の処理コードを変更する必要があります。</span> </p><br><div data-lang=rust,ignore><div data-l=...></div><div data-l="    let mut opts = Options::new();"></div><div data-l="    opts.optopt(&quot;f&quot;, &quot;file&quot;, &quot;Choose an input file, instead of using STDIN.&quot;, &quot;NAME&quot;);"></div><div data-l="    opts.optflag(&quot;h&quot;, &quot;help&quot;, &quot;Show this usage message.&quot;);"></div><div data-l="    ..."></div><div data-l="    let data_path = matches.opt_str(&quot;f&quot;);"></div><div data-l=""></div><div data-l="    let city = if !matches.free.is_empty() {"></div><div data-l="        &amp;matches.free[0]"></div><div data-l="    } else {"></div><div data-l="        print_usage(&amp;program, opts);"></div><div data-l="        return;"></div><div data-l="    };"></div><div data-l=""></div><div data-l="    match search(&amp;data_path, city) {"></div><div data-l="        Ok(pops) =&gt; {"></div><div data-l="            for pop in pops {"></div><div data-l="                println!(&quot;{}, {}: {:?}&quot;, pop.city, pop.country, pop.count);"></div><div data-l="            }"></div><div data-l="        }"></div><div data-l="        Err(err) =&gt; println!(&quot;{}&quot;, err)"></div><div data-l="    }"></div><div data-l=...></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ve made the user experience a bit nicer by showing the usage message, instead of a panic from an out-of-bounds index, when <code>city</code> , the remaining free argument, is not present.</span>残りのフリーの引数<code>city</code>が存在しないときに、範囲外インデックスからのパニックではなく、使用法のメッセージを表示することで、ユーザーエクスペリエンスを少し改善しました。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Modifying <code>search</code> is slightly trickier.</span> <code>search</code>変更はややこしい。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>csv</code> crate can build a parser out of <a href=#2http://burntsushi.net/rustdoc/csv/struct.Reader.html#method.from_reader>any type that implements <code>io::Read</code></a> .</span> <code>csv</code>クレートは、 <a href=#2http://burntsushi.net/rustdoc/csv/struct.Reader.html#method.from_reader><code>io::Read</code>を実装する任意のタイプの</a>パーサーを構築できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But how can we use the same code over both types?</span>しかし、どのようにして両方の型で同じコードを使うことができますか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There&#39;s actually a couple ways we could go about this.</span>実際にはこれについていくつかの方法があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">One way is to write <code>search</code> such that it is generic on some type parameter <code>R</code> that satisfies <code>io::Read</code> .</span> 1つの方法は、 <code>io::Read</code>を満たすいくつかの型パラメータ<code>R</code>汎用であるように<code>search</code>を書くことです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Another way is to use trait objects:</span>別の方法は、特性オブジェクトを使用することです。</span> </p><br><div data-lang=rust,ignore><div data-l="use std::io;"></div><div data-l=""></div><div data-l="#// The rest of the code before this is unchanged."></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The rest of the code before this is unchanged.</span>それ以前のコードの残りの部分は変更されていません。</span> </div><div data-l=""></div><div data-l="fn search&lt;P: AsRef&lt;Path&gt;&gt;"></div><div data-l="         (file_path: &amp;Option&lt;P&gt;, city: &amp;str)"></div><div data-l="         -&gt; Result&lt;Vec&lt;PopulationCount&gt;, Box&lt;Error&gt;&gt; {"></div><div data-l="    let mut found = vec![];"></div><div data-l="    let input: Box&lt;io::Read&gt; = match *file_path {"></div><div data-l="        None =&gt; Box::new(io::stdin()),"></div><div data-l="        Some(ref file_path) =&gt; Box::new(try!(File::open(file_path))),"></div><div data-l="    };"></div><div data-l="    let mut rdr = csv::Reader::from_reader(input);"></div><div data-l="#    // The rest remains unchanged!"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The rest remains unchanged!</span>残りは変わりません！</span> </div><div data-l=}></div></div><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Error handling with a custom type</span>カスタムタイプによるエラー処理</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Previously, we learned how to <a href=#2#composing-custom-error-types>compose errors using a custom error type</a> .</span>以前は<a href=#2#composing-custom-error-types>、カスタムエラータイプを使用してエラーを構成する</a>方法を学習しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We did this by defining our error type as an <code>enum</code> and implementing <code>Error</code> and <code>From</code> .</span>これを行うには、エラータイプを<code>enum</code>型として定義し、 <code>Error</code>と<code>From</code>を実装します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Since we have three distinct errors (IO, CSV parsing and not found), let&#39;s define an <code>enum</code> with three variants:</span> 3つの異なるエラー（IO、CSV解析、見つからない）があるので、3つのバリアントを持つ<code>enum</code>を定義しましょう：</span> </p><br><div data-lang=rust,ignore><div data-l=#[derive(Debug)]></div><div data-l="enum CliError {"></div><div data-l="    Io(io::Error),"></div><div data-l="    Csv(csv::Error),"></div><div data-l="    NotFound,"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">And now for impls on <code>Display</code> and <code>Error</code> :</span>そして今、 <code>Display</code>と<code>Error</code>含意します：</span> </p><br><div data-lang=rust,ignore><div data-l="use std::fmt;"></div><div data-l=""></div><div data-l="impl fmt::Display for CliError {"></div><div data-l="    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {"></div><div data-l="        match *self {"></div><div data-l="            CliError::Io(ref err) =&gt; err.fmt(f),"></div><div data-l="            CliError::Csv(ref err) =&gt; err.fmt(f),"></div><div data-l="            CliError::NotFound =&gt; write!(f, &quot;No matching cities with a \"></div><div data-l="                                             population were found.&quot;),"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="impl Error for CliError {"></div><div data-l="    fn cause(&amp;self) -&gt; Option&lt;&amp;Error&gt; {"></div><div data-l="        match *self {"></div><div data-l="            CliError::Io(ref err) =&gt; Some(err),"></div><div data-l="            CliError::Csv(ref err) =&gt; Some(err),"></div><div data-l="#            // Our custom error doesn't have an underlying cause,"></div><div data-l="#            // but we could modify it so that it does."></div><div data-l="            // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Our custom error doesn&#39;t have an underlying cause, but we could modify it so that it does.</span>私たちのカスタムエラーには根本的な原因はありませんが、変更することができます。</span> </div><div data-l="            CliError::NotFound =&gt; None,"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Before we can use our <code>CliError</code> type in our <code>search</code> function, we need to provide a couple <code>From</code> impls.</span> <code>CliError</code>型を<code>search</code>関数で使用するには、 <code>CliError</code> 、 <code>From</code> implsというカップルを提供する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">How do we know which impls to provide?</span>どのようなインプラントが提供されるのかはどのようにわかりますか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Well, we&#39;ll need to convert from both <code>io::Error</code> and <code>csv::Error</code> to <code>CliError</code> .</span>さて、 <code>io::Error</code>と<code>csv::Error</code>両方を<code>CliError</code>に変換する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Those are the only external errors, so we&#39;ll only need two <code>From</code> impls for now:</span>これらは唯一の外部エラーであるため、ここ<code>From</code> 2つのインプレッションを必要とします：</span> </p><br><div data-lang=rust,ignore><div data-l="impl From&lt;io::Error&gt; for CliError {"></div><div data-l="    fn from(err: io::Error) -&gt; CliError {"></div><div data-l="        CliError::Io(err)"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="impl From&lt;csv::Error&gt; for CliError {"></div><div data-l="    fn from(err: csv::Error) -&gt; CliError {"></div><div data-l="        CliError::Csv(err)"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>From</code> impls are important because of how <a href=#2#code-try-def><code>try€</code> is defined</a> .</span> <code>From</code> implsは、 <a href=#2#code-try-def><code>try€</code></a>がどのように<a href=#2#code-try-def>定義されて</a>いるかによって重要です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In particular, if an error occurs, <code>From::from</code> is called on the error, which in this case, will convert it to our own error type <code>CliError</code> .</span>特に、エラーが発生した場合は、 <code>From::from</code>がエラーで呼び出されます。この場合、エラータイプ<code>CliError</code>変換されます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">With the <code>From</code> impls done, we only need to make two small tweaks to our <code>search</code> function: the return type and the “not found” error.</span> <code>From</code> impls doneを使用すると、 <code>search</code>関数の戻り値の型と &quot;見つからない&quot;という2つの小さな調整が必要になります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here it is in full:</span>ここにそれはいっぱいです：</span> </p><br><div data-lang=rust,ignore><div data-l="fn search&lt;P: AsRef&lt;Path&gt;&gt;"></div><div data-l="         (file_path: &amp;Option&lt;P&gt;, city: &amp;str)"></div><div data-l="         -&gt; Result&lt;Vec&lt;PopulationCount&gt;, CliError&gt; {"></div><div data-l="    let mut found = vec![];"></div><div data-l="    let input: Box&lt;io::Read&gt; = match *file_path {"></div><div data-l="        None =&gt; Box::new(io::stdin()),"></div><div data-l="        Some(ref file_path) =&gt; Box::new(try!(File::open(file_path))),"></div><div data-l="    };"></div><div data-l="    let mut rdr = csv::Reader::from_reader(input);"></div><div data-l="    for row in rdr.decode::&lt;Row&gt;() {"></div><div data-l="        let row = try!(row);"></div><div data-l="        match row.population {"></div><div data-l="#//            None =&gt; { } // Skip it."></div><div data-l="            None =&gt; { } // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Skip it.</span>それをスキップします。</span> </div><div data-l="            Some(count) =&gt; if row.city == city {"></div><div data-l="                found.push(PopulationCount {"></div><div data-l="                    city: row.city,"></div><div data-l="                    country: row.country,"></div><div data-l="                    count: count,"></div><div data-l="                });"></div><div data-l="            },"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l="    if found.is_empty() {"></div><div data-l="        Err(CliError::NotFound)"></div><div data-l="    } else {"></div><div data-l="        Ok(found)"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">No other changes are necessary.</span>その他の変更は必要ありません。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Adding functionality</span>機能の追加</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Writing generic code is great, because generalizing stuff is cool, and it can then be useful later.</span>一般的なコードを書くことは素晴らしいことです。一般化することはすばらしく、後で役に立ちます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But sometimes, the juice isn&#39;t worth the squeeze.</span>しかし時には、ジュースは圧搾に値するものではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Look at what we just did in the previous step:</span>前のステップで行ったことを見てください。</span> </p><br><div data-b=1.> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Defined a new error type.</span>新しいエラータイプを定義しました。</span> </div><div data-b=2.> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Added impls for <code>Error</code> , <code>Display</code> and two for <code>From</code> .</span>追加しましたimpls <code>Error</code> 、 <code>Display</code>とするための2つ<code>From</code> 。</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The big downside here is that our program didn&#39;t improve a whole lot.</span>ここでの大きな欠点は、私たちのプログラムが全体的に改善されなかったことです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There is quite a bit of overhead to representing errors with <code>enum</code> s, especially in short programs like this.</span> <code>enum</code>のエラーを表現するには、特にこのような短いプログラムではかなりのオーバーヘッドがあります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><i>One</i> useful aspect of using a custom error type like we&#39;ve done here is that the <code>main</code> function can now choose to handle errors differently.</span>ここで行ったようなカスタムエラータイプを使用する<i>1つの</i>有用な側面は、 <code>main</code>関数がエラーを別々に処理することを選択できるようにすることです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Previously, with <code>Box&lt;Error&gt;</code> , it didn&#39;t have much of a choice: just print the message.</span>以前は、 <code>Box&lt;Error&gt;</code>を使用していましたが、選択肢はあまりありませんでした。メッセージを印刷するだけです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;re still doing that here, but what if we wanted to, say, add a <code>--quiet</code> flag?</span>私たちはまだここでそれをやっていますが、もし<code>--quiet</code>フラグを追加したいとしたら？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>--quiet</code> flag should silence any verbose output.</span> <code>--quiet</code>フラグは冗長な出力を抑止します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Right now, if the program doesn&#39;t find a match, it will output a message saying so.</span>今のところ、プログラムが一致するものを見つけられなかった場合、それを示すメッセージが出力されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This can be a little clumsy, especially if you intend for the program to be used in shell scripts.</span>これは、特にあなたがシェルスクリプトでプログラムを使うつもりならば、ややこしいかもしれません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So let&#39;s start by adding the flags.</span>ですから、フラグを追加することから始めましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Like before, we need to tweak the usage string and add a flag to the Option variable.</span>前と同じように、使用文字列を調整し、Option変数にフラグを追加する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Once we&#39;ve done that, Getopts does the rest:</span>私たちがこれをしたら、Getoptsは残りを行います：</span> </p><br><div data-lang=rust,ignore><div data-l=...></div><div data-l="    let mut opts = Options::new();"></div><div data-l="    opts.optopt(&quot;f&quot;, &quot;file&quot;, &quot;Choose an input file, instead of using STDIN.&quot;, &quot;NAME&quot;);"></div><div data-l="    opts.optflag(&quot;h&quot;, &quot;help&quot;, &quot;Show this usage message.&quot;);"></div><div data-l="    opts.optflag(&quot;q&quot;, &quot;quiet&quot;, &quot;Silences errors and warnings.&quot;);"></div><div data-l=...></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now we only need to implement our “quiet” functionality.</span>これで &quot;静かな&quot;機能を実装するだけです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This requires us to tweak the case analysis in <code>main</code> :</span>これは、 <code>main</code>ケース分析を微調整する必要があります。</span> </p><br><div data-lang=rust,ignore><div data-l="use std::process;"></div><div data-l=...></div><div data-l="    match search(&amp;data_path, city) {"></div><div data-l="        Err(CliError::NotFound) if matches.opt_present(&quot;q&quot;) =&gt; process::exit(1),"></div><div data-l="        Err(err) =&gt; panic!(&quot;{}&quot;, err),"></div><div data-l="        Ok(pops) =&gt; for pop in pops {"></div><div data-l="            println!(&quot;{}, {}: {:?}&quot;, pop.city, pop.country, pop.count);"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=...></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Certainly, we don&#39;t want to be quiet if there was an IO error or if the data failed to parse.</span>確かに、私たちはIOエラーがあった場合、またはデータが解析できなかった場合には静かではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Therefore, we use case analysis to check if the error type is <code>NotFound</code> <i>and</i> if <code>--quiet</code> has been enabled.</span>したがって、我々は、エラーの種類があるかどうかを確認するためにケースの分析を使用し<code>NotFound</code>場合<i>と</i> <code>--quiet</code>有効になっています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If the search failed, we still quit with an exit code (following <code>grep</code> &#39;s convention).</span>検索が失敗した場合でも、終了コード（ <code>grep</code>の規則に従って）で終了します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we had stuck with <code>Box&lt;Error&gt;</code> , then it would be pretty tricky to implement the <code>--quiet</code> functionality.</span> <code>Box&lt;Error&gt;</code>で動かなかった場合、-- <code>--quiet</code>機能を実装するのはかなり難しいでしょう。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This pretty much sums up our case study.</span>これは私たちのケーススタディをかなり要約しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">From here, you should be ready to go out into the world and write your own programs and libraries with proper error handling.</span>ここから、あなたは世界に出かけて、適切なエラー処理をして独自のプログラムとライブラリを書く準備ができているはずです。</span> </p><br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The Short Story</span>ショート・ストーリー</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Since this section is long, it is useful to have a quick summary for error handling in Rust.</span>このセクションは長いので、Rustのエラー処理についての簡単な要約があると便利です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These are some good “rules of thumb.&quot; They are emphatically <i>not</i> commandments. There are probably good reasons to break every one of these heuristics!</span>これらは、いくつかの良い「経験則」です。これらは、重大な戒めではあり<i>ません</i> 。これらの経験則のすべてを破る良い理由があります。</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you&#39;re writing short example code that would be overburdened by error handling, it&#39;s probably fine to use <code>unwrap</code> (whether that&#39;s <a class=notranslate href=#2../../std/result/enum.Result.html#method.unwrap><code>Result::unwrap</code></a> , <a class=notranslate href=#2../../std/option/enum.Option.html#method.unwrap><code>Option::unwrap</code></a> or preferably <a class=notranslate href=#2../../std/option/enum.Option.html#method.expect><code>Option::expect</code></a> ).</span>エラー処理によって過負荷になるような短いサンプルコードを書いているのなら、おそらく<code>unwrap</code> （ <a class=notranslate href=#2../../std/result/enum.Result.html#method.unwrap><code>Result::unwrap</code></a> 、 <a class=notranslate href=#2../../std/option/enum.Option.html#method.unwrap><code>Option::unwrap</code></a>または<a class=notranslate href=#2../../std/option/enum.Option.html#method.expect><code>Option::expect</code></a> ）を使用しても問題ありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Consumers of your code should know to use proper error handling.</span>コードの消費者は、適切なエラー処理を使用することを知っている必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">(If they don&#39;t, send them here!)</span> （そうでない場合は、ここに送ってください！）</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you&#39;re writing a quick &#39;n&#39; dirty program, don&#39;t feel ashamed if you use <code>unwrap</code> .</span>クイックアンドダーティプログラムを書いているのなら、 <code>unwrap</code>を使うと恥ずかしがり屋ではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Be warned: if it winds up in someone else&#39;s hands, don&#39;t be surprised if they are agitated by poor error messages!</span>警告：誰かの手の中に巻き込まれている場合は、エラーメッセージが貧弱になっても驚かないでください！</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you&#39;re writing a quick &#39;n&#39; dirty program and feel ashamed about panicking anyway, then use either a <code>String</code> or a <code>Box&lt;Error&gt;</code> for your error type.</span>クイックアンドダーティープログラムを作成していて、とにかくパニックになるのを恥ずかしく思っているなら、あなたのエラータイプには<code>String</code>か<code>Box&lt;Error&gt;</code>を使います。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Otherwise, in a program, define your own error types with appropriate <a class=notranslate href=#2../../std/convert/trait.From.html><code>From</code></a> and <a class=notranslate href=#2../../std/error/trait.Error.html><code>Error</code></a> impls to make the <a class=notranslate href=#2../../std/macro.try.html><code>try€</code></a> macro more ergonomic.</span>それ以外の場合は、プログラム内で、適切な<a class=notranslate href=#2../../std/convert/trait.From.html><code>From</code></a>と<a class=notranslate href=#2../../std/error/trait.Error.html><code>Error</code></a> implsを使用して独自のエラータイプを定義し、 <a class=notranslate href=#2../../std/macro.try.html><code>try€</code></a> macroをより人間工学的にする。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you&#39;re writing a library and your code can produce errors, define your own error type and implement the <a class=notranslate href=#2../../std/error/trait.Error.html><code>std::error::Error</code></a> trait.</span>ライブラリを作成しているときにコードでエラーが発生する場合は、独自のエラータイプを定義し、 <a class=notranslate href=#2../../std/error/trait.Error.html><code>std::error::Error</code></a>特性を実装して<a class=notranslate href=#2../../std/error/trait.Error.html><code>std::error::Error</code></a> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Where appropriate, implement <a class=notranslate href=#2../../std/convert/trait.From.html><code>From</code></a> to make both your library code and the caller&#39;s code easier to write.</span>必要に応じて、 <a class=notranslate href=#2../../std/convert/trait.From.html><code>From</code></a>を実装して、ライブラリのコードと呼び出し元のコードの両方を簡単に書くことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">(Because of Rust&#39;s coherence rules, callers will not be able to impl <code>From</code> on your error type, so your library should do it.)</span> （Rustの一貫性の規則のため、呼び出し元はあなたのエラータイプ<code>From</code>インプリメントを行うことができないので、ライブラリはそれを行う必要があります。）</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Learn the combinators defined on <a class=notranslate href=#2../../std/option/enum.Option.html><code>Option</code></a> and <a class=notranslate href=#2../../std/result/enum.Result.html><code>Result</code></a> .</span> <a class=notranslate href=#2../../std/option/enum.Option.html><code>Option</code></a>と<a class=notranslate href=#2../../std/result/enum.Result.html><code>Result</code></a>定義されたコンビネータを学んでください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Using them exclusively can be a bit tiring at times, but I&#39;ve personally found a healthy mix of <code>try€</code> and combinators to be quite appealing.</span>それらを独占的に使用することは時々少し疲れることがありますが、私は個人的には魅力的な<code>try€</code>とcombinatorsの健康な組み合わせを見つけました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>and_then</code> , <code>map</code> and <code>unwrap_or</code> are my favorites.</span> <code>and_then</code> 、 <code>map</code>と<code>unwrap_or</code>は私のお気に入りです。</span> </div><br> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a class=notranslate href=#1patterns.html>1</a> <a class=notranslate href=#1../../std/option/enum.Option.html#method.map>2</a> <a class=notranslate href=#1../../std/option/enum.Option.html#method.unwrap_or>3</a> <a class=notranslate href=#1../../std/option/enum.Option.html#method.unwrap_or_else>4</a> <a class=notranslate href=#1../../std/option/enum.Option.html>5</a> <a class=notranslate href=#1../../std/result/index.html>6</a> <a class=notranslate href=#1../../std/result/enum.Result.html#method.unwrap>7</a> <a class=notranslate href=#1../../std/fmt/trait.Debug.html>8</a> <a class=notranslate href=#1../../std/primitive.str.html#method.parse>9</a> <a class=notranslate href=#1associated-types.html>10</a> <a class=notranslate href=#1https://github.com/petewarden/dstkdata>11</a> <a class=notranslate href=#1http://burntsushi.net/stuff/worldcitiespop.csv.gz>12</a> <a class=notranslate href=#1http://burntsushi.net/stuff/uscitiespop.csv.gz>13</a> <a class=notranslate href=#1http://doc.crates.io/guide.html>14</a> <a class=notranslate href=#1http://doc.rust-lang.org/getopts/getopts/index.html>15</a></span> <a class=notranslate href=#1patterns.html>1</a> <a class=notranslate href=#1../../std/option/enum.Option.html#method.map>2</a> <a class=notranslate href=#1../../std/option/enum.Option.html#method.unwrap_or>3</a> <a class=notranslate href=#1../../std/option/enum.Option.html#method.unwrap_or_else>4</a> <a class=notranslate href=#1../../std/option/enum.Option.html>5</a> <a class=notranslate href=#1../../std/result/index.html>6</a> <a class=notranslate href=#1../../std/result/enum.Result.html#method.unwrap>7</a> <a class=notranslate href=#1../../std/fmt/trait.Debug.html>8</a> <a class=notranslate href=#1../../std/primitive.str.html#method.parse>9</a> <a class=notranslate href=#1associated-types.html>10</a> <a class=notranslate href=#1https://github.com/petewarden/dstkdata>11</a> <a class=notranslate href=#1http://burntsushi.net/stuff/worldcitiespop.csv.gz>12</a> <a class=notranslate href=#1http://burntsushi.net/stuff/uscitiespop.csv.gz>13</a> <a class=notranslate href=#1http://doc.crates.io/guide.html>14</a> <a class=notranslate href=#1http://doc.rust-lang.org/getopts/getopts/index.html>15</a></span>
<script>_addload(function(){_setupIW('com');_csi('en','ja','error-handling-2.html');});</script>