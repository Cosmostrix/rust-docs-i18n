<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180709_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=references-and-borrowing.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">References and Borrowing</span>参照と借用</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is the second of three sections presenting Rust&#39;s ownership system.</span>これは、Rustの所有システムを提示する3つのセクションのうちの2番目です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is one of Rust&#39;s most distinct and compelling features, with which Rust developers should become quite acquainted.</span>これは、Rustの最も顕著で魅力的な機能の1つで、Rustの開発者はかなり知り合いになるはずです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Ownership is how Rust achieves its largest goal, memory safety.</span>所有権とは、Rustが最大の目標であるメモリの安全性を達成する方法です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There are a few distinct concepts, each with its own chapter:</span>いくつかの異なる概念があり、それぞれ独自の章があります。</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a class=notranslate href=#3ownership>ownership</a> , the key concept</span> <a class=notranslate href=#3ownership>ownership</a> 、キーコンセプト</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">borrowing, which you&#39;re reading now</span>あなたが今読んでいる借り</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a class=notranslate href=#3lifetimes>lifetimes</a> , an advanced concept of borrowing</span> <a class=notranslate href=#3lifetimes>lifetimes</a> 、高度な借入概念</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These three chapters are related, and in order.</span>これら3つの章は関連しており、順番に説明されています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You&#39;ll need all three to fully understand the ownership system.</span>所有権システムを完全に理解するには、3つすべてが必要です。</span> </p><br> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a class=notranslate href=#1ownership.html>ownership</a> <a class=notranslate href=#1lifetimes.html>lifetimes</a></span> <a class=notranslate href=#1ownership.html>ownership</a> <a class=notranslate href=#1lifetimes.html>lifetimes</a></span> <br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Meta</span>メタ</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Before we get to the details, two important notes about the ownership system.</span>詳細を知る前に、オーナーシップシステムに関する2つの重要な注意事項。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust has a focus on safety and speed.</span>錆は安全性とスピードに焦点を当てています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It accomplishes these goals through many &#39;zero-cost abstractions&#39;, which means that in Rust, abstractions cost as little as possible in order to make them work.</span>これは、多くの「ゼロコスト抽象化」によってこれらの目標を達成します。つまり、Rustでは抽象化のコストをできるだけ少なくして機能させることを意味します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The ownership system is a prime example of a zero-cost abstraction.</span>所有権システムは、ゼロコスト抽象化の主要な例です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">All of the analysis we&#39;ll talk about in this guide is <s>done at compile time</s> .</span>このガイド<s>で説明する</s>すべての分析は<s>、コンパイル時に行われます</s> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You do not pay any run-time cost for any of these features.</span>これらの機能のランタイムコストを支払うことはありません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, this system does have a certain cost: learning curve.</span>しかし、このシステムには一定のコストがあります：学習曲線。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Many new users to Rust experience something we like to call &#39;fighting with the borrow checker&#39;, where the Rust compiler refuses to compile a program that the author thinks is valid.</span> Rustの新しいユーザーの多くは、Rustコンパイラが作成者が有効だと思うプログラムをコンパイルすることを拒否する「borrow checkerとの戦い」と呼ばれることを経験しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This often happens because the programmer&#39;s mental model of how ownership should work doesn&#39;t match the actual rules that Rust implements.</span>これは、所有者がどのように動作するかについてのプログラマーの精神モデルが、Rustが実装する実際のルールと一致しないためによく発生します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You probably will experience similar things at first.</span>最初は似たようなことを経験するでしょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There is good news, however: more experienced Rust developers report that once they work with the rules of the ownership system for a period of time, they fight the borrow checker less and less.</span>ただし、経験豊かなRustデベロッパーは、所有システムのルールを一定期間使用すると、借りチェッカーとの競争が少なくなることを報告しています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">With that in mind, let&#39;s learn about borrowing.</span>それを念頭において、借り入れについて学びましょう。</span> </p><br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Borrowing</span>借りる</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">At the end of the <a class=notranslate href=#3ownership>ownership</a> section, we had a nasty function that looked like this:</span> <a class=notranslate href=#3ownership>ownership</a>セクションの最後には、次のような厄介な機能がありました。</span> </p><br><div data-lang=rust><div data-l="fn foo(v1: Vec&lt;i32&gt;, v2: Vec&lt;i32&gt;) -&gt; (Vec&lt;i32&gt;, Vec&lt;i32&gt;, i32) {"></div><div data-l="#    // Do stuff with `v1` and `v2`."></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Do stuff with <code>v1</code> and <code>v2</code> .</span> <code>v1</code>と<code>v2</code>ものを使ってください。</span> </div><div data-l=""></div><div data-l="#    // Hand back ownership, and the result of our function."></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Hand back ownership, and the result of our function.</span>手持ちの所有権と私たちの機能の結果。</span> </div><div data-l="    (v1, v2, 42)"></div><div data-l=}></div><div data-l=""></div><div data-l="let v1 = vec![1, 2, 3];"></div><div data-l="let v2 = vec![1, 2, 3];"></div><div data-l=""></div><div data-l="let (v1, v2, answer) = foo(v1, v2);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is not idiomatic Rust, however, as it doesn&#39;t take advantage of borrowing.</span>しかし、借用を利用していないので、これは慣用的な錆ではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here&#39;s the first step:</span>ここでは最初のステップです：</span> </p><br><div data-lang=rust><div data-l="fn foo(v1: &amp;Vec&lt;i32&gt;, v2: &amp;Vec&lt;i32&gt;) -&gt; i32 {"></div><div data-l="#    // Do stuff with `v1` and `v2`."></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Do stuff with <code>v1</code> and <code>v2</code> .</span> <code>v1</code>と<code>v2</code>ものを使ってください。</span> </div><div data-l=""></div><div data-l="#    // Return the answer."></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Return the answer.</span>答えを返します。</span> </div><div data-l="    42"></div><div data-l=}></div><div data-l=""></div><div data-l="let v1 = vec![1, 2, 3];"></div><div data-l="let v2 = vec![1, 2, 3];"></div><div data-l=""></div><div data-l="let answer = foo(&amp;v1, &amp;v2);"></div><div data-l=""></div><div data-l="#// We can use `v1` and `v2` here!"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can use <code>v1</code> and <code>v2</code> here!</span>ここで<code>v1</code>と<code>v2</code>を使うことができます！</span> </div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A more concrete example:</span>より具体的な例：</span> </p><br><div data-lang=rust><div data-l="fn main() {"></div><div data-l="#    // Don't worry if you don't understand how `fold` works, the point here is that an immutable reference is borrowed."></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Don&#39;t worry if you don&#39;t understand how <code>fold</code> works, the point here is that an immutable reference is borrowed.</span> <code>fold</code>仕組みがわからない場合は心配しないでください。ここでのポイントは、不変のリファレンスが借用されていることです。</span> </div><div data-l="    fn sum_vec(v: &amp;Vec&lt;i32&gt;) -&gt; i32 {"></div><div data-l="        v.iter().fold(0, |a, &amp;b| a + b)"></div><div data-l="    }"></div><div data-l="#    // Borrow two vectors and sum them."></div><div data-l="#    // This kind of borrowing does not allow mutation through the borrowed reference."></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Borrow two vectors and sum them.</span> 2つのベクトルを借りて合計します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This kind of borrowing does not allow mutation through the borrowed reference.</span>このような借り入れは、借用された参照による突然変異を許さない。</span> </div><div data-l="    fn foo(v1: &amp;Vec&lt;i32&gt;, v2: &amp;Vec&lt;i32&gt;) -&gt; i32 {"></div><div data-l="#        // Do stuff with `v1` and `v2`."></div><div data-l="        // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Do stuff with <code>v1</code> and <code>v2</code> .</span> <code>v1</code>と<code>v2</code>ものを使ってください。</span> </div><div data-l="        let s1 = sum_vec(v1);"></div><div data-l="        let s2 = sum_vec(v2);"></div><div data-l="#        // Return the answer."></div><div data-l="        // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Return the answer.</span>答えを返します。</span> </div><div data-l="        s1 + s2"></div><div data-l="    }"></div><div data-l=""></div><div data-l="    let v1 = vec![1, 2, 3];"></div><div data-l="    let v2 = vec![4, 5, 6];"></div><div data-l=""></div><div data-l="    let answer = foo(&amp;v1, &amp;v2);"></div><div data-l="    println!(&quot;{}&quot;, answer);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Instead of taking <code>Vec&lt;i32&gt;</code> s as our arguments, we take a reference: <code>&amp;Vec&lt;i32&gt;</code> .</span> <code>Vec&lt;i32&gt;</code>引数として取るのではなく、 <code>&amp;Vec&lt;i32&gt;</code>参照します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">And instead of passing <code>v1</code> and <code>v2</code> directly, we pass <code>&amp;v1</code> and <code>&amp;v2</code> .</span>そして、 <code>v1</code>と<code>v2</code>直接渡す代わりに、 <code>&amp;v1</code>と<code>&amp;v2</code>を渡します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We call the <code>&amp;T</code> type a &#39;reference&#39;, and rather than owning the resource, it borrows ownership.</span> <code>&amp;T</code>タイプは「参照」と呼ばれ、リソースを所有するのではなく、所有権を借りています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A binding that borrows something does not deallocate the resource when it goes out of scope.</span>何かを借りるバインディングは、リソースが範囲外になったときにリソースの割り当てを解除しません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This means that after the call to <code>foo()</code> , we can use our original bindings again.</span>これは、 <code>foo()</code>呼び出しの後、元のバインディングを再度使用できることを意味します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">References are immutable, like bindings.</span>参照はバインドのように不変です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This means that inside of <code>foo()</code> , the vectors can&#39;t be changed at all:</span>つまり、 <code>foo()</code>内部では、ベクトルをまったく変更することはできません。</span> </p><br><div data-lang=rust,ignore><div data-l="fn foo(v: &amp;Vec&lt;i32&gt;) {"></div><div data-l="     v.push(5);"></div><div data-l=}></div><div data-l=""></div><div data-l="let v = vec![];"></div><div data-l=""></div><div data-l=foo(&amp;v);></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">will give us this error:</span>私たちにこのエラーを与えるでしょう：</span> </p><br><div data-lang=text><div data-l="error: cannot borrow immutable borrowed content `*v` as mutable"></div><div data-l=v.push(5);></div><div data-l=^></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Pushing a value mutates the vector, and so we aren&#39;t allowed to do it.</span>値を押すとベクトルが変化するので、それを行うことはできません。</span> </p><br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">&amp;mut references</span> mutリファレンス（＆M）</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There&#39;s a second kind of reference: <code>&amp;mut T</code> .</span> 2番目の種類の参照： <code>&amp;mut T</code>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A &#39;mutable reference&#39; allows you to mutate the resource you&#39;re borrowing.</span> &#39;mutable reference&#39;は、あなたが借りているリソースを突然変異させることを可能にします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example:</span>例えば：</span> </p><br><div data-lang=rust><div data-l="let mut x = 5;"></div><div data-l={></div><div data-l="    let y = &amp;mut x;"></div><div data-l="    *y += 1;"></div><div data-l=}></div><div data-l="println!(&quot;{}&quot;, x);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This will print <code>6</code> .</span>これにより、 <code>6</code>が印刷されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We make <code>y</code> a mutable reference to <code>x</code> , then add one to the thing <code>y</code> points at.</span> <code>y</code>を<code>x</code>変更可能な参照とし、 <code>y</code>点に追加する。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You&#39;ll notice that <code>x</code> had to be marked <code>mut</code> as well.</span>あなたは<code>x</code>も<code>mut</code>とマークされなければならないことに気付くでしょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If it wasn&#39;t, we couldn&#39;t take a mutable borrow to an immutable value.</span>もしそうでなければ、不変の価値に変更可能な借り入れをすることができませんでした。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You&#39;ll also notice we added an asterisk ( <code>*</code> ) in front of <code>y</code> , making it <code>*y</code> , this is because <code>y</code> is a <code>&amp;mut</code> reference.</span>あなたはまた、我々はアスタリスク（追加気付くでしょう<code>*</code>目の前に） <code>y</code>それ作り、 <code>*y</code>ためである、 <code>y</code>ある<code>&amp;mut</code>参照。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You&#39;ll need to use asterisks to access the contents of a reference as well.</span>参照の内容にもアスタリスクを使用する必要があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Otherwise, <code>&amp;mut</code> references are like references.</span>それ以外の場合、 <code>&amp;mut</code>リファレンスは同じ参照です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There <s>is</s> a large difference between the two, and how they interact, though.</span> 2、およびそれらがどのようにかかわらず、対話の間には大きな違いが<s>あり</s>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can tell something is fishy in the above example, because we need that extra scope, with the <code>{</code> and <code>}</code> .</span>上記の例では、 <code>{</code>と<code>}</code>で余分なスコープが必要なので、何かが怪しいと言うことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we remove them, we get an error:</span>削除した場合、エラーが発生します：</span> </p><br><div data-lang=text><div data-l="error: cannot borrow `x` as immutable because it is also borrowed as mutable"></div><div data-l="    println!(&quot;{}&quot;, x);"></div><div data-l="                   ^"></div><div data-l="note: previous borrow of `x` occurs here; the mutable borrow prevents"></div><div data-l="subsequent moves, borrows, or modification of `x` until the borrow ends"></div><div data-l="        let y = &amp;mut x;"></div><div data-l="                     ^"></div><div data-l="note: previous borrow ends here"></div><div data-l="fn main() {"></div><div data-l=""></div><div data-l=}></div><div data-l=^></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As it turns out, there are rules.</span>それが判明したので、規則があります。</span> </p><br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The Rules</span>ルール</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here are the rules for borrowing in Rust:</span> Rustで借りるための規則は次のとおりです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">First, any borrow must last for a scope no greater than that of the owner.</span>まず、借り入れは所有者の範囲を超えない範囲で継続する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Second, you may have one or the other of these two kinds of borrows, but not both at the same time:</span>第二に、これらの2種類の借用のどちらか一方を持つことができますが、同時に両方を使うことはできません。</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">one or more references ( <code>&amp;T</code> ) to a resource,</span> 1つまたは複数のリソースへの参照（ <code>&amp;T</code> ）</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">exactly one mutable reference ( <code>&amp;mut T</code> ).</span>正確に1つの可変参照（ <code>&amp;mut T</code> ）。</span> </div><br><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You may notice that this is very similar to, though not exactly the same as, the definition of a data race:</span>これは、データレースの定義とまったく同じではありませんが、これと非常によく似ています。</span> </p><br><blockquote><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There is a &#39;data race&#39; when two or more pointers access the same memory location at the same time, where at least one of them is writing, and the operations are not synchronized.</span> 2つ以上のポインタが同じメモリ位置に同時にアクセスするときに、それらのうちの少なくとも1つが書き込みを行っており、その動作が同期されていない場合、「データ競合」が存在する。</span> </p></blockquote><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">With references, you may have as many as you&#39;d like, since none of them are writing.</span>参考文献では、どれもあなたが好きなだけ書くことはできません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, as we can only have one <code>&amp;mut</code> at a time, it is impossible to have a data race.</span>しかし、一度に1つの<code>&amp;mut</code>しか持つことができないため、データ競争は不可能です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is how Rust prevents data races at compile time: we&#39;ll get errors if we break the rules.</span>これは、Rustがコンパイル時にデータ競合を防止する方法です。規則を破るとエラーが発生します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">With this in mind, let&#39;s consider our example again.</span>これを念頭に置いて、例をもう一度考えてみましょう。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Thinking in scopes</span>スコープで考える</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here&#39;s the code:</span>コードは次のとおりです：</span> </p><br><div data-lang=rust,ignore><div data-l="fn main() {"></div><div data-l="    let mut x = 5;"></div><div data-l="    let y = &amp;mut x;"></div><div data-l=""></div><div data-l="    *y += 1;"></div><div data-l=""></div><div data-l="    println!(&quot;{}&quot;, x);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This code gives us this error:</span>このコードは私たちにこのエラーを与えます：</span> </p><br><div data-lang=text><div data-l="error: cannot borrow `x` as immutable because it is also borrowed as mutable"></div><div data-l="    println!(&quot;{}&quot;, x);"></div><div data-l="                   ^"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is because we&#39;ve violated the rules: we have a <code>&amp;mut T</code> pointing to <code>x</code> , and so we aren&#39;t allowed to create any <code>&amp;T</code> s.</span>これは、我々がルールに違反したためです： <code>x</code>指している<code>&amp;mut T</code>があるため、 <code>&amp;T</code>を作成することはできません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It&#39;s one or the other.</span>それはどちらか一方です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The note hints at how to think about this problem:</span>ノートは、この問題についてどのように考えるべきかを示唆しています。</span> </p><br><div data-lang=text><div data-l="note: previous borrow ends here"></div><div data-l="fn main() {"></div><div data-l=""></div><div data-l=}></div><div data-l=^></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In other words, the mutable borrow is held through the rest of our example.</span>言い換えれば、変更可能な借り入れは、残りの例を介して保持されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">What we want is for the mutable borrow by <code>y</code> to end so that the resource can be returned to the owner, <code>x</code> .</span>私たちが望むのは、リソースが所有者<code>x</code>返されるように、 <code>y</code>が終了する可変の借用です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>x</code> can then provide an immutable borrow to <code>println€</code> .</span> <code>x</code>は<code>println€</code>不変の借用を提供することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In Rust, borrowing is tied to the scope that the borrow is valid for.</span> Rustでは、借り入れは借用が有効な範囲に縛られています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">And our scopes look like this:</span>スコープは次のようになります。</span> </p><br><div data-lang=rust,ignore><div data-l="fn main() {"></div><div data-l="    let mut x = 5;"></div><div data-l=""></div><div data-l="#//    let y = &amp;mut x;    // -+ &amp;mut borrow of `x` starts here."></div><div data-l="#                       //  |"></div><div data-l="    let y = &amp;mut x;    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">-+ &amp;mut borrow of <code>x</code> starts here.</span>ここでは<code>x</code> +＆mut borrowが始まります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">|</span> |</span> </div><div data-l="#//    *y += 1;           //  |"></div><div data-l="#                       //  |"></div><div data-l="    *y += 1;           // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">|</span> |</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">|</span> |</span> </div><div data-l="#//    println!(&quot;{}&quot;, x); // -+ - Try to borrow `x` here."></div><div data-l="    println!(&quot;{}&quot;, x); // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">-+ - Try to borrow <code>x</code> here.</span> -  +  - ここで<code>x</code>を借りてみてください。</span> </div><div data-l="#//}                      // -+ &amp;mut borrow of `x` ends here."></div><div data-l="}                      // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">-+ &amp;mut borrow of <code>x</code> ends here.</span> -  +＆mutの<code>x</code>借用はここで終わります。</span> </div><div data-l="                       "></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The scopes conflict: we can&#39;t make an <code>&amp;x</code> while <code>y</code> is in scope.</span>スコープの競合： <code>y</code>がスコープ内にある<code>&amp;x</code>を作ることはできません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So when we add the curly braces:</span>したがって、中括弧を追加すると：</span> </p><br><div data-lang=rust><div data-l="let mut x = 5;"></div><div data-l=""></div><div data-l={></div><div data-l="#//    let y = &amp;mut x; // -+ &amp;mut borrow starts here."></div><div data-l="    let y = &amp;mut x; // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">-+ &amp;mut borrow starts here.</span> -  +＆mut borrowはここから始まります。</span> </div><div data-l="#//    *y += 1;        //  |"></div><div data-l="    *y += 1;        // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">|</span> |</span> </div><div data-l="#//}                   // -+ ... and ends here."></div><div data-l="}                   // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">-+ ... and ends here.</span> -  + ...ここで終わります。</span> </div><div data-l=""></div><div data-l="#//println!(&quot;{}&quot;, x);  // &lt;- Try to borrow `x` here."></div><div data-l="println!(&quot;{}&quot;, x);  // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">&lt;- Try to borrow <code>x</code> here.</span> &lt; - ここで<code>x</code>を借りてみてください。</span> </div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There&#39;s no problem.</span>何も問題ない。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Our mutable borrow goes out of scope before we create an immutable one.</span>不変のものを作る前に、私たちの可変的な借りは範囲外になります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So scope is the key to seeing how long a borrow lasts for.</span>スコープは、借りがどれくらい持続するかを見るための鍵です。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Issues borrowing prevents</span>借入問題は防止する</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Why have these restrictive rules?</span>なぜこれらの制限的な規則はありますか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Well, as we noted, these rules prevent data races.</span>さて、われわれが指摘したように、これらのルールはデータ競合を防ぎます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">What kinds of issues do data races cause?</span>データ競争の原因となる問題は何ですか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here are a few.</span>ここにいくつかあります。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Iterator invalidation</span>イテレータの無効化</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">One example is &#39;iterator invalidation&#39;, which happens when you try to mutate a collection that you&#39;re iterating over.</span> 1つの例は &#39;iterator invalidation&#39;です。反復処理中のコレクションを変更しようとすると発生します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust&#39;s borrow checker prevents this from happening:</span> Rustの借用チェッカーがこれを防ぐ：</span> </p><br><div data-lang=rust><div data-l="let mut v = vec![1, 2, 3];"></div><div data-l=""></div><div data-l="for i in &amp;v {"></div><div data-l="    println!(&quot;{}&quot;, i);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This prints out one through three.</span>これは1から3までを印刷します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As we iterate through the vector, we&#39;re only given references to the elements.</span>ベクトルを反復処理するとき、要素への参照のみが与えられます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">And <code>v</code> is itself borrowed as immutable, which means we can&#39;t change it while we&#39;re iterating:</span>そして、 <code>v</code>自体は不変として借用されています。つまり、反復処理中に変更することはできません。</span> </p><br><div data-lang=rust,ignore><div data-l="let mut v = vec![1, 2, 3];"></div><div data-l=""></div><div data-l="for i in &amp;v {"></div><div data-l="    println!(&quot;{}&quot;, i);"></div><div data-l="    v.push(34);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here&#39;s the error:</span>ここにエラーがあります：</span> </p><br><div data-lang=text><div data-l="error: cannot borrow `v` as mutable because it is also borrowed as immutable"></div><div data-l="    v.push(34);"></div><div data-l="    ^"></div><div data-l="note: previous borrow of `v` occurs here; the immutable borrow prevents"></div><div data-l="subsequent moves or mutable borrows of `v` until the borrow ends"></div><div data-l="for i in &amp;v {"></div><div data-l="          ^"></div><div data-l="note: previous borrow ends here"></div><div data-l="for i in &amp;v {"></div><div data-l="    println!(“{}”, i);"></div><div data-l="    v.push(34);"></div><div data-l=}></div><div data-l=^></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can&#39;t modify <code>v</code> because it&#39;s borrowed by the loop.</span> <code>v</code>がループによって借用されているため、 <code>v</code>変更することはできません。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Use after free</span>無料で使用する</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">References must not live longer than the resource they refer to.</span>参照は参照するリソースより長く生きてはならない。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust will check the scopes of your references to ensure that this is true.</span> Rustはあなたの参照のスコープをチェックして、これが正しいことを確認します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If Rust didn&#39;t check this property, we could accidentally use a reference which was invalid.</span> Rustがこのプロパティをチェックしなかった場合、誤って無効な参照を使用する可能性があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example:</span>例えば：</span> </p><br><div data-lang=rust,ignore><div data-l="let y: &amp;i32;"></div><div data-l={></div><div data-l="    let x = 5;"></div><div data-l="    y = &amp;x;"></div><div data-l=}></div><div data-l=""></div><div data-l="println!(&quot;{}&quot;, y);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We get this error:</span>このエラーが発生します：</span> </p><br><div data-lang=text><div data-l="error: `x` does not live long enough"></div><div data-l="    y = &amp;x;"></div><div data-l="         ^"></div><div data-l="note: reference must be valid for the block suffix following statement 0 at"></div><div data-l=2:16...></div><div data-l="let y: &amp;i32;"></div><div data-l={></div><div data-l="    let x = 5;"></div><div data-l="    y = &amp;x;"></div><div data-l=}></div><div data-l=""></div><div data-l="note: ...but borrowed value is only valid for the block suffix following"></div><div data-l="statement 0 at 4:18"></div><div data-l="    let x = 5;"></div><div data-l="    y = &amp;x;"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In other words, <code>y</code> is only valid for the scope where <code>x</code> exists.</span>つまり、 <code>y</code>は<code>x</code>が存在するスコープに対してのみ有効です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As soon as <code>x</code> goes away, it becomes invalid to refer to it.</span> <code>x</code>がなくなると、それを参照するのが無効になります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As such, the error says that the borrow &#39;doesn&#39;t live long enough&#39; because it&#39;s not valid for the right amount of time.</span>そのようなエラーは、借りている時間が適切ではないため、「十分に長く生きていない」と言います。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The same problem occurs when the reference is declared <s>before</s> the variable it refers to.</span>同じ問題は、変数が参照さ<s>れる前に</s>参照が宣言されている場合に発生します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is because resources within the same scope are freed in the opposite order they were declared:</span>これは、同じスコープ内のリソースが宣言された順序と反対の順序で解放されるためです。</span> </p><br><div data-lang=rust,ignore><div data-l="let y: &amp;i32;"></div><div data-l="let x = 5;"></div><div data-l="y = &amp;x;"></div><div data-l=""></div><div data-l="println!(&quot;{}&quot;, y);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We get this error:</span>このエラーが発生します：</span> </p><br><div data-lang=text><div data-l="error: `x` does not live long enough"></div><div data-l="y = &amp;x;"></div><div data-l="     ^"></div><div data-l="note: reference must be valid for the block suffix following statement 0 at"></div><div data-l=2:16...></div><div data-l="    let y: &amp;i32;"></div><div data-l="    let x = 5;"></div><div data-l="    y = &amp;x;"></div><div data-l=""></div><div data-l="    println!(&quot;{}&quot;, y);"></div><div data-l=}></div><div data-l=""></div><div data-l="note: ...but borrowed value is only valid for the block suffix following"></div><div data-l="statement 1 at 3:14"></div><div data-l="    let x = 5;"></div><div data-l="    y = &amp;x;"></div><div data-l=""></div><div data-l="    println!(&quot;{}&quot;, y);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In the above example, <code>y</code> is declared before <code>x</code> , meaning that <code>y</code> lives longer than <code>x</code> , which is not allowed.</span>上記の例では、 <code>y</code>は<code>x</code>前に宣言されています。つまり、 <code>y</code>は<code>x</code>よりも長く存続しますが、これは許可されません。</span> </p><script>_addload(function(){_setupIW('com');_csi('en','ja','references-and-borrowing.html');});</script>