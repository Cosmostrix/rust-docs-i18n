<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180709_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=deref-coercions.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>Deref</code> coercions</span> <code>Deref</code>強制</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The standard library provides a special trait, <a class=notranslate href=#3deref><code>Deref</code></a> .</span>標準ライブラリは特別な特性<a class=notranslate href=#3deref><code>Deref</code></a>提供します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It&#39;s normally used to overload <code>*</code> , the dereference operator:</span>これは、通常、デリファレンス演算子<code>*</code>をオーバーロードするために使用されます。</span> </p><br><div data-lang=rust><div data-l="use std::ops::Deref;"></div><div data-l=""></div><div data-l="struct DerefExample&lt;T&gt; {"></div><div data-l="    value: T,"></div><div data-l=}></div><div data-l=""></div><div data-l="impl&lt;T&gt; Deref for DerefExample&lt;T&gt; {"></div><div data-l="    type Target = T;"></div><div data-l=""></div><div data-l="    fn deref(&amp;self) -&gt; &amp;T {"></div><div data-l="        &amp;self.value"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let x = DerefExample { value: 'a' };"></div><div data-l="    assert_eq!('a', *x);"></div><div data-l=}></div></div><br> <a class=notranslate href=#1../../std/ops/trait.Deref.html>deref</a> <br> <p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is useful for writing custom pointer types.</span>これは、カスタムポインタ型を記述するのに便利です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, there&#39;s a language feature related to <code>Deref</code> : &#39;deref coercions&#39;.</span>しかし、 <code>Deref</code>関連する言語機能があります： &#39;deref coercions&#39;。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here&#39;s the rule: If you have a type <code>U</code> , and it implements <code>Deref&lt;Target=T&gt;</code> , values of <code>&amp;U</code> will automatically coerce to a <code>&amp;T</code> .</span>ルールは次のとおりです：タイプ<code>U</code>を持ち、 <code>Deref&lt;Target=T&gt;</code>実装している場合、 <code>&amp;U</code>値は自動的に<code>&amp;T</code>強制的に変換されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here&#39;s an example:</span>ここに例があります：</span> </p><br><div data-lang=rust><div data-l="fn foo(s: &amp;str) {"></div><div data-l="#    // Borrow a string for a second."></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Borrow a string for a second.</span> 1秒間ストリングを借りてください。</span> </div><div data-l=}></div><div data-l=""></div><div data-l="#// String implements Deref&lt;Target=str&gt;."></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">String implements Deref</span> StringはDerefを実装しています</span> <Target=str> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">.</span> 。</span> </div><div data-l="let owned = &quot;Hello&quot;.to_string();"></div><div data-l=""></div><div data-l="#// Therefore, this works:"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Therefore, this works:</span>したがって、これは動作します：</span> </div><div data-l=foo(&amp;owned);></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Using an ampersand in front of a value takes a reference to it.</span>値の前にアンパサンドを使用すると、値が参照されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So <code>owned</code> is a <code>String</code> , <code>&amp;owned</code> is an <code>&amp;String</code> , and since <code>impl Deref&lt;Target=str&gt; for String</code> , <code>&amp;String</code> will deref to <code>&amp;str</code> , which <code>foo()</code> takes.</span>だから、 <code>owned</code>である<code>String</code> 、 <code>&amp;owned</code>いる<code>&amp;String</code> 、および以降<code>impl Deref&lt;Target=str&gt; for String</code> 、 <code>&amp;String</code>するDEREFます<code>&amp;str</code> <code>foo()</code>とります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That&#39;s it.</span>それでおしまい。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This rule is one of the only places in which Rust does an automatic conversion for you, but it adds a lot of flexibility.</span>このルールは、Rustが自動変換を行う唯一の場所の1つですが、多くの柔軟性が追加されています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, the <code>Rc&lt;T&gt;</code> type implements <code>Deref&lt;Target=T&gt;</code> , so this works:</span>例えば、 <code>Rc&lt;T&gt;</code>型は<code>Deref&lt;Target=T&gt;</code>実装しているので、これはうまく<code>Deref&lt;Target=T&gt;</code>ます：</span> </p><br><div data-lang=rust><div data-l="use std::rc::Rc;"></div><div data-l=""></div><div data-l="fn foo(s: &amp;str) {"></div><div data-l="#    // Borrow a string for a second."></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Borrow a string for a second.</span> 1秒間ストリングを借りてください。</span> </div><div data-l=}></div><div data-l=""></div><div data-l="#// String implements Deref&lt;Target=str&gt;."></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">String implements Deref</span> StringはDerefを実装しています</span> <Target=str> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">.</span> 。</span> </div><div data-l="let owned = &quot;Hello&quot;.to_string();"></div><div data-l="let counted = Rc::new(owned);"></div><div data-l=""></div><div data-l="#// Therefore, this works:"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Therefore, this works:</span>したがって、これは動作します：</span> </div><div data-l=foo(&amp;counted);></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">All we&#39;ve done is wrap our <code>String</code> in an <code>Rc&lt;T&gt;</code> .</span>私たちがしたのは、 <code>String</code>を<code>Rc&lt;T&gt;</code>ラップすることだけでした。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But we can now pass the <code>Rc&lt;String&gt;</code> around anywhere we&#39;d have a <code>String</code> .</span>しかし、我々は今、渡すことができます<code>Rc&lt;String&gt;</code>我々は持っているだろうどこにでも周りの<code>String</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The signature of <code>foo</code> didn&#39;t change, but works just as well with either type.</span> <code>foo</code>のシグネチャは変更されませんでしたが、いずれのタイプでも同様に機能します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This example has two conversions: <code>&amp;Rc&lt;String&gt;</code> to <code>&amp;String</code> and then <code>&amp;String</code> to <code>&amp;str</code> .</span>この例では<code>&amp;Rc&lt;String&gt;</code>を<code>&amp;String</code>変換し、 <code>&amp;String</code>を<code>&amp;str</code>変換し<code>&amp;str</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust will do this as many times as possible until the types match.</span>タイプが一致するまで、Rustはできるだけ多くの回数これを行います。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Another very common implementation provided by the standard library is:</span>標準ライブラリによって提供される別の非常に一般的な実装は次のとおりです。</span> </p><br><div data-lang=rust><div data-l="fn foo(s: &amp;[i32]) {"></div><div data-l="#    // Borrow a slice for a second."></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Borrow a slice for a second.</span> 1秒間スライスを借りてください。</span> </div><div data-l=}></div><div data-l=""></div><div data-l="#// Vec&lt;T&gt; implements Deref&lt;Target=[T]&gt;."></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Vec</span> Vec</span> <T> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">implements Deref</span> Derefを実装する</span> <Target=[T]> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">.</span> 。</span> </div><div data-l="let owned = vec![1, 2, 3];"></div><div data-l=""></div><div data-l=foo(&amp;owned);></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Vectors can <code>Deref</code> to a slice.</span>ベクトルはスライスに<code>Deref</code>できます。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Deref and method calls</span> Derefとメソッド呼び出し</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>Deref</code> will also kick in when calling a method.</span>メソッドを呼び出すときに<code>Deref</code>も<code>Deref</code>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Consider the following example.</span>次の例を考えてみましょう。</span> </p><br><div data-lang=rust><div data-l="struct Foo;"></div><div data-l=""></div><div data-l="impl Foo {"></div><div data-l="    fn foo(&amp;self) { println!(&quot;Foo&quot;); }"></div><div data-l=}></div><div data-l=""></div><div data-l="let f = &amp;&amp;Foo;"></div><div data-l=""></div><div data-l=f.foo();></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Even though <code>f</code> is a <code>&amp;&amp;Foo</code> and <code>foo</code> takes <code>&amp;self</code> , this works.</span> <code>f</code>は<code>&amp;&amp;Foo</code>で<code>foo</code>は<code>&amp;self</code>取るが、これは機能する。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That&#39;s because these things are the same:</span>これは、これらのことが同じであるためです。</span> </p><br><div data-lang=rust,ignore><div data-l=f.foo();></div><div data-l=(&amp;f).foo();></div><div data-l=(&amp;&amp;f).foo();></div><div data-l=(&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;f).foo();></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A value of type <code>&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;Foo</code> can still have methods defined on <code>Foo</code> called, because the compiler will insert as many * operations as necessary to get it right.</span> <code>&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;Foo</code>値は、 <code>Foo</code>定義されたメソッドを<code>&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;Foo</code>ことができます。これは、コンパイラが必要なだけ多くの*演算を挿入するためです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">And since it&#39;s inserting <code>*</code> s, that uses <code>Deref</code> .</span>そして、 <code>*</code> sを挿入しているので、 <code>Deref</code>を使用しています。</span> </p><script>_addload(function(){_setupIW('com');_csi('en','ja','deref-coercions.html');});</script>