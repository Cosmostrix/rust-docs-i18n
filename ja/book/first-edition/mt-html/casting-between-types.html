<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180709_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=casting-between-types.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Casting Between Types</span>タイプ間のキャスト</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust, with its focus on safety, provides two different ways of casting different types between each other.</span>錆は、安全性に重点を置いて、お互いに異なる種類のキャストに2つの異なる方法を提供します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The first, <code>as</code> , is for safe casts.</span> 、最初<code>as</code> 、安全なキャストのためです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In contrast, <code>transmute</code> allows for arbitrary casting, and is one of the most dangerous features of Rust!</span>対照的に、 <code>transmute</code>は任意のキャスティングを可能にし、Rustの最も危険な機能の1つです！</span> </p><br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Coercion</span>強制</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Coercion between types is implicit and has no syntax of its own, but can be spelled out with <a class=notranslate href=#2#explicit-coercions><code>as</code></a> .</span>タイプ間の強制は暗黙的であり、独自の構文はありませんが、 <a class=notranslate href=#2#explicit-coercions><code>as</code></a>で綴ることができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Coercion occurs in <code>let</code> , <code>const</code> , and <code>static</code> statements;</span>強制は<code>let</code> 、 <code>const</code> 、および<code>static</code>文で行われます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">in function call arguments;</span>関数呼び出しの引数。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">in field values in struct initialization;</span>構造体初期化のフィールド値</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">and in a function result.</span>関数の結果に含まれます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The most common case of coercion is removing mutability from a reference:</span>強制の最も一般的なケースは、参照からの変更を取り除くことです：</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>&amp;mut T</code> to <code>&amp;T</code></span> <code>&amp;mut T</code>から<code>&amp;T</code>への<code>&amp;mut T</code></span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">An analogous conversion is to remove mutability from a <a href=#2raw-pointers.html>raw pointer</a> :</span>類似の変換は、 <a href=#2raw-pointers.html>生ポインタ</a>からの変更を取り除くことです：</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>*mut T</code> to <code>*const T</code></span> <code>*mut T</code>から<code>*const T</code></span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">References can also be coerced to raw pointers:</span>参照は生ポインタに強制することもできます：</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>&amp;T</code> to <code>*const T</code></span> <code>&amp;T</code>から<code>*const T</code></span> </div><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>&amp;mut T</code> to <code>*mut T</code></span> <code>&amp;mut T</code>から<code>*mut T</code></span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Custom coercions may be defined using <a class=notranslate href=#2deref-coercions.html><code>Deref</code></a> .</span>カスタム変換は、 <a class=notranslate href=#2deref-coercions.html><code>Deref</code></a>を使用して定義できます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Coercion is transitive.</span>強制は推移的です。</span> </p><br><h1> <code>as</code> </h1> <br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>as</code> keyword does safe casting:</span> <code>as</code>キーワードは安全なキャストを行います：</span> </p><br><div data-lang=rust><div data-l="let x: i32 = 5;"></div><div data-l=""></div><div data-l="let y = x as i64;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There are three major categories of safe cast: explicit coercions, casts between numeric types, and pointer casts.</span>安全なキャストには、明示的な変換、数値型間のキャスト、およびポインタキャストの3つの主要なカテゴリがあります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Casting is not transitive: even if <code>e as U1 as U2</code> is a valid expression, <code>e as U2</code> is not necessarily so (in fact it will only be valid if <code>U1</code> coerces to <code>U2</code> ).</span>キャスティングは推移的ではありません。たとえ<code>e as U1 as U2</code>が有効な式であっても、 <code>e as U2</code>は必ずしもそうである必要はありません（ <code>U1</code>が<code>U2</code>強制する場合にのみ有効です）。</span> </p><br><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Explicit coercions</span>明示的な変換</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A cast <code>e as U</code> is valid if <code>e</code> has type <code>T</code> and <code>T</code> <i>coerces</i> to <code>U</code> .</span>キャスト<code>e as U</code>あれば有効である<code>e</code>型が<code>T</code>と<code>T</code>に<i>強制的に変換</i> <code>U</code> 。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Numeric casts</span>数値キャスト</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A cast <code>e as U</code> is also valid in any of the following cases:</span> <code>e as U</code>のキャスト<code>e as U</code>は、以下のいずれの場合にも有効です。</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>e</code> has type <code>T</code> and <code>T</code> and <code>U</code> are any numeric types;</span> <code>e</code>は<code>T</code>型を持ち、 <code>T</code>と<code>U</code>は任意の数値型です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><i>numeric-cast</i></span> <i>数字キャスト</i></span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>e</code> is an enum with no data attached to the variants (a &quot;field-less enumeration&quot;), and <code>U</code> is an integer type;</span> <code>e</code>は、バリアントにデータが添付されていない列挙型（「フィールドレス列挙」）であり、 <code>U</code>は整数型です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><i>enum-cast</i></span> <i>列挙型</i></span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>e</code> has type <code>bool</code> or <code>char</code> and <code>U</code> is an integer type;</span> <code>e</code>は<code>bool</code>または<code>char</code>型を持ち、 <code>U</code>は整数型です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><i>prim-int-cast</i></span> <i>プリムキャスト</i></span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>e</code> has type <code>u8</code> and <code>U</code> is <code>char</code> ;</span> <code>e</code>は<code>u8</code>型、 <code>U</code>は<code>char</code>型です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><i>u8-char-cast</i></span> <i>u8-char-cast</i></span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example</span>例えば</span> </p><br><div data-lang=rust><div data-l="let one = true as u8;"></div><div data-l="let at_sign = 64 as char;"></div><div data-l="let two_hundred = -56i8 as u8;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The semantics of numeric casts are:</span>数値キャストのセマンティクスは次のとおりです。</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Casting between two integers of the same size (eg i32 -&gt; u32) is a no-op</span>同じサイズの2つの整数間のキャスト（例：i32  - &gt; u32）はノーオペレーションです</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Casting from a larger integer to a smaller integer (eg u32 -&gt; u8) will truncate</span>大きな整数から小さな整数（例えば、u32  - &gt; u8）へのキャスティングは、切り詰められます</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Casting from a smaller integer to a larger integer (eg u8 -&gt; u32) will</span>小さな整数から大きな整数へのキャスト（例：u8  - &gt; u32）</span> </div><div data-b="    *"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">zero-extend if the source is unsigned</span>ソースが符号なしの場合はゼロ拡張</span> </div><div data-b="    *"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">sign-extend if the source is signed</span>ソースが署名されている場合は符号拡張する</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Casting from a float to an integer will round the float towards zero</span>浮動小数点から整数へのキャストは浮動小数点をゼロに向かって丸めます</span> </div><div data-b="    *"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><b>[NOTE: currently this will cause Undefined Behavior if the rounded value cannot be represented by the target integer type][float-int]</b> .</span> <b>[注記：現在、丸められた値をターゲット整数型で表現できない場合、未定義の振る舞いが発生します] [float-int]</b> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This includes Inf and NaN.</span>これには、InfとNaNが含まれます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is a bug and will be fixed.</span>これはバグであり修正される予定です。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Casting from an integer to float will produce the floating point representation of the integer, rounded if necessary (rounding strategy unspecified)</span>整数から浮動小数点へのキャストは、必要に応じて丸められた整数の浮動小数点表現を生成します（丸め戦略は指定されていません）</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Casting from an f32 to an f64 is perfect and lossless</span> f32からf64へのキャストは完璧でロスレスです</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Casting from an f64 to an f32 will produce the closest possible value (rounding strategy unspecified)</span> f64からf32へのキャストは、可能な限り近い値を生成します（丸め戦略は指定されていません）</span> </div><div data-b="    *"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><b>[NOTE: currently this will cause Undefined Behavior if the value is finite but larger or smaller than the largest or smallest finite value representable by f32][float-float]</b> .</span> <b>[注記：現在、値が有限であるが、f32で表現可能な最大または最小の有限値より大きいまたは小さい場合は、未定義動作が発生します</b> 。 <b>[float-float]</b></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is a bug and will be fixed.</span>これはバグであり修正される予定です。</span> </div><br> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a class=notranslate href=#1https://github.com/rust-lang/rust/issues/10184>float-int</a> <a class=notranslate href=#1https://github.com/rust-lang/rust/issues/15536>float-float</a></span> <a class=notranslate href=#1https://github.com/rust-lang/rust/issues/10184>float-int</a> <a class=notranslate href=#1https://github.com/rust-lang/rust/issues/15536>float-float</a></span> <br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Pointer casts</span>ポインタキャスト</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Perhaps surprisingly, it is safe to cast <a href=#2raw-pointers.html>raw pointers</a> to and from integers, and to cast between pointers to different types subject to some constraints.</span>おそらく驚くべきことに、整数との間で<a href=#2raw-pointers.html>生ポインタ</a>をキャストしたり、いくつかの制約のもとで異なる型へのポインタ間でキャストすることは安全です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It is only unsafe to dereference the pointer:</span>ポインタを逆参照することは危険です。</span> </p><br><div data-lang=rust><div data-l="#//let a = 300 as *const char; // `a` is a pointer to location 300."></div><div data-l="let a = 300 as *const char; // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>a</code> is a pointer to location 300.</span> <code>a</code>は位置300へのポインタです。</span> </div><div data-l="let b = a as u32;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>e as U</code> is a valid pointer cast in any of the following cases:</span> <code>e as U</code>は、次のいずれかの場合に有効なポインタキャストです。</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>e</code> has type <code>*T</code> , <code>U</code> has type <code>*U_0</code> , and either <code>U_0: Sized</code> or <code>unsize_kind(T) == unsize_kind(U_0)</code> ;</span> <code>e</code>はタイプ<code>*T</code>を持ち、 <code>U</code>はタイプ<code>*U_0</code>を持ち、 <code>U_0: Sized</code>または<code>unsize_kind(T) == unsize_kind(U_0)</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">a <i>ptr-ptr-cast</i></span> <i>ptr-ptr-cast</i></span> </div><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>e</code> has type <code>*T</code> and <code>U</code> is a numeric type, while <code>T: Sized</code> ;</span> <code>e</code>はタイプ<code>*T</code>持ち、 <code>U</code>は数値タイプ、 <code>T: Sized</code>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><i>ptr-addr-cast</i></span> <i>ptr-addr-cast</i></span> </div><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>e</code> is an integer and <code>U</code> is <code>*U_0</code> , while <code>U_0: Sized</code> ;</span> <code>e</code>は整数であり、 <code>U</code>は<code>*U_0</code>であり、 <code>U_0: Sized</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><i>addr-ptr-cast</i></span> <i>addr-ptr-cast</i></span> </div><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>e</code> has type <code>&amp;[T; n]</code></span> <code>e</code>は<code>&amp;[T; n]</code></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>&amp;[T; n]</code> and <code>U</code> is <code>*const T</code> ;</span> <code>&amp;[T; n]</code>あり、 <code>U</code>は<code>*const T</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><i>array-ptr-cast</i></span> <i>配列-ptrキャスト</i></span> </div><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>e</code> is a function pointer type and <code>U</code> has type <code>*T</code> , while <code>T: Sized</code> ;</span> <code>e</code>は関数ポインタ型であり、 <code>U</code>は<code>*T</code>型を持ち、 <code>T: Sized</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><i>fptr-ptr-cast</i></span> <i>fptr-ptr-cast</i></span> </div><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>e</code> is a function pointer type and <code>U</code> is an integer;</span> <code>e</code>は関数ポインタ型であり、 <code>U</code>は整数です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><i>fptr-addr-cast</i></span> <i>fptr-addr-cast</i></span> </div><br><br><h1> <code>transmute</code> </h1> <br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>as</code> only allows safe casting, and will for example reject an attempt to cast four bytes into a <code>u32</code> :</span>唯一の安全なキャストを可能にし、例えば意志に4つのバイトをキャストしようとすると拒否<code>u32</code> ：</span> </p><br><div data-lang=rust,ignore><div data-l="let a = [0u8, 0u8, 0u8, 0u8];"></div><div data-l=""></div><div data-l="#//let b = a as u32; // Four u8s makes a u32."></div><div data-l="let b = a as u32; // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Four u8s makes a u32.</span> 4つのu8はu32を作ります。</span> </div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This errors with:</span>このエラーは、</span> </p><br><div data-lang=text><div data-l="error: non-scalar cast: `[u8; 4]` as `u32`"></div><div data-l="#//let b = a as u32; // Four u8s makes a u32."></div><div data-l="let b = a as u32; // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Four u8s makes a u32.</span> 4つのu8はu32を作ります。</span> </div><div data-l="        ^~~~~~~~"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is a &#39;non-scalar cast&#39; because we have multiple values here: the four elements of the array.</span>これは、配列の4つの要素である複数の値を持つため、非スカラーキャストです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These kinds of casts are very dangerous, because they make assumptions about the way that multiple underlying structures are implemented.</span>これらの種類のキャストは、複数の基本構造が実装される方法について前提を定めているため、非常に危険です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For this, we need something more dangerous.</span>このためには、もっと危険なものが必要です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>transmute</code> function is very simple, but very scary.</span> <code>transmute</code>機能は非常にシンプルですが、非常に怖いです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It tells Rust to treat a value of one type as though it were another type.</span> 1つのタイプの値を別のタイプのように扱うようにRustに指示します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It does this regardless of the typechecking system, and completely trusts you.</span>それは型検査システムに関係なくこれを行い、完全にあなたを信頼します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In our previous example, we know that an array of four <code>u8</code> s represents a <code>u32</code> properly, and so we want to do the cast.</span>前の例では、4つの<code>u8</code>の配列が正しく<code>u32</code>表していることを知っています。したがって、キャストを行いたいと思います。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Using <code>transmute</code> instead of <code>as</code> , Rust lets us:</span> <code>as</code>代わりに<code>transmute</code>使うと、Rustは次のようになります：</span> </p><br><div data-lang=rust><div data-l="use std::mem;"></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    unsafe {"></div><div data-l="        let a = [0u8, 1u8, 0u8, 0u8];"></div><div data-l="        let b = mem::transmute::&lt;[u8; 4], u32&gt;(a);"></div><div data-l="#//        println!(&quot;{}&quot;, b); // 256"></div><div data-l="        println!(&quot;{}&quot;, b); // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">256</span> 256</span> </div><div data-l="#        // Or, more concisely:"></div><div data-l="        // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Or, more concisely:</span>または、より簡潔に：</span> </div><div data-l="        let c: u32 = mem::transmute(a);"></div><div data-l="#//        println!(&quot;{}&quot;, c); // 256"></div><div data-l="        println!(&quot;{}&quot;, c); // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">256</span> 256</span> </div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We have to wrap the operation in an <code>unsafe</code> block for this to compile successfully.</span>これを正常にコンパイルするには、 <code>unsafe</code>ブロックで操作をラップする必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Technically, only the <code>mem::transmute</code> call itself needs to be in the block, but it&#39;s nice in this case to enclose everything related, so you know where to look.</span>技術的には、 <code>mem::transmute</code>コールだけがブロック内に存在する必要がありますが、この場合は関連するすべてを囲むのがいいので、どこを見るか分かります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this case, the details about <code>a</code> are also important, and so they&#39;re in the block.</span>この場合、 <code>a</code>の詳細も重要なので、ブロック内にあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You&#39;ll see code in either style, sometimes the context is too far away, and wrapping all of the code in <code>unsafe</code> isn&#39;t a great idea.</span>どちらのスタイルでもコードが表示されますが、状況があまりにも遠すぎる場合があります。 <code>unsafe</code>でないコードをすべてラップするのは良い考えではありません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">While <code>transmute</code> does very little checking, it will at least make sure that the types are the same size.</span> <code>transmute</code>はほとんどチェックを行いませんが、少なくとも同じ種類の型であることを確認します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This errors:</span>このエラー：</span> </p><br><div data-lang=rust,ignore><div data-l="use std::mem;"></div><div data-l=""></div><div data-l="unsafe {"></div><div data-l="    let a = [0u8, 0u8, 0u8, 0u8];"></div><div data-l=""></div><div data-l="    let b = mem::transmute::&lt;[u8; 4], u64&gt;(a);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">with:</span> with：</span> </p><br><div data-lang=text><div data-l="error: transmute called with differently sized types: [u8; 4] (32 bits) to u64"></div><div data-l="(64 bits)"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Other than that, you&#39;re on your own!</span>それ以外は、あなた自身である！</span> </p><script>_addload(function(){_setupIW('com');_csi('en','ja','casting-between-types.html');});</script>