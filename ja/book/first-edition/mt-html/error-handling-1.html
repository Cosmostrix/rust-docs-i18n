<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180709_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=error-handling.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Error Handling</span>エラー処理</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Like most programming languages, Rust encourages the programmer to handle errors in a particular way.</span>ほとんどのプログラミング言語と同様に、Rustはプログラマーに特定の方法でエラーを処理させるよう促します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Generally speaking, error handling is divided into two broad categories: exceptions and return values.</span>一般に、エラー処理は、例外と戻り値の2つの大きなカテゴリに分かれています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust opts for return values.</span>錆は戻り値を選択します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this section, we intend to provide a comprehensive treatment of how to deal with errors in Rust.</span>このセクションでは、Rustのエラー処理方法の包括的な扱いを提供するつもりです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">More than that, we will attempt to introduce error handling one piece at a time so that you&#39;ll come away with a solid working knowledge of how everything fits together.</span>それ以上に、私たちは一度に1つずつエラー処理を導入しようとします。そうすれば、すべてのものがどのように適合しているかについての実用的な知識を得ることができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When done naïvely, error handling in Rust can be verbose and annoying.</span> naïvelyを実行すると、Rustのエラー処理が冗長で迷惑になる可能性があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This section will explore those stumbling blocks and demonstrate how to use the standard library to make error handling concise and ergonomic.</span>このセクションでは、これらの障害ブロックを調べ、標準ライブラリを使用してエラー処理を簡潔かつ人間工学的にする方法を示します。</span> </p><br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Table of Contents</span>目次</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This section is very long, mostly because we start at the very beginning with sum types and combinators, and try to motivate the way Rust does error handling incrementally.</span>このセクションは非常に長く、ほとんどの場合、最初に和の型と結合子で開始し、Rustがエラー処理を段階的に行う方法を動機付けようとしているからです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As such, programmers with experience in other expressive type systems may want to jump around.</span>したがって、他の表現型システムでの経験を持つプログラマは、飛び回りたいかもしれません。</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a href=#2#the-basics>The Basics</a></span> <a href=#2#the-basics>基礎</a></span> </div><div data-b="    *"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a href=#2#unwrapping-explained>Unwrapping explained</a></span> <a href=#2#unwrapping-explained>アンラッピングの説明</a></span> </div><div data-b="    *"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a href=#2#the-option-type>The <code>Option</code> type</a></span> <a href=#2#the-option-type><code>Option</code>種類</a></span> </div><div data-b="        *"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a href=#2#composing-optiont-values>Composing <code>Option&lt;T&gt;</code> values</a></span> <a href=#2#composing-optiont-values><code>Option&lt;T&gt;</code>値の作成</a></span> </div><div data-b="    *"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a href=#2#the-result-type>The <code>Result</code> type</a></span> <a href=#2#the-result-type><code>Result</code>型</a></span> </div><div data-b="        *"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a href=#2#parsing-integers>Parsing integers</a></span> <a href=#2#parsing-integers>整数の解析</a></span> </div><div data-b="        *"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a href=#2#the-result-type-alias-idiom>The <code>Result</code> type alias idiom</a></span> <a href=#2#the-result-type-alias-idiom><code>Result</code>型別名イディオム</a></span> </div><div data-b="    *"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a href=#2#a-brief-interlude-unwrapping-isnt-evil>A brief interlude: unwrapping isn&#39;t evil</a></span> <a href=#2#a-brief-interlude-unwrapping-isnt-evil>簡単な間奏：アンラップは悪くない</a></span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a href=#2#working-with-multiple-error-types>Working with multiple error types</a></span> <a href=#2#working-with-multiple-error-types>複数のエラータイプの操作</a></span> </div><div data-b="    *"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a href=#2#composing-option-and-result>Composing <code>Option</code> and <code>Result</code></a></span> <a href=#2#composing-option-and-result><code>Option</code>と<code>Result</code></a></span> </div><div data-b="    *"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a href=#2#the-limits-of-combinators>The limits of combinators</a></span> <a href=#2#the-limits-of-combinators>コンビネータの限界</a></span> </div><div data-b="    *"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a href=#2#early-returns>Early returns</a></span> <a href=#2#early-returns>早期返品</a></span> </div><div data-b="    *"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a href=#2#the-try-macro>The <code>try€</code> macro</a></span> <a href=#2#the-try-macro><code>try€</code>マクロ</a></span> </div><div data-b="    *"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a href=#2#defining-your-own-error-type>Defining your own error type</a></span> <a href=#2#defining-your-own-error-type>独自のエラータイプを定義する</a></span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a href=#2#standard-library-traits-used-for-error-handling>Standard library traits used for error handling</a></span> <a href=#2#standard-library-traits-used-for-error-handling>エラー処理に使用される標準ライブラリ特性</a></span> </div><div data-b="    *"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a href=#2#the-error-trait>The <code>Error</code> trait</a></span> <a href=#2#the-error-trait><code>Error</code>特性</a></span> </div><div data-b="    *"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a href=#2#the-from-trait>The <code>From</code> trait</a></span> <a href=#2#the-from-trait><code>From</code>特性</a></span> </div><div data-b="    *"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a href=#2#the-real-try-macro>The real <code>try€</code> macro</a></span> <a href=#2#the-real-try-macro>本当の<code>try€</code>マクロ</a></span> </div><div data-b="    *"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a href=#2#composing-custom-error-types>Composing custom error types</a></span> <a href=#2#composing-custom-error-types>カスタムエラータイプの作成</a></span> </div><div data-b="    *"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a href=#2#advice-for-library-writers>Advice for library writers</a></span> <a href=#2#advice-for-library-writers>図書館の作家のためのアドバイス</a></span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a href=#2#case-study-a-program-to-read-population-data>Case study: A program to read population data</a></span> <a href=#2#case-study-a-program-to-read-population-data>ケーススタディ：人口データを読み込むプログラム</a></span> </div><div data-b="    *"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a href=#2#initial-setup>Initial setup</a></span> <a href=#2#initial-setup>初期設定</a></span> </div><div data-b="    *"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a href=#2#argument-parsing>Argument parsing</a></span> <a href=#2#argument-parsing>引数の解析</a></span> </div><div data-b="    *"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a href=#2#writing-the-logic>Writing the logic</a></span> <a href=#2#writing-the-logic>論理を書く</a></span> </div><div data-b="    *"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a href=#2#error-handling-with-boxerror>Error handling with <code>Box&lt;Error&gt;</code></a></span> <a href=#2#error-handling-with-boxerror><code>Box&lt;Error&gt;</code>エラー処理<code>Box&lt;Error&gt;</code></a></span> </div><div data-b="    *"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a href=#2#reading-from-stdin>Reading from stdin</a></span> <a href=#2#reading-from-stdin>スタンダードから読む</a></span> </div><div data-b="    *"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a href=#2#error-handling-with-a-custom-type>Error handling with a custom type</a></span> <a href=#2#error-handling-with-a-custom-type>カスタムタイプによるエラー処理</a></span> </div><div data-b="    *"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a href=#2#adding-functionality>Adding functionality</a></span> <a href=#2#adding-functionality>機能の追加</a></span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a href=#2#the-short-story>The short story</a></span> <a href=#2#the-short-story>短編小説</a></span> </div><br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The Basics</span>基礎</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can think of error handling as using <i>case analysis</i> to determine whether a computation was successful or not.</span>エラー処理は、 <i>ケース分析</i>を使用して計算が成功したかどうかを判断すると考えることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As you will see, the key to ergonomic error handling is reducing the amount of explicit case analysis the programmer has to do while keeping code composable.</span>ご存じのように、人間工学的なエラー処理の鍵は、プログラマがコードを構成可能に保ちながら明示的なケース分析を減らすことです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Keeping code composable is important, because without that requirement, we could <a class=notranslate href=#2../../std/macro.panic.html><code>panic</code></a> whenever we come across something unexpected.</span>コードを構成可能にすることは重要です。なぜなら、そのような要件がなければ、予期せぬことが起こるたびに<a class=notranslate href=#2../../std/macro.panic.html><code>panic</code></a>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">( <code>panic</code> causes the current task to unwind, and in most cases, the entire program aborts.) Here&#39;s an example:</span> （ <code>panic</code>により現在のタスクが巻き戻され、ほとんどの場合、プログラム全体が異常終了します）。次に例を示します。</span> </p><br><div data-lang=rust,should_panic><div data-l="#// Guess a number between 1 and 10."></div><div data-l="#// If it matches the number we had in mind, return `true`. Else, return `false`."></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Guess a number between 1 and 10. If it matches the number we had in mind, return <code>true</code> .</span> 1と10の間の数字を推測し<code>true</code> 。私たちが気にしていた数字と一致する場合は<code>true</code>返し<code>true</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Else, return <code>false</code> .</span>それ以外の場合は<code>false</code>返し<code>false</code> 。</span> </div><div data-l="fn guess(n: i32) -&gt; bool {"></div><div data-l="    if n &lt; 1 || n &gt; 10 {"></div><div data-l="        panic!(&quot;Invalid number: {}&quot;, n);"></div><div data-l="    }"></div><div data-l="    n == 5"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    guess(11);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you try running this code, the program will crash with a message like this:</span>このコードを実行しようとすると、プログラムは次のようなメッセージでクラッシュします。</span> </p><br><div data-lang=text><div data-l="thread 'main' panicked at 'Invalid number: 11', src/bin/panic-simple.rs:5"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here&#39;s another example that is slightly less contrived.</span>ここにもう少し人工的ではない別の例があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A program that accepts an integer as an argument, doubles it and prints it.</span>引数として整数を受け取り、倍精度化して出力するプログラム。</span> </p><br><p><span id=code-unwrap-double></span></p><br><div data-lang=rust,should_panic><div data-l="use std::env;"></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let mut argv = env::args();"></div><div data-l="#//    let arg: String = argv.nth(1).unwrap(); // error 1"></div><div data-l="    let arg: String = argv.nth(1).unwrap(); // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">error 1</span>エラー1</span> </div><div data-l="#//    let n: i32 = arg.parse().unwrap(); // error 2"></div><div data-l="    let n: i32 = arg.parse().unwrap(); // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">error 2</span>エラー2</span> </div><div data-l="    println!(&quot;{}&quot;, 2 * n);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you give this program zero arguments (error 1) or if the first argument isn&#39;t an integer (error 2), the program will panic just like in the first example.</span>このプログラムにゼロ引数（エラー1）を渡すか、最初の引数が整数でない場合（エラー2）、プログラムは最初の例のようにパニックになります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can think of this style of error handling as similar to a bull running through a china shop.</span>このエラー処理のスタイルは、中国の店を走っているブルと同様に考えることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The bull will get to where it wants to go, but it will trample everything in the process.</span>牛はどこに行きたいのか分かりますが、その過程ですべてを踏みにじります。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Unwrapping explained</span>アンラッピングの説明</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In the previous example, we claimed that the program would simply panic if it reached one of the two error conditions, yet, the program does not include an explicit call to <code>panic</code> like the first example.</span>前の例では、プログラムが2つのエラー条件のいずれかに達した場合にパニックになると主張しましたが、プログラムには最初の例のように明示的な<code>panic</code>コールは含まれていません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is because the panic is embedded in the calls to <code>unwrap</code> .</span>これは、パニックが<code>unwrap</code>の呼び出しに埋め込まれているためです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To “unwrap” something in Rust is to say, “Give me the result of the computation, and if there was an error, panic and stop the program.” It would be better if we showed the code for unwrapping because it is so simple, but to do that, we will first need to explore the <code>Option</code> and <code>Result</code> types.</span> Rustの中の何かを &quot;unwrap&quot;するのは、 &quot;計算の結果を教えてください。エラーがあった場合は、パニックを起こしてプログラムを止めてください&quot;ということです。それを行うには、まず<code>Option</code>と<code>Result</code>型を調べる必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Both of these types have a method called <code>unwrap</code> defined on them.</span>これらの両方の型には、 <code>unwrap</code>というメソッドが定義されています。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Option</code> type</span> <code>Option</code>種類</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Option</code> type is <a href=#35>defined in the standard library</a> :</span> <code>Option</code>タイプは<a href=#35>標準ライブラリで定義されています</a> ：</span> </p><br><div data-lang=rust><div data-l="enum Option&lt;T&gt; {"></div><div data-l="    None,"></div><div data-l="    Some(T),"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Option</code> type is a way to use Rust&#39;s type system to express the <i>possibility of absence</i> .</span> <code>Option</code>型は、Rustの型システムを使用して<i>不在</i>の<i>可能性</i>を表現する方法です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Encoding the possibility of absence into the type system is an important concept because it will cause the compiler to force the programmer to handle that absence.</span>型システムへの不在の可能性をコード化することは、コンパイラがプログラマにその不在を処理させるため、重要な概念です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s take a look at an example that tries to find a character in a string:</span>文字列内の文字を検索しようとする例を見てみましょう：</span> </p><br><p><span id=code-option-ex-string-find></span></p><br><div data-lang=rust><div data-l="#// Searches `haystack` for the Unicode character `needle`. If one is found, the"></div><div data-l="#// byte offset of the character is returned. Otherwise, `None` is returned."></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Searches <code>haystack</code> for the Unicode character <code>needle</code> .</span> <code>haystack</code>でUnicode文字の<code>needle</code>検索します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If one is found, the byte offset of the character is returned.</span>見つかった場合、文字のバイトオフセットが返されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Otherwise, <code>None</code> is returned.</span>それ以外の場合は、 <code>None</code>が返されます。</span> </div><div data-l="fn find(haystack: &amp;str, needle: char) -&gt; Option&lt;usize&gt; {"></div><div data-l="    for (offset, c) in haystack.char_indices() {"></div><div data-l="        if c == needle {"></div><div data-l="            return Some(offset);"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l="    None"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Notice that when this function finds a matching character, it doesn&#39;t only return the <code>offset</code> .</span>この関数が一致する文字を見つけると、 <code>offset</code>返すだけではないことに注意してください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Instead, it returns <code>Some(offset)</code> .</span>代わりに、 <code>Some(offset)</code>返します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>Some</code> is a variant or a <i>value constructor</i> for the <code>Option</code> type.</span> <code>Some</code>は、 <code>Option</code>タイプのバリアントまたは<i>値コンストラクタ</i>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can think of it as a function with the type <code>fn&lt;T&gt;(value: T) -&gt; Option&lt;T&gt;</code> .</span>これは、 <code>fn&lt;T&gt;(value: T) -&gt; Option&lt;T&gt;</code>型の関数と考えることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Correspondingly, <code>None</code> is also a value constructor, except it has no arguments.</span>これに対応して、 <code>None</code>も引数を持たないことを除いて、値のコンストラクタです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can think of <code>None</code> as a function with the type <code>fn&lt;T&gt;() -&gt; Option&lt;T&gt;</code> .</span> <code>None</code>は<code>fn&lt;T&gt;() -&gt; Option&lt;T&gt;</code>型の関数と考えることができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This might seem like much ado about nothing, but this is only half of the story.</span>これは何のためにも大きな騒ぎのように思えるかもしれませんが、これは物語の半分に過ぎません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The other half is <i>using</i> the <code>find</code> function we&#39;ve written.</span>残りの半分は、私たちが書いた<code>find</code>関数を<i>使っ</i>てい<code>find</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s try to use it to find the extension in a file name.</span>ファイル名の拡張子を見つけるためにそれを使ってみましょう。</span> </p><br><div data-lang=rust><div data-l="# fn find(haystack: &amp;str, needle: char) -&gt; Option&lt;usize&gt; { haystack.find(needle) }"></div><div data-l="fn main() {"></div><div data-l="    let file_name = &quot;foobar.rs&quot;;"></div><div data-l="    match find(file_name, '.') {"></div><div data-l="        None =&gt; println!(&quot;No file extension found.&quot;),"></div><div data-l="        Some(i) =&gt; println!(&quot;File extension: {}&quot;, &amp;file_name[i+1..]),"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This code uses <a href=#31>pattern matching</a> to do <i>case analysis</i> on the <code>Option&lt;usize&gt;</code> returned by the <code>find</code> function.</span>このコードは、 <a href=#31>パターンマッチング</a>を使用して、 <code>find</code>関数によって返された<code>Option&lt;usize&gt;</code>に対して<i>ケース分析</i>を行います。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In fact, case analysis is the only way to get at the value stored inside an <code>Option&lt;T&gt;</code> .</span>実際、ケース分析は、 <code>Option&lt;T&gt;</code>内に格納された値を取得する唯一の方法です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This means that you, as the programmer, must handle the case when an <code>Option&lt;T&gt;</code> is <code>None</code> instead of <code>Some(t)</code> .</span>これは、プログラマとして、 <code>Option&lt;T&gt;</code> <code>Some(t)</code>が<code>Some(t)</code>ではなく<code>None</code> <code>Some(t)</code> <code>None</code>の場合に対処する必要があることを意味します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But wait, what about <code>unwrap</code> , which we used <a class=notranslate href=#2#code-unwrap-double>previously</a> ?</span>しかし、私たちが<a class=notranslate href=#2#code-unwrap-double>previously</a>に使った<code>unwrap</code>はどうですか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There was no case analysis there!</span>そこに事例分析はなかった！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Instead, the case analysis was put inside the <code>unwrap</code> method for you.</span>代わりに、ケース分析を<code>unwrap</code>メソッドの中に入れました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You could define it yourself if you want:</span>あなたが望むならそれを自分で定義することができます：</span> </p><br><p><span id=code-option-def-unwrap></span></p><br><div data-lang=rust><div data-l="enum Option&lt;T&gt; {"></div><div data-l="    None,"></div><div data-l="    Some(T),"></div><div data-l=}></div><div data-l=""></div><div data-l="impl&lt;T&gt; Option&lt;T&gt; {"></div><div data-l="    fn unwrap(self) -&gt; T {"></div><div data-l="        match self {"></div><div data-l="            Option::Some(val) =&gt; val,"></div><div data-l="            Option::None =&gt;"></div><div data-l="              panic!(&quot;called `Option::unwrap()` on a `None` value&quot;),"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>unwrap</code> method <i>abstracts away the case analysis</i> .</span> <code>unwrap</code>メソッド<i>は、ケース分析を抽象化します</i> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is precisely the thing that makes <code>unwrap</code> ergonomic to use.</span>これはまさに人間工学に基づいた<code>unwrap</code>を使用することです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Unfortunately, that <code>panic€</code> means that <code>unwrap</code> is not composable: it is the bull in the china shop.</span>残念なことに、その<code>panic€</code>は、 <code>unwrap</code>が構成可能でないことを意味します。それは中国の店の雄牛です。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Composing <code>Option&lt;T&gt;</code> values</span> <code>Option&lt;T&gt;</code>値の作成</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In an <a href=#2#code-option-ex-string-find>example from before</a> , we saw how to use <code>find</code> to discover the extension in a file name.</span> <a href=#2#code-option-ex-string-find>前</a>の<a href=#2#code-option-ex-string-find>例では</a> 、 <code>find</code>を使用してファイル名の拡張子を検出する方法を見てきました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Of course, not all file names have a <code>.</code></span>もちろん、すべてのファイル名にaが付いているわけではありません<code>.</code></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">in them, so it&#39;s possible that the file name has no extension.</span>そのため、ファイル名には拡張子がない可能性があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This <i>possibility of absence</i> is encoded into the types using <code>Option&lt;T&gt;</code> .</span>この<i>不在の可能性は、</i> <code>Option&lt;T&gt;</code>を使用して型にコード化されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In other words, the compiler will force us to address the possibility that an extension does not exist.</span>言い換えると、コンパイラは、拡張が存在しない可能性に対処するように強制します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In our case, we only print out a message saying as such.</span>私たちの場合は、そのようなメッセージだけを出力します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Getting the extension of a file name is a pretty common operation, so it makes sense to put it into a function:</span>ファイル名の拡張子を取得するのはかなり一般的な操作なので、それを関数に入れるのは理にかなっています：</span> </p><br><div data-lang=rust><div data-l="# fn find(haystack: &amp;str, needle: char) -&gt; Option&lt;usize&gt; { haystack.find(needle) }"></div><div data-l="#// Returns the extension of the given file name, where the extension is defined"></div><div data-l="#// as all characters following the first `.`."></div><div data-l="#// If `file_name` has no `.`, then `None` is returned."></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Returns the extension of the given file name, where the extension is defined as all characters following the first <code>.</code></span>指定されたファイル名の拡張子を返します。拡張子は、最初の拡張子に続くすべての文字として定義されます<code>.</code></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">.</span> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If <code>file_name</code> has no <code>.</code></span> <code>file_name</code>にnoが<code>file_name</code>ている場合<code>.</code></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">, then <code>None</code> is returned.</span> 、 <code>None</code>が返されます。</span> </div><div data-l="fn extension_explicit(file_name: &amp;str) -&gt; Option&lt;&amp;str&gt; {"></div><div data-l="    match find(file_name, '.') {"></div><div data-l="        None =&gt; None,"></div><div data-l="        Some(i) =&gt; Some(&amp;file_name[i+1..]),"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">(Pro-tip: don&#39;t use this code. Use the <a class=notranslate href=#2../../std/path/struct.Path.html#method.extension><code>extension</code></a> method in the standard library instead.)</span> （Pro-tip：このコードは使用しないでください。代わりに標準ライブラリの<a class=notranslate href=#2../../std/path/struct.Path.html#method.extension><code>extension</code></a>メソッドを使用してください）。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The code stays simple, but the important thing to notice is that the type of <code>find</code> forces us to consider the possibility of absence.</span>コードは単純なままですが、気付くべき重要なことは、 <code>find</code>のタイプが<code>find</code>私たちに不在の可能性を考慮させることです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is a good thing because it means the compiler won&#39;t let us accidentally forget about the case where a file name doesn&#39;t have an extension.</span>これは、ファイル名に拡張子が付いていない場合をコンパイラーが誤って忘れてしまうことを意味しないため、良いことです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">On the other hand, doing explicit case analysis like we&#39;ve done in <code>extension_explicit</code> every time can get a bit tiresome.</span>一方、毎回<code>extension_explicit</code>行ったような明示的なケース分析を行うと、少し面倒なことが起こります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In fact, the case analysis in <code>extension_explicit</code> follows a very common pattern: <i>map</i> a function on to the value inside of an <code>Option&lt;T&gt;</code> , unless the option is <code>None</code> , in which case, return <code>None</code> .</span>実際には、中ケース解析<code>extension_explicit</code>非常に一般的なパターンに従う：の内部値へのファンクションを<i>マップ</i> <code>Option&lt;T&gt;</code>オプションがない場合を除き、 <code>None</code> 、その場合には、返さない<code>None</code> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust has parametric polymorphism, so it is very easy to define a combinator that abstracts this pattern:</span> Rustはパラメトリック多形性を持つため、このパターンを抽象化するコンビネータを定義するのは非常に簡単です：</span> </p><br><p><span id=code-option-map></span></p><br><div data-lang=rust><div data-l="fn map&lt;F, T, A&gt;(option: Option&lt;T&gt;, f: F) -&gt; Option&lt;A&gt; where F: FnOnce(T) -&gt; A {"></div><div data-l="    match option {"></div><div data-l="        None =&gt; None,"></div><div data-l="        Some(value) =&gt; Some(f(value)),"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Indeed, <code>map</code> is <a href=#32>defined as a method</a> on <code>Option&lt;T&gt;</code> in the standard library.</span>実際、 <code>map</code>は標準ライブラリの<code>Option&lt;T&gt;</code> <a href=#32>メソッドとして定義されてい</a>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As a method, it has a slightly different signature: methods take <code>self</code> , <code>&amp;self</code> , or <code>&amp;mut self</code> as their first argument.</span>メソッドとして、それはわずかに異なるシグネチャを持ちます：メソッドは、 <code>self</code> 、 <code>&amp;self</code> 、または<code>&amp;mut self</code>を最初の引数として取ります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Armed with our new combinator, we can rewrite our <code>extension_explicit</code> method to get rid of the case analysis:</span>新しいコンビネータを使用して、 <code>extension_explicit</code>メソッドを書き直して、ケース分析を取り除くことができます：</span> </p><br><div data-lang=rust><div data-l="# fn find(haystack: &amp;str, needle: char) -&gt; Option&lt;usize&gt; { haystack.find(needle) }"></div><div data-l="#// Returns the extension of the given file name, where the extension is defined"></div><div data-l="#// as all characters following the first `.`."></div><div data-l="#// If `file_name` has no `.`, then `None` is returned."></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Returns the extension of the given file name, where the extension is defined as all characters following the first <code>.</code></span>指定されたファイル名の拡張子を返します。拡張子は、最初の拡張子に続くすべての文字として定義されます<code>.</code></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">.</span> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If <code>file_name</code> has no <code>.</code></span> <code>file_name</code>にnoが<code>file_name</code>ている場合<code>.</code></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">, then <code>None</code> is returned.</span> 、 <code>None</code>が返されます。</span> </div><div data-l="fn extension(file_name: &amp;str) -&gt; Option&lt;&amp;str&gt; {"></div><div data-l="    find(file_name, '.').map(|i| &amp;file_name[i+1..])"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">One other pattern we commonly find is assigning a default value to the case when an <code>Option</code> value is <code>None</code> .</span>私たちがよく見かけるもう一つのパターンは、 <code>Option</code>値が<code>None</code>場合にデフォルト値を代入することです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, maybe your program assumes that the extension of a file is <code>rs</code> even if none is present.</span>たとえば、ファイルが存在しない場合でもファイルの拡張子が<code>rs</code>であるとプログラムが想定しているとします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As you might imagine, the case analysis for this is not specific to file extensions - it can work with any <code>Option&lt;T&gt;</code> :</span>ご想像のように、これについてのケース分析は、ファイル拡張子に固有のものではなく、 <code>Option&lt;T&gt;</code>動作します：</span> </p><br><div data-lang=rust><div data-l="fn unwrap_or&lt;T&gt;(option: Option&lt;T&gt;, default: T) -&gt; T {"></div><div data-l="    match option {"></div><div data-l="        None =&gt; default,"></div><div data-l="        Some(value) =&gt; value,"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Like with <code>map</code> above, the standard library implementation is a method instead of a free function.</span>上記の<code>map</code>と同様に、標準ライブラリの実装は空き関数ではなくメソッドです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The trick here is that the default value must have the same type as the value that might be inside the <code>Option&lt;T&gt;</code> .</span>ここでのトリックは、デフォルト値が<code>Option&lt;T&gt;</code>内にある可能性のある値と同じ型でなければならないということです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Using it is dead simple in our case:</span>私たちの場合、それを使うのは簡単ではありません。</span> </p><br><div data-lang=rust><div data-l="# fn find(haystack: &amp;str, needle: char) -&gt; Option&lt;usize&gt; {"></div><div data-l="#     for (offset, c) in haystack.char_indices() {"></div><div data-l="#         if c == needle {"></div><div data-l="#             return Some(offset);"></div><div data-l="#         }"></div><div data-l="#     }"></div><div data-l="#     None"></div><div data-l="# }"></div><div data-l=#></div><div data-l="# fn extension(file_name: &amp;str) -&gt; Option&lt;&amp;str&gt; {"></div><div data-l="#     find(file_name, '.').map(|i| &amp;file_name[i+1..])"></div><div data-l="# }"></div><div data-l="fn main() {"></div><div data-l="    assert_eq!(extension(&quot;foobar.csv&quot;).unwrap_or(&quot;rs&quot;), &quot;csv&quot;);"></div><div data-l="    assert_eq!(extension(&quot;foobar&quot;).unwrap_or(&quot;rs&quot;), &quot;rs&quot;);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">(Note that <code>unwrap_or</code> is <a href=#33>defined as a method</a> on <code>Option&lt;T&gt;</code> in the standard library, so we use that here instead of the free-standing function we defined above. Don&#39;t forget to check out the more general <a class=notranslate href=#34><code>unwrap_or_else</code></a> method.)</span> （ <code>unwrap_or</code>は標準ライブラリの<code>Option&lt;T&gt;</code> <a href=#33>メソッドとして定義されているので、</a>上で<a href=#33>定義した</a>自立関数の代わりにここで使用します）もっと一般的な<a class=notranslate href=#34><code>unwrap_or_else</code></a>メソッドをチェックしてください。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There is one more combinator that we think is worth paying special attention to: <code>and_then</code> .</span>特別な注意を払う価値のあるコンビネータがもう1人あります： <code>and_then</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It makes it easy to compose distinct computations that admit the <i>possibility of absence</i> .</span>これは<i>、不在</i>の<i>可能性</i>を認める明確な計算を容易に構成する。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, much of the code in this section is about finding an extension given a file name.</span>たとえば、このセクションのコードの大部分は、ファイル名を指定して拡張子を見つけることです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In order to do this, you first need the file name which is typically extracted from a file <i>path</i> .</span>これを行うには、まずファイル<i>パス</i>から抽出されるファイル名が必要です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">While most file paths have a file name, not <i>all</i> of them do.</span>ほとんどのファイルパスはファイル名を持っていますが、 <i>すべて</i>のファイルパスではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, <code>.</code></span>たとえば、 <code>.</code></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">, <code>..</code> or <code>/</code> .</span> 、 <code>..</code>または<code>/</code> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So, we are tasked with the challenge of finding an extension given a file <i>path</i> .</span>したがって、私たちは、ファイル<i>パスを</i>与えられた拡張子を見つけるという課題に取り組んでいます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s start with explicit case analysis:</span>明示的なケース分析から始めましょう：</span> </p><br><div data-lang=rust><div data-l="# fn extension(file_name: &amp;str) -&gt; Option&lt;&amp;str&gt; { None }"></div><div data-l="fn file_path_ext_explicit(file_path: &amp;str) -&gt; Option&lt;&amp;str&gt; {"></div><div data-l="    match file_name(file_path) {"></div><div data-l="        None =&gt; None,"></div><div data-l="        Some(name) =&gt; match extension(name) {"></div><div data-l="            None =&gt; None,"></div><div data-l="            Some(ext) =&gt; Some(ext),"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="fn file_name(file_path: &amp;str) -&gt; Option&lt;&amp;str&gt; {"></div><div data-l="#  // Implementation elided."></div><div data-l="  // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Implementation elided.</span>実装は省略されました。</span> </div><div data-l="  unimplemented!()"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You might think that we could use the <code>map</code> combinator to reduce the case analysis, but its type doesn&#39;t quite fit...</span>あなたは事例分析を減らすために<code>map</code>コンビネータを使うことができると思うかもしれませんが、そのタイプはあまり適切ではありません...</span> </p><br><div data-lang=rust,ignore><div data-l="fn file_path_ext(file_path: &amp;str) -&gt; Option&lt;&amp;str&gt; {"></div><div data-l="#//    file_name(file_path).map(|x| extension(x)) // This causes a compilation error."></div><div data-l="    file_name(file_path).map(|x| extension(x)) // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This causes a compilation error.</span>これにより、コンパイルエラーが発生します。</span> </div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>map</code> function here wraps the value returned by the <code>extension</code> function inside an <code>Option&lt;_&gt;</code> and since the <code>extension</code> function itself returns an <code>Option&lt;&amp;str&gt;</code> the expression <code>file_name(file_path).map(|x| extension(x))</code> actually returns an <code>Option&lt;Option&lt;&amp;str&gt;&gt;</code> .</span> <code>map</code>関数は、 <code>extension</code>関数によって返された値を<code>Option&lt;_&gt;</code>中にラップします。 <code>extension</code>関数自身が<code>Option&lt;&amp;str&gt;</code>返すので、式<code>file_name(file_path).map(|x| extension(x))</code>実際に<code>Option&lt;Option&lt;&amp;str&gt;&gt;</code></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But since <code>file_path_ext</code> just returns <code>Option&lt;&amp;str&gt;</code> (and not <code>Option&lt;Option&lt;&amp;str&gt;&gt;</code> ) we get a compilation error.</span>しかし、 <code>file_path_ext</code>は<code>Option&lt;&amp;str&gt;</code> （ <code>Option&lt;Option&lt;&amp;str&gt;&gt;</code>ではなく）を返すので、コンパイルエラーが発生します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The result of the function taken by map as input is <i>always</i> <a href=#2#code-option-map>rewrapped with <code>Some</code></a> .</span>入力としてマップで撮影された関数の結果は<i>、常に</i>され<a href=#2#code-option-map>てリラップ<code>Some</code></a> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Instead, we need something like <code>map</code> , but which allows the caller to return a <code>Option&lt;_&gt;</code> directly without wrapping it in another <code>Option&lt;_&gt;</code> .</span>代わりに、 <code>map</code>ようなものが必要ですが、呼び出し元が<code>Option&lt;_&gt;</code>を別の<code>Option&lt;_&gt;</code>ラップすることなく直接返すことができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Its generic implementation is even simpler than <code>map</code> :</span>一般的な実装は<code>map</code>よりも簡単です：</span> </p><br><div data-lang=rust><div data-l="fn and_then&lt;F, T, A&gt;(option: Option&lt;T&gt;, f: F) -&gt; Option&lt;A&gt;"></div><div data-l="        where F: FnOnce(T) -&gt; Option&lt;A&gt; {"></div><div data-l="    match option {"></div><div data-l="        None =&gt; None,"></div><div data-l="        Some(value) =&gt; f(value),"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now we can rewrite our <code>file_path_ext</code> function without explicit case analysis:</span>これで、明示的なケース分析なしで<code>file_path_ext</code>関数を書き直すことができます。</span> </p><br><div data-lang=rust><div data-l="# fn extension(file_name: &amp;str) -&gt; Option&lt;&amp;str&gt; { None }"></div><div data-l="# fn file_name(file_path: &amp;str) -&gt; Option&lt;&amp;str&gt; { None }"></div><div data-l="fn file_path_ext(file_path: &amp;str) -&gt; Option&lt;&amp;str&gt; {"></div><div data-l="    file_name(file_path).and_then(extension)"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Side note: Since <code>and_then</code> essentially works like <code>map</code> but returns an <code>Option&lt;_&gt;</code> instead of an <code>Option&lt;Option&lt;_&gt;&gt;</code> it is known as <code>flatmap</code> in some other languages.</span>サイドノート： <code>and_then</code>本質的に<code>map</code>ように動作し<code>map</code>が、 <code>Option&lt;Option&lt;_&gt;&gt;</code>ではなく<code>Option&lt;_&gt;</code>返します。これは他の言語では<code>flatmap</code>として知られています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Option</code> type has many other combinators <a href=#35>defined in the standard library</a> .</span> <code>Option</code>型には<a href=#35>、標準ライブラリで定義され</a>ている他の多くのコンビネータ<a href=#35>があります</a> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It is a good idea to skim this list and familiarize yourself with what&#39;s available—they can often reduce case analysis for you.</span>このリストを読み飛ばして、利用可能なものを熟知することは良い考えです。彼らはあなたのケース分析を減らすことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Familiarizing yourself with these combinators will pay dividends because many of them are also defined (with similar semantics) for <code>Result</code> , which we will talk about next.</span>これらのコンビネータに慣れ親しむことで、 <code>Result</code>ために定義されている（同様のセマンティクスで）ため、配当を支払うことになります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Combinators make using types like <code>Option</code> ergonomic because they reduce explicit case analysis.</span>コンビネータは、明示的なケース分析を減らすため、人間工学に基づいた<code>Option</code>ようなタイプを使用します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">They are also composable because they permit the caller to handle the possibility of absence in their own way.</span>彼らは発信者が自らの方法で不在の可能性を扱うことができるので、構成も可能です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Methods like <code>unwrap</code> remove choices because they will panic if <code>Option&lt;T&gt;</code> is <code>None</code> .</span> <code>unwrap</code>ようなメソッドは、 <code>Option&lt;T&gt;</code>が<code>None</code>場合にパニックになるので選択肢を削除します。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Result</code> type</span> <code>Result</code>型</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Result</code> type is also <a href=#36>defined in the standard library</a> :</span> <code>Result</code>型も<a href=#36>標準ライブラリで定義されています</a> ：</span> </p><br><p><span id=code-result-def></span></p><br><div data-lang=rust><div data-l="enum Result&lt;T, E&gt; {"></div><div data-l="    Ok(T),"></div><div data-l="    Err(E),"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Result</code> type is a richer version of <code>Option</code> .</span> <code>Result</code>型は、より豊富なバージョンの<code>Option</code>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Instead of expressing the possibility of <i>absence</i> like <code>Option</code> does, <code>Result</code> expresses the possibility of <i>error</i> .</span> <code>Option</code>ような<i>不在</i>の可能性を表現する代わりに、 <code>Result</code>は<i>エラー</i>の可能性を表し<i>ます</i> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Usually, the <i>error</i> is used to explain why the execution of some computation failed.</span>通常、この<i>エラー</i>は、何らかの計算の実行が失敗した理由を説明するために使用されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is a strictly more general form of <code>Option</code> .</span>これは厳密により一般的な<code>Option</code>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Consider the following type alias, which is semantically equivalent to the real <code>Option&lt;T&gt;</code> in every way:</span>以下の型のエイリアスを考えてみましょう。これは、実際の<code>Option&lt;T&gt;</code>と意味的に等価です。</span> </p><br><div data-lang=rust><div data-l="type Option&lt;T&gt; = Result&lt;T, ()&gt;;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This fixes the second type parameter of <code>Result</code> to always be <code>()</code> (pronounced “unit” or “empty tuple”).</span>これは<code>Result</code>第2の型パラメータを常にbe <code>()</code> （「単位」または「空タプル」と発音する<code>()</code>修正します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Exactly one value inhabits the <code>()</code> type: <code>()</code> .</span>ちょうど1つの値が<code>()</code>型に存在します：（ <code>()</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">(Yup, the type and value level terms have the same notation!)</span> （はい、タイプと値レベルの用語は同じ表記です！）</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Result</code> type is a way of representing one of two possible outcomes in a computation.</span> <code>Result</code>型は、計算において2つの可能な結果のうちの1つを表す方法です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">By convention, one outcome is meant to be expected or “ <code>Ok</code> ” while the other outcome is meant to be unexpected or “ <code>Err</code> ”.</span>慣例により、一方の結果は期待されるか、「 <code>Ok</code> 」を意味し、他方の結果は予期しないまたは「 <code>Err</code> 」を意味する。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Just like <code>Option</code> , the <code>Result</code> type also has an <a href=#37><code>unwrap</code> method defined</a> in the standard library.</span> <code>Option</code>と同様に、 <code>Result</code>型には標準ライブラリに<a href=#37>定義さ</a>れている<a href=#37><code>unwrap</code>メソッド</a>もあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s define it:</span>それを定義しよう：</span> </p><br><div data-lang=rust><div data-l="# enum Result&lt;T, E&gt; { Ok(T), Err(E) }"></div><div data-l="impl&lt;T, E: ::std::fmt::Debug&gt; Result&lt;T, E&gt; {"></div><div data-l="    fn unwrap(self) -&gt; T {"></div><div data-l="        match self {"></div><div data-l="            Result::Ok(val) =&gt; val,"></div><div data-l="            Result::Err(err) =&gt;"></div><div data-l="              panic!(&quot;called `Result::unwrap()` on an `Err` value: {:?}&quot;, err),"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is effectively the same as our <a href=#2#code-option-def-unwrap>definition for <code>Option::unwrap</code></a> , except it includes the error value in the <code>panic€</code> message.</span>これは<a href=#2#code-option-def-unwrap>、 <code>Option::unwrap</code>定義</a>と事実上同じですが、 <code>panic€</code>メッセージにエラー値が含まれている点が異なります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This makes debugging easier, but it also requires us to add a <a class=notranslate href=#38><code>Debug</code></a> constraint on the <code>E</code> type parameter (which represents our error type).</span>これによりデバッグが容易になりますが、 <code>E</code>タイプパラメータ（エラータイプを表す）に<a class=notranslate href=#38><code>Debug</code></a>制約を追加する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Since the vast majority of types should satisfy the <code>Debug</code> constraint, this tends to work out in practice.</span>大多数の型は<code>Debug</code>制約を満たす必要があるため、実際にはうまくいく傾向があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">( <code>Debug</code> on a type simply means that there&#39;s a reasonable way to print a human-readable description of values with that type.)</span> （型の<code>Debug</code>は、その型の値の人間が判読可能な記述を出力する合理的な方法があることを単に意味します）。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">OK, let&#39;s move on to an example.</span>さて、例に移りましょう。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Parsing integers</span>整数の解析</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The Rust standard library makes converting strings to integers dead simple.</span> Rust標準ライブラリは、文字列を整数に変換するのを簡単にします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It&#39;s so easy in fact, that it is very tempting to write something like the following:</span>実際にはとても簡単なので、次のようなものを書くのはとても魅力的です。</span> </p><br><div data-lang=rust><div data-l="fn double_number(number_str: &amp;str) -&gt; i32 {"></div><div data-l="    2 * number_str.parse::&lt;i32&gt;().unwrap()"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let n: i32 = double_number(&quot;10&quot;);"></div><div data-l="    assert_eq!(n, 20);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">At this point, you should be skeptical of calling <code>unwrap</code> .</span>この時点で、あなたは<code>unwrap</code>を呼び出すのに懐疑的でなければなりません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, if the string doesn&#39;t parse as a number, you&#39;ll get a panic:</span>たとえば、文字列が数値として解析されない場合、パニックが発生します。</span> </p><br><div data-lang=text><div data-l="thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: ParseIntError { kind: InvalidDigit }', /home/rustbuild/src/rust-buildbot/slave/beta-dist-rustc-linux/build/src/libcore/result.rs:729"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is rather unsightly, and if this happened inside a library you&#39;re using, you might be understandably annoyed.</span>これはむしろ見苦しいものです。もしこれがあなたが使っている図書館の中で起こったのであれば、あなたはわずらわしいかもしれません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Instead, we should try to handle the error in our function and let the caller decide what to do.</span>代わりに、私たちは関数のエラーを処理して、呼び出し元に何をすべきかを決定させるべきです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This means changing the return type of <code>double_number</code> .</span>これは、 <code>double_number</code>の戻り値の型を変更することを意味します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But to what?</span>しかし何に？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Well, that requires looking at the signature of the <a class=notranslate href=#39><code>parse</code> method</a> in the standard library:</span>つまり、標準ライブラリの<a class=notranslate href=#39><code>parse</code> method</a>シグネチャを調べる必要があります。</span> </p><br><div data-lang=rust,ignore><div data-l="impl str {"></div><div data-l="    fn parse&lt;F: FromStr&gt;(&amp;self) -&gt; Result&lt;F, F::Err&gt;;"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Hmm.</span>うーん。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So we at least know that we need to use a <code>Result</code> .</span>だから少なくとも<code>Result</code>を使う必要があることは分かっている。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Certainly, it&#39;s possible that this could have returned an <code>Option</code> .</span>確かに、これは<code>Option</code>を返す可能性があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">After all, a string either parses as a number or it doesn&#39;t, right?</span>結局のところ、文字列は数値として解析するか、そうではないのですか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That&#39;s certainly a reasonable way to go, but the implementation internally distinguishes <i>why</i> the string didn&#39;t parse as an integer.</span>これは確かに合理的な方法ですが、インプリメンテーションは文字列が整数として解析されなかった<i>理由を</i>内部的に区別します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">(Whether it&#39;s an empty string, an invalid digit, too big or too small.) Therefore, using a <code>Result</code> makes sense because we want to provide more information than simply “absence.” We want to say <i>why</i> the parsing failed.</span> （それは大きすぎるか小さすぎる、空の文字列、無効な数字、だかどうか。）ので、使用して<code>Result</code>我々は単によりも多くの情報を提供したいので、理にかなっている「が存在しないことを。」我々は、構文解析が失敗した<i>理由を</i>言いたいです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You should try to emulate this line of reasoning when faced with a choice between <code>Option</code> and <code>Result</code> .</span> <code>Option</code>と<code>Result</code>間の選択に直面したとき、この推論の行をエミュレートしようとする必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you can provide detailed error information, then you probably should.</span>詳細なエラー情報を提供できる場合は、おそらく必要です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">(We&#39;ll see more on this later.)</span> （後で詳しく説明します）</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">OK, but how do we write our return type?</span>はい、戻り値の型はどうやって書くのですか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>parse</code> method as defined above is generic over all the different number types defined in the standard library.</span>上で定義した<code>parse</code>メソッドは、標準ライブラリで定義されているすべての異なる数値型に対して汎用です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We could (and probably should) also make our function generic, but let&#39;s favor explicitness for the moment.</span>私たちは機能を一般的にすることもできますが、おそらくそうすべきです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We only care about <code>i32</code> , so we need to <a href=#2../../std/primitive.i32.html>find its implementation of <code>FromStr</code></a> (do a <code>CTRL-F</code> in your browser for “FromStr”) and look at its <a href=#310>associated type</a> <code>Err</code> .</span>私たちは<code>i32</code>だけを気にするので<a href=#2../../std/primitive.i32.html>、 <code>FromStr</code>実装</a>を<a href=#2../../std/primitive.i32.html>見つける</a>必要があり<a href=#2../../std/primitive.i32.html>ます</a> （あなたのブラウザーで &quot;FromStr&quot;の<code>CTRL-F</code>を実行）し、 <a href=#310>関連するタイプ</a> <code>Err</code>を<a href=#2../../std/primitive.i32.html>調べる</a>必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We did this so we can find the concrete error type.</span>私たちは具体的なエラータイプを見つけるためにこれを行いました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this case, it&#39;s <a class=notranslate href=#2../../std/num/struct.ParseIntError.html><code>std::num::ParseIntError</code></a> .</span>この場合、 <a class=notranslate href=#2../../std/num/struct.ParseIntError.html><code>std::num::ParseIntError</code></a>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Finally, we can rewrite our function:</span>最後に、関数を書き直すことができます：</span> </p><br><div data-lang=rust><div data-l="use std::num::ParseIntError;"></div><div data-l=""></div><div data-l="fn double_number(number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {"></div><div data-l="    match number_str.parse::&lt;i32&gt;() {"></div><div data-l="        Ok(n) =&gt; Ok(2 * n),"></div><div data-l="        Err(err) =&gt; Err(err),"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    match double_number(&quot;10&quot;) {"></div><div data-l="        Ok(n) =&gt; assert_eq!(n, 20),"></div><div data-l="        Err(err) =&gt; println!(&quot;Error: {:?}&quot;, err),"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is a little better, but now we&#39;ve written much more code!</span>これはやや良いですが、今はもっとコードを書いています！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The case analysis has once again bitten us.</span>事例分析がもう一度私たちに咬まれた。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Combinators to the rescue!</span>救助者とのコンビニエーター！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Just like <code>Option</code> , <code>Result</code> has lots of combinators defined as methods.</span> <code>Option</code>と同様に、 <code>Result</code>はメソッドとして定義された多数のコンビネータがあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There is a large intersection of common combinators between <code>Result</code> and <code>Option</code> .</span> <code>Result</code>と<code>Option</code>間には一般的なコンビネータの大きな交差点があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In particular, <code>map</code> is part of that intersection:</span>特に、 <code>map</code>はその交差点の一部です：</span> </p><br><div data-lang=rust><div data-l="use std::num::ParseIntError;"></div><div data-l=""></div><div data-l="fn double_number(number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {"></div><div data-l="    number_str.parse::&lt;i32&gt;().map(|n| 2 * n)"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    match double_number(&quot;10&quot;) {"></div><div data-l="        Ok(n) =&gt; assert_eq!(n, 20),"></div><div data-l="        Err(err) =&gt; println!(&quot;Error: {:?}&quot;, err),"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The usual suspects are all there for <code>Result</code> , including <a class=notranslate href=#2../../std/result/enum.Result.html#method.unwrap_or><code>unwrap_or</code></a> and <a class=notranslate href=#2../../std/result/enum.Result.html#method.and_then><code>and_then</code></a> .</span> <a class=notranslate href=#2../../std/result/enum.Result.html#method.unwrap_or><code>unwrap_or</code></a>と<a class=notranslate href=#2../../std/result/enum.Result.html#method.and_then><code>and_then</code></a>を含む通常の容疑者がすべて<code>Result</code>にあり<a class=notranslate href=#2../../std/result/enum.Result.html#method.and_then><code>and_then</code></a> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Additionally, since <code>Result</code> has a second type parameter, there are combinators that affect only the error type, such as <a class=notranslate href=#2../../std/result/enum.Result.html#method.map_err><code>map_err</code></a> (instead of <code>map</code> ) and <a class=notranslate href=#2../../std/result/enum.Result.html#method.or_else><code>or_else</code></a> (instead of <code>and_then</code> ).</span>以降さらに、 <code>Result</code>第二型パラメータを有している、などのみエラータイプに影響コンビネータ、ある<a class=notranslate href=#2../../std/result/enum.Result.html#method.map_err><code>map_err</code></a> （代わりの<code>map</code> ）と<a class=notranslate href=#2../../std/result/enum.Result.html#method.or_else><code>or_else</code></a> （代わりに<code>and_then</code> ）。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Result</code> type alias idiom</span> <code>Result</code>型別名イディオム</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In the standard library, you may frequently see types like <code>Result&lt;i32&gt;</code> .</span>標準ライブラリでは、 <code>Result&lt;i32&gt;</code>ような型がよく見えます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But wait, <a href=#2#code-result-def>we defined <code>Result</code></a> to have two type parameters.</span>しかし、 <a href=#2#code-result-def>私たちは<code>Result</code></a>に2つの型パラメータを持つよう<a href=#2#code-result-def>に定義しました</a> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">How can we get away with only specifying one?</span>どのように指定するだけで取り除くことができますか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The key is to define a <code>Result</code> type alias that <i>fixes</i> one of the type parameters to a particular type.</span>キーは、型パラメータの1つを特定の型に<i>固定</i>する<code>Result</code>型のエイリアスを定義することです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Usually the fixed type is the error type.</span>通常、固定タイプはエラータイプです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, our previous example parsing integers could be rewritten like this:</span>たとえば、前の例の解析用の整数は次のように書き直すことができます：</span> </p><br><div data-lang=rust><div data-l="use std::num::ParseIntError;"></div><div data-l="use std::result;"></div><div data-l=""></div><div data-l="type Result&lt;T&gt; = result::Result&lt;T, ParseIntError&gt;;"></div><div data-l=""></div><div data-l="fn double_number(number_str: &amp;str) -&gt; Result&lt;i32&gt; {"></div><div data-l="    unimplemented!();"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Why would we do this?</span>なぜ我々はこれを行うだろうか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Well, if we have a lot of functions that could return <code>ParseIntError</code> , then it&#39;s much more convenient to define an alias that always uses <code>ParseIntError</code> so that we don&#39;t have to write it out all the time.</span> <code>ParseIntError</code>返す関数がたくさんある場合は、常に<code>ParseIntError</code>を使用するエイリアスを定義して、常に書き出す必要はありません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The most prominent place this idiom is used in the standard library is with <a class=notranslate href=#2../../std/io/type.Result.html><code>io::Result</code></a> .</span>このイディオムが標準ライブラリで使用される最も顕著な場所は、 <a class=notranslate href=#2../../std/io/type.Result.html><code>io::Result</code></a>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Typically, one writes <code>io::Result&lt;T&gt;</code> , which makes it clear that you&#39;re using the <code>io</code> module&#39;s type alias instead of the plain definition from <code>std::result</code> .</span>通常、 <code>io::Result&lt;T&gt;</code>書くと、 <code>std::result</code>プレーンな定義ではなく、 <code>io</code>モジュールのタイプエイリアスを使用していることがわかります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">(This idiom is also used for <a class=notranslate href=#2../../std/fmt/type.Result.html><code>fmt::Result</code></a> .)</span> （このイディオムは<a class=notranslate href=#2../../std/fmt/type.Result.html><code>fmt::Result</code></a>も使用されます）。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A brief interlude: unwrapping isn&#39;t evil</span>簡単な間奏：アンラップは悪くない</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you&#39;ve been following along, you might have noticed that I&#39;ve taken a pretty hard line against calling methods like <code>unwrap</code> that could <code>panic</code> and abort your program.</span>もしあなたがフォローしてきたのであれば、私はあなたのプログラムを<code>panic</code>て中止するかもしれない<code>unwrap</code>ようなメソッドを呼び出すことに対してかなり厳しい行を見たことに気づいたかもしれません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><i>Generally speaking</i> , this is good advice.</span> <i>一般的に言えば</i> 、これは良いアドバイスです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, <code>unwrap</code> can still be used judiciously.</span>しかし、 <code>unwrap</code>は依然として慎重に使用することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">What exactly justifies use of <code>unwrap</code> is somewhat of a grey area and reasonable people can disagree.</span> <code>unwrap</code>使用を正当に正当化するものは多少グレーの領域であり、合理的な人々は同意できません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">I&#39;ll summarize some of my <i>opinions</i> on the matter.</span>私はこの問題に関する私の<i>意見</i>を要約します。</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><b>In examples and quick &#39;n&#39; dirty code.</b></span> <b>例では、素早く &#39;n&#39;のダーティコードです。</b></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Sometimes you&#39;re writing examples or a quick program, and error handling simply isn&#39;t important.</span>時には例や簡単なプログラムを書いていることもあり、エラー処理は単純ではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Beating the convenience of <code>unwrap</code> can be hard in such scenarios, so it is very appealing.</span>このようなシナリオでは、 <code>unwrap</code>の利便性を<code>unwrap</code>することは難しいため、非常に魅力的です。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><b>When panicking indicates a bug in the program.</b></span> <b>パニックがプログラムのバグを示すとき。</b></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When the invariants of your code should prevent a certain case from happening (like, say, popping from an empty stack), then panicking can be permissible.</span>あなたのコードのインバリアントが特定のケースが起こらないようにする（空のスタックからポップするなど）場合、パニックが許されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is because it exposes a bug in your program.</span>これは、プログラムのバグを公開するためです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This can be explicit, like from an <code>assert€</code> failing, or it could be because your index into an array was out of bounds.</span>これは明示的に<code>assert€</code>ことができます。 <code>assert€</code>失敗した場合などです。配列へのインデックスが範囲外だったためです。</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is probably not an exhaustive list.</span>おそらく網羅的なリストではないでしょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Moreover, when using an <code>Option</code> , it is often better to use its <a class=notranslate href=#2../../std/option/enum.Option.html#method.expect><code>expect</code></a> method.</span>さらに、 <code>Option</code>を使用する場合、 <a class=notranslate href=#2../../std/option/enum.Option.html#method.expect><code>expect</code></a>メソッドを使用するほうがよい場合があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>expect</code> does exactly the same thing as <code>unwrap</code> , except it prints a message you give to <code>expect</code> .</span> <code>expect</code>はあなたが<code>expect</code>するメッセージを出力する点を除いて、 <code>unwrap</code>と全く同じことを行います。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This makes the resulting panic a bit nicer to deal with, since it will show your message instead of “called unwrap on a <code>None</code> value.”</span>これにより、 &quot; <code>None</code>値にアンラップされた&quot;の代わりにメッセージが表示されるため、結果的なパニックが扱いやすくなります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">My advice boils down to this: use good judgment.</span>私の助言はこれにまでこだわります。良い判断をしてください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There&#39;s a reason why the words “never do X” or “Y is considered harmful” don&#39;t appear in my writing.</span> 「Xはしない」または「Yは有害とみなされる」という言葉が私の文章には現れない理由があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There are trade-offs to all things, and it is up to you as the programmer to determine what is acceptable for your use cases.</span>すべてのことにトレードオフがあります。ユースケースに受け入れられるものを判断するのはプログラマとしての任務です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">My goal is only to help you evaluate trade-offs as accurately as possible.</span>私の目標は、できるだけ正確にトレードオフを評価するのに役立つだけです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now that we&#39;ve covered the basics of error handling in Rust, and explained unwrapping, let&#39;s start exploring more of the standard library.</span> Rustのエラー処理の基礎について説明し、アンラッピングについて説明したので、標準ライブラリの詳細を調べてみましょう。</span> </p><br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Working with multiple error types</span>複数のエラータイプの操作</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Thus far, we&#39;ve looked at error handling where everything was either an <code>Option&lt;T&gt;</code> or a <code>Result&lt;T, SomeError&gt;</code> .</span>これまでは、すべてが<code>Option&lt;T&gt;</code>または<code>Result&lt;T, SomeError&gt;</code>いずれかのエラー処理を見てきました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But what happens when you have both an <code>Option</code> and a <code>Result</code> ?</span>しかし、 <code>Option</code>と<code>Result</code>両方を持っているとどうなりますか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Or what if you have a <code>Result&lt;T, Error1&gt;</code> and a <code>Result&lt;T, Error2&gt;</code> ?</span>または、 <code>Result&lt;T, Error1&gt;</code>および<code>Result&lt;T, Error2&gt;</code>どうなりますか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Handling <i>composition of distinct error types</i> is the next challenge in front of us, and it will be the major theme throughout the rest of this section.</span> <i>個別のエラータイプの処理</i>は、私たちの前で次の課題です。このセクションの残りの部分では、主なテーマになります。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Composing <code>Option</code> and <code>Result</code></span> <code>Option</code>と<code>Result</code></span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So far, I&#39;ve talked about combinators defined for <code>Option</code> and combinators defined for <code>Result</code> .</span>今までは、 <code>Option</code>に対して定義されたコンビネータと<code>Result</code>に対して定義されたコンビネータについて説明しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can use these combinators to compose results of different computations without doing explicit case analysis.</span>これらのコンビネータを使用して、明示的なケース分析を行うことなく、異なる計算の結果を構成することができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Of course, in real code, things aren&#39;t always as clean.</span>もちろん、実際のコードでは、物事は常にきれいではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Sometimes you have a mix of <code>Option</code> and <code>Result</code> types.</span> <code>Option</code>と<code>Result</code>タイプが混在していることがあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Must we resort to explicit case analysis, or can we continue using combinators?</span>明示的なケース分析に頼らなければならないのですか、あるいはコンビネータを使用し続けることができますか？</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For now, let&#39;s revisit one of the first examples in this section:</span>ここでは、このセクションの最初の例の1つに戻ってみましょう。</span> </p><br><div data-lang=rust,should_panic><div data-l="use std::env;"></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let mut argv = env::args();"></div><div data-l="#//    let arg: String = argv.nth(1).unwrap(); // error 1"></div><div data-l="    let arg: String = argv.nth(1).unwrap(); // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">error 1</span>エラー1</span> </div><div data-l="#//    let n: i32 = arg.parse().unwrap(); // error 2"></div><div data-l="    let n: i32 = arg.parse().unwrap(); // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">error 2</span>エラー2</span> </div><div data-l="    println!(&quot;{}&quot;, 2 * n);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Given our new found knowledge of <code>Option</code> , <code>Result</code> and their various combinators, we should try to rewrite this so that errors are handled properly and the program doesn&#39;t panic if there&#39;s an error.</span> <code>Option</code> 、 <code>Result</code> 、およびそれらのさまざまなコンビネータに関する新しい知識があれば、エラーを正しく処理し、エラーがあればプログラムがパニックに陥らないように書き直してください。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The tricky aspect here is that <code>argv.nth(1)</code> produces an <code>Option</code> while <code>arg.parse()</code> produces a <code>Result</code> .</span>ここでのトリッキーな側面は、 <code>argv.nth(1)</code>は<code>Option</code>を生成し、 <code>arg.parse()</code>は<code>Result</code>生成するということです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These aren&#39;t directly composable.</span>これらは直接構成可能ではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When faced with both an <code>Option</code> and a <code>Result</code> , the solution is <i>usually</i> to convert the <code>Option</code> to a <code>Result</code> .</span> <code>Option</code>と<code>Result</code>両方に直面した場合、 <i>通常</i>は<code>Option</code>を<code>Result</code>に変換します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In our case, the absence of a command line parameter (from <code>env::args()</code> ) means the user didn&#39;t invoke the program correctly.</span>私たちの場合、（ <code>env::args()</code> ）コマンドラインパラメータがないということは、ユーザがプログラムを正しく呼び出さなかったことを意味します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We could use a <code>String</code> to describe the error.</span>エラーを記述するために<code>String</code>を使用できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s try:</span>やってみよう：</span> </p><br><p><span id=code-error-double-string></span></p><br><div data-lang=rust><div data-l="use std::env;"></div><div data-l=""></div><div data-l="fn double_arg(mut argv: env::Args) -&gt; Result&lt;i32, String&gt; {"></div><div data-l="    argv.nth(1)"></div><div data-l="        .ok_or(&quot;Please give at least one argument&quot;.to_owned())"></div><div data-l="        .and_then(|arg| arg.parse::&lt;i32&gt;().map_err(|err| err.to_string()))"></div><div data-l="        .map(|n| 2 * n)"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    match double_arg(env::args()) {"></div><div data-l="        Ok(n) =&gt; println!(&quot;{}&quot;, n),"></div><div data-l="        Err(err) =&gt; println!(&quot;Error: {}&quot;, err),"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There are a couple new things in this example.</span>この例ではいくつか新しいことがあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The first is the use of the <a class=notranslate href=#2../../std/option/enum.Option.html#method.ok_or><code>Option::ok_or</code></a> combinator.</span>最初は、 <a class=notranslate href=#2../../std/option/enum.Option.html#method.ok_or><code>Option::ok_or</code></a>コンビネータの使用です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is one way to convert an <code>Option</code> into a <code>Result</code> .</span>これは<code>Option</code>を<code>Result</code>に変換する1つの方法です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The conversion requires you to specify what error to use if <code>Option</code> is <code>None</code> .</span>この変換では、 <code>Option</code>が<code>None</code>場合に使用するエラーを指定する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Like the other combinators we&#39;ve seen, its definition is very simple:</span>私たちが見た他のコンビネータと同様に、その定義は非常に簡単です：</span> </p><br><div data-lang=rust><div data-l="fn ok_or&lt;T, E&gt;(option: Option&lt;T&gt;, err: E) -&gt; Result&lt;T, E&gt; {"></div><div data-l="    match option {"></div><div data-l="        Some(val) =&gt; Ok(val),"></div><div data-l="        None =&gt; Err(err),"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The other new combinator used here is <a class=notranslate href=#2../../std/result/enum.Result.html#method.map_err><code>Result::map_err</code></a> .</span>ここで使用される新しいコンビネータは、 <a class=notranslate href=#2../../std/result/enum.Result.html#method.map_err><code>Result::map_err</code></a>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is like <code>Result::map</code> , except it maps a function on to the <i>error</i> portion of a <code>Result</code> value.</span> <code>Result::map</code>と似ていますが、関数を<code>Result</code>値の<i>エラー</i>部分にマップする点が異なります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If the <code>Result</code> is an <code>Ok(...)</code> value, then it is returned unmodified.</span> <code>Result</code>が<code>Ok(...)</code>値である場合、 <code>Result</code>は変更されずに戻されます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We use <code>map_err</code> here because it is necessary for the error types to remain the same (because of our use of <code>and_then</code> ).</span>ここで<code>map_err</code>を使用して<code>map_err</code>ます。なぜなら、エラーの種類は同じである必要があるから<code>map_err</code>を使用しているため<code>and_then</code> ）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Since we chose to convert the <code>Option&lt;String&gt;</code> (from <code>argv.nth(1)</code> ) to a <code>Result&lt;String, String&gt;</code> , we must also convert the <code>ParseIntError</code> from <code>arg.parse()</code> to a <code>String</code> .</span> <code>Option&lt;String&gt;</code> （ <code>argv.nth(1)</code> ）を<code>Result&lt;String, String&gt;</code>に変換することを選択したので、 <code>ParseIntError</code>を<code>arg.parse()</code>から<code>String</code>も変換する必要があります。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The limits of combinators</span>コンビネータの限界</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Doing IO and parsing input is a very common task, and it&#39;s one that I personally have done a lot of in Rust.</span> IOを行い、入力を解析することは非常に一般的な作業であり、私が個人的にRustで多く行ったことです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Therefore, we will use (and continue to use) IO and various parsing routines to exemplify error handling.</span>したがって、私たちはIOとさまざまな解析ルーチンを使用して（そして引き続き使用して）エラー処理を例示します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s start simple.</span>簡単に始めましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We are tasked with opening a file, reading all of its contents and converting its contents to a number.</span>私たちは、ファイルを開き、すべての内容を読み込み、その内容を数値に変換することを任されています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then we multiply it by <code>2</code> and print the output.</span>次に、 <code>2</code>倍して出力します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Although I&#39;ve tried to convince you not to use <code>unwrap</code> , it can be useful to first write your code using <code>unwrap</code> .</span>私はあなたに<code>unwrap</code>を使わないように説得しようとしましたが、最初に<code>unwrap</code>を使ってコードを書いておくと便利です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It allows you to focus on your problem instead of the error handling, and it exposes the points where proper error handling need to occur.</span>これにより、エラー処理の代わりに問題に集中することができ、適切なエラー処理が必要な箇所が表示されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s start there so we can get a handle on the code, and then refactor it to use better error handling.</span>そこから始めましょう。そこで、コードのハンドルを取得して、より良いエラー処理を使用するようにリファクタリングします。</span> </p><br><div data-lang=rust,should_panic><div data-l="use std::fs::File;"></div><div data-l="use std::io::Read;"></div><div data-l="use std::path::Path;"></div><div data-l=""></div><div data-l="fn file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; i32 {"></div><div data-l="#//    let mut file = File::open(file_path).unwrap(); // error 1"></div><div data-l="    let mut file = File::open(file_path).unwrap(); // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">error 1</span>エラー1</span> </div><div data-l="    let mut contents = String::new();"></div><div data-l="#//    file.read_to_string(&amp;mut contents).unwrap(); // error 2"></div><div data-l="    file.read_to_string(&amp;mut contents).unwrap(); // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">error 2</span>エラー2</span> </div><div data-l="#//    let n: i32 = contents.trim().parse().unwrap(); // error 3"></div><div data-l="    let n: i32 = contents.trim().parse().unwrap(); // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">error 3</span>エラー3</span> </div><div data-l="    2 * n"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let doubled = file_double(&quot;foobar&quot;);"></div><div data-l="    println!(&quot;{}&quot;, doubled);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">(NB The <code>AsRef&lt;Path&gt;</code> is used because those are the <a href=#2../../std/fs/struct.File.html#method.open>same bounds used on <code>std::fs::File::open</code></a> . This makes it ergonomic to use any kind of string as a file path.)</span> （NB <code>AsRef&lt;Path&gt;</code>は<a href=#2../../std/fs/struct.File.html#method.open>、 <code>std::fs::File::open</code>使用されている境界と同じ境界線であるため使用され<code>std::fs::File::open</code></a> 。これにより、ファイルパスとしてあらゆる種類の文字列を使用する人間工学になります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There are three different errors that can occur here:</span>ここで発生する可能性がある3つの異なるエラーがあります。</span> </p><br><div data-b=1.> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A problem opening the file.</span>ファイルを開く際に問題が発生しました。</span> </div><div data-b=2.> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A problem reading data from the file.</span>ファイルからデータを読み取る際に問題が発生しました。</span> </div><div data-b=3.> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A problem parsing the data as a number.</span>データを数値として解析する問題。</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The first two problems are described via the <a class=notranslate href=#2../../std/io/struct.Error.html><code>std::io::Error</code></a> type.</span>最初の2つの問題は、 <a class=notranslate href=#2../../std/io/struct.Error.html><code>std::io::Error</code></a>型を介して記述されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We know this because of the return types of <a class=notranslate href=#2../../std/fs/struct.File.html#method.open><code>std::fs::File::open</code></a> and <a class=notranslate href=#2../../std/io/trait.Read.html#method.read_to_string><code>std::io::Read::read_to_string</code></a> .</span>これは、 <a class=notranslate href=#2../../std/fs/struct.File.html#method.open><code>std::fs::File::open</code></a>と<a class=notranslate href=#2../../std/io/trait.Read.html#method.read_to_string><code>std::io::Read::read_to_string</code></a>の戻り値の型のために<a class=notranslate href=#2../../std/io/trait.Read.html#method.read_to_string><code>std::io::Read::read_to_string</code></a>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">(Note that they both use the <a href=#2#the-result-type-alias-idiom><code>Result</code> type alias idiom</a> described previously. If you click on the <code>Result</code> type, you&#39;ll <a href=#2../../std/io/type.Result.html>see the type alias</a> , and consequently, the underlying <code>io::Error</code> type.) The third problem is described by the <a class=notranslate href=#2../../std/num/struct.ParseIntError.html><code>std::num::ParseIntError</code></a> type.</span> （どちらも使用することに注意してください<a href=#2#the-result-type-alias-idiom><code>Result</code>タイプエイリアスイディオムは、</a>あなたが上でクリックした場合。前述の<code>Result</code>タイプ、あなたはよ<a href=#2../../std/io/type.Result.html>タイプの別名を参照</a>し、その結果、基礎となる<code>io::Error</code>タイプ。）第三の問題は次のように記述され<a class=notranslate href=#2../../std/num/struct.ParseIntError.html><code>std::num::ParseIntError</code></a>型。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>io::Error</code> type in particular is <i>pervasive</i> throughout the standard library.</span> <code>io::Error</code>型は、特に標準ライブラリ全体に<i>広がっ</i>ています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You will see it again and again.</span>あなたはそれを何度も見ます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s start the process of refactoring the <code>file_double</code> function.</span> <code>file_double</code>関数をリファクタリングするプロセスを開始しましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To make this function composable with other components of the program, it should <i>not</i> panic if any of the above error conditions are met.</span>この機能をプログラムの他のコンポーネントと組み合わせるには、上記のエラー条件のいずれかが満たされている場合、パニックにはなり<i>ません</i> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Effectively, this means that the function should <i>return an error</i> if any of its operations fail.</span>効果的には、操作が失敗した場合に関数が<i>エラー</i>を<i>返す</i>必要<i>があります</i> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Our problem is that the return type of <code>file_double</code> is <code>i32</code> , which does not give us any useful way of reporting an error.</span>私たちの問題は、 <code>file_double</code>の戻り値の型が<code>i32</code>であるため、エラーを報告する有用な方法はありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Thus, we must start by changing the return type from <code>i32</code> to something else.</span>したがって、戻り値の型を<code>i32</code>から別のものに変更することから始めなければなりません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The first thing we need to decide: should we use <code>Option</code> or <code>Result</code> ?</span>最初に決定する必要があるのは、 <code>Option</code>または<code>Result</code>を使用するかどうかです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We certainly could use <code>Option</code> very easily.</span>我々は確かに非常に簡単に<code>Option</code>使用することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If any of the three errors occur, we could simply return <code>None</code> .</span> 3つのエラーのいずれかが発生した場合、単に<code>None</code>返すことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This will work <i>and it is better than panicking</i> , but we can do much better.</span>これ<i>はうまくいってパニックよりも優れていますが、もっとうまく</i>いくことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Instead, we should pass some detail about the error that occurred.</span>代わりに、発生したエラーについていくつかの詳細を渡す必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Since we want to express the <i>possibility of error</i> , we should use <code>Result&lt;i32, E&gt;</code> .</span> <i>エラー</i>の<i>可能性</i>を表現したいので、 <code>Result&lt;i32, E&gt;</code>使うべきです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But what should <code>E</code> be?</span>しかし、 <code>E</code>どうなるべきですか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Since two <i>different</i> types of errors can occur, we need to convert them to a common type.</span> 2つの<i>異なる</i>タイプのエラーが発生する可能性があるため、それらを共通のタイプに変換する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">One such type is <code>String</code> .</span>そのようなタイプの1つは<code>String</code>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s see how that impacts our code:</span>それが私たちのコードにどのように影響するのかを見てみましょう：</span> </p><br><div data-lang=rust><div data-l="use std::fs::File;"></div><div data-l="use std::io::Read;"></div><div data-l="use std::path::Path;"></div><div data-l=""></div><div data-l="fn file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;i32, String&gt; {"></div><div data-l="    File::open(file_path)"></div><div data-l="         .map_err(|err| err.to_string())"></div><div data-l="         .and_then(|mut file| {"></div><div data-l="              let mut contents = String::new();"></div><div data-l="              file.read_to_string(&amp;mut contents)"></div><div data-l="                  .map_err(|err| err.to_string())"></div><div data-l="                  .map(|_| contents)"></div><div data-l="         })"></div><div data-l="         .and_then(|contents| {"></div><div data-l="              contents.trim().parse::&lt;i32&gt;()"></div><div data-l="                      .map_err(|err| err.to_string())"></div><div data-l="         })"></div><div data-l="         .map(|n| 2 * n)"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    match file_double(&quot;foobar&quot;) {"></div><div data-l="        Ok(n) =&gt; println!(&quot;{}&quot;, n),"></div><div data-l="        Err(err) =&gt; println!(&quot;Error: {}&quot;, err),"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This code looks a bit hairy.</span>このコードは少し毛深いです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It can take quite a bit of practice before code like this becomes easy to write.</span>このようなコードが書くのが簡単になるには、かなりの練習が必要です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The way we write it is by <i>following the types</i> .</span>私たちが書いているのは、 <i>そのタイプに従うことです</i> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As soon as we changed the return type of <code>file_double</code> to <code>Result&lt;i32, String&gt;</code> , we had to start looking for the right combinators.</span> <code>file_double</code>の戻り値の型を<code>Result&lt;i32, String&gt;</code>に変更するとすぐに、適切なコンビネータを探す必要がありました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this case, we only used three different combinators: <code>and_then</code> , <code>map</code> and <code>map_err</code> .</span>この例では、3つの異なるコンビネータを使用しました： <code>and_then</code> 、 <code>map</code> 、および<code>map_err</code> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>and_then</code> is used to chain multiple computations where each computation could return an error.</span> <code>and_then</code>は、各計算がエラーを返すことができる複数の計算を連鎖させるために使用されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">After opening the file, there are two more computations that could fail: reading from the file and parsing the contents as a number.</span>ファイルを開いた後、失敗する可能性のある計算がもう2つあります：ファイルからの読み取りと内容を数値として解析することです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Correspondingly, there are two calls to <code>and_then</code> .</span>対応して、 <code>and_then</code>への呼び出しが2回あります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>map</code> is used to apply a function to the <code>Ok(...)</code> value of a <code>Result</code> .</span> <code>map</code>は、 <code>Result</code> <code>Ok(...)</code>値に関数を適用するために使用されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, the very last call to <code>map</code> multiplies the <code>Ok(...)</code> value (which is an <code>i32</code> ) by <code>2</code> .</span>たとえば、最後に<code>map</code>呼び出すと、 <code>Ok(...)</code>値（ <code>i32</code> ）に<code>2</code>が乗算されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If an error had occurred before that point, this operation would have been skipped because of how <code>map</code> is defined.</span>そのポイントの前にエラーが発生した場合、 <code>map</code>がどのように定義されているかにより、この操作はスキップされます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>map_err</code> is the trick that makes all of this work.</span> <code>map_err</code>はこのすべてのことを<code>map_err</code>トリックです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>map_err</code> is like <code>map</code> , except it applies a function to the <code>Err(...)</code> value of a <code>Result</code> .</span> <code>map_err</code>は、 <code>Result</code> <code>Err(...)</code>値に関数を適用する点を除いて<code>map</code>と似ています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this case, we want to convert all of our errors to one type: <code>String</code> .</span>この場合、すべてのエラーを1つの型に変換する必要があります。 <code>String</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Since both <code>io::Error</code> and <code>num::ParseIntError</code> implement <code>ToString</code> , we can call the <code>to_string()</code> method to convert them.</span> <code>io::Error</code>と<code>num::ParseIntError</code>どちらも<code>ToString</code>を実装している<code>to_string()</code> 、 <code>to_string()</code>メソッドを呼び出して変換することができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">With all of that said, the code is still hairy.</span>そのすべてが言われて、コードはまだ毛深いです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Mastering use of combinators is important, but they have their limits.</span>コンビネータの使用をマスターすることは重要ですが、それらには限界があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s try a different approach: early returns.</span>別のアプローチ、早期復帰を試してみましょう。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Early returns</span>早期返品</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">I&#39;d like to take the code from the previous section and rewrite it using <i>early returns</i> .</span>私は、前のセクションのコードを取り上げ、 <i>早期復帰</i>を使用して書き直したいと思い<i>ます</i> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Early returns let you exit the function early.</span>早期返品により、早期に機能を終了することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can&#39;t return early in <code>file_double</code> from inside another closure, so we&#39;ll need to revert back to explicit case analysis.</span>別のクロージャの内側から<code>file_double</code>早い段階で戻ることはできないので、明示的なケース分析に戻す必要があります。</span> </p><br><div data-lang=rust><div data-l="use std::fs::File;"></div><div data-l="use std::io::Read;"></div><div data-l="use std::path::Path;"></div><div data-l=""></div><div data-l="fn file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;i32, String&gt; {"></div><div data-l="    let mut file = match File::open(file_path) {"></div><div data-l="        Ok(file) =&gt; file,"></div><div data-l="        Err(err) =&gt; return Err(err.to_string()),"></div><div data-l="    };"></div><div data-l="    let mut contents = String::new();"></div><div data-l="    if let Err(err) = file.read_to_string(&amp;mut contents) {"></div><div data-l="        return Err(err.to_string());"></div><div data-l="    }"></div><div data-l="    let n: i32 = match contents.trim().parse() {"></div><div data-l="        Ok(n) =&gt; n,"></div><div data-l="        Err(err) =&gt; return Err(err.to_string()),"></div><div data-l="    };"></div><div data-l="    Ok(2 * n)"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    match file_double(&quot;foobar&quot;) {"></div><div data-l="        Ok(n) =&gt; println!(&quot;{}&quot;, n),"></div><div data-l="        Err(err) =&gt; println!(&quot;Error: {}&quot;, err),"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Reasonable people can disagree over whether this code is better than the code that uses combinators, but if you aren&#39;t familiar with the combinator approach, this code looks simpler to read to me.</span>合理的な人は、このコードがコンビネータを使用するコードよりも優れているかどうかについては意見を異にすることができますが、コンビネータのアプローチに精通していない場合は、</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It uses explicit case analysis with <code>match</code> and <code>if let</code> .</span>これは、 <code>match</code>と<code>if let</code>を使用した明示的なケース分析を使用<code>if let</code>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If an error occurs, it simply stops executing the function and returns the error (by converting it to string).</span>エラーが発生すると、関数の実行が停止し、エラーが返されます（文字列に変換されます）。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Isn&#39;t this a step backwards though?</span>しかしこれは後退していませんか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Previously, we said that the key to ergonomic error handling is reducing explicit case analysis, yet we&#39;ve reverted back to explicit case analysis here.</span>以前は、人間工学的なエラー処理の鍵は、明示的なケース分析を減らすことですが、ここでは明示的なケース分析に戻しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It turns out, there are <i>multiple</i> ways to reduce explicit case analysis.</span>これは、明示的なケース分析を低減するための<i>複数の</i>方法がありますが、判明しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Combinators aren&#39;t the only way.</span>コンビネータだけが唯一の方法ではありません。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>try€</code> macro</span> <code>try€</code>マクロ</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A cornerstone of error handling in Rust is the <code>try€</code> macro.</span> Rustのエラー処理の基本は<code>try€</code>マクロです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>try€</code> macro abstracts case analysis like combinators, but unlike combinators, it also abstracts <i>control flow</i> .</span> <code>try€</code>マクロはコンバイナのようなケース分析を抽象化しますが、コンビネータとは異なり、 <i>コントロールフロー</i>も抽象化<i>します</i> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Namely, it can abstract the <i>early return</i> pattern seen above.</span>つまり、上記の<i>早期復帰</i>パターンを抽象化することができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here is a simplified definition of a <code>try€</code> macro:</span> <code>try€</code>マクロの簡単な定義を以下に示します。</span> </p><br><p><span id=code-try-def-simple></span></p><br><div data-lang=rust><div data-l="macro_rules! try {"></div><div data-l="    ($e:expr) =&gt; (match $e {"></div><div data-l="        Ok(val) =&gt; val,"></div><div data-l="        Err(err) =&gt; return Err(err),"></div><div data-l="    });"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">(The <a href=#2../../std/macro.try.html>real definition</a> is a bit more sophisticated. We will address that later.)</span> （ <a href=#2../../std/macro.try.html>実際の定義</a>はちょっと洗練されていますが、後でそれを扱います）。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Using the <code>try€</code> macro makes it very easy to simplify our last example.</span> <code>try€</code>マクロを使用する<code>try€</code> 、最後の例を簡単に簡単にすることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Since it does the case analysis and the early return for us, we get tighter code that is easier to read:</span>ケース分析と早期返品を行うので、読みやすい、より厳密なコードが得られます。</span> </p><br><div data-lang=rust><div data-l="use std::fs::File;"></div><div data-l="use std::io::Read;"></div><div data-l="use std::path::Path;"></div><div data-l=""></div><div data-l="fn file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;i32, String&gt; {"></div><div data-l="    let mut file = try!(File::open(file_path).map_err(|e| e.to_string()));"></div><div data-l="    let mut contents = String::new();"></div><div data-l="    try!(file.read_to_string(&amp;mut contents).map_err(|e| e.to_string()));"></div><div data-l="    let n = try!(contents.trim().parse::&lt;i32&gt;().map_err(|e| e.to_string()));"></div><div data-l="    Ok(2 * n)"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    match file_double(&quot;foobar&quot;) {"></div><div data-l="        Ok(n) =&gt; println!(&quot;{}&quot;, n),"></div><div data-l="        Err(err) =&gt; println!(&quot;Error: {}&quot;, err),"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>map_err</code> calls are still necessary given <a href=#2#code-try-def-simple>our definition of <code>try€</code></a> .</span> <a href=#2#code-try-def-simple><code>try€</code>定義を</a>考えると<a href=#2#code-try-def-simple>、</a> <code>map_err</code>コールはまだ必要<a href=#2#code-try-def-simple><code>try€</code></a> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is because the error types still need to be converted to <code>String</code> .</span>これは、エラータイプを引き続き<code>String</code>に変換する必要があるためです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The good news is that we will soon learn how to remove those <code>map_err</code> calls!</span>良いニュースは、私たちが間もなくそれらの<code>map_err</code>呼び出しを削除する方法を学ぶことです！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The bad news is that we will need to learn a bit more about a couple important traits in the standard library before we can remove the <code>map_err</code> calls.</span>悪いニュースは、 <code>map_err</code>呼び出しを削除する前に、標準ライブラリの重要な特性についてもう少し学ぶ必要があることです。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Defining your own error type</span>独自のエラータイプを定義する</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Before we dive into some of the standard library error traits, I&#39;d like to wrap up this section by removing the use of <code>String</code> as our error type in the previous examples.</span>標準的なライブラリのエラー特性のいくつかを知る前に、前の例のエラータイプとして<code>String</code>の使用を取り除いて、このセクションをまとめておきたいと思います。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Using <code>String</code> as we did in our previous examples is convenient because it&#39;s easy to convert errors to strings, or even make up your own errors as strings on the spot.</span>以前の例で行ったように<code>String</code>を使用すると、エラーを文字列に変換したり、現場で文字列として独自のエラーを作成したりすることが容易になるので便利です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, using <code>String</code> for your errors has some downsides.</span>しかし、エラーのために<code>String</code>を使用することにはいくつかの欠点があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The first downside is that the error messages tend to clutter your code.</span>最初の欠点は、エラーメッセージがコードを乱雑にする傾向があることです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It&#39;s possible to define the error messages elsewhere, but unless you&#39;re unusually disciplined, it is very tempting to embed the error message into your code.</span>他の場所でエラーメッセージを定義することは可能ですが、あなたが異常に訓練されていない限り、エラーメッセージをコードに埋め込むことは非常に魅力的です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Indeed, we did exactly this in a <a class=notranslate href=#2#code-error-double-string>previous example</a> .</span>実際、これ<a class=notranslate href=#2#code-error-double-string>previous example</a>ではこれを正確に行いました。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The second and more important downside is that <code>String</code> s are <i>lossy</i> .</span>第2の重要な欠点は、 <code>String</code>が<i>損失であること</i>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That is, if all errors are converted to strings, then the errors we pass to the caller become completely opaque.</span>つまり、すべてのエラーが文字列に変換された場合、呼び出し側に渡すエラーは完全に不透明になります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The only reasonable thing the caller can do with a <code>String</code> error is show it to the user.</span>呼び出し側が<code>String</code>エラーで行うことができる唯一の妥当なことは、ユーザーに表示することです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Certainly, inspecting the string to determine the type of error is not robust.</span>確かに、エラーの種類を判断するために文字列を検査することは堅牢ではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">(Admittedly, this downside is far more important inside of a library as opposed to, say, an application.)</span> （確かに、この欠点は、アプリケーションとは対照的に、図書館の中ではるかに重要です。）</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, the <code>io::Error</code> type embeds an <a class=notranslate href=#2../../std/io/enum.ErrorKind.html><code>io::ErrorKind</code></a> , which is <i>structured data</i> that represents what went wrong during an IO operation.</span>たとえば、 <code>io::Error</code>型は、IO操作中に何が問題になったかを表す<i>構造化データ</i>である<a class=notranslate href=#2../../std/io/enum.ErrorKind.html><code>io::ErrorKind</code></a>埋め込みます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is important because you might want to react differently depending on the error.</span>これは、エラーに応じて異なる反応を起こす可能性があるため、重要です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">(eg, A <code>BrokenPipe</code> error might mean quitting your program gracefully while a <code>NotFound</code> error might mean exiting with an error code and showing an error to the user.) With <code>io::ErrorKind</code> , the caller can examine the type of an error with case analysis, which is strictly superior to trying to tease out the details of an error inside of a <code>String</code> .</span> （例えば、A <code>BrokenPipe</code>エラーは、 <code>NotFound</code>エラーがエラーコードで終了してユーザにエラーを表示している間にプログラムを正常に終了することを意味するかもしれません） <code>io::ErrorKind</code>と、呼び出し側はケース分析これは、 <code>String</code>内部でエラーの詳細を解説しようとするよりも厳密に優れています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Instead of using a <code>String</code> as an error type in our previous example of reading an integer from a file, we can define our own error type that represents errors with <i>structured data</i> .</span>前述のファイルから整数を読み込む例では、エラータイプとして<code>String</code>を使用する代わりに、 <i>構造化データの</i>エラーを表す独自のエラータイプを定義することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We endeavor to not drop information from underlying errors in case the caller wants to inspect the details.</span>発信者が詳細を調べたい場合、根本的なエラーから情報を削除しないように努めます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The ideal way to represent <i>one of many possibilities</i> is to define our own sum type using <code>enum</code> .</span> <i>多くの可能性</i>を表現する理想的な方法は、 <code>enum</code>を使って独自の和型を定義することです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In our case, an error is either an <code>io::Error</code> or a <code>num::ParseIntError</code> , so a natural definition arises:</span>私たちの場合、エラーは<code>io::Error</code>または<code>num::ParseIntError</code>いずれかであるため、自然な定義が生成されます。</span> </p><br><div data-lang=rust><div data-l="use std::io;"></div><div data-l="use std::num;"></div><div data-l=""></div><div data-l="#// We derive `Debug` because all types should probably derive `Debug`."></div><div data-l="#// This gives us a reasonable human-readable description of `CliError` values."></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We derive <code>Debug</code> because all types should probably derive <code>Debug</code> .</span>私たちは、派生<code>Debug</code>すべての種類は、おそらく派生する必要があるため<code>Debug</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This gives us a reasonable human-readable description of <code>CliError</code> values.</span>これは<code>CliError</code>値を人が読めるように説明して<code>CliError</code>ます。</span> </div><div data-l=#[derive(Debug)]></div><div data-l="enum CliError {"></div><div data-l="    Io(io::Error),"></div><div data-l="    Parse(num::ParseIntError),"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Tweaking our code is very easy.</span>私たちのコードを調整するのはとても簡単です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Instead of converting errors to strings, we simply convert them to our <code>CliError</code> type using the corresponding value constructor:</span>エラーを文字列に変換するのではなく、対応する値コンストラクタを使用して<code>CliError</code>型に変換するだけです。</span> </p><br><div data-lang=rust><div data-l="# #[derive(Debug)]"></div><div data-l="# enum CliError { Io(::std::io::Error), Parse(::std::num::ParseIntError) }"></div><div data-l="use std::fs::File;"></div><div data-l="use std::io::Read;"></div><div data-l="use std::path::Path;"></div><div data-l=""></div><div data-l="fn file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;i32, CliError&gt; {"></div><div data-l="    let mut file = try!(File::open(file_path).map_err(CliError::Io));"></div><div data-l="    let mut contents = String::new();"></div><div data-l="    try!(file.read_to_string(&amp;mut contents).map_err(CliError::Io));"></div><div data-l="    let n: i32 = try!(contents.trim().parse().map_err(CliError::Parse));"></div><div data-l="    Ok(2 * n)"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    match file_double(&quot;foobar&quot;) {"></div><div data-l="        Ok(n) =&gt; println!(&quot;{}&quot;, n),"></div><div data-l="        Err(err) =&gt; println!(&quot;Error: {:?}&quot;, err),"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The only change here is switching <code>map_err(|e| e.to_string())</code> (which converts errors to strings) to <code>map_err(CliError::Io)</code> or <code>map_err(CliError::Parse)</code> .</span>ここでの唯一の変更は、 <code>map_err(CliError::Io)</code>または<code>map_err(CliError::Parse)</code> <code>map_err(|e| e.to_string())</code>切り替えること<code>map_err(|e| e.to_string())</code>エラーを文字列に変換します<code>map_err(CliError::Parse)</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <i>caller</i> gets to decide the level of detail to report to the user.</span> <i>呼び出し元</i>は、ユーザーに報告する詳細レベルを決定します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In effect, using a <code>String</code> as an error type removes choices from the caller while using a custom <code>enum</code> error type like <code>CliError</code> gives the caller all of the conveniences as before in addition to <i>structured data</i> describing the error.</span>実際には、Error型として<code>String</code>を使用すると、Errorを記述する<i>構造化データ</i>に加えて、 <code>CliError</code>が前のようにすべての便利さを呼び出し元に与えるような、カスタム<code>enum</code>エラー型を使用しながら呼び出し元から選択肢を削除します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A rule of thumb is to define your own error type, but a <code>String</code> error type will do in a pinch, particularly if you&#39;re writing an application.</span>経験則は独自のエラータイプを定義することですが、特にアプリケーションを作成している場合は、 <code>String</code>エラータイプをピンチで処理します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you&#39;re writing a library, defining your own error type should be strongly preferred so that you don&#39;t remove choices from the caller unnecessarily.</span>ライブラリを作成する場合は、呼び出し元から不必要な選択肢を削除しないように、独自のエラータイプを定義することを強く推奨します。</span> </p><br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Standard library traits used for error handling</span>エラー処理に使用される標準ライブラリ特性</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The standard library defines two integral traits for error handling: <a class=notranslate href=#2../../std/error/trait.Error.html><code>std::error::Error</code></a> and <a class=notranslate href=#2../../std/convert/trait.From.html><code>std::convert::From</code></a> .</span>標準ライブラリは、エラー処理のために<a class=notranslate href=#2../../std/error/trait.Error.html><code>std::error::Error</code></a>と<a class=notranslate href=#2../../std/convert/trait.From.html><code>std::convert::From</code></a> 2つの不可欠な特性を定義しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">While <code>Error</code> is designed specifically for generically describing errors, the <code>From</code> trait serves a more general role for converting values between two distinct types.</span> <code>Error</code>は一般的にエラーを一般的に記述するために設計されていますが、 <code>From</code>特性は2つの異なるタイプ間で値を変換するためのより一般的な役割を果たします。</span> </p><br>
