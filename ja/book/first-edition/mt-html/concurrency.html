<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180709_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=concurrency.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Concurrency</span>並行性</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Concurrency and parallelism are incredibly important topics in computer science, and are also a hot topic in industry today.</span>並行処理と並列処理は、コンピュータサイエンスにおいて非常に重要なトピックであり、今日の業界でも注目されています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Computers are gaining more and more cores, yet many programmers aren&#39;t prepared to fully utilize them.</span>コンピュータはますます多くのコアを獲得していますが、多くのプログラマはそれらを十分に活用する準備ができていません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust&#39;s memory safety features also apply to its concurrency story.</span> Rustのメモリ安全機能は、並行処理の話題にも適用されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Even concurrent Rust programs must be memory safe, having no data races.</span>並行して実行されるRustプログラムであっても、データ競合のないメモリ安全でなければなりません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust&#39;s type system is up to the task, and gives you powerful ways to reason about concurrent code at compile time.</span> Rustの型システムはタスクに依存しており、コンパイル時に同時にコードを推論する強力な方法を提供します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Before we talk about the concurrency features that come with Rust, it&#39;s important to understand something: Rust is low-level enough that the vast majority of this is provided by the standard library, not by the language.</span> Rustに付属する並行処理機能について説明する前に、何かを理解することが重要です。Rustは低レベルであり、これの大部分は言語ではなく標準ライブラリによって提供されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This means that if you don&#39;t like some aspect of the way Rust handles concurrency, you can implement an alternative way of doing things.</span>つまり、Rustが並行処理を行う方法のいくつかの側面が気に入らなければ、別のやり方で実装することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a class=notranslate href=#2https://github.com/carllerche/mio>mio</a> is a real-world example of this principle in action.</span> <a class=notranslate href=#2https://github.com/carllerche/mio>mio</a>は実際のこの原則の実際の例です。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Background: <code>Send</code> and <code>Sync</code></span>背景： <code>Send</code>と<code>Sync</code></span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Concurrency is difficult to reason about.</span>並行処理は理にかなっていません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In Rust, we have a strong, static type system to help us reason about our code.</span> Rustには、コードについての理由を理解するのに役立つ強力な静的型システムがあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As such, Rust gives us two traits to help us make sense of code that can possibly be concurrent.</span>そのため、Rustは、おそらく同時に起こりうるコードの意味を理解するのに役立つ2つの特性を与えてくれます。</span> </p><br><h3> <code>Send</code> </h3> <br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The first trait we&#39;re going to talk about is <a class=notranslate href=#2../../std/marker/trait.Send.html><code>Send</code></a> .</span>話すつもりの最初の特性は<a class=notranslate href=#2../../std/marker/trait.Send.html><code>Send</code></a>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When a type <code>T</code> implements <code>Send</code> , it indicates that something of this type is able to have ownership transferred safely between threads.</span>タイプ<code>T</code>が<code>Send</code>実装するとき、このタイプのものが所有権をスレッド間で安全に転送できることを示します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is important to enforce certain restrictions.</span>これは、特定の制限を実施するために重要です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, if we have a channel connecting two threads, we would want to be able to send some data down the channel and to the other thread.</span>たとえば、2つのスレッドを接続するチャネルがある場合、チャネルと別のスレッドにいくつかのデータを送信できるようにする必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Therefore, we&#39;d ensure that <code>Send</code> was implemented for that type.</span>そのため、そのタイプの<code>Send</code>が実装されていること<code>Send</code>確認します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In the opposite way, if we were wrapping a library with <a class=notranslate href=#3ffi>FFI</a> that isn&#39;t thread-safe, we wouldn&#39;t want to implement <code>Send</code> , and so the compiler will help us enforce that it can&#39;t leave the current thread.</span>反対に、スレッドセーフではない<a class=notranslate href=#3ffi>FFI</a>を使用してライブラリをラップする場合、 <code>Send</code>を実装したくないので、コンパイラは現在のスレッドから離れることができないように強制します。</span> </p><br> <a class=notranslate href=#1ffi.html>ffi</a> <br> <h3> <code>Sync</code> </h3> <br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The second of these traits is called <a class=notranslate href=#2../../std/marker/trait.Sync.html><code>Sync</code></a> .</span>これらの特性の2番目のものを「 <a class=notranslate href=#2../../std/marker/trait.Sync.html><code>Sync</code></a>と呼びます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When a type <code>T</code> implements <code>Sync</code> , it indicates that something of this type has no possibility of introducing memory unsafety when used from multiple threads concurrently through shared references.</span>タイプ<code>T</code>が<code>Sync</code>実装するとき、このタイプのものは、共有参照を介して複数のスレッドから同時に使用されるときにメモリ不安定性を招く可能性がないことを示します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This implies that types which don&#39;t have <a href=#2mutability.html>interior mutability</a> are inherently <code>Sync</code> , which includes simple primitive types (like <code>u8</code> ) and aggregate types containing them.</span>これは、 <a href=#2mutability.html>内部の</a> <code>u8</code>性を持たない型は本質的に<code>Sync</code>であり、シンプルなプリミティブ型（ <code>u8</code> ）とそれを含む集約型を含みます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For sharing references across threads, Rust provides a wrapper type called <code>Arc&lt;T&gt;</code> .</span>スレッド間で参照を共有するために、Rustは<code>Arc&lt;T&gt;</code>というラッパー型を提供します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>Arc&lt;T&gt;</code> implements <code>Send</code> and <code>Sync</code> if and only if <code>T</code> implements both <code>Send</code> and <code>Sync</code> .</span> <code>Arc&lt;T&gt;</code>実装<code>Send</code>と<code>Sync</code>している場合にのみあれば<code>T</code>実装の両方の<code>Send</code>と<code>Sync</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, an object of type <code>Arc&lt;RefCell&lt;U&gt;&gt;</code> cannot be transferred across threads because <a class=notranslate href=#2choosing-your-guarantees.html#refcellt><code>RefCell</code></a> does not implement <code>Sync</code> , consequently <code>Arc&lt;RefCell&lt;U&gt;&gt;</code> would not implement <code>Send</code> .</span>たとえば、 <a class=notranslate href=#2choosing-your-guarantees.html#refcellt><code>RefCell</code></a>は<code>Sync</code>実装していないため、 <code>Arc&lt;RefCell&lt;U&gt;&gt;</code>型のオブジェクトはスレッド間で転送できないため、 <code>Arc&lt;RefCell&lt;U&gt;&gt;</code>は<code>Send</code>実装しません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These two traits allow you to use the type system to make strong guarantees about the properties of your code under concurrency.</span>この2つの特性により、型システムを使用して、並行性の下でコードのプロパティを強力に保証することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Before we demonstrate why, we need to learn how to create a concurrent Rust program in the first place!</span>理由を説明する前に、最初に同時Rustプログラムを作成する方法を学ぶ必要があります。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Threads</span>スレッド</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust&#39;s standard library provides a library for threads, which allow you to run Rust code in parallel.</span> Rustの標準ライブラリにはスレッド用のライブラリが用意されており、Rustコードを並列に実行できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here&#39;s a basic example of using <code>std::thread</code> :</span> <code>std::thread</code>を使用する基本的な例を次に示し<code>std::thread</code> 。</span> </p><br><div data-lang=rust><div data-l="use std::thread;"></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    thread::spawn(|| {"></div><div data-l="        println!(&quot;Hello from a thread!&quot;);"></div><div data-l="    });"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>thread::spawn()</code> method accepts a <a class=notranslate href=#2closures.html>closure</a> , which is executed in a new thread.</span> <code>thread::spawn()</code>メソッドは、新しいスレッドで実行される<a class=notranslate href=#2closures.html>closure</a>受け入れます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It returns a handle to the thread, that can be used to wait for the child thread to finish and extract its result:</span>スレッドへのハンドルを返します。これは、子スレッドが終了してその結果を抽出するのを待つために使用できます。</span> </p><br><div data-lang=rust><div data-l="use std::thread;"></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let handle = thread::spawn(|| {"></div><div data-l="        &quot;Hello from a thread!&quot;"></div><div data-l="    });"></div><div data-l=""></div><div data-l="    println!(&quot;{}&quot;, handle.join().unwrap());"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As closures can capture variables from their environment, we can also try to bring some data into the other thread:</span>クロージャは環境から変数を取り込むことができるので、他のスレッドにいくつかのデータを渡そうとすることもできます：</span> </p><br><div data-lang=rust,ignore><div data-l="use std::thread;"></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let x = 1;"></div><div data-l="    thread::spawn(|| {"></div><div data-l="        println!(&quot;x is {}&quot;, x);"></div><div data-l="    });"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, this gives us an error:</span>しかし、これは私たちにエラーを与えます：</span> </p><br><div data-lang=text><div data-l="5:19: 7:6 error: closure may outlive the current function, but it"></div><div data-l="                 borrows `x`, which is owned by the current function"></div><div data-l=...></div><div data-l="5:19: 7:6 help: to force the closure to take ownership of `x` (and any other referenced variables),"></div><div data-l="          use the `move` keyword, as shown:"></div><div data-l="      thread::spawn(move || {"></div><div data-l="          println!(&quot;x is {}&quot;, x);"></div><div data-l="      });"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is because by default closures capture variables by reference, and thus the closure only captures a <s>reference to `x`</s> .</span>これは、デフォルトでは変数を参照によってクローズするため、クロージャーは<s>`x`へ</s>の<s>参照</s>しかキャプチャし<s>ないから</s>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is a problem, because the thread may outlive the scope of <code>x</code> , leading to a dangling pointer.</span>これは問題です。スレッドが<code>x</code>のスコープよりも長生きして、ぶら下がりポインタにつながる可能性があるからです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To fix this, we use a <code>move</code> closure as mentioned in the error message.</span>これを修正するには、エラーメッセージで説明したように<code>move</code>クロージャを使用します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>move</code> closures are explained in depth <a class=notranslate href=#2closures.html#move-closures>here</a> ;</span> <code>move</code>クロージャについては<a class=notranslate href=#2closures.html#move-closures>here</a>で詳しく説明し<a class=notranslate href=#2closures.html#move-closures>here</a> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">basically they move variables from their environment into themselves.</span>基本的には変数を環境から自分自身に移します。</span> </p><br><div data-lang=rust><div data-l="use std::thread;"></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let x = 1;"></div><div data-l="    thread::spawn(move || {"></div><div data-l="        println!(&quot;x is {}&quot;, x);"></div><div data-l="    });"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Many languages have the ability to execute threads, but it&#39;s wildly unsafe.</span>多くの言語はスレッドを実行する能力を持っていますが、それは危険にさらされています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There are entire books about how to prevent errors that occur from shared mutable state.</span>共有可能な可変状態から発生するエラーを防ぐ方法については、全書籍があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust helps out with its type system here as well, by preventing data races at compile time.</span>錆はコンパイル時にデータ競合を防ぐことで、ここでも型システムをサポートします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s talk about how you actually share things between threads.</span>実際にスレッド間で物事を共有する方法について話しましょう。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Safe Shared Mutable State</span>安全な共有可変状態</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Due to Rust&#39;s type system, we have a concept that sounds like a lie: &quot;safe shared mutable state.&quot;</span> Rustのタイプシステムのおかげで、私たちは嘘のように思えるコンセプトを持っています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Many programmers agree that shared mutable state is very, very bad.</span>多くのプログラマーは、共有可能な可変状態が非常に悪いことに同意します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Someone once said this:</span>誰かがこれを一度言った：</span> </p><br><blockquote><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Shared mutable state is the root of all evil.</span>共有される可変状態はすべての悪の根です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Most languages attempt to deal with this problem through the &#39;mutable&#39; part, but Rust deals with it by solving the &#39;shared&#39; part.</span>ほとんどの言語はこの問題を &#39;変更可能な部分&#39;で処理しようとしますが、Rustは &#39;共有&#39;部分を解決することでそれを処理します。</span> </p></blockquote><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The same <a href=#2ownership.html>ownership system</a> that helps prevent using pointers incorrectly also helps rule out data races, one of the worst kinds of concurrency bugs.</span>ポインタを誤って使用するのを防ぐのに役立つ同じ<a href=#2ownership.html>所有権システム</a>は、最悪の並行性バグの1つであるデータ競合を排除します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As an example, here is a Rust program that would have a data race in many languages.</span>一例として、多くの言語でデータ競争するRustプログラムがあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It will not compile:</span>それはコンパイルされません：</span> </p><br><div data-lang=rust,ignore><div data-l="use std::thread;"></div><div data-l="use std::time::Duration;"></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let mut data = vec![1, 2, 3];"></div><div data-l=""></div><div data-l="    for i in 0..3 {"></div><div data-l="        thread::spawn(move || {"></div><div data-l="            data[0] += i;"></div><div data-l="        });"></div><div data-l="    }"></div><div data-l=""></div><div data-l="    thread::sleep(Duration::from_millis(50));"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This gives us an error:</span>これは私達にエラーを与えます：</span> </p><br><div data-lang=text><div data-l="8:17 error: capture of moved value: `data`"></div><div data-l="        data[0] += i;"></div><div data-l="        ^~~~"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust knows this wouldn&#39;t be safe!</span>錆はこれが安全ではないことを知っている！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we had a reference to <code>data</code> in each thread, and the thread takes ownership of the reference, we&#39;d have three owners!</span>各スレッドの<code>data</code>への参照があり、そのスレッドが参照の所有権を取得している場合、3人の所有者がいます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>data</code> gets moved out of <code>main</code> in the first call to <code>spawn()</code> , so subsequent calls in the loop cannot use this variable.</span> <code>data</code>は<code>spawn()</code>への最初の呼び出しで<code>main</code>から移動します。そのため、ループ内の後続の呼び出しはこの変数を使用できません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So, we need some type that lets us have more than one owning reference to a value.</span>だから、値への参照を複数持つことができるような型が必要です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Usually, we&#39;d use <code>Rc&lt;T&gt;</code> for this, which is a reference counted type that provides shared ownership.</span>通常、これには<code>Rc&lt;T&gt;</code>を使用します。これは共有所有権を提供する参照カウント型です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It has some runtime bookkeeping that keeps track of the number of references to it, hence the &quot;reference count&quot; part of its name.</span>これには、参照の数、つまりその名前の「参照カウント」の部分を追跡する実行時簿記があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Calling <code>clone()</code> on an <code>Rc&lt;T&gt;</code> will return a new owned reference and bump the internal reference count.</span> <code>Rc&lt;T&gt;</code> <code>clone()</code>を呼び出すと、新しい所有参照が返され、内部参照カウントがバンプされます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We create one of these for each thread:</span>スレッドごとに次のいずれかを作成します。</span> </p><br><br><div data-lang=rust,ignore><div data-l="use std::thread;"></div><div data-l="use std::time::Duration;"></div><div data-l="use std::rc::Rc;"></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let mut data = Rc::new(vec![1, 2, 3]);"></div><div data-l=""></div><div data-l="    for i in 0..3 {"></div><div data-l="#        // Create a new owned reference:"></div><div data-l="        // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Create a new owned reference:</span>新しい所有参照を作成する：</span> </div><div data-l="        let data_ref = data.clone();"></div><div data-l=""></div><div data-l="#        // Use it in a thread:"></div><div data-l="        // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Use it in a thread:</span>スレッドで使用する：</span> </div><div data-l="        thread::spawn(move || {"></div><div data-l="            data_ref[0] += i;"></div><div data-l="        });"></div><div data-l="    }"></div><div data-l=""></div><div data-l="    thread::sleep(Duration::from_millis(50));"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This won&#39;t work, however, and will give us the error:</span>しかし、これはうまくいかず、エラーが表示されます：</span> </p><br><div data-lang=text><div data-l="13:9: 13:22 error: the trait bound `alloc::rc::Rc&lt;collections::vec::Vec&lt;i32&gt;&gt; : core::marker::Send`"></div><div data-l="            is not satisfied"></div><div data-l=...></div><div data-l="13:9: 13:22 note: `alloc::rc::Rc&lt;collections::vec::Vec&lt;i32&gt;&gt;`"></div><div data-l="            cannot be sent between threads safely"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As the error message mentions, <code>Rc</code> cannot be sent between threads safely.</span>エラーメッセージに記載されているように、 <code>Rc</code>はスレッド間で安全に送信できません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is because the internal reference count is not maintained in a thread-safe manner and can have a data race.</span>これは、内部参照カウントがスレッドセーフな方法で維持されず、データ競合が発生する可能性があるためです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To solve this, we&#39;ll use <code>Arc&lt;T&gt;</code> , Rust&#39;s standard atomic reference count type.</span>これを解決するために、Rustの標準原子基準型である<code>Arc&lt;T&gt;</code>使用します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The Atomic part means <code>Arc&lt;T&gt;</code> can safely be accessed from multiple threads.</span> Atomicの部分は、 <code>Arc&lt;T&gt;</code>が複数のスレッドから安全にアクセスできることを意味します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To do this the compiler guarantees that mutations of the internal count use indivisible operations which can&#39;t have data races.</span>これを実行するために、コンパイラは、内部カウントの突然変異がデータ競合を持つことができない分割不可能な操作を使用することを保証します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In essence, <code>Arc&lt;T&gt;</code> is a type that lets us share ownership of data <s>across threads</s> .</span>本質的に、 <code>Arc&lt;T&gt;</code>は、 <s>スレッド間</s>でデータの所有権を共有できるようにする型です。</span> </p><br><br><div data-lang=rust,ignore><div data-l="use std::thread;"></div><div data-l="use std::sync::Arc;"></div><div data-l="use std::time::Duration;"></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let mut data = Arc::new(vec![1, 2, 3]);"></div><div data-l=""></div><div data-l="    for i in 0..3 {"></div><div data-l="        let data = data.clone();"></div><div data-l="        thread::spawn(move || {"></div><div data-l="            data[0] += i;"></div><div data-l="        });"></div><div data-l="    }"></div><div data-l=""></div><div data-l="    thread::sleep(Duration::from_millis(50));"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Similarly to last time, we use <code>clone()</code> to create a new owned handle.</span>前回同様、 <code>clone()</code>を使用して新しい所有ハンドルを作成します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This handle is then moved into the new thread.</span>このハンドルは、新しいスレッドに移動されます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">And... still gives us an error.</span>そして...まだ、私たちには誤りがあります。</span> </p><br><div data-lang=text><div data-l="&lt;anon&gt;:11:24 error: cannot borrow immutable borrowed content as mutable"></div><div data-l="&lt;anon&gt;:11                    data[0] += i;"></div><div data-l="                             ^~~~"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>Arc&lt;T&gt;</code> by default has immutable contents.</span> <code>Arc&lt;T&gt;</code>はデフォルトでは不変の内容を持っています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It allows the <s>sharing</s> of data between threads, but shared mutable data is unsafe—and when threads are involved—can cause data races!</span>スレッド間でデータを<s>共有する</s>ことは可能ですが、変更可能な共有データは安全ではなく、スレッドが関与するとデータ競合が発生する可能性があります。</span> </p><br><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Usually when we wish to make something in an immutable position mutable, we use <code>Cell&lt;T&gt;</code> or <code>RefCell&lt;T&gt;</code> which allow safe mutation via runtime checks or otherwise (see also: <a href=#2choosing-your-guarantees.html>Choosing Your Guarantees</a> ).</span>通常は、不変の位置を変更可能にする場合は、ランタイムチェックやその他の方法で安全な突然変異を可能にする<code>Cell&lt;T&gt;</code>または<code>RefCell&lt;T&gt;</code>を使用します（ <a href=#2choosing-your-guarantees.html>保証の選択</a>も参照してください）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, similar to <code>Rc</code> , these are not thread-safe.</span>ただし、 <code>Rc</code>と同様に、これらはスレッドセーフではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we try using these, we will get an error about these types not being <code>Sync</code> , and the code will fail to compile.</span>これらを使用しようとすると、これらのタイプが<code>Sync</code>ではないというエラーが発生し、コードがコンパイルに失敗します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It looks like we need some type that allows us to safely mutate a shared value across threads, for example a type that can ensure only one thread at a time is able to mutate the value inside it at any one time.</span>スレッド間で共有された値を安全に変更できるような型が必要なようです。たとえば、一度に1つのスレッドしか一度に値を変更することはできません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For that, we can use the <code>Mutex&lt;T&gt;</code> type!</span>そのためには、 <code>Mutex&lt;T&gt;</code>型を使用することができます！</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here&#39;s the working version:</span>ここに作業用のバージョンがあります：</span> </p><br><div data-lang=rust><div data-l="use std::sync::{Arc, Mutex};"></div><div data-l="use std::thread;"></div><div data-l="use std::time::Duration;"></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let data = Arc::new(Mutex::new(vec![1, 2, 3]));"></div><div data-l=""></div><div data-l="    for i in 0..3 {"></div><div data-l="        let data = data.clone();"></div><div data-l="        thread::spawn(move || {"></div><div data-l="            let mut data = data.lock().unwrap();"></div><div data-l="            data[0] += i;"></div><div data-l="        });"></div><div data-l="    }"></div><div data-l=""></div><div data-l="    thread::sleep(Duration::from_millis(50));"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that the value of <code>i</code> is bound (copied) to the closure and not shared among the threads.</span> <code>i</code>の値はクロージャにバインド（コピー）され、スレッド間で共有されないことに注意してください。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;re &quot;locking&quot; the mutex here.</span>ここではmutexを「ロック」しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A mutex (short for &quot;mutual exclusion&quot;), as mentioned, only allows one thread at a time to access a value.</span>前述のようにmutex（「相互排他」の略）は、一度に1つのスレッドのみが値にアクセスできるようにします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When we wish to access the value, we use <code>lock()</code> on it.</span>値にアクセスするときは、 <code>lock()</code>を使用し<code>lock()</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This will &quot;lock&quot; the mutex, and no other thread will be able to lock it (and hence, do anything with the value) until we&#39;re done with it.</span>これはミューテックスを「ロック」し、完了するまで、他のスレッドはそれをロックすることができず（従って、値で何かを行うことはできません）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If a thread attempts to lock a mutex which is already locked, it will wait until the other thread releases the lock.</span>スレッドが既にロックされているミューテックスをロックしようとすると、他のスレッドがロックを解除するまで待機します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The lock &quot;release&quot; here is implicit;</span>ここでのロック「リリース」は暗黙的です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">when the result of the lock (in this case, <code>data</code> ) goes out of scope, the lock is automatically released.</span>ロックの結果（この場合は<code>data</code> ）が有効範囲外になると、ロックは自動的に解放されます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that <a class=notranslate href=#2../../std/sync/struct.Mutex.html#method.lock><code>lock</code></a> method of <a class=notranslate href=#2../../std/sync/struct.Mutex.html><code>Mutex</code></a> has this signature:</span> <a class=notranslate href=#2../../std/sync/struct.Mutex.html><code>Mutex</code></a> <a class=notranslate href=#2../../std/sync/struct.Mutex.html#method.lock><code>lock</code></a>メソッドには次のシグネチャがあります。</span> </p><br><div data-lang=rust,ignore><div data-l="fn lock(&amp;self) -&gt; LockResult&lt;MutexGuard&lt;T&gt;&gt;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">and because <code>Send</code> is not implemented for <code>MutexGuard&lt;T&gt;</code> , the guard cannot cross thread boundaries, ensuring thread-locality of lock acquire and release.</span> <code>Send</code>は<code>MutexGuard&lt;T&gt;</code>実装されていないため、ガードはスレッドの境界を越えることができず、ロックの取得と解放のスレッド<code>MutexGuard&lt;T&gt;</code>性が保証されます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s examine the body of the thread more closely:</span>スレッドの本体をより詳しく調べてみましょう。</span> </p><br><div data-lang=rust><div data-l="# use std::sync::{Arc, Mutex};"></div><div data-l="# use std::thread;"></div><div data-l="# use std::time::Duration;"></div><div data-l="# fn main() {"></div><div data-l="#     let data = Arc::new(Mutex::new(vec![1, 2, 3]));"></div><div data-l="#     for i in 0..3 {"></div><div data-l="#         let data = data.clone();"></div><div data-l="thread::spawn(move || {"></div><div data-l="    let mut data = data.lock().unwrap();"></div><div data-l="    data[0] += i;"></div><div data-l=});></div><div data-l="#     }"></div><div data-l="#     thread::sleep(Duration::from_millis(50));"></div><div data-l="# }"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">First, we call <code>lock()</code> , which acquires the mutex&#39;s lock.</span>まず、mutexのロックを取得する<code>lock()</code>を呼び出します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because this may fail, it returns a <code>Result&lt;T, E&gt;</code> , and because this is just an example, we <code>unwrap()</code> it to get a reference to the data.</span>これは失敗する可能性があるため、 <code>Result&lt;T, E&gt;</code>返します。これは単なる例であるため、データへの参照を取得するために<code>unwrap()</code>します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Real code would have more robust error handling here.</span>実際のコードでは、ここでより頑強なエラー処理が行われます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;re then free to mutate it, since we have the lock.</span>私たちはロックを持っているので、自由に変更することができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Lastly, while the threads are running, we wait on a short timer.</span>最後に、スレッドが実行されている間、短いタイマーで待機します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But this is not ideal: we may have picked a reasonable amount of time to wait but it&#39;s more likely we&#39;ll either be waiting longer than necessary or not long enough, depending on just how much time the threads actually take to finish computing when the program runs.</span>しかし、これは理想的ではありません。待機するのに妥当な時間を選んでいるかもしれませんが、スレッドが実際に計算を完了するのにどれくらい時間がかかっているかによって、必要以上に長い時間待機するか、プログラムが実行されます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A more precise alternative to the timer would be to use one of the mechanisms provided by the Rust standard library for synchronizing threads with each other.</span>タイマーのより正確な代替方法は、スレッドを互いに同期させるためにRust標準ライブラリによって提供されるメカニズムの1つを使用することです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s talk about one of them: channels.</span>そのうちの1つについて話しましょう：チャンネル。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Channels</span>チャンネル</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here&#39;s a version of our code that uses channels for synchronization, rather than waiting for a specific time:</span>特定の時間を待つのではなく、同期のためにチャネルを使用するコードのバージョンです：</span> </p><br><div data-lang=rust><div data-l="use std::sync::{Arc, Mutex};"></div><div data-l="use std::thread;"></div><div data-l="use std::sync::mpsc;"></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let data = Arc::new(Mutex::new(0));"></div><div data-l=""></div><div data-l="#    // `tx` is the &quot;transmitter&quot; or &quot;sender&quot;."></div><div data-l="#    // `rx` is the &quot;receiver&quot;."></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>tx</code> is the &quot;transmitter&quot; or &quot;sender&quot;.</span> <code>tx</code>は「送信者」または「送信者」です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>rx</code> is the &quot;receiver&quot;.</span> <code>rx</code>は「受信者」です。</span> </div><div data-l="    let (tx, rx) = mpsc::channel();"></div><div data-l=""></div><div data-l="    for _ in 0..10 {"></div><div data-l="        let (data, tx) = (data.clone(), tx.clone());"></div><div data-l=""></div><div data-l="        thread::spawn(move || {"></div><div data-l="            let mut data = data.lock().unwrap();"></div><div data-l="            *data += 1;"></div><div data-l=""></div><div data-l="            tx.send(()).unwrap();"></div><div data-l="        });"></div><div data-l="    }"></div><div data-l=""></div><div data-l="    for _ in 0..10 {"></div><div data-l="        rx.recv().unwrap();"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We use the <code>mpsc::channel()</code> method to construct a new channel.</span> <code>mpsc::channel()</code>メソッドを使用して新しいチャンネルを作成します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We <code>send</code> a simple <code>()</code> down the channel, and then wait for ten of them to come back.</span>私たちは、 <code>send</code> 、単純な<code>()</code>チャンネルダウンをした後、戻ってきて、それらの10のを待ちます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">While this channel is sending a generic signal, we can send any data that is <code>Send</code> over the channel!</span>このチャンネルは一般的な信号を<code>Send</code>していますが、チャンネル経由で<code>Send</code>することができます。</span> </p><br><div data-lang=rust><div data-l="use std::thread;"></div><div data-l="use std::sync::mpsc;"></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let (tx, rx) = mpsc::channel();"></div><div data-l=""></div><div data-l="    for i in 0..10 {"></div><div data-l="        let tx = tx.clone();"></div><div data-l=""></div><div data-l="        thread::spawn(move || {"></div><div data-l="            let answer = i * i;"></div><div data-l=""></div><div data-l="            tx.send(answer).unwrap();"></div><div data-l="        });"></div><div data-l="    }"></div><div data-l=""></div><div data-l="    for _ in 0..10 {"></div><div data-l="        println!(&quot;{}&quot;, rx.recv().unwrap());"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here we create 10 threads, asking each to calculate the square of a number ( <code>i</code> at the time of <code>spawn()</code> ), and then <code>send()</code> back the answer over the channel.</span>ここでは、数の二乗を計算するために、それぞれを求めて、10個のスレッドを作成します（ <code>i</code>する時に<code>spawn()</code>その後、 <code>send()</code>バックチャネルを介しての答え。</span> </p><br><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Panics</span>パニック</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A <code>panic€</code> will crash the currently executing thread.</span> <code>panic€</code>が実行中のスレッドをクラッシュさせます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can use Rust&#39;s threads as a simple isolation mechanism:</span> Rustのスレッドは、単純な分離機構として使用できます。</span> </p><br><div data-lang=rust><div data-l="use std::thread;"></div><div data-l=""></div><div data-l="let handle = thread::spawn(move || {"></div><div data-l="    panic!(&quot;oops!&quot;);"></div><div data-l=});></div><div data-l=""></div><div data-l="let result = handle.join();"></div><div data-l=""></div><div data-l=assert!(result.is_err());></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>Thread.join()</code> gives us a <code>Result</code> back, which allows us to check if the thread has panicked or not.</span> <code>Thread.join()</code>は<code>Result</code> backを返すので、スレッドがパニックになっているかどうかを確認することができます。</span> </p><script>_addload(function(){_setupIW('com');_csi('en','ja','concurrency.html');});</script>