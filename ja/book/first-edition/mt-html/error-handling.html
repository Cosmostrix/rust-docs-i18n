<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180709_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=error-handling.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Error Handling</span>エラー処理</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Like most programming languages, Rust encourages the programmer to handle errors in a particular way.</span>ほとんどのプログラミング言語と同様に、Rustはプログラマーに特定の方法でエラーを処理させるよう促します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Generally speaking, error handling is divided into two broad categories: exceptions and return values.</span>一般に、エラー処理は、例外と戻り値の2つの大きなカテゴリに分かれています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust opts for return values.</span>錆は戻り値を選択します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this section, we intend to provide a comprehensive treatment of how to deal with errors in Rust.</span>このセクションでは、Rustのエラー処理方法の包括的な扱いを提供するつもりです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">More than that, we will attempt to introduce error handling one piece at a time so that you&#39;ll come away with a solid working knowledge of how everything fits together.</span>それ以上に、私たちは一度に1つずつエラー処理を導入しようとします。そうすれば、すべてのものがどのように適合しているかについての実用的な知識を得ることができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When done naïvely, error handling in Rust can be verbose and annoying.</span> naïvelyを実行すると、Rustのエラー処理が冗長で迷惑になる可能性があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This section will explore those stumbling blocks and demonstrate how to use the standard library to make error handling concise and ergonomic.</span>このセクションでは、これらの障害ブロックを調べ、標準ライブラリを使用してエラー処理を簡潔かつ人間工学的にする方法を示します。</span> </p><br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Table of Contents</span>目次</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This section is very long, mostly because we start at the very beginning with sum types and combinators, and try to motivate the way Rust does error handling incrementally.</span>このセクションは非常に長く、ほとんどの場合、最初に和の型と結合子で開始し、Rustがエラー処理を段階的に行う方法を動機付けようとしているからです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As such, programmers with experience in other expressive type systems may want to jump around.</span>したがって、他の表現型システムでの経験を持つプログラマは、飛び回りたいかもしれません。</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a href=#2#the-basics>The Basics</a></span> <a href=#2#the-basics>基礎</a></span> </div><div data-b="    *"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a href=#2#unwrapping-explained>Unwrapping explained</a></span> <a href=#2#unwrapping-explained>アンラッピングの説明</a></span> </div><div data-b="    *"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a href=#2#the-option-type>The <code>Option</code> type</a></span> <a href=#2#the-option-type><code>Option</code>種類</a></span> </div><div data-b="        *"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a href=#2#composing-optiont-values>Composing <code>Option&lt;T&gt;</code> values</a></span> <a href=#2#composing-optiont-values><code>Option&lt;T&gt;</code>値の作成</a></span> </div><div data-b="    *"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a href=#2#the-result-type>The <code>Result</code> type</a></span> <a href=#2#the-result-type><code>Result</code>型</a></span> </div><div data-b="        *"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a href=#2#parsing-integers>Parsing integers</a></span> <a href=#2#parsing-integers>整数の解析</a></span> </div><div data-b="        *"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a href=#2#the-result-type-alias-idiom>The <code>Result</code> type alias idiom</a></span> <a href=#2#the-result-type-alias-idiom><code>Result</code>型別名イディオム</a></span> </div><div data-b="    *"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a href=#2#a-brief-interlude-unwrapping-isnt-evil>A brief interlude: unwrapping isn&#39;t evil</a></span> <a href=#2#a-brief-interlude-unwrapping-isnt-evil>簡単な間奏：アンラップは悪くない</a></span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a href=#2#working-with-multiple-error-types>Working with multiple error types</a></span> <a href=#2#working-with-multiple-error-types>複数のエラータイプの操作</a></span> </div><div data-b="    *"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a href=#2#composing-option-and-result>Composing <code>Option</code> and <code>Result</code></a></span> <a href=#2#composing-option-and-result><code>Option</code>と<code>Result</code></a></span> </div><div data-b="    *"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a href=#2#the-limits-of-combinators>The limits of combinators</a></span> <a href=#2#the-limits-of-combinators>コンビネータの限界</a></span> </div><div data-b="    *"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a href=#2#early-returns>Early returns</a></span> <a href=#2#early-returns>早期返品</a></span> </div><div data-b="    *"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a href=#2#the-try-macro>The <code>try€</code> macro</a></span> <a href=#2#the-try-macro><code>try€</code>マクロ</a></span> </div><div data-b="    *"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a href=#2#defining-your-own-error-type>Defining your own error type</a></span> <a href=#2#defining-your-own-error-type>独自のエラータイプを定義する</a></span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a href=#2#standard-library-traits-used-for-error-handling>Standard library traits used for error handling</a></span> <a href=#2#standard-library-traits-used-for-error-handling>エラー処理に使用される標準ライブラリ特性</a></span> </div><div data-b="    *"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a href=#2#the-error-trait>The <code>Error</code> trait</a></span> <a href=#2#the-error-trait><code>Error</code>特性</a></span> </div><div data-b="    *"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a href=#2#the-from-trait>The <code>From</code> trait</a></span> <a href=#2#the-from-trait><code>From</code>特性</a></span> </div><div data-b="    *"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a href=#2#the-real-try-macro>The real <code>try€</code> macro</a></span> <a href=#2#the-real-try-macro>本当の<code>try€</code>マクロ</a></span> </div><div data-b="    *"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a href=#2#composing-custom-error-types>Composing custom error types</a></span> <a href=#2#composing-custom-error-types>カスタムエラータイプの作成</a></span> </div><div data-b="    *"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a href=#2#advice-for-library-writers>Advice for library writers</a></span> <a href=#2#advice-for-library-writers>図書館の作家のためのアドバイス</a></span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a href=#2#case-study-a-program-to-read-population-data>Case study: A program to read population data</a></span> <a href=#2#case-study-a-program-to-read-population-data>ケーススタディ：人口データを読み込むプログラム</a></span> </div><div data-b="    *"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a href=#2#initial-setup>Initial setup</a></span> <a href=#2#initial-setup>初期設定</a></span> </div><div data-b="    *"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a href=#2#argument-parsing>Argument parsing</a></span> <a href=#2#argument-parsing>引数の解析</a></span> </div><div data-b="    *"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a href=#2#writing-the-logic>Writing the logic</a></span> <a href=#2#writing-the-logic>論理を書く</a></span> </div><div data-b="    *"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a href=#2#error-handling-with-boxerror>Error handling with <code>Box&lt;Error&gt;</code></a></span> <a href=#2#error-handling-with-boxerror><code>Box&lt;Error&gt;</code>エラー処理<code>Box&lt;Error&gt;</code></a></span> </div><div data-b="    *"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a href=#2#reading-from-stdin>Reading from stdin</a></span> <a href=#2#reading-from-stdin>スタンダードから読む</a></span> </div><div data-b="    *"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a href=#2#error-handling-with-a-custom-type>Error handling with a custom type</a></span> <a href=#2#error-handling-with-a-custom-type>カスタムタイプによるエラー処理</a></span> </div><div data-b="    *"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a href=#2#adding-functionality>Adding functionality</a></span> <a href=#2#adding-functionality>機能の追加</a></span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a href=#2#the-short-story>The short story</a></span> <a href=#2#the-short-story>短編小説</a></span> </div><br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The Basics</span>基礎</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can think of error handling as using <i>case analysis</i> to determine whether a computation was successful or not.</span>エラー処理は、 <i>ケース分析</i>を使用して計算が成功したかどうかを判断すると考えることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As you will see, the key to ergonomic error handling is reducing the amount of explicit case analysis the programmer has to do while keeping code composable.</span>ご存じのように、人間工学的なエラー処理の鍵は、プログラマがコードを構成可能に保ちながら明示的なケース分析を減らすことです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Keeping code composable is important, because without that requirement, we could <a class=notranslate href=#2../../std/macro.panic.html><code>panic</code></a> whenever we come across something unexpected.</span>コードを構成可能にすることは重要です。なぜなら、そのような要件がなければ、予期せぬことが起こるたびに<a class=notranslate href=#2../../std/macro.panic.html><code>panic</code></a>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">( <code>panic</code> causes the current task to unwind, and in most cases, the entire program aborts.) Here&#39;s an example:</span> （ <code>panic</code>により現在のタスクが巻き戻され、ほとんどの場合、プログラム全体が異常終了します）。次に例を示します。</span> </p><br><div data-lang=rust,should_panic><div data-l="#// Guess a number between 1 and 10."></div><div data-l="#// If it matches the number we had in mind, return `true`. Else, return `false`."></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Guess a number between 1 and 10. If it matches the number we had in mind, return <code>true</code> .</span> 1と10の間の数字を推測し<code>true</code> 。私たちが気にしていた数字と一致する場合は<code>true</code>返し<code>true</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Else, return <code>false</code> .</span>それ以外の場合は<code>false</code>返し<code>false</code> 。</span> </div><div data-l="fn guess(n: i32) -&gt; bool {"></div><div data-l="    if n &lt; 1 || n &gt; 10 {"></div><div data-l="        panic!(&quot;Invalid number: {}&quot;, n);"></div><div data-l="    }"></div><div data-l="    n == 5"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    guess(11);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you try running this code, the program will crash with a message like this:</span>このコードを実行しようとすると、プログラムは次のようなメッセージでクラッシュします。</span> </p><br><div data-lang=text><div data-l="thread 'main' panicked at 'Invalid number: 11', src/bin/panic-simple.rs:5"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here&#39;s another example that is slightly less contrived.</span>ここにもう少し人工的ではない別の例があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A program that accepts an integer as an argument, doubles it and prints it.</span>引数として整数を受け取り、倍精度化して出力するプログラム。</span> </p><br><p><span id=code-unwrap-double></span></p><br><div data-lang=rust,should_panic><div data-l="use std::env;"></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let mut argv = env::args();"></div><div data-l="#//    let arg: String = argv.nth(1).unwrap(); // error 1"></div><div data-l="    let arg: String = argv.nth(1).unwrap(); // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">error 1</span>エラー1</span> </div><div data-l="#//    let n: i32 = arg.parse().unwrap(); // error 2"></div><div data-l="    let n: i32 = arg.parse().unwrap(); // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">error 2</span>エラー2</span> </div><div data-l="    println!(&quot;{}&quot;, 2 * n);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you give this program zero arguments (error 1) or if the first argument isn&#39;t an integer (error 2), the program will panic just like in the first example.</span>このプログラムにゼロ引数（エラー1）を渡すか、最初の引数が整数でない場合（エラー2）、プログラムは最初の例のようにパニックになります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can think of this style of error handling as similar to a bull running through a china shop.</span>このエラー処理のスタイルは、中国の店を走っているブルと同様に考えることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The bull will get to where it wants to go, but it will trample everything in the process.</span>牛はどこに行きたいのか分かりますが、その過程ですべてを踏みにじります。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Unwrapping explained</span>アンラッピングの説明</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In the previous example, we claimed that the program would simply panic if it reached one of the two error conditions, yet, the program does not include an explicit call to <code>panic</code> like the first example.</span>前の例では、プログラムが2つのエラー条件のいずれかに達した場合にパニックになると主張しましたが、プログラムには最初の例のように明示的な<code>panic</code>コールは含まれていません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is because the panic is embedded in the calls to <code>unwrap</code> .</span>これは、パニックが<code>unwrap</code>の呼び出しに埋め込まれているためです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To “unwrap” something in Rust is to say, “Give me the result of the computation, and if there was an error, panic and stop the program.” It would be better if we showed the code for unwrapping because it is so simple, but to do that, we will first need to explore the <code>Option</code> and <code>Result</code> types.</span> Rustの中の何かを &quot;unwrap&quot;するのは、 &quot;計算の結果を教えてください。エラーがあった場合は、パニックを起こしてプログラムを止めてください&quot;ということです。それを行うには、まず<code>Option</code>と<code>Result</code>型を調べる必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Both of these types have a method called <code>unwrap</code> defined on them.</span>これらの両方の型には、 <code>unwrap</code>というメソッドが定義されています。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Option</code> type</span> <code>Option</code>種類</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Option</code> type is <a href=#35>defined in the standard library</a> :</span> <code>Option</code>タイプは<a href=#35>標準ライブラリで定義されています</a> ：</span> </p><br><div data-lang=rust><div data-l="enum Option&lt;T&gt; {"></div><div data-l="    None,"></div><div data-l="    Some(T),"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Option</code> type is a way to use Rust&#39;s type system to express the <i>possibility of absence</i> .</span> <code>Option</code>型は、Rustの型システムを使用して<i>不在</i>の<i>可能性</i>を表現する方法です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Encoding the possibility of absence into the type system is an important concept because it will cause the compiler to force the programmer to handle that absence.</span>型システムへの不在の可能性をコード化することは、コンパイラがプログラマにその不在を処理させるため、重要な概念です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s take a look at an example that tries to find a character in a string:</span>文字列内の文字を検索しようとする例を見てみましょう：</span> </p><br><p><span id=code-option-ex-string-find></span></p><br><div data-lang=rust><div data-l="#// Searches `haystack` for the Unicode character `needle`. If one is found, the"></div><div data-l="#// byte offset of the character is returned. Otherwise, `None` is returned."></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Searches <code>haystack</code> for the Unicode character <code>needle</code> .</span> <code>haystack</code>でUnicode文字の<code>needle</code>検索します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If one is found, the byte offset of the character is returned.</span>見つかった場合、文字のバイトオフセットが返されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Otherwise, <code>None</code> is returned.</span>それ以外の場合は、 <code>None</code>が返されます。</span> </div><div data-l="fn find(haystack: &amp;str, needle: char) -&gt; Option&lt;usize&gt; {"></div><div data-l="    for (offset, c) in haystack.char_indices() {"></div><div data-l="        if c == needle {"></div><div data-l="            return Some(offset);"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l="    None"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Notice that when this function finds a matching character, it doesn&#39;t only return the <code>offset</code> .</span>この関数が一致する文字を見つけると、 <code>offset</code>返すだけではないことに注意してください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Instead, it returns <code>Some(offset)</code> .</span>代わりに、 <code>Some(offset)</code>返します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>Some</code> is a variant or a <i>value constructor</i> for the <code>Option</code> type.</span> <code>Some</code>は、 <code>Option</code>タイプのバリアントまたは<i>値コンストラクタ</i>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can think of it as a function with the type <code>fn&lt;T&gt;(value: T) -&gt; Option&lt;T&gt;</code> .</span>これは、 <code>fn&lt;T&gt;(value: T) -&gt; Option&lt;T&gt;</code>型の関数と考えることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Correspondingly, <code>None</code> is also a value constructor, except it has no arguments.</span>これに対応して、 <code>None</code>も引数を持たないことを除いて、値のコンストラクタです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can think of <code>None</code> as a function with the type <code>fn&lt;T&gt;() -&gt; Option&lt;T&gt;</code> .</span> <code>None</code>は<code>fn&lt;T&gt;() -&gt; Option&lt;T&gt;</code>型の関数と考えることができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This might seem like much ado about nothing, but this is only half of the story.</span>これは何のためにも大きな騒ぎのように思えるかもしれませんが、これは物語の半分に過ぎません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The other half is <i>using</i> the <code>find</code> function we&#39;ve written.</span>残りの半分は、私たちが書いた<code>find</code>関数を<i>使っ</i>てい<code>find</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s try to use it to find the extension in a file name.</span>ファイル名の拡張子を見つけるためにそれを使ってみましょう。</span> </p><br><div data-lang=rust><div data-l="# fn find(haystack: &amp;str, needle: char) -&gt; Option&lt;usize&gt; { haystack.find(needle) }"></div><div data-l="fn main() {"></div><div data-l="    let file_name = &quot;foobar.rs&quot;;"></div><div data-l="    match find(file_name, '.') {"></div><div data-l="        None =&gt; println!(&quot;No file extension found.&quot;),"></div><div data-l="        Some(i) =&gt; println!(&quot;File extension: {}&quot;, &amp;file_name[i+1..]),"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This code uses <a href=#31>pattern matching</a> to do <i>case analysis</i> on the <code>Option&lt;usize&gt;</code> returned by the <code>find</code> function.</span>このコードは、 <a href=#31>パターンマッチング</a>を使用して、 <code>find</code>関数によって返された<code>Option&lt;usize&gt;</code>に対して<i>ケース分析</i>を行います。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In fact, case analysis is the only way to get at the value stored inside an <code>Option&lt;T&gt;</code> .</span>実際、ケース分析は、 <code>Option&lt;T&gt;</code>内に格納された値を取得する唯一の方法です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This means that you, as the programmer, must handle the case when an <code>Option&lt;T&gt;</code> is <code>None</code> instead of <code>Some(t)</code> .</span>これは、プログラマとして、 <code>Option&lt;T&gt;</code> <code>Some(t)</code>が<code>Some(t)</code>ではなく<code>None</code> <code>Some(t)</code> <code>None</code>の場合に対処する必要があることを意味します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But wait, what about <code>unwrap</code> , which we used <a class=notranslate href=#2#code-unwrap-double>previously</a> ?</span>しかし、私たちが<a class=notranslate href=#2#code-unwrap-double>previously</a>に使った<code>unwrap</code>はどうですか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There was no case analysis there!</span>そこに事例分析はなかった！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Instead, the case analysis was put inside the <code>unwrap</code> method for you.</span>代わりに、ケース分析を<code>unwrap</code>メソッドの中に入れました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You could define it yourself if you want:</span>あなたが望むならそれを自分で定義することができます：</span> </p><br><p><span id=code-option-def-unwrap></span></p><br><div data-lang=rust><div data-l="enum Option&lt;T&gt; {"></div><div data-l="    None,"></div><div data-l="    Some(T),"></div><div data-l=}></div><div data-l=""></div><div data-l="impl&lt;T&gt; Option&lt;T&gt; {"></div><div data-l="    fn unwrap(self) -&gt; T {"></div><div data-l="        match self {"></div><div data-l="            Option::Some(val) =&gt; val,"></div><div data-l="            Option::None =&gt;"></div><div data-l="              panic!(&quot;called `Option::unwrap()` on a `None` value&quot;),"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>unwrap</code> method <i>abstracts away the case analysis</i> .</span> <code>unwrap</code>メソッド<i>は、ケース分析を抽象化します</i> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is precisely the thing that makes <code>unwrap</code> ergonomic to use.</span>これはまさに人間工学に基づいた<code>unwrap</code>を使用することです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Unfortunately, that <code>panic€</code> means that <code>unwrap</code> is not composable: it is the bull in the china shop.</span>残念なことに、その<code>panic€</code>は、 <code>unwrap</code>が構成可能でないことを意味します。それは中国の店の雄牛です。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Composing <code>Option&lt;T&gt;</code> values</span> <code>Option&lt;T&gt;</code>値の作成</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In an <a href=#2#code-option-ex-string-find>example from before</a> , we saw how to use <code>find</code> to discover the extension in a file name.</span> <a href=#2#code-option-ex-string-find>前</a>の<a href=#2#code-option-ex-string-find>例では</a> 、 <code>find</code>を使用してファイル名の拡張子を検出する方法を見てきました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Of course, not all file names have a <code>.</code></span>もちろん、すべてのファイル名にaが付いているわけではありません<code>.</code></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">in them, so it&#39;s possible that the file name has no extension.</span>そのため、ファイル名には拡張子がない可能性があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This <i>possibility of absence</i> is encoded into the types using <code>Option&lt;T&gt;</code> .</span>この<i>不在の可能性は、</i> <code>Option&lt;T&gt;</code>を使用して型にコード化されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In other words, the compiler will force us to address the possibility that an extension does not exist.</span>言い換えると、コンパイラは、拡張が存在しない可能性に対処するように強制します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In our case, we only print out a message saying as such.</span>私たちの場合は、そのようなメッセージだけを出力します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Getting the extension of a file name is a pretty common operation, so it makes sense to put it into a function:</span>ファイル名の拡張子を取得するのはかなり一般的な操作なので、それを関数に入れるのは理にかなっています：</span> </p><br><div data-lang=rust><div data-l="# fn find(haystack: &amp;str, needle: char) -&gt; Option&lt;usize&gt; { haystack.find(needle) }"></div><div data-l="#// Returns the extension of the given file name, where the extension is defined"></div><div data-l="#// as all characters following the first `.`."></div><div data-l="#// If `file_name` has no `.`, then `None` is returned."></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Returns the extension of the given file name, where the extension is defined as all characters following the first <code>.</code></span>指定されたファイル名の拡張子を返します。拡張子は、最初の拡張子に続くすべての文字として定義されます<code>.</code></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">.</span> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If <code>file_name</code> has no <code>.</code></span> <code>file_name</code>にnoが<code>file_name</code>ている場合<code>.</code></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">, then <code>None</code> is returned.</span> 、 <code>None</code>が返されます。</span> </div><div data-l="fn extension_explicit(file_name: &amp;str) -&gt; Option&lt;&amp;str&gt; {"></div><div data-l="    match find(file_name, '.') {"></div><div data-l="        None =&gt; None,"></div><div data-l="        Some(i) =&gt; Some(&amp;file_name[i+1..]),"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">(Pro-tip: don&#39;t use this code. Use the <a class=notranslate href=#2../../std/path/struct.Path.html#method.extension><code>extension</code></a> method in the standard library instead.)</span> （Pro-tip：このコードは使用しないでください。代わりに標準ライブラリの<a class=notranslate href=#2../../std/path/struct.Path.html#method.extension><code>extension</code></a>メソッドを使用してください）。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The code stays simple, but the important thing to notice is that the type of <code>find</code> forces us to consider the possibility of absence.</span>コードは単純なままですが、気付くべき重要なことは、 <code>find</code>のタイプが<code>find</code>私たちに不在の可能性を考慮させることです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is a good thing because it means the compiler won&#39;t let us accidentally forget about the case where a file name doesn&#39;t have an extension.</span>これは、ファイル名に拡張子が付いていない場合をコンパイラーが誤って忘れてしまうことを意味しないため、良いことです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">On the other hand, doing explicit case analysis like we&#39;ve done in <code>extension_explicit</code> every time can get a bit tiresome.</span>一方、毎回<code>extension_explicit</code>行ったような明示的なケース分析を行うと、少し面倒なことが起こります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In fact, the case analysis in <code>extension_explicit</code> follows a very common pattern: <i>map</i> a function on to the value inside of an <code>Option&lt;T&gt;</code> , unless the option is <code>None</code> , in which case, return <code>None</code> .</span>実際には、中ケース解析<code>extension_explicit</code>非常に一般的なパターンに従う：の内部値へのファンクションを<i>マップ</i> <code>Option&lt;T&gt;</code>オプションがない場合を除き、 <code>None</code> 、その場合には、返さない<code>None</code> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust has parametric polymorphism, so it is very easy to define a combinator that abstracts this pattern:</span> Rustはパラメトリック多形性を持つため、このパターンを抽象化するコンビネータを定義するのは非常に簡単です：</span> </p><br><p><span id=code-option-map></span></p><br><div data-lang=rust><div data-l="fn map&lt;F, T, A&gt;(option: Option&lt;T&gt;, f: F) -&gt; Option&lt;A&gt; where F: FnOnce(T) -&gt; A {"></div><div data-l="    match option {"></div><div data-l="        None =&gt; None,"></div><div data-l="        Some(value) =&gt; Some(f(value)),"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Indeed, <code>map</code> is <a href=#32>defined as a method</a> on <code>Option&lt;T&gt;</code> in the standard library.</span>実際、 <code>map</code>は標準ライブラリの<code>Option&lt;T&gt;</code> <a href=#32>メソッドとして定義されてい</a>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As a method, it has a slightly different signature: methods take <code>self</code> , <code>&amp;self</code> , or <code>&amp;mut self</code> as their first argument.</span>メソッドとして、それはわずかに異なるシグネチャを持ちます：メソッドは、 <code>self</code> 、 <code>&amp;self</code> 、または<code>&amp;mut self</code>を最初の引数として取ります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Armed with our new combinator, we can rewrite our <code>extension_explicit</code> method to get rid of the case analysis:</span>新しいコンビネータを使用して、 <code>extension_explicit</code>メソッドを書き直して、ケース分析を取り除くことができます：</span> </p><br><div data-lang=rust><div data-l="# fn find(haystack: &amp;str, needle: char) -&gt; Option&lt;usize&gt; { haystack.find(needle) }"></div><div data-l="#// Returns the extension of the given file name, where the extension is defined"></div><div data-l="#// as all characters following the first `.`."></div><div data-l="#// If `file_name` has no `.`, then `None` is returned."></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Returns the extension of the given file name, where the extension is defined as all characters following the first <code>.</code></span>指定されたファイル名の拡張子を返します。拡張子は、最初の拡張子に続くすべての文字として定義されます<code>.</code></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">.</span> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If <code>file_name</code> has no <code>.</code></span> <code>file_name</code>にnoが<code>file_name</code>ている場合<code>.</code></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">, then <code>None</code> is returned.</span> 、 <code>None</code>が返されます。</span> </div><div data-l="fn extension(file_name: &amp;str) -&gt; Option&lt;&amp;str&gt; {"></div><div data-l="    find(file_name, '.').map(|i| &amp;file_name[i+1..])"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">One other pattern we commonly find is assigning a default value to the case when an <code>Option</code> value is <code>None</code> .</span>私たちがよく見かけるもう一つのパターンは、 <code>Option</code>値が<code>None</code>場合にデフォルト値を代入することです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, maybe your program assumes that the extension of a file is <code>rs</code> even if none is present.</span>たとえば、ファイルが存在しない場合でもファイルの拡張子が<code>rs</code>であるとプログラムが想定しているとします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As you might imagine, the case analysis for this is not specific to file extensions - it can work with any <code>Option&lt;T&gt;</code> :</span>ご想像のように、これについてのケース分析は、ファイル拡張子に固有のものではなく、 <code>Option&lt;T&gt;</code>動作します：</span> </p><br><div data-lang=rust><div data-l="fn unwrap_or&lt;T&gt;(option: Option&lt;T&gt;, default: T) -&gt; T {"></div><div data-l="    match option {"></div><div data-l="        None =&gt; default,"></div><div data-l="        Some(value) =&gt; value,"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Like with <code>map</code> above, the standard library implementation is a method instead of a free function.</span>上記の<code>map</code>と同様に、標準ライブラリの実装は空き関数ではなくメソッドです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The trick here is that the default value must have the same type as the value that might be inside the <code>Option&lt;T&gt;</code> .</span>ここでのトリックは、デフォルト値が<code>Option&lt;T&gt;</code>内にある可能性のある値と同じ型でなければならないということです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Using it is dead simple in our case:</span>私たちの場合、それを使うのは簡単ではありません。</span> </p><br><div data-lang=rust><div data-l="# fn find(haystack: &amp;str, needle: char) -&gt; Option&lt;usize&gt; {"></div><div data-l="#     for (offset, c) in haystack.char_indices() {"></div><div data-l="#         if c == needle {"></div><div data-l="#             return Some(offset);"></div><div data-l="#         }"></div><div data-l="#     }"></div><div data-l="#     None"></div><div data-l="# }"></div><div data-l=#></div><div data-l="# fn extension(file_name: &amp;str) -&gt; Option&lt;&amp;str&gt; {"></div><div data-l="#     find(file_name, '.').map(|i| &amp;file_name[i+1..])"></div><div data-l="# }"></div><div data-l="fn main() {"></div><div data-l="    assert_eq!(extension(&quot;foobar.csv&quot;).unwrap_or(&quot;rs&quot;), &quot;csv&quot;);"></div><div data-l="    assert_eq!(extension(&quot;foobar&quot;).unwrap_or(&quot;rs&quot;), &quot;rs&quot;);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">(Note that <code>unwrap_or</code> is <a href=#33>defined as a method</a> on <code>Option&lt;T&gt;</code> in the standard library, so we use that here instead of the free-standing function we defined above. Don&#39;t forget to check out the more general <a class=notranslate href=#34><code>unwrap_or_else</code></a> method.)</span> （ <code>unwrap_or</code>は標準ライブラリの<code>Option&lt;T&gt;</code> <a href=#33>メソッドとして定義されているので、</a>上で<a href=#33>定義した</a>自立関数の代わりにここで使用します）もっと一般的な<a class=notranslate href=#34><code>unwrap_or_else</code></a>メソッドをチェックしてください。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There is one more combinator that we think is worth paying special attention to: <code>and_then</code> .</span>特別な注意を払う価値のあるコンビネータがもう1人あります： <code>and_then</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It makes it easy to compose distinct computations that admit the <i>possibility of absence</i> .</span>これは<i>、不在</i>の<i>可能性</i>を認める明確な計算を容易に構成する。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, much of the code in this section is about finding an extension given a file name.</span>たとえば、このセクションのコードの大部分は、ファイル名を指定して拡張子を見つけることです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In order to do this, you first need the file name which is typically extracted from a file <i>path</i> .</span>これを行うには、まずファイル<i>パス</i>から抽出されるファイル名が必要です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">While most file paths have a file name, not <i>all</i> of them do.</span>ほとんどのファイルパスはファイル名を持っていますが、 <i>すべて</i>のファイルパスではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, <code>.</code></span>たとえば、 <code>.</code></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">, <code>..</code> or <code>/</code> .</span> 、 <code>..</code>または<code>/</code> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So, we are tasked with the challenge of finding an extension given a file <i>path</i> .</span>したがって、私たちは、ファイル<i>パスを</i>与えられた拡張子を見つけるという課題に取り組んでいます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s start with explicit case analysis:</span>明示的なケース分析から始めましょう：</span> </p><br><div data-lang=rust><div data-l="# fn extension(file_name: &amp;str) -&gt; Option&lt;&amp;str&gt; { None }"></div><div data-l="fn file_path_ext_explicit(file_path: &amp;str) -&gt; Option&lt;&amp;str&gt; {"></div><div data-l="    match file_name(file_path) {"></div><div data-l="        None =&gt; None,"></div><div data-l="        Some(name) =&gt; match extension(name) {"></div><div data-l="            None =&gt; None,"></div><div data-l="            Some(ext) =&gt; Some(ext),"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="fn file_name(file_path: &amp;str) -&gt; Option&lt;&amp;str&gt; {"></div><div data-l="#  // Implementation elided."></div><div data-l="  // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Implementation elided.</span>実装は省略されました。</span> </div><div data-l="  unimplemented!()"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You might think that we could use the <code>map</code> combinator to reduce the case analysis, but its type doesn&#39;t quite fit...</span>あなたは事例分析を減らすために<code>map</code>コンビネータを使うことができると思うかもしれませんが、そのタイプはあまり適切ではありません...</span> </p><br><div data-lang=rust,ignore><div data-l="fn file_path_ext(file_path: &amp;str) -&gt; Option&lt;&amp;str&gt; {"></div><div data-l="#//    file_name(file_path).map(|x| extension(x)) // This causes a compilation error."></div><div data-l="    file_name(file_path).map(|x| extension(x)) // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This causes a compilation error.</span>これにより、コンパイルエラーが発生します。</span> </div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>map</code> function here wraps the value returned by the <code>extension</code> function inside an <code>Option&lt;_&gt;</code> and since the <code>extension</code> function itself returns an <code>Option&lt;&amp;str&gt;</code> the expression <code>file_name(file_path).map(|x| extension(x))</code> actually returns an <code>Option&lt;Option&lt;&amp;str&gt;&gt;</code> .</span> <code>map</code>関数は、 <code>extension</code>関数によって返された値を<code>Option&lt;_&gt;</code>中にラップします。 <code>extension</code>関数自身が<code>Option&lt;&amp;str&gt;</code>返すので、式<code>file_name(file_path).map(|x| extension(x))</code>実際に<code>Option&lt;Option&lt;&amp;str&gt;&gt;</code></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But since <code>file_path_ext</code> just returns <code>Option&lt;&amp;str&gt;</code> (and not <code>Option&lt;Option&lt;&amp;str&gt;&gt;</code> ) we get a compilation error.</span>しかし、 <code>file_path_ext</code>は<code>Option&lt;&amp;str&gt;</code> （ <code>Option&lt;Option&lt;&amp;str&gt;&gt;</code>ではなく）を返すので、コンパイルエラーが発生します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The result of the function taken by map as input is <i>always</i> <a href=#2#code-option-map>rewrapped with <code>Some</code></a> .</span>入力としてマップで撮影された関数の結果は<i>、常に</i>され<a href=#2#code-option-map>てリラップ<code>Some</code></a> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Instead, we need something like <code>map</code> , but which allows the caller to return a <code>Option&lt;_&gt;</code> directly without wrapping it in another <code>Option&lt;_&gt;</code> .</span>代わりに、 <code>map</code>ようなものが必要ですが、呼び出し元が<code>Option&lt;_&gt;</code>を別の<code>Option&lt;_&gt;</code>ラップすることなく直接返すことができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Its generic implementation is even simpler than <code>map</code> :</span>一般的な実装は<code>map</code>よりも簡単です：</span> </p><br><div data-lang=rust><div data-l="fn and_then&lt;F, T, A&gt;(option: Option&lt;T&gt;, f: F) -&gt; Option&lt;A&gt;"></div><div data-l="        where F: FnOnce(T) -&gt; Option&lt;A&gt; {"></div><div data-l="    match option {"></div><div data-l="        None =&gt; None,"></div><div data-l="        Some(value) =&gt; f(value),"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now we can rewrite our <code>file_path_ext</code> function without explicit case analysis:</span>これで、明示的なケース分析なしで<code>file_path_ext</code>関数を書き直すことができます。</span> </p><br><div data-lang=rust><div data-l="# fn extension(file_name: &amp;str) -&gt; Option&lt;&amp;str&gt; { None }"></div><div data-l="# fn file_name(file_path: &amp;str) -&gt; Option&lt;&amp;str&gt; { None }"></div><div data-l="fn file_path_ext(file_path: &amp;str) -&gt; Option&lt;&amp;str&gt; {"></div><div data-l="    file_name(file_path).and_then(extension)"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Side note: Since <code>and_then</code> essentially works like <code>map</code> but returns an <code>Option&lt;_&gt;</code> instead of an <code>Option&lt;Option&lt;_&gt;&gt;</code> it is known as <code>flatmap</code> in some other languages.</span>サイドノート： <code>and_then</code>本質的に<code>map</code>ように動作し<code>map</code>が、 <code>Option&lt;Option&lt;_&gt;&gt;</code>ではなく<code>Option&lt;_&gt;</code>返します。これは他の言語では<code>flatmap</code>として知られています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Option</code> type has many other combinators <a href=#35>defined in the standard library</a> .</span> <code>Option</code>型には<a href=#35>、標準ライブラリで定義され</a>ている他の多くのコンビネータ<a href=#35>があります</a> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It is a good idea to skim this list and familiarize yourself with what&#39;s available—they can often reduce case analysis for you.</span>このリストを読み飛ばして、利用可能なものを熟知することは良い考えです。彼らはあなたのケース分析を減らすことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Familiarizing yourself with these combinators will pay dividends because many of them are also defined (with similar semantics) for <code>Result</code> , which we will talk about next.</span>これらのコンビネータに慣れ親しむことで、 <code>Result</code>ために定義されている（同様のセマンティクスで）ため、配当を支払うことになります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Combinators make using types like <code>Option</code> ergonomic because they reduce explicit case analysis.</span>コンビネータは、明示的なケース分析を減らすため、人間工学に基づいた<code>Option</code>ようなタイプを使用します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">They are also composable because they permit the caller to handle the possibility of absence in their own way.</span>彼らは発信者が自らの方法で不在の可能性を扱うことができるので、構成も可能です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Methods like <code>unwrap</code> remove choices because they will panic if <code>Option&lt;T&gt;</code> is <code>None</code> .</span> <code>unwrap</code>ようなメソッドは、 <code>Option&lt;T&gt;</code>が<code>None</code>場合にパニックになるので選択肢を削除します。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Result</code> type</span> <code>Result</code>型</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Result</code> type is also <a href=#36>defined in the standard library</a> :</span> <code>Result</code>型も<a href=#36>標準ライブラリで定義されています</a> ：</span> </p><br><p><span id=code-result-def></span></p><br><div data-lang=rust><div data-l="enum Result&lt;T, E&gt; {"></div><div data-l="    Ok(T),"></div><div data-l="    Err(E),"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Result</code> type is a richer version of <code>Option</code> .</span> <code>Result</code>型は、より豊富なバージョンの<code>Option</code>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Instead of expressing the possibility of <i>absence</i> like <code>Option</code> does, <code>Result</code> expresses the possibility of <i>error</i> .</span> <code>Option</code>ような<i>不在</i>の可能性を表現する代わりに、 <code>Result</code>は<i>エラー</i>の可能性を表し<i>ます</i> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Usually, the <i>error</i> is used to explain why the execution of some computation failed.</span>通常、この<i>エラー</i>は、何らかの計算の実行が失敗した理由を説明するために使用されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is a strictly more general form of <code>Option</code> .</span>これは厳密により一般的な<code>Option</code>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Consider the following type alias, which is semantically equivalent to the real <code>Option&lt;T&gt;</code> in every way:</span>以下の型のエイリアスを考えてみましょう。これは、実際の<code>Option&lt;T&gt;</code>と意味的に等価です。</span> </p><br><div data-lang=rust><div data-l="type Option&lt;T&gt; = Result&lt;T, ()&gt;;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This fixes the second type parameter of <code>Result</code> to always be <code>()</code> (pronounced “unit” or “empty tuple”).</span>これは<code>Result</code>第2の型パラメータを常にbe <code>()</code> （「単位」または「空タプル」と発音する<code>()</code>修正します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Exactly one value inhabits the <code>()</code> type: <code>()</code> .</span>ちょうど1つの値が<code>()</code>型に存在します：（ <code>()</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">(Yup, the type and value level terms have the same notation!)</span> （はい、タイプと値レベルの用語は同じ表記です！）</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Result</code> type is a way of representing one of two possible outcomes in a computation.</span> <code>Result</code>型は、計算において2つの可能な結果のうちの1つを表す方法です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">By convention, one outcome is meant to be expected or “ <code>Ok</code> ” while the other outcome is meant to be unexpected or “ <code>Err</code> ”.</span>慣例により、一方の結果は期待されるか、「 <code>Ok</code> 」を意味し、他方の結果は予期しないまたは「 <code>Err</code> 」を意味する。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Just like <code>Option</code> , the <code>Result</code> type also has an <a href=#37><code>unwrap</code> method defined</a> in the standard library.</span> <code>Option</code>と同様に、 <code>Result</code>型には標準ライブラリに<a href=#37>定義さ</a>れている<a href=#37><code>unwrap</code>メソッド</a>もあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s define it:</span>それを定義しよう：</span> </p><br><div data-lang=rust><div data-l="# enum Result&lt;T, E&gt; { Ok(T), Err(E) }"></div><div data-l="impl&lt;T, E: ::std::fmt::Debug&gt; Result&lt;T, E&gt; {"></div><div data-l="    fn unwrap(self) -&gt; T {"></div><div data-l="        match self {"></div><div data-l="            Result::Ok(val) =&gt; val,"></div><div data-l="            Result::Err(err) =&gt;"></div><div data-l="              panic!(&quot;called `Result::unwrap()` on an `Err` value: {:?}&quot;, err),"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is effectively the same as our <a href=#2#code-option-def-unwrap>definition for <code>Option::unwrap</code></a> , except it includes the error value in the <code>panic€</code> message.</span>これは<a href=#2#code-option-def-unwrap>、 <code>Option::unwrap</code>定義</a>と事実上同じですが、 <code>panic€</code>メッセージにエラー値が含まれている点が異なります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This makes debugging easier, but it also requires us to add a <a class=notranslate href=#38><code>Debug</code></a> constraint on the <code>E</code> type parameter (which represents our error type).</span>これによりデバッグが容易になりますが、 <code>E</code>タイプパラメータ（エラータイプを表す）に<a class=notranslate href=#38><code>Debug</code></a>制約を追加する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Since the vast majority of types should satisfy the <code>Debug</code> constraint, this tends to work out in practice.</span>大多数の型は<code>Debug</code>制約を満たす必要があるため、実際にはうまくいく傾向があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">( <code>Debug</code> on a type simply means that there&#39;s a reasonable way to print a human-readable description of values with that type.)</span> （型の<code>Debug</code>は、その型の値の人間が判読可能な記述を出力する合理的な方法があることを単に意味します）。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">OK, let&#39;s move on to an example.</span>さて、例に移りましょう。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Parsing integers</span>整数の解析</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The Rust standard library makes converting strings to integers dead simple.</span> Rust標準ライブラリは、文字列を整数に変換するのを簡単にします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It&#39;s so easy in fact, that it is very tempting to write something like the following:</span>実際にはとても簡単なので、次のようなものを書くのはとても魅力的です。</span> </p><br><div data-lang=rust><div data-l="fn double_number(number_str: &amp;str) -&gt; i32 {"></div><div data-l="    2 * number_str.parse::&lt;i32&gt;().unwrap()"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let n: i32 = double_number(&quot;10&quot;);"></div><div data-l="    assert_eq!(n, 20);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">At this point, you should be skeptical of calling <code>unwrap</code> .</span>この時点で、あなたは<code>unwrap</code>を呼び出すのに懐疑的でなければなりません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, if the string doesn&#39;t parse as a number, you&#39;ll get a panic:</span>たとえば、文字列が数値として解析されない場合、パニックが発生します。</span> </p><br><div data-lang=text><div data-l="thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: ParseIntError { kind: InvalidDigit }', /home/rustbuild/src/rust-buildbot/slave/beta-dist-rustc-linux/build/src/libcore/result.rs:729"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is rather unsightly, and if this happened inside a library you&#39;re using, you might be understandably annoyed.</span>これはむしろ見苦しいものです。もしこれがあなたが使っている図書館の中で起こったのであれば、あなたはわずらわしいかもしれません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Instead, we should try to handle the error in our function and let the caller decide what to do.</span>代わりに、私たちは関数のエラーを処理して、呼び出し元に何をすべきかを決定させるべきです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This means changing the return type of <code>double_number</code> .</span>これは、 <code>double_number</code>の戻り値の型を変更することを意味します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But to what?</span>しかし何に？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Well, that requires looking at the signature of the <a class=notranslate href=#39><code>parse</code> method</a> in the standard library:</span>つまり、標準ライブラリの<a class=notranslate href=#39><code>parse</code> method</a>シグネチャを調べる必要があります。</span> </p><br><div data-lang=rust,ignore><div data-l="impl str {"></div><div data-l="    fn parse&lt;F: FromStr&gt;(&amp;self) -&gt; Result&lt;F, F::Err&gt;;"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Hmm.</span>うーん。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So we at least know that we need to use a <code>Result</code> .</span>だから少なくとも<code>Result</code>を使う必要があることは分かっている。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Certainly, it&#39;s possible that this could have returned an <code>Option</code> .</span>確かに、これは<code>Option</code>を返す可能性があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">After all, a string either parses as a number or it doesn&#39;t, right?</span>結局のところ、文字列は数値として解析するか、そうではないのですか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That&#39;s certainly a reasonable way to go, but the implementation internally distinguishes <i>why</i> the string didn&#39;t parse as an integer.</span>これは確かに合理的な方法ですが、インプリメンテーションは文字列が整数として解析されなかった<i>理由を</i>内部的に区別します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">(Whether it&#39;s an empty string, an invalid digit, too big or too small.) Therefore, using a <code>Result</code> makes sense because we want to provide more information than simply “absence.” We want to say <i>why</i> the parsing failed.</span> （それは大きすぎるか小さすぎる、空の文字列、無効な数字、だかどうか。）ので、使用して<code>Result</code>我々は単によりも多くの情報を提供したいので、理にかなっている「が存在しないことを。」我々は、構文解析が失敗した<i>理由を</i>言いたいです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You should try to emulate this line of reasoning when faced with a choice between <code>Option</code> and <code>Result</code> .</span> <code>Option</code>と<code>Result</code>間の選択に直面したとき、この推論の行をエミュレートしようとする必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you can provide detailed error information, then you probably should.</span>詳細なエラー情報を提供できる場合は、おそらく必要です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">(We&#39;ll see more on this later.)</span> （後で詳しく説明します）</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">OK, but how do we write our return type?</span>はい、戻り値の型はどうやって書くのですか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>parse</code> method as defined above is generic over all the different number types defined in the standard library.</span>上で定義した<code>parse</code>メソッドは、標準ライブラリで定義されているすべての異なる数値型に対して汎用です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We could (and probably should) also make our function generic, but let&#39;s favor explicitness for the moment.</span>私たちは機能を一般的にすることもできますが、おそらくそうすべきです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We only care about <code>i32</code> , so we need to <a href=#2../../std/primitive.i32.html>find its implementation of <code>FromStr</code></a> (do a <code>CTRL-F</code> in your browser for “FromStr”) and look at its <a href=#310>associated type</a> <code>Err</code> .</span>私たちは<code>i32</code>だけを気にするので<a href=#2../../std/primitive.i32.html>、 <code>FromStr</code>実装</a>を<a href=#2../../std/primitive.i32.html>見つける</a>必要があり<a href=#2../../std/primitive.i32.html>ます</a> （あなたのブラウザーで &quot;FromStr&quot;の<code>CTRL-F</code>を実行）し、 <a href=#310>関連するタイプ</a> <code>Err</code>を<a href=#2../../std/primitive.i32.html>調べる</a>必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We did this so we can find the concrete error type.</span>私たちは具体的なエラータイプを見つけるためにこれを行いました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this case, it&#39;s <a class=notranslate href=#2../../std/num/struct.ParseIntError.html><code>std::num::ParseIntError</code></a> .</span>この場合、 <a class=notranslate href=#2../../std/num/struct.ParseIntError.html><code>std::num::ParseIntError</code></a>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Finally, we can rewrite our function:</span>最後に、関数を書き直すことができます：</span> </p><br><div data-lang=rust><div data-l="use std::num::ParseIntError;"></div><div data-l=""></div><div data-l="fn double_number(number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {"></div><div data-l="    match number_str.parse::&lt;i32&gt;() {"></div><div data-l="        Ok(n) =&gt; Ok(2 * n),"></div><div data-l="        Err(err) =&gt; Err(err),"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    match double_number(&quot;10&quot;) {"></div><div data-l="        Ok(n) =&gt; assert_eq!(n, 20),"></div><div data-l="        Err(err) =&gt; println!(&quot;Error: {:?}&quot;, err),"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is a little better, but now we&#39;ve written much more code!</span>これはやや良いですが、今はもっとコードを書いています！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The case analysis has once again bitten us.</span>事例分析がもう一度私たちに咬まれた。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Combinators to the rescue!</span>救助者とのコンビニエーター！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Just like <code>Option</code> , <code>Result</code> has lots of combinators defined as methods.</span> <code>Option</code>と同様に、 <code>Result</code>はメソッドとして定義された多数のコンビネータがあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There is a large intersection of common combinators between <code>Result</code> and <code>Option</code> .</span> <code>Result</code>と<code>Option</code>間には一般的なコンビネータの大きな交差点があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In particular, <code>map</code> is part of that intersection:</span>特に、 <code>map</code>はその交差点の一部です：</span> </p><br><div data-lang=rust><div data-l="use std::num::ParseIntError;"></div><div data-l=""></div><div data-l="fn double_number(number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {"></div><div data-l="    number_str.parse::&lt;i32&gt;().map(|n| 2 * n)"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    match double_number(&quot;10&quot;) {"></div><div data-l="        Ok(n) =&gt; assert_eq!(n, 20),"></div><div data-l="        Err(err) =&gt; println!(&quot;Error: {:?}&quot;, err),"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The usual suspects are all there for <code>Result</code> , including <a class=notranslate href=#2../../std/result/enum.Result.html#method.unwrap_or><code>unwrap_or</code></a> and <a class=notranslate href=#2../../std/result/enum.Result.html#method.and_then><code>and_then</code></a> .</span> <a class=notranslate href=#2../../std/result/enum.Result.html#method.unwrap_or><code>unwrap_or</code></a>と<a class=notranslate href=#2../../std/result/enum.Result.html#method.and_then><code>and_then</code></a>を含む通常の容疑者がすべて<code>Result</code>にあり<a class=notranslate href=#2../../std/result/enum.Result.html#method.and_then><code>and_then</code></a> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Additionally, since <code>Result</code> has a second type parameter, there are combinators that affect only the error type, such as <a class=notranslate href=#2../../std/result/enum.Result.html#method.map_err><code>map_err</code></a> (instead of <code>map</code> ) and <a class=notranslate href=#2../../std/result/enum.Result.html#method.or_else><code>or_else</code></a> (instead of <code>and_then</code> ).</span>以降さらに、 <code>Result</code>第二型パラメータを有している、などのみエラータイプに影響コンビネータ、ある<a class=notranslate href=#2../../std/result/enum.Result.html#method.map_err><code>map_err</code></a> （代わりの<code>map</code> ）と<a class=notranslate href=#2../../std/result/enum.Result.html#method.or_else><code>or_else</code></a> （代わりに<code>and_then</code> ）。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Result</code> type alias idiom</span> <code>Result</code>型別名イディオム</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In the standard library, you may frequently see types like <code>Result&lt;i32&gt;</code> .</span>標準ライブラリでは、 <code>Result&lt;i32&gt;</code>ような型がよく見えます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But wait, <a href=#2#code-result-def>we defined <code>Result</code></a> to have two type parameters.</span>しかし、 <a href=#2#code-result-def>私たちは<code>Result</code></a>に2つの型パラメータを持つよう<a href=#2#code-result-def>に定義しました</a> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">How can we get away with only specifying one?</span>どのように指定するだけで取り除くことができますか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The key is to define a <code>Result</code> type alias that <i>fixes</i> one of the type parameters to a particular type.</span>キーは、型パラメータの1つを特定の型に<i>固定</i>する<code>Result</code>型のエイリアスを定義することです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Usually the fixed type is the error type.</span>通常、固定タイプはエラータイプです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, our previous example parsing integers could be rewritten like this:</span>たとえば、前の例の解析用の整数は次のように書き直すことができます：</span> </p><br><div data-lang=rust><div data-l="use std::num::ParseIntError;"></div><div data-l="use std::result;"></div><div data-l=""></div><div data-l="type Result&lt;T&gt; = result::Result&lt;T, ParseIntError&gt;;"></div><div data-l=""></div><div data-l="fn double_number(number_str: &amp;str) -&gt; Result&lt;i32&gt; {"></div><div data-l="    unimplemented!();"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Why would we do this?</span>なぜ我々はこれを行うだろうか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Well, if we have a lot of functions that could return <code>ParseIntError</code> , then it&#39;s much more convenient to define an alias that always uses <code>ParseIntError</code> so that we don&#39;t have to write it out all the time.</span> <code>ParseIntError</code>返す関数がたくさんある場合は、常に<code>ParseIntError</code>を使用するエイリアスを定義して、常に書き出す必要はありません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The most prominent place this idiom is used in the standard library is with <a class=notranslate href=#2../../std/io/type.Result.html><code>io::Result</code></a> .</span>このイディオムが標準ライブラリで使用される最も顕著な場所は、 <a class=notranslate href=#2../../std/io/type.Result.html><code>io::Result</code></a>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Typically, one writes <code>io::Result&lt;T&gt;</code> , which makes it clear that you&#39;re using the <code>io</code> module&#39;s type alias instead of the plain definition from <code>std::result</code> .</span>通常、 <code>io::Result&lt;T&gt;</code>書くと、 <code>std::result</code>プレーンな定義ではなく、 <code>io</code>モジュールのタイプエイリアスを使用していることがわかります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">(This idiom is also used for <a class=notranslate href=#2../../std/fmt/type.Result.html><code>fmt::Result</code></a> .)</span> （このイディオムは<a class=notranslate href=#2../../std/fmt/type.Result.html><code>fmt::Result</code></a>も使用されます）。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A brief interlude: unwrapping isn&#39;t evil</span>簡単な間奏：アンラップは悪くない</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you&#39;ve been following along, you might have noticed that I&#39;ve taken a pretty hard line against calling methods like <code>unwrap</code> that could <code>panic</code> and abort your program.</span>もしあなたがフォローしてきたのであれば、私はあなたのプログラムを<code>panic</code>て中止するかもしれない<code>unwrap</code>ようなメソッドを呼び出すことに対してかなり厳しい行を見たことに気づいたかもしれません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><i>Generally speaking</i> , this is good advice.</span> <i>一般的に言えば</i> 、これは良いアドバイスです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, <code>unwrap</code> can still be used judiciously.</span>しかし、 <code>unwrap</code>は依然として慎重に使用することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">What exactly justifies use of <code>unwrap</code> is somewhat of a grey area and reasonable people can disagree.</span> <code>unwrap</code>使用を正当に正当化するものは多少グレーの領域であり、合理的な人々は同意できません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">I&#39;ll summarize some of my <i>opinions</i> on the matter.</span>私はこの問題に関する私の<i>意見</i>を要約します。</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><b>In examples and quick &#39;n&#39; dirty code.</b></span> <b>例では、素早く &#39;n&#39;のダーティコードです。</b></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Sometimes you&#39;re writing examples or a quick program, and error handling simply isn&#39;t important.</span>時には例や簡単なプログラムを書いていることもあり、エラー処理は単純ではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Beating the convenience of <code>unwrap</code> can be hard in such scenarios, so it is very appealing.</span>このようなシナリオでは、 <code>unwrap</code>の利便性を<code>unwrap</code>することは難しいため、非常に魅力的です。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><b>When panicking indicates a bug in the program.</b></span> <b>パニックがプログラムのバグを示すとき。</b></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When the invariants of your code should prevent a certain case from happening (like, say, popping from an empty stack), then panicking can be permissible.</span>あなたのコードのインバリアントが特定のケースが起こらないようにする（空のスタックからポップするなど）場合、パニックが許されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is because it exposes a bug in your program.</span>これは、プログラムのバグを公開するためです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This can be explicit, like from an <code>assert€</code> failing, or it could be because your index into an array was out of bounds.</span>これは明示的に<code>assert€</code>ことができます。 <code>assert€</code>失敗した場合などです。配列へのインデックスが範囲外だったためです。</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is probably not an exhaustive list.</span>おそらく網羅的なリストではないでしょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Moreover, when using an <code>Option</code> , it is often better to use its <a class=notranslate href=#2../../std/option/enum.Option.html#method.expect><code>expect</code></a> method.</span>さらに、 <code>Option</code>を使用する場合、 <a class=notranslate href=#2../../std/option/enum.Option.html#method.expect><code>expect</code></a>メソッドを使用するほうがよい場合があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>expect</code> does exactly the same thing as <code>unwrap</code> , except it prints a message you give to <code>expect</code> .</span> <code>expect</code>はあなたが<code>expect</code>するメッセージを出力する点を除いて、 <code>unwrap</code>と全く同じことを行います。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This makes the resulting panic a bit nicer to deal with, since it will show your message instead of “called unwrap on a <code>None</code> value.”</span>これにより、 &quot; <code>None</code>値にアンラップされた&quot;の代わりにメッセージが表示されるため、結果的なパニックが扱いやすくなります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">My advice boils down to this: use good judgment.</span>私の助言はこれにまでこだわります。良い判断をしてください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There&#39;s a reason why the words “never do X” or “Y is considered harmful” don&#39;t appear in my writing.</span> 「Xはしない」または「Yは有害とみなされる」という言葉が私の文章には現れない理由があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There are trade-offs to all things, and it is up to you as the programmer to determine what is acceptable for your use cases.</span>すべてのことにトレードオフがあります。ユースケースに受け入れられるものを判断するのはプログラマとしての任務です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">My goal is only to help you evaluate trade-offs as accurately as possible.</span>私の目標は、できるだけ正確にトレードオフを評価するのに役立つだけです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now that we&#39;ve covered the basics of error handling in Rust, and explained unwrapping, let&#39;s start exploring more of the standard library.</span> Rustのエラー処理の基礎について説明し、アンラッピングについて説明したので、標準ライブラリの詳細を調べてみましょう。</span> </p><br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Working with multiple error types</span>複数のエラータイプの操作</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Thus far, we&#39;ve looked at error handling where everything was either an <code>Option&lt;T&gt;</code> or a <code>Result&lt;T, SomeError&gt;</code> .</span>これまでは、すべてが<code>Option&lt;T&gt;</code>または<code>Result&lt;T, SomeError&gt;</code>いずれかのエラー処理を見てきました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But what happens when you have both an <code>Option</code> and a <code>Result</code> ?</span>しかし、 <code>Option</code>と<code>Result</code>両方を持っているとどうなりますか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Or what if you have a <code>Result&lt;T, Error1&gt;</code> and a <code>Result&lt;T, Error2&gt;</code> ?</span>または、 <code>Result&lt;T, Error1&gt;</code>および<code>Result&lt;T, Error2&gt;</code>どうなりますか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Handling <i>composition of distinct error types</i> is the next challenge in front of us, and it will be the major theme throughout the rest of this section.</span> <i>個別のエラータイプの処理</i>は、私たちの前で次の課題です。このセクションの残りの部分では、主なテーマになります。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Composing <code>Option</code> and <code>Result</code></span> <code>Option</code>と<code>Result</code></span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So far, I&#39;ve talked about combinators defined for <code>Option</code> and combinators defined for <code>Result</code> .</span>今までは、 <code>Option</code>に対して定義されたコンビネータと<code>Result</code>に対して定義されたコンビネータについて説明しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can use these combinators to compose results of different computations without doing explicit case analysis.</span>これらのコンビネータを使用して、明示的なケース分析を行うことなく、異なる計算の結果を構成することができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Of course, in real code, things aren&#39;t always as clean.</span>もちろん、実際のコードでは、物事は常にきれいではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Sometimes you have a mix of <code>Option</code> and <code>Result</code> types.</span> <code>Option</code>と<code>Result</code>タイプが混在していることがあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Must we resort to explicit case analysis, or can we continue using combinators?</span>明示的なケース分析に頼らなければならないのですか、あるいはコンビネータを使用し続けることができますか？</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For now, let&#39;s revisit one of the first examples in this section:</span>ここでは、このセクションの最初の例の1つに戻ってみましょう。</span> </p><br><div data-lang=rust,should_panic><div data-l="use std::env;"></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let mut argv = env::args();"></div><div data-l="#//    let arg: String = argv.nth(1).unwrap(); // error 1"></div><div data-l="    let arg: String = argv.nth(1).unwrap(); // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">error 1</span>エラー1</span> </div><div data-l="#//    let n: i32 = arg.parse().unwrap(); // error 2"></div><div data-l="    let n: i32 = arg.parse().unwrap(); // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">error 2</span>エラー2</span> </div><div data-l="    println!(&quot;{}&quot;, 2 * n);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Given our new found knowledge of <code>Option</code> , <code>Result</code> and their various combinators, we should try to rewrite this so that errors are handled properly and the program doesn&#39;t panic if there&#39;s an error.</span> <code>Option</code> 、 <code>Result</code> 、およびそれらのさまざまなコンビネータに関する新しい知識があれば、エラーを正しく処理し、エラーがあればプログラムがパニックに陥らないように書き直してください。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The tricky aspect here is that <code>argv.nth(1)</code> produces an <code>Option</code> while <code>arg.parse()</code> produces a <code>Result</code> .</span>ここでのトリッキーな側面は、 <code>argv.nth(1)</code>は<code>Option</code>を生成し、 <code>arg.parse()</code>は<code>Result</code>生成するということです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These aren&#39;t directly composable.</span>これらは直接構成可能ではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When faced with both an <code>Option</code> and a <code>Result</code> , the solution is <i>usually</i> to convert the <code>Option</code> to a <code>Result</code> .</span> <code>Option</code>と<code>Result</code>両方に直面した場合、 <i>通常</i>は<code>Option</code>を<code>Result</code>に変換します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In our case, the absence of a command line parameter (from <code>env::args()</code> ) means the user didn&#39;t invoke the program correctly.</span>私たちの場合、（ <code>env::args()</code> ）コマンドラインパラメータがないということは、ユーザがプログラムを正しく呼び出さなかったことを意味します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We could use a <code>String</code> to describe the error.</span>エラーを記述するために<code>String</code>を使用できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s try:</span>やってみよう：</span> </p><br><p><span id=code-error-double-string></span></p><br><div data-lang=rust><div data-l="use std::env;"></div><div data-l=""></div><div data-l="fn double_arg(mut argv: env::Args) -&gt; Result&lt;i32, String&gt; {"></div><div data-l="    argv.nth(1)"></div><div data-l="        .ok_or(&quot;Please give at least one argument&quot;.to_owned())"></div><div data-l="        .and_then(|arg| arg.parse::&lt;i32&gt;().map_err(|err| err.to_string()))"></div><div data-l="        .map(|n| 2 * n)"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    match double_arg(env::args()) {"></div><div data-l="        Ok(n) =&gt; println!(&quot;{}&quot;, n),"></div><div data-l="        Err(err) =&gt; println!(&quot;Error: {}&quot;, err),"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There are a couple new things in this example.</span>この例ではいくつか新しいことがあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The first is the use of the <a class=notranslate href=#2../../std/option/enum.Option.html#method.ok_or><code>Option::ok_or</code></a> combinator.</span>最初は、 <a class=notranslate href=#2../../std/option/enum.Option.html#method.ok_or><code>Option::ok_or</code></a>コンビネータの使用です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is one way to convert an <code>Option</code> into a <code>Result</code> .</span>これは<code>Option</code>を<code>Result</code>に変換する1つの方法です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The conversion requires you to specify what error to use if <code>Option</code> is <code>None</code> .</span>この変換では、 <code>Option</code>が<code>None</code>場合に使用するエラーを指定する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Like the other combinators we&#39;ve seen, its definition is very simple:</span>私たちが見た他のコンビネータと同様に、その定義は非常に簡単です：</span> </p><br><div data-lang=rust><div data-l="fn ok_or&lt;T, E&gt;(option: Option&lt;T&gt;, err: E) -&gt; Result&lt;T, E&gt; {"></div><div data-l="    match option {"></div><div data-l="        Some(val) =&gt; Ok(val),"></div><div data-l="        None =&gt; Err(err),"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The other new combinator used here is <a class=notranslate href=#2../../std/result/enum.Result.html#method.map_err><code>Result::map_err</code></a> .</span>ここで使用される新しいコンビネータは、 <a class=notranslate href=#2../../std/result/enum.Result.html#method.map_err><code>Result::map_err</code></a>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is like <code>Result::map</code> , except it maps a function on to the <i>error</i> portion of a <code>Result</code> value.</span> <code>Result::map</code>と似ていますが、関数を<code>Result</code>値の<i>エラー</i>部分にマップする点が異なります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If the <code>Result</code> is an <code>Ok(...)</code> value, then it is returned unmodified.</span> <code>Result</code>が<code>Ok(...)</code>値である場合、 <code>Result</code>は変更されずに戻されます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We use <code>map_err</code> here because it is necessary for the error types to remain the same (because of our use of <code>and_then</code> ).</span>ここで<code>map_err</code>を使用して<code>map_err</code>ます。なぜなら、エラーの種類は同じである必要があるから<code>map_err</code>を使用しているため<code>and_then</code> ）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Since we chose to convert the <code>Option&lt;String&gt;</code> (from <code>argv.nth(1)</code> ) to a <code>Result&lt;String, String&gt;</code> , we must also convert the <code>ParseIntError</code> from <code>arg.parse()</code> to a <code>String</code> .</span> <code>Option&lt;String&gt;</code> （ <code>argv.nth(1)</code> ）を<code>Result&lt;String, String&gt;</code>に変換することを選択したので、 <code>ParseIntError</code>を<code>arg.parse()</code>から<code>String</code>も変換する必要があります。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The limits of combinators</span>コンビネータの限界</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Doing IO and parsing input is a very common task, and it&#39;s one that I personally have done a lot of in Rust.</span> IOを行い、入力を解析することは非常に一般的な作業であり、私が個人的にRustで多く行ったことです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Therefore, we will use (and continue to use) IO and various parsing routines to exemplify error handling.</span>したがって、私たちはIOとさまざまな解析ルーチンを使用して（そして引き続き使用して）エラー処理を例示します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s start simple.</span>簡単に始めましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We are tasked with opening a file, reading all of its contents and converting its contents to a number.</span>私たちは、ファイルを開き、すべての内容を読み込み、その内容を数値に変換することを任されています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then we multiply it by <code>2</code> and print the output.</span>次に、 <code>2</code>倍して出力します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Although I&#39;ve tried to convince you not to use <code>unwrap</code> , it can be useful to first write your code using <code>unwrap</code> .</span>私はあなたに<code>unwrap</code>を使わないように説得しようとしましたが、最初に<code>unwrap</code>を使ってコードを書いておくと便利です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It allows you to focus on your problem instead of the error handling, and it exposes the points where proper error handling need to occur.</span>これにより、エラー処理の代わりに問題に集中することができ、適切なエラー処理が必要な箇所が表示されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s start there so we can get a handle on the code, and then refactor it to use better error handling.</span>そこから始めましょう。そこで、コードのハンドルを取得して、より良いエラー処理を使用するようにリファクタリングします。</span> </p><br><div data-lang=rust,should_panic><div data-l="use std::fs::File;"></div><div data-l="use std::io::Read;"></div><div data-l="use std::path::Path;"></div><div data-l=""></div><div data-l="fn file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; i32 {"></div><div data-l="#//    let mut file = File::open(file_path).unwrap(); // error 1"></div><div data-l="    let mut file = File::open(file_path).unwrap(); // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">error 1</span>エラー1</span> </div><div data-l="    let mut contents = String::new();"></div><div data-l="#//    file.read_to_string(&amp;mut contents).unwrap(); // error 2"></div><div data-l="    file.read_to_string(&amp;mut contents).unwrap(); // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">error 2</span>エラー2</span> </div><div data-l="#//    let n: i32 = contents.trim().parse().unwrap(); // error 3"></div><div data-l="    let n: i32 = contents.trim().parse().unwrap(); // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">error 3</span>エラー3</span> </div><div data-l="    2 * n"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let doubled = file_double(&quot;foobar&quot;);"></div><div data-l="    println!(&quot;{}&quot;, doubled);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">(NB The <code>AsRef&lt;Path&gt;</code> is used because those are the <a href=#2../../std/fs/struct.File.html#method.open>same bounds used on <code>std::fs::File::open</code></a> . This makes it ergonomic to use any kind of string as a file path.)</span> （NB <code>AsRef&lt;Path&gt;</code>は<a href=#2../../std/fs/struct.File.html#method.open>、 <code>std::fs::File::open</code>使用されている境界と同じ境界線であるため使用され<code>std::fs::File::open</code></a> 。これにより、ファイルパスとしてあらゆる種類の文字列を使用する人間工学になります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There are three different errors that can occur here:</span>ここで発生する可能性がある3つの異なるエラーがあります。</span> </p><br><div data-b=1.> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A problem opening the file.</span>ファイルを開く際に問題が発生しました。</span> </div><div data-b=2.> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A problem reading data from the file.</span>ファイルからデータを読み取る際に問題が発生しました。</span> </div><div data-b=3.> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A problem parsing the data as a number.</span>データを数値として解析する問題。</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The first two problems are described via the <a class=notranslate href=#2../../std/io/struct.Error.html><code>std::io::Error</code></a> type.</span>最初の2つの問題は、 <a class=notranslate href=#2../../std/io/struct.Error.html><code>std::io::Error</code></a>型を介して記述されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We know this because of the return types of <a class=notranslate href=#2../../std/fs/struct.File.html#method.open><code>std::fs::File::open</code></a> and <a class=notranslate href=#2../../std/io/trait.Read.html#method.read_to_string><code>std::io::Read::read_to_string</code></a> .</span>これは、 <a class=notranslate href=#2../../std/fs/struct.File.html#method.open><code>std::fs::File::open</code></a>と<a class=notranslate href=#2../../std/io/trait.Read.html#method.read_to_string><code>std::io::Read::read_to_string</code></a>の戻り値の型のために<a class=notranslate href=#2../../std/io/trait.Read.html#method.read_to_string><code>std::io::Read::read_to_string</code></a>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">(Note that they both use the <a href=#2#the-result-type-alias-idiom><code>Result</code> type alias idiom</a> described previously. If you click on the <code>Result</code> type, you&#39;ll <a href=#2../../std/io/type.Result.html>see the type alias</a> , and consequently, the underlying <code>io::Error</code> type.) The third problem is described by the <a class=notranslate href=#2../../std/num/struct.ParseIntError.html><code>std::num::ParseIntError</code></a> type.</span> （どちらも使用することに注意してください<a href=#2#the-result-type-alias-idiom><code>Result</code>タイプエイリアスイディオムは、</a>あなたが上でクリックした場合。前述の<code>Result</code>タイプ、あなたはよ<a href=#2../../std/io/type.Result.html>タイプの別名を参照</a>し、その結果、基礎となる<code>io::Error</code>タイプ。）第三の問題は次のように記述され<a class=notranslate href=#2../../std/num/struct.ParseIntError.html><code>std::num::ParseIntError</code></a>型。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>io::Error</code> type in particular is <i>pervasive</i> throughout the standard library.</span> <code>io::Error</code>型は、特に標準ライブラリ全体に<i>広がっ</i>ています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You will see it again and again.</span>あなたはそれを何度も見ます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s start the process of refactoring the <code>file_double</code> function.</span> <code>file_double</code>関数をリファクタリングするプロセスを開始しましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To make this function composable with other components of the program, it should <i>not</i> panic if any of the above error conditions are met.</span>この機能をプログラムの他のコンポーネントと組み合わせるには、上記のエラー条件のいずれかが満たされている場合、パニックにはなり<i>ません</i> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Effectively, this means that the function should <i>return an error</i> if any of its operations fail.</span>効果的には、操作が失敗した場合に関数が<i>エラー</i>を<i>返す</i>必要<i>があります</i> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Our problem is that the return type of <code>file_double</code> is <code>i32</code> , which does not give us any useful way of reporting an error.</span>私たちの問題は、 <code>file_double</code>の戻り値の型が<code>i32</code>であるため、エラーを報告する有用な方法はありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Thus, we must start by changing the return type from <code>i32</code> to something else.</span>したがって、戻り値の型を<code>i32</code>から別のものに変更することから始めなければなりません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The first thing we need to decide: should we use <code>Option</code> or <code>Result</code> ?</span>最初に決定する必要があるのは、 <code>Option</code>または<code>Result</code>を使用するかどうかです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We certainly could use <code>Option</code> very easily.</span>我々は確かに非常に簡単に<code>Option</code>使用することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If any of the three errors occur, we could simply return <code>None</code> .</span> 3つのエラーのいずれかが発生した場合、単に<code>None</code>返すことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This will work <i>and it is better than panicking</i> , but we can do much better.</span>これ<i>はうまくいってパニックよりも優れていますが、もっとうまく</i>いくことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Instead, we should pass some detail about the error that occurred.</span>代わりに、発生したエラーについていくつかの詳細を渡す必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Since we want to express the <i>possibility of error</i> , we should use <code>Result&lt;i32, E&gt;</code> .</span> <i>エラー</i>の<i>可能性</i>を表現したいので、 <code>Result&lt;i32, E&gt;</code>使うべきです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But what should <code>E</code> be?</span>しかし、 <code>E</code>どうなるべきですか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Since two <i>different</i> types of errors can occur, we need to convert them to a common type.</span> 2つの<i>異なる</i>タイプのエラーが発生する可能性があるため、それらを共通のタイプに変換する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">One such type is <code>String</code> .</span>そのようなタイプの1つは<code>String</code>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s see how that impacts our code:</span>それが私たちのコードにどのように影響するのかを見てみましょう：</span> </p><br><div data-lang=rust><div data-l="use std::fs::File;"></div><div data-l="use std::io::Read;"></div><div data-l="use std::path::Path;"></div><div data-l=""></div><div data-l="fn file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;i32, String&gt; {"></div><div data-l="    File::open(file_path)"></div><div data-l="         .map_err(|err| err.to_string())"></div><div data-l="         .and_then(|mut file| {"></div><div data-l="              let mut contents = String::new();"></div><div data-l="              file.read_to_string(&amp;mut contents)"></div><div data-l="                  .map_err(|err| err.to_string())"></div><div data-l="                  .map(|_| contents)"></div><div data-l="         })"></div><div data-l="         .and_then(|contents| {"></div><div data-l="              contents.trim().parse::&lt;i32&gt;()"></div><div data-l="                      .map_err(|err| err.to_string())"></div><div data-l="         })"></div><div data-l="         .map(|n| 2 * n)"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    match file_double(&quot;foobar&quot;) {"></div><div data-l="        Ok(n) =&gt; println!(&quot;{}&quot;, n),"></div><div data-l="        Err(err) =&gt; println!(&quot;Error: {}&quot;, err),"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This code looks a bit hairy.</span>このコードは少し毛深いです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It can take quite a bit of practice before code like this becomes easy to write.</span>このようなコードが書くのが簡単になるには、かなりの練習が必要です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The way we write it is by <i>following the types</i> .</span>私たちが書いているのは、 <i>そのタイプに従うことです</i> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As soon as we changed the return type of <code>file_double</code> to <code>Result&lt;i32, String&gt;</code> , we had to start looking for the right combinators.</span> <code>file_double</code>の戻り値の型を<code>Result&lt;i32, String&gt;</code>に変更するとすぐに、適切なコンビネータを探す必要がありました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this case, we only used three different combinators: <code>and_then</code> , <code>map</code> and <code>map_err</code> .</span>この例では、3つの異なるコンビネータを使用しました： <code>and_then</code> 、 <code>map</code> 、および<code>map_err</code> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>and_then</code> is used to chain multiple computations where each computation could return an error.</span> <code>and_then</code>は、各計算がエラーを返すことができる複数の計算を連鎖させるために使用されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">After opening the file, there are two more computations that could fail: reading from the file and parsing the contents as a number.</span>ファイルを開いた後、失敗する可能性のある計算がもう2つあります：ファイルからの読み取りと内容を数値として解析することです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Correspondingly, there are two calls to <code>and_then</code> .</span>対応して、 <code>and_then</code>への呼び出しが2回あります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>map</code> is used to apply a function to the <code>Ok(...)</code> value of a <code>Result</code> .</span> <code>map</code>は、 <code>Result</code> <code>Ok(...)</code>値に関数を適用するために使用されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, the very last call to <code>map</code> multiplies the <code>Ok(...)</code> value (which is an <code>i32</code> ) by <code>2</code> .</span>たとえば、最後に<code>map</code>呼び出すと、 <code>Ok(...)</code>値（ <code>i32</code> ）に<code>2</code>が乗算されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If an error had occurred before that point, this operation would have been skipped because of how <code>map</code> is defined.</span>そのポイントの前にエラーが発生した場合、 <code>map</code>がどのように定義されているかにより、この操作はスキップされます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>map_err</code> is the trick that makes all of this work.</span> <code>map_err</code>はこのすべてのことを<code>map_err</code>トリックです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>map_err</code> is like <code>map</code> , except it applies a function to the <code>Err(...)</code> value of a <code>Result</code> .</span> <code>map_err</code>は、 <code>Result</code> <code>Err(...)</code>値に関数を適用する点を除いて<code>map</code>と似ています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this case, we want to convert all of our errors to one type: <code>String</code> .</span>この場合、すべてのエラーを1つの型に変換する必要があります。 <code>String</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Since both <code>io::Error</code> and <code>num::ParseIntError</code> implement <code>ToString</code> , we can call the <code>to_string()</code> method to convert them.</span> <code>io::Error</code>と<code>num::ParseIntError</code>どちらも<code>ToString</code>を実装している<code>to_string()</code> 、 <code>to_string()</code>メソッドを呼び出して変換することができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">With all of that said, the code is still hairy.</span>そのすべてが言われて、コードはまだ毛深いです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Mastering use of combinators is important, but they have their limits.</span>コンビネータの使用をマスターすることは重要ですが、それらには限界があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s try a different approach: early returns.</span>別のアプローチ、早期復帰を試してみましょう。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Early returns</span>早期返品</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">I&#39;d like to take the code from the previous section and rewrite it using <i>early returns</i> .</span>私は、前のセクションのコードを取り上げ、 <i>早期復帰</i>を使用して書き直したいと思い<i>ます</i> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Early returns let you exit the function early.</span>早期返品により、早期に機能を終了することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can&#39;t return early in <code>file_double</code> from inside another closure, so we&#39;ll need to revert back to explicit case analysis.</span>別のクロージャの内側から<code>file_double</code>早い段階で戻ることはできないので、明示的なケース分析に戻す必要があります。</span> </p><br><div data-lang=rust><div data-l="use std::fs::File;"></div><div data-l="use std::io::Read;"></div><div data-l="use std::path::Path;"></div><div data-l=""></div><div data-l="fn file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;i32, String&gt; {"></div><div data-l="    let mut file = match File::open(file_path) {"></div><div data-l="        Ok(file) =&gt; file,"></div><div data-l="        Err(err) =&gt; return Err(err.to_string()),"></div><div data-l="    };"></div><div data-l="    let mut contents = String::new();"></div><div data-l="    if let Err(err) = file.read_to_string(&amp;mut contents) {"></div><div data-l="        return Err(err.to_string());"></div><div data-l="    }"></div><div data-l="    let n: i32 = match contents.trim().parse() {"></div><div data-l="        Ok(n) =&gt; n,"></div><div data-l="        Err(err) =&gt; return Err(err.to_string()),"></div><div data-l="    };"></div><div data-l="    Ok(2 * n)"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    match file_double(&quot;foobar&quot;) {"></div><div data-l="        Ok(n) =&gt; println!(&quot;{}&quot;, n),"></div><div data-l="        Err(err) =&gt; println!(&quot;Error: {}&quot;, err),"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Reasonable people can disagree over whether this code is better than the code that uses combinators, but if you aren&#39;t familiar with the combinator approach, this code looks simpler to read to me.</span>合理的な人は、このコードがコンビネータを使用するコードよりも優れているかどうかについては意見を異にすることができますが、コンビネータのアプローチに精通していない場合は、</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It uses explicit case analysis with <code>match</code> and <code>if let</code> .</span>これは、 <code>match</code>と<code>if let</code>を使用した明示的なケース分析を使用<code>if let</code>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If an error occurs, it simply stops executing the function and returns the error (by converting it to string).</span>エラーが発生すると、関数の実行が停止し、エラーが返されます（文字列に変換されます）。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Isn&#39;t this a step backwards though?</span>しかしこれは後退していませんか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Previously, we said that the key to ergonomic error handling is reducing explicit case analysis, yet we&#39;ve reverted back to explicit case analysis here.</span>以前は、人間工学的なエラー処理の鍵は、明示的なケース分析を減らすことですが、ここでは明示的なケース分析に戻しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It turns out, there are <i>multiple</i> ways to reduce explicit case analysis.</span>これは、明示的なケース分析を低減するための<i>複数の</i>方法がありますが、判明しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Combinators aren&#39;t the only way.</span>コンビネータだけが唯一の方法ではありません。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>try€</code> macro</span> <code>try€</code>マクロ</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A cornerstone of error handling in Rust is the <code>try€</code> macro.</span> Rustのエラー処理の基本は<code>try€</code>マクロです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>try€</code> macro abstracts case analysis like combinators, but unlike combinators, it also abstracts <i>control flow</i> .</span> <code>try€</code>マクロはコンバイナのようなケース分析を抽象化しますが、コンビネータとは異なり、 <i>コントロールフロー</i>も抽象化<i>します</i> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Namely, it can abstract the <i>early return</i> pattern seen above.</span>つまり、上記の<i>早期復帰</i>パターンを抽象化することができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here is a simplified definition of a <code>try€</code> macro:</span> <code>try€</code>マクロの簡単な定義を以下に示します。</span> </p><br><p><span id=code-try-def-simple></span></p><br><div data-lang=rust><div data-l="macro_rules! try {"></div><div data-l="    ($e:expr) =&gt; (match $e {"></div><div data-l="        Ok(val) =&gt; val,"></div><div data-l="        Err(err) =&gt; return Err(err),"></div><div data-l="    });"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">(The <a href=#2../../std/macro.try.html>real definition</a> is a bit more sophisticated. We will address that later.)</span> （ <a href=#2../../std/macro.try.html>実際の定義</a>はちょっと洗練されていますが、後でそれを扱います）。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Using the <code>try€</code> macro makes it very easy to simplify our last example.</span> <code>try€</code>マクロを使用する<code>try€</code> 、最後の例を簡単に簡単にすることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Since it does the case analysis and the early return for us, we get tighter code that is easier to read:</span>ケース分析と早期返品を行うので、読みやすい、より厳密なコードが得られます。</span> </p><br><div data-lang=rust><div data-l="use std::fs::File;"></div><div data-l="use std::io::Read;"></div><div data-l="use std::path::Path;"></div><div data-l=""></div><div data-l="fn file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;i32, String&gt; {"></div><div data-l="    let mut file = try!(File::open(file_path).map_err(|e| e.to_string()));"></div><div data-l="    let mut contents = String::new();"></div><div data-l="    try!(file.read_to_string(&amp;mut contents).map_err(|e| e.to_string()));"></div><div data-l="    let n = try!(contents.trim().parse::&lt;i32&gt;().map_err(|e| e.to_string()));"></div><div data-l="    Ok(2 * n)"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    match file_double(&quot;foobar&quot;) {"></div><div data-l="        Ok(n) =&gt; println!(&quot;{}&quot;, n),"></div><div data-l="        Err(err) =&gt; println!(&quot;Error: {}&quot;, err),"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>map_err</code> calls are still necessary given <a href=#2#code-try-def-simple>our definition of <code>try€</code></a> .</span> <a href=#2#code-try-def-simple><code>try€</code>定義を</a>考えると<a href=#2#code-try-def-simple>、</a> <code>map_err</code>コールはまだ必要<a href=#2#code-try-def-simple><code>try€</code></a> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is because the error types still need to be converted to <code>String</code> .</span>これは、エラータイプを引き続き<code>String</code>に変換する必要があるためです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The good news is that we will soon learn how to remove those <code>map_err</code> calls!</span>良いニュースは、私たちが間もなくそれらの<code>map_err</code>呼び出しを削除する方法を学ぶことです！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The bad news is that we will need to learn a bit more about a couple important traits in the standard library before we can remove the <code>map_err</code> calls.</span>悪いニュースは、 <code>map_err</code>呼び出しを削除する前に、標準ライブラリの重要な特性についてもう少し学ぶ必要があることです。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Defining your own error type</span>独自のエラータイプを定義する</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Before we dive into some of the standard library error traits, I&#39;d like to wrap up this section by removing the use of <code>String</code> as our error type in the previous examples.</span>標準的なライブラリのエラー特性のいくつかを知る前に、前の例のエラータイプとして<code>String</code>の使用を取り除いて、このセクションをまとめておきたいと思います。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Using <code>String</code> as we did in our previous examples is convenient because it&#39;s easy to convert errors to strings, or even make up your own errors as strings on the spot.</span>以前の例で行ったように<code>String</code>を使用すると、エラーを文字列に変換したり、現場で文字列として独自のエラーを作成したりすることが容易になるので便利です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, using <code>String</code> for your errors has some downsides.</span>しかし、エラーのために<code>String</code>を使用することにはいくつかの欠点があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The first downside is that the error messages tend to clutter your code.</span>最初の欠点は、エラーメッセージがコードを乱雑にする傾向があることです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It&#39;s possible to define the error messages elsewhere, but unless you&#39;re unusually disciplined, it is very tempting to embed the error message into your code.</span>他の場所でエラーメッセージを定義することは可能ですが、あなたが異常に訓練されていない限り、エラーメッセージをコードに埋め込むことは非常に魅力的です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Indeed, we did exactly this in a <a class=notranslate href=#2#code-error-double-string>previous example</a> .</span>実際、これ<a class=notranslate href=#2#code-error-double-string>previous example</a>ではこれを正確に行いました。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The second and more important downside is that <code>String</code> s are <i>lossy</i> .</span>第2の重要な欠点は、 <code>String</code>が<i>損失であること</i>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That is, if all errors are converted to strings, then the errors we pass to the caller become completely opaque.</span>つまり、すべてのエラーが文字列に変換された場合、呼び出し側に渡すエラーは完全に不透明になります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The only reasonable thing the caller can do with a <code>String</code> error is show it to the user.</span>呼び出し側が<code>String</code>エラーで行うことができる唯一の妥当なことは、ユーザーに表示することです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Certainly, inspecting the string to determine the type of error is not robust.</span>確かに、エラーの種類を判断するために文字列を検査することは堅牢ではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">(Admittedly, this downside is far more important inside of a library as opposed to, say, an application.)</span> （確かに、この欠点は、アプリケーションとは対照的に、図書館の中ではるかに重要です。）</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, the <code>io::Error</code> type embeds an <a class=notranslate href=#2../../std/io/enum.ErrorKind.html><code>io::ErrorKind</code></a> , which is <i>structured data</i> that represents what went wrong during an IO operation.</span>たとえば、 <code>io::Error</code>型は、IO操作中に何が問題になったかを表す<i>構造化データ</i>である<a class=notranslate href=#2../../std/io/enum.ErrorKind.html><code>io::ErrorKind</code></a>埋め込みます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is important because you might want to react differently depending on the error.</span>これは、エラーに応じて異なる反応を起こす可能性があるため、重要です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">(eg, A <code>BrokenPipe</code> error might mean quitting your program gracefully while a <code>NotFound</code> error might mean exiting with an error code and showing an error to the user.) With <code>io::ErrorKind</code> , the caller can examine the type of an error with case analysis, which is strictly superior to trying to tease out the details of an error inside of a <code>String</code> .</span> （例えば、A <code>BrokenPipe</code>エラーは、 <code>NotFound</code>エラーがエラーコードで終了してユーザにエラーを表示している間にプログラムを正常に終了することを意味するかもしれません） <code>io::ErrorKind</code>と、呼び出し側はケース分析これは、 <code>String</code>内部でエラーの詳細を解説しようとするよりも厳密に優れています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Instead of using a <code>String</code> as an error type in our previous example of reading an integer from a file, we can define our own error type that represents errors with <i>structured data</i> .</span>前述のファイルから整数を読み込む例では、エラータイプとして<code>String</code>を使用する代わりに、 <i>構造化データの</i>エラーを表す独自のエラータイプを定義することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We endeavor to not drop information from underlying errors in case the caller wants to inspect the details.</span>発信者が詳細を調べたい場合、根本的なエラーから情報を削除しないように努めます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The ideal way to represent <i>one of many possibilities</i> is to define our own sum type using <code>enum</code> .</span> <i>多くの可能性</i>を表現する理想的な方法は、 <code>enum</code>を使って独自の和型を定義することです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In our case, an error is either an <code>io::Error</code> or a <code>num::ParseIntError</code> , so a natural definition arises:</span>私たちの場合、エラーは<code>io::Error</code>または<code>num::ParseIntError</code>いずれかであるため、自然な定義が生成されます。</span> </p><br><div data-lang=rust><div data-l="use std::io;"></div><div data-l="use std::num;"></div><div data-l=""></div><div data-l="#// We derive `Debug` because all types should probably derive `Debug`."></div><div data-l="#// This gives us a reasonable human-readable description of `CliError` values."></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We derive <code>Debug</code> because all types should probably derive <code>Debug</code> .</span>私たちは、派生<code>Debug</code>すべての種類は、おそらく派生する必要があるため<code>Debug</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This gives us a reasonable human-readable description of <code>CliError</code> values.</span>これは<code>CliError</code>値を人が読めるように説明して<code>CliError</code>ます。</span> </div><div data-l=#[derive(Debug)]></div><div data-l="enum CliError {"></div><div data-l="    Io(io::Error),"></div><div data-l="    Parse(num::ParseIntError),"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Tweaking our code is very easy.</span>私たちのコードを調整するのはとても簡単です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Instead of converting errors to strings, we simply convert them to our <code>CliError</code> type using the corresponding value constructor:</span>エラーを文字列に変換するのではなく、対応する値コンストラクタを使用して<code>CliError</code>型に変換するだけです。</span> </p><br><div data-lang=rust><div data-l="# #[derive(Debug)]"></div><div data-l="# enum CliError { Io(::std::io::Error), Parse(::std::num::ParseIntError) }"></div><div data-l="use std::fs::File;"></div><div data-l="use std::io::Read;"></div><div data-l="use std::path::Path;"></div><div data-l=""></div><div data-l="fn file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;i32, CliError&gt; {"></div><div data-l="    let mut file = try!(File::open(file_path).map_err(CliError::Io));"></div><div data-l="    let mut contents = String::new();"></div><div data-l="    try!(file.read_to_string(&amp;mut contents).map_err(CliError::Io));"></div><div data-l="    let n: i32 = try!(contents.trim().parse().map_err(CliError::Parse));"></div><div data-l="    Ok(2 * n)"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    match file_double(&quot;foobar&quot;) {"></div><div data-l="        Ok(n) =&gt; println!(&quot;{}&quot;, n),"></div><div data-l="        Err(err) =&gt; println!(&quot;Error: {:?}&quot;, err),"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The only change here is switching <code>map_err(|e| e.to_string())</code> (which converts errors to strings) to <code>map_err(CliError::Io)</code> or <code>map_err(CliError::Parse)</code> .</span>ここでの唯一の変更は、 <code>map_err(CliError::Io)</code>または<code>map_err(CliError::Parse)</code> <code>map_err(|e| e.to_string())</code>切り替えること<code>map_err(|e| e.to_string())</code>エラーを文字列に変換します<code>map_err(CliError::Parse)</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <i>caller</i> gets to decide the level of detail to report to the user.</span> <i>呼び出し元</i>は、ユーザーに報告する詳細レベルを決定します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In effect, using a <code>String</code> as an error type removes choices from the caller while using a custom <code>enum</code> error type like <code>CliError</code> gives the caller all of the conveniences as before in addition to <i>structured data</i> describing the error.</span>実際には、Error型として<code>String</code>を使用すると、Errorを記述する<i>構造化データ</i>に加えて、 <code>CliError</code>が前のようにすべての便利さを呼び出し元に与えるような、カスタム<code>enum</code>エラー型を使用しながら呼び出し元から選択肢を削除します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A rule of thumb is to define your own error type, but a <code>String</code> error type will do in a pinch, particularly if you&#39;re writing an application.</span>経験則は独自のエラータイプを定義することですが、特にアプリケーションを作成している場合は、 <code>String</code>エラータイプをピンチで処理します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you&#39;re writing a library, defining your own error type should be strongly preferred so that you don&#39;t remove choices from the caller unnecessarily.</span>ライブラリを作成する場合は、呼び出し元から不必要な選択肢を削除しないように、独自のエラータイプを定義することを強く推奨します。</span> </p><br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Standard library traits used for error handling</span>エラー処理に使用される標準ライブラリ特性</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The standard library defines two integral traits for error handling: <a class=notranslate href=#2../../std/error/trait.Error.html><code>std::error::Error</code></a> and <a class=notranslate href=#2../../std/convert/trait.From.html><code>std::convert::From</code></a> .</span>標準ライブラリは、エラー処理のために<a class=notranslate href=#2../../std/error/trait.Error.html><code>std::error::Error</code></a>と<a class=notranslate href=#2../../std/convert/trait.From.html><code>std::convert::From</code></a> 2つの不可欠な特性を定義しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">While <code>Error</code> is designed specifically for generically describing errors, the <code>From</code> trait serves a more general role for converting values between two distinct types.</span> <code>Error</code>は一般的にエラーを一般的に記述するために設計されていますが、 <code>From</code>特性は2つの異なるタイプ間で値を変換するためのより一般的な役割を果たします。</span> </p><br>
<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180709_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=error-handling-2.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Error</code> trait</span> <code>Error</code>特性</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Error</code> trait is <a href=#2../../std/error/trait.Error.html>defined in the standard library</a> :</span> <code>Error</code>特性は<a href=#2../../std/error/trait.Error.html>標準ライブラリで定義されています</a> ：</span> </p><br><div data-lang=rust><div data-l="use std::fmt::{Debug, Display};"></div><div data-l=""></div><div data-l="trait Error: Debug + Display {"></div><div data-l="#//  /// The lower level cause of this error, if any."></div><div data-l="  /// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The lower level cause of this error, if any.</span>このエラーが発生した場合は、その原因を示します。</span> </div><div data-l="  fn cause(&amp;self) -&gt; Option&lt;&amp;Error&gt; { None }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This trait is super generic because it is meant to be implemented for <i>all</i> types that represent errors.</span>この特性は、エラーを表す<i>すべての</i>タイプに対して実装されるため、スーパージェネリックです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This will prove useful for writing composable code as we&#39;ll see later.</span>これは、後で見るように、合成可能なコードを記述するのに便利です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Otherwise, the trait allows you to do at least the following things:</span>それ以外の場合は、少なくとも以下のことを行うことができます。</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Obtain a <code>Debug</code> representation of the error.</span>エラーの<code>Debug</code>表現を取得します。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Obtain a user-facing <code>Display</code> representation of the error.</span>エラーのユーザー側の<code>Display</code>表現を取得します。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Inspect the causal chain of an error, if one exists (via the <code>cause</code> method).</span>エラーの因果連鎖が存在する場合（ <code>cause</code>メソッドを使用して）、因果連鎖を検査します。</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The first two are a result of <code>Error</code> requiring impls for both <code>Debug</code> and <code>Display</code> .</span>最初の2つは、 <code>Debug</code>と<code>Display</code>両方にimplを必要とする<code>Error</code>結果です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The latter two are from the two methods defined on <code>Error</code> .</span>後者の2つは<code>Error</code>定義された2つのメソッドからのものです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The power of <code>Error</code> comes from the fact that all error types impl <code>Error</code> , which means errors can be existentially quantified as a <a href=#2trait-objects.html>trait object</a> .</span> <code>Error</code>の威力は、すべてのエラータイプが<code>Error</code>になるという事実から来<a href=#2trait-objects.html>ます</a> 。これは、エラーが現実的に<a href=#2trait-objects.html>特性オブジェクト</a>として定量化できることを意味し<a href=#2trait-objects.html>ます</a> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This manifests as either <code>Box&lt;Error&gt;</code> or <code>&amp;Error</code> .</span>これは、 <code>Box&lt;Error&gt;</code>または<code>&amp;Error</code>いずれかとして現れます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Indeed, the <code>cause</code> method returns an <code>&amp;Error</code> , which is itself a trait object.</span>実際、 <code>cause</code>メソッドは<code>&amp;Error</code>返します。これはそれ自体が特性オブジェクトです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll revisit the <code>Error</code> trait&#39;s utility as a trait object later.</span> <code>Error</code> traitのユーティリティを後で特性オブジェクトとして再訪します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For now, it suffices to show an example implementing the <code>Error</code> trait.</span>今のところ、 <code>Error</code>特性を実装する例を示すだけで十分です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s use the error type we defined in the <a href=#2#defining-your-own-error-type>previous section</a> :</span> <a href=#2#defining-your-own-error-type>前のセクションで</a>定義したエラータイプを使用しましょう：</span> </p><br><div data-lang=rust><div data-l="use std::io;"></div><div data-l="use std::num;"></div><div data-l=""></div><div data-l="#// We derive `Debug` because all types should probably derive `Debug`."></div><div data-l="#// This gives us a reasonable human-readable description of `CliError` values."></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We derive <code>Debug</code> because all types should probably derive <code>Debug</code> .</span>私たちは、派生<code>Debug</code>すべての種類は、おそらく派生する必要があるため<code>Debug</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This gives us a reasonable human-readable description of <code>CliError</code> values.</span>これは<code>CliError</code>値を人が読めるように説明して<code>CliError</code>ます。</span> </div><div data-l=#[derive(Debug)]></div><div data-l="enum CliError {"></div><div data-l="    Io(io::Error),"></div><div data-l="    Parse(num::ParseIntError),"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This particular error type represents the possibility of two types of errors occurring: an error dealing with I/O or an error converting a string to a number.</span>この特定のエラータイプは、I / Oを処理するエラーまたは文字列を数値に変換するエラーの2種類のエラーが発生する可能性を表します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The error could represent as many error types as you want by adding new variants to the <code>enum</code> definition.</span>このエラーは、新しいバリアントを<code>enum</code>定義に追加することで、必要な数のエラータイプを表現できます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Implementing <code>Error</code> is pretty straight-forward.</span>実装<code>Error</code>はかなり簡単です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It&#39;s mostly going to be a lot explicit case analysis.</span>ほとんどの場合、明示的なケース分析が行われます。</span> </p><br><div data-lang=rust,ignore><div data-l="use std::error;"></div><div data-l="use std::fmt;"></div><div data-l=""></div><div data-l="impl fmt::Display for CliError {"></div><div data-l="    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {"></div><div data-l="        match *self {"></div><div data-l="#            // Both underlying errors already impl `Display`, so we defer to"></div><div data-l="#            // their implementations."></div><div data-l="            // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Both underlying errors already impl <code>Display</code> , so we defer to their implementations.</span>両方の根底にあるエラーは既に<code>Display</code>を暗示しているので、実装に遅れをとっています。</span> </div><div data-l="            CliError::Io(ref err) =&gt; write!(f, &quot;IO error: {}&quot;, err),"></div><div data-l="            CliError::Parse(ref err) =&gt; write!(f, &quot;Parse error: {}&quot;, err),"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="impl error::Error for CliError {"></div><div data-l="    fn cause(&amp;self) -&gt; Option&lt;&amp;error::Error&gt; {"></div><div data-l="        match *self {"></div><div data-l="#            // N.B. Both of these implicitly cast `err` from their concrete"></div><div data-l="#            // types (either `&amp;io::Error` or `&amp;num::ParseIntError`)"></div><div data-l="#            // to a trait object `&amp;Error`. This works because both error types"></div><div data-l="#            // implement `Error`."></div><div data-l="            // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">NB Both of these implicitly cast <code>err</code> from their concrete types (either <code>&amp;io::Error</code> or <code>&amp;num::ParseIntError</code> ) to a trait object <code>&amp;Error</code> .</span> NBこれらの暗黙的キャストの両方<code>err</code>その具体的な種類から（どちらか<code>&amp;io::Error</code>または<code>&amp;num::ParseIntError</code>形質オブジェクトへの） <code>&amp;Error</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This works because both error types implement <code>Error</code> .</span>これは両方のエラータイプが<code>Error</code>実装しているために機能します。</span> </div><div data-l="            CliError::Io(ref err) =&gt; Some(err),"></div><div data-l="            CliError::Parse(ref err) =&gt; Some(err),"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We note that this is a very typical implementation of <code>Error</code> : match on your different error types and satisfy the contracts defined for <code>cause</code> .</span>これは非常に典型的な<code>Error</code> ：matchの実装であり、さまざまな種類のエラーに対応し、 <code>cause</code>に対して定義されたコントラクトを満たしてい<code>cause</code> 。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>From</code> trait</span> <code>From</code>特性</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>std::convert::From</code> trait is <a href=#2../../std/convert/trait.From.html>defined in the standard library</a> :</span> <code>std::convert::From</code> traitは<a href=#2../../std/convert/trait.From.html>標準ライブラリで定義されています</a> ：</span> </p><br><p><span id=code-from-def></span></p><br><div data-lang=rust><div data-l="trait From&lt;T&gt; {"></div><div data-l="    fn from(T) -&gt; Self;"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Deliciously simple, yes?</span>おいしいシンプルな、はい？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>From</code> is very useful because it gives us a generic way to talk about conversion <i>from</i> a particular type <code>T</code> to some other type (in this case, “some other type” is the subject of the impl, or <code>Self</code> ).</span>それは私たちに、特定の型<i>から</i>の変換について話をする汎用的な方法与えるので、非常に便利である<code>T</code> （この場合は、「他のいくつかのタイプが」IMPL、またはの対象である他のいくつかのタイプに<code>Self</code> ）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The crux of <code>From</code> is the <a href=#2../../std/convert/trait.From.html>set of implementations provided by the standard library</a> .</span> <code>From</code>の要点は<a href=#2../../std/convert/trait.From.html>、標準ライブラリによって提供される一連の実装</a>です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here are a few simple examples demonstrating how <code>From</code> works:</span> <code>From</code>仕組みを示す簡単な例がいくつかあります：</span> </p><br><div data-lang=rust><div data-l="let string: String = From::from(&quot;foo&quot;);"></div><div data-l="let bytes: Vec&lt;u8&gt; = From::from(&quot;foo&quot;);"></div><div data-l="let cow: ::std::borrow::Cow&lt;str&gt; = From::from(&quot;foo&quot;);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">OK, so <code>From</code> is useful for converting between strings.</span> OK、 <code>From</code>は文字列間の変換に便利です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But what about errors?</span>しかし、エラーはどうですか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It turns out, there is one critical impl:</span>それは、1つの重要なインプリケーションがあることが判明しました。</span> </p><br><div data-lang=rust,ignore><div data-l="impl&lt;'a, E: Error + 'a&gt; From&lt;E&gt; for Box&lt;Error + 'a&gt;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This impl says that for <i>any</i> type that impls <code>Error</code> , we can convert it to a trait object <code>Box&lt;Error&gt;</code> .</span>これは、 <code>Error</code>を意味する<i>任意の</i>型に対して、それを特性オブジェクト<code>Box&lt;Error&gt;</code>変換できることを意味します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This may not seem terribly surprising, but it is useful in a generic context.</span>これはひどく驚くようなことではないかもしれませんが、一般的な文脈では役に立ちます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Remember the two errors we were dealing with previously?</span>以前に扱っていた2つのエラーを覚えていますか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Specifically, <code>io::Error</code> and <code>num::ParseIntError</code> .</span>具体的には、 <code>io::Error</code>と<code>num::ParseIntError</code>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Since both impl <code>Error</code> , they work with <code>From</code> :</span>両方ともimpl <code>Error</code>であるため、 <code>From</code>と動作します：</span> </p><br><div data-lang=rust><div data-l="use std::error::Error;"></div><div data-l="use std::fs;"></div><div data-l="use std::io;"></div><div data-l="use std::num;"></div><div data-l=""></div><div data-l="#// We have to jump through some hoops to actually get error values:"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We have to jump through some hoops to actually get error values:</span>実際にエラー値を取得するには、いくつかのフープを飛ばしなければなりません。</span> </div><div data-l="let io_err: io::Error = io::Error::last_os_error();"></div><div data-l="let parse_err: num::ParseIntError = &quot;not a number&quot;.parse::&lt;i32&gt;().unwrap_err();"></div><div data-l=""></div><div data-l="#// OK, here are the conversions:"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">OK, here are the conversions:</span>はい、コンバージョンは次のとおりです。</span> </div><div data-l="let err1: Box&lt;Error&gt; = From::from(io_err);"></div><div data-l="let err2: Box&lt;Error&gt; = From::from(parse_err);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There is a really important pattern to recognize here.</span>ここで本当に重要なパターンがあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Both <code>err1</code> and <code>err2</code> have the <i>same type</i> .</span> <code>err1</code>と<code>err2</code>が<i>同じタイプ</i>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is because they are existentially quantified types, or trait objects.</span>これは、それらが現存する定量化された型または形質オブジェクトであるためです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In particular, their underlying type is <i>erased</i> from the compiler&#39;s knowledge, so it truly sees <code>err1</code> and <code>err2</code> as exactly the same.</span>特に、その基礎となる型はコンパイラの知識から<i>消去さ</i>れるため、まったく同じものとして<code>err1</code>と<code>err2</code>真に見えます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Additionally, we constructed <code>err1</code> and <code>err2</code> using precisely the same function call: <code>From::from</code> .</span>さらに、正確に同じ関数呼び出し、 <code>From::from</code>を使用して<code>err1</code>と<code>err2</code>を構築<code>From::from</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is because <code>From::from</code> is overloaded on both its argument and its return type.</span>これは、 <code>From::from</code>がその引数とその戻り型の両方でオーバーロードされているためです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This pattern is important because it solves a problem we had earlier: it gives us a way to reliably convert errors to the same type using the same function.</span>このパターンは、以前の問題を解決するため重要です。同じ関数を使用してエラーを同じタイプに確実に変換する方法を提供します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Time to revisit an old friend;</span>古い友達を再訪する時間。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">the <code>try€</code> macro.</span> <code>try€</code>マクロ。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The real <code>try€</code> macro</span>本当の<code>try€</code>マクロ</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Previously, we presented this definition of <code>try€</code> :</span>これまで、私たちは<code>try€</code>この定義を提示しました：</span> </p><br><div data-lang=rust><div data-l="macro_rules! try {"></div><div data-l="    ($e:expr) =&gt; (match $e {"></div><div data-l="        Ok(val) =&gt; val,"></div><div data-l="        Err(err) =&gt; return Err(err),"></div><div data-l="    });"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is not its real definition.</span>これは実際の定義ではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Its real definition is <a href=#2../../std/macro.try.html>in the standard library</a> :</span>その実際の定義は<a href=#2../../std/macro.try.html>標準ライブラリにあります</a> ：</span> </p><br><p><span id=code-try-def></span></p><br><div data-lang=rust><div data-l="macro_rules! try {"></div><div data-l="    ($e:expr) =&gt; (match $e {"></div><div data-l="        Ok(val) =&gt; val,"></div><div data-l="        Err(err) =&gt; return Err(::std::convert::From::from(err)),"></div><div data-l="    });"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There&#39;s one tiny but powerful change: the error value is passed through <code>From::from</code> .</span>小さくても強力な変更が1つあります。エラー値は<code>From::from</code>渡さ<code>From::from</code>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This makes the <code>try€</code> macro much more powerful because it gives you automatic type conversion for free.</span>これにより、 <code>try€</code>マクロをより強力にすることができます。これは、自動的に型変換を行うためです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Armed with our more powerful <code>try€</code> macro, let&#39;s take a look at code we wrote previously to read a file and convert its contents to an integer:</span>より強力な<code>try€</code>マクロを用意して、ファイルを読み込んでその内容を整数に変換するために以前書いたコードを見てみましょう：</span> </p><br><div data-lang=rust><div data-l="use std::fs::File;"></div><div data-l="use std::io::Read;"></div><div data-l="use std::path::Path;"></div><div data-l=""></div><div data-l="fn file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;i32, String&gt; {"></div><div data-l="    let mut file = try!(File::open(file_path).map_err(|e| e.to_string()));"></div><div data-l="    let mut contents = String::new();"></div><div data-l="    try!(file.read_to_string(&amp;mut contents).map_err(|e| e.to_string()));"></div><div data-l="    let n = try!(contents.trim().parse::&lt;i32&gt;().map_err(|e| e.to_string()));"></div><div data-l="    Ok(2 * n)"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Earlier, we promised that we could get rid of the <code>map_err</code> calls.</span>以前は、 <code>map_err</code>呼び出しを取り除くことができると約束しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Indeed, all we have to do is pick a type that <code>From</code> works with.</span>確かに、私たちがしなければならないのは、 <code>From</code>作品を選ぶことだけです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As we saw in the previous section, <code>From</code> has an impl that lets it convert any error type into a <code>Box&lt;Error&gt;</code> :</span>前のセクションで見たように、 <code>From</code>は、あらゆるエラータイプを<code>Box&lt;Error&gt;</code>に変換するためのインプリメンテーションがあります。</span> </p><br><div data-lang=rust><div data-l="use std::error::Error;"></div><div data-l="use std::fs::File;"></div><div data-l="use std::io::Read;"></div><div data-l="use std::path::Path;"></div><div data-l=""></div><div data-l="fn file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;i32, Box&lt;Error&gt;&gt; {"></div><div data-l="    let mut file = try!(File::open(file_path));"></div><div data-l="    let mut contents = String::new();"></div><div data-l="    try!(file.read_to_string(&amp;mut contents));"></div><div data-l="    let n = try!(contents.trim().parse::&lt;i32&gt;());"></div><div data-l="    Ok(2 * n)"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We are getting very close to ideal error handling.</span>理想的なエラー処理に非常に近づいています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Our code has very little overhead as a result from error handling because the <code>try€</code> macro encapsulates three things simultaneously:</span> <code>try€</code>マクロは3つのものを同時にカプセル化するため、エラー処理の結果としてオーバーヘッドはほとんどありません。</span> </p><br><div data-b=1.> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Case analysis.</span>ケース分析。</span> </div><div data-b=2.> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Control flow.</span>制御フロー。</span> </div><div data-b=3.> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Error type conversion.</span>エラータイプ変換。</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When all three things are combined, we get code that is unencumbered by combinators, calls to <code>unwrap</code> or case analysis.</span> 3つのものがすべて結合されると、コンビネータ、 <code>unwrap</code>またはケース分析の呼び出しによって妨げられないコードが得られます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There&#39;s one little nit left: the <code>Box&lt;Error&gt;</code> type is <i>opaque</i> .</span>少し残っています： <code>Box&lt;Error&gt;</code>タイプは<i>不透明</i>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we return a <code>Box&lt;Error&gt;</code> to the caller, the caller can&#39;t (easily) inspect underlying error type.</span>呼び出し元に<code>Box&lt;Error&gt;</code>を返すと、呼び出し元は基になるエラータイプを（簡単に）検査できません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The situation is certainly better than <code>String</code> because the caller can call methods like <a class=notranslate href=#2../../std/error/trait.Error.html#method.cause><code>cause</code></a> , but the limitation remains: <code>Box&lt;Error&gt;</code> is opaque.</span>状況がより確かに優れている<code>String</code> 、発信者のようなメソッドを呼び出すことができますので<a class=notranslate href=#2../../std/error/trait.Error.html#method.cause><code>cause</code></a> 、しかし制限が残っています： <code>Box&lt;Error&gt;</code>不透明です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">(NB This isn&#39;t entirely true because Rust does have runtime reflection, which is useful in some scenarios that are <a href=#2https://crates.io/crates/error>beyond the scope of this section</a> .)</span> （これは完全に真実ではありません。なぜなら、Rustにはランタイムリフレクションがあるからです。 <a href=#2https://crates.io/crates/error>これは、このセクションの範囲を超えて</a>いるシナリオで便利です）。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It&#39;s time to revisit our custom <code>CliError</code> type and tie everything together.</span>今度は、カスタム<code>CliError</code>型を再訪し、すべてを結びつけるときです。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Composing custom error types</span>カスタムエラータイプの作成</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In the last section, we looked at the real <code>try€</code> macro and how it does automatic type conversion for us by calling <code>From::from</code> on the error value.</span>最後のセクションでは、実際の<code>try€</code>マクロと、エラー値の<code>From::from</code>を呼び出すことによって、自動型変換を行う方法を見てきました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In particular, we converted errors to <code>Box&lt;Error&gt;</code> , which works, but the type is opaque to callers.</span>特に、エラーを<code>Box&lt;Error&gt;</code>に変換しましたが、これは動作しますが、タイプは呼び出し元に対して不透明です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To fix this, we use the same remedy that we&#39;re already familiar with: a custom error type.</span>これを修正するには、既に慣れ親しんでいるのと同じ措置、すなわちカスタムエラータイプを使用します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Once again, here is the code that reads the contents of a file and converts it to an integer:</span>もう一度、ファイルの内容を読み取り、それを整数に変換するコードを次に示します。</span> </p><br><div data-lang=rust><div data-l="use std::fs::File;"></div><div data-l="use std::io::{self, Read};"></div><div data-l="use std::num;"></div><div data-l="use std::path::Path;"></div><div data-l=""></div><div data-l="#// We derive `Debug` because all types should probably derive `Debug`."></div><div data-l="#// This gives us a reasonable human-readable description of `CliError` values."></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We derive <code>Debug</code> because all types should probably derive <code>Debug</code> .</span>私たちは、派生<code>Debug</code>すべての種類は、おそらく派生する必要があるため<code>Debug</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This gives us a reasonable human-readable description of <code>CliError</code> values.</span>これは<code>CliError</code>値を人が読めるように説明して<code>CliError</code>ます。</span> </div><div data-l=#[derive(Debug)]></div><div data-l="enum CliError {"></div><div data-l="    Io(io::Error),"></div><div data-l="    Parse(num::ParseIntError),"></div><div data-l=}></div><div data-l=""></div><div data-l="fn file_double_verbose&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;i32, CliError&gt; {"></div><div data-l="    let mut file = try!(File::open(file_path).map_err(CliError::Io));"></div><div data-l="    let mut contents = String::new();"></div><div data-l="    try!(file.read_to_string(&amp;mut contents).map_err(CliError::Io));"></div><div data-l="    let n: i32 = try!(contents.trim().parse().map_err(CliError::Parse));"></div><div data-l="    Ok(2 * n)"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Notice that we still have the calls to <code>map_err</code> .</span> <code>map_err</code>の呼び出しがまだあることに注意して<code>map_err</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Why?</span>どうして？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Well, recall the definitions of <a class=notranslate href=#2#code-try-def><code>try€</code></a> and <a class=notranslate href=#2#code-from-def><code>From</code></a> .</span>まあ、 <a class=notranslate href=#2#code-try-def><code>try€</code></a>と<a class=notranslate href=#2#code-from-def><code>From</code></a>定義を思い出して<a class=notranslate href=#2#code-try-def><code>try€</code></a> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The problem is that there is no <code>From</code> impl that allows us to convert from error types like <code>io::Error</code> and <code>num::ParseIntError</code> to our own custom <code>CliError</code> .</span>問題は、 <code>io::Error</code>や<code>num::ParseIntError</code>ようなエラー型から私たちのカスタム<code>CliError</code>に変換することを可能にする<code>From</code> implは存在しないということ<code>CliError</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Of course, it is easy to fix this!</span>もちろん、これを修正するのは簡単です！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Since we defined <code>CliError</code> , we can impl <code>From</code> with it:</span>我々が定義されているので<code>CliError</code> 、我々はIMPLできる<code>From</code>それと：</span> </p><br><div data-lang=rust><div data-l="# #[derive(Debug)]"></div><div data-l="# enum CliError { Io(io::Error), Parse(num::ParseIntError) }"></div><div data-l="use std::io;"></div><div data-l="use std::num;"></div><div data-l=""></div><div data-l="impl From&lt;io::Error&gt; for CliError {"></div><div data-l="    fn from(err: io::Error) -&gt; CliError {"></div><div data-l="        CliError::Io(err)"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="impl From&lt;num::ParseIntError&gt; for CliError {"></div><div data-l="    fn from(err: num::ParseIntError) -&gt; CliError {"></div><div data-l="        CliError::Parse(err)"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">All these impls are doing is teaching <code>From</code> how to create a <code>CliError</code> from other error types.</span>これらのすべてのimplsを教えてやっている<code>From</code>作成方法<code>CliError</code>他のエラータイプからを。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In our case, construction is as simple as invoking the corresponding value constructor.</span>私たちの場合、構築は対応する値コンストラクタを呼び出すのと同じくらい簡単です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Indeed, it is <i>typically</i> this easy.</span>確かに、これは<i>通常</i>簡単です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can finally rewrite <code>file_double</code> :</span>最終的に<code>file_double</code>書き直すことができ<code>file_double</code> ：</span> </p><br><div data-lang=rust><div data-l="# use std::io;"></div><div data-l="# use std::num;"></div><div data-l="# enum CliError { Io(::std::io::Error), Parse(::std::num::ParseIntError) }"></div><div data-l="# impl From&lt;io::Error&gt; for CliError {"></div><div data-l="#     fn from(err: io::Error) -&gt; CliError { CliError::Io(err) }"></div><div data-l="# }"></div><div data-l="# impl From&lt;num::ParseIntError&gt; for CliError {"></div><div data-l="#     fn from(err: num::ParseIntError) -&gt; CliError { CliError::Parse(err) }"></div><div data-l="# }"></div><div data-l=""></div><div data-l="use std::fs::File;"></div><div data-l="use std::io::Read;"></div><div data-l="use std::path::Path;"></div><div data-l=""></div><div data-l="fn file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;i32, CliError&gt; {"></div><div data-l="    let mut file = try!(File::open(file_path));"></div><div data-l="    let mut contents = String::new();"></div><div data-l="    try!(file.read_to_string(&amp;mut contents));"></div><div data-l="    let n: i32 = try!(contents.trim().parse());"></div><div data-l="    Ok(2 * n)"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The only thing we did here was remove the calls to <code>map_err</code> .</span>ここで唯一行ったことは、 <code>map_err</code>への呼び出しを削除すること<code>map_err</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">They are no longer needed because the <code>try€</code> macro invokes <code>From::from</code> on the error value.</span> <code>try€</code>マクロがエラー値の<code>From::from</code>を呼び出すため、これらのマクロは不要になりました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This works because we&#39;ve provided <code>From</code> impls for all the error types that could appear.</span>これは、出現する可能性のあるすべてのエラータイプに対して、 <code>From</code>差し込み」 <code>From</code>提供されているために機能します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we modified our <code>file_double</code> function to perform some other operation, say, convert a string to a float, then we&#39;d need to add a new variant to our error type:</span> <code>file_double</code>関数を変更して、たとえば文字列を浮動小数点数に変換するなどの操作を実行した場合は、新しいバリアントをエラータイプに追加する必要があります。</span> </p><br><div data-lang=rust><div data-l="use std::io;"></div><div data-l="use std::num;"></div><div data-l=""></div><div data-l="enum CliError {"></div><div data-l="    Io(io::Error),"></div><div data-l="    ParseInt(num::ParseIntError),"></div><div data-l="    ParseFloat(num::ParseFloatError),"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">And add a new <code>From</code> impl:</span>新規追加<code>From</code>のimpl：</span> </p><br><div data-lang=rust><div data-l="# enum CliError {"></div><div data-l="#     Io(::std::io::Error),"></div><div data-l="#     ParseInt(num::ParseIntError),"></div><div data-l="#     ParseFloat(num::ParseFloatError),"></div><div data-l="# }"></div><div data-l=""></div><div data-l="use std::num;"></div><div data-l=""></div><div data-l="impl From&lt;num::ParseFloatError&gt; for CliError {"></div><div data-l="    fn from(err: num::ParseFloatError) -&gt; CliError {"></div><div data-l="        CliError::ParseFloat(err)"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">And that&#39;s it!</span>以上です！</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Advice for library writers</span>図書館の作家のためのアドバイス</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If your library needs to report custom errors, then you should probably define your own error type.</span>ライブラリでカスタムエラーをレポートする必要がある場合は、おそらく独自のエラータイプを定義する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It&#39;s up to you whether or not to expose its representation (like <a class=notranslate href=#2../../std/io/enum.ErrorKind.html><code>ErrorKind</code></a> ) or keep it hidden (like <a class=notranslate href=#2../../std/num/struct.ParseIntError.html><code>ParseIntError</code></a> ).</span>その表現（ <a class=notranslate href=#2../../std/io/enum.ErrorKind.html><code>ErrorKind</code></a> ）を公開するかどうか、または<a class=notranslate href=#2../../std/num/struct.ParseIntError.html><code>ParseIntError</code></a>ように非表示にするかどうかは、あなた次第です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Regardless of how you do it, it&#39;s usually good practice to at least provide some information about the error beyond its <code>String</code> representation.</span>それをどうしているかにかかわらず、少なくともエラーの情報を<code>String</code>表現を超えて提供することは、通常は良い方法です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But certainly, this will vary depending on use cases.</span>しかし、確かに、これはユースケースによって異なります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">At a minimum, you should probably implement the <a class=notranslate href=#2../../std/error/trait.Error.html><code>Error</code></a> trait.</span>少なくとも、 <a class=notranslate href=#2../../std/error/trait.Error.html><code>Error</code></a>特性を実装するべきです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This will give users of your library some minimum flexibility for <a href=#2#the-real-try-macro>composing errors</a> .</span>これにより、ライブラリのユーザーは<a href=#2#the-real-try-macro>エラー</a>を<a href=#2#the-real-try-macro>作成する</a>ための柔軟性が<a href=#2#the-real-try-macro>失われ</a>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Implementing the <code>Error</code> trait also means that users are guaranteed the ability to obtain a string representation of an error (because it requires impls for both <code>fmt::Debug</code> and <code>fmt::Display</code> ).</span> <code>Error</code>特性を実装することは、 <code>fmt::Debug</code>と<code>fmt::Display</code>両方にimplを必要とするため、ユーザーがエラーの文字列表現を取得することが保証されていることも意味します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Beyond that, it can also be useful to provide implementations of <code>From</code> on your error types.</span>それ以外にも、エラータイプの<code>From</code>実装を提供すると便利です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This allows you (the library author) and your users to <a href=#2#composing-custom-error-types>compose more detailed errors</a> .</span>これにより、あなた（ライブラリ作成者）とユーザーは<a href=#2#composing-custom-error-types>より詳細なエラー</a>を<a href=#2#composing-custom-error-types>作成することができ</a>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, <a class=notranslate href=#2http://burntsushi.net/rustdoc/csv/enum.Error.html><code>csv::Error</code></a> provides <code>From</code> impls for both <code>io::Error</code> and <code>byteorder::Error</code> .</span>例えば、 <a class=notranslate href=#2http://burntsushi.net/rustdoc/csv/enum.Error.html><code>csv::Error</code></a>は、 <code>io::Error</code>と<code>byteorder::Error</code>両方<code>From</code> implsを提供します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Finally, depending on your tastes, you may also want to define a <a href=#2#the-result-type-alias-idiom><code>Result</code> type alias</a> , particularly if your library defines a single error type.</span>最後に、あなたの好みに応じて、特にライブラリで単一のエラータイプが定義されている場合は、 <a href=#2#the-result-type-alias-idiom><code>Result</code>型のエイリアス</a>を定義することもできます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is used in the standard library for <a class=notranslate href=#2../../std/io/type.Result.html><code>io::Result</code></a> and <a class=notranslate href=#2../../std/fmt/type.Result.html><code>fmt::Result</code></a> .</span>これは、 <a class=notranslate href=#2../../std/io/type.Result.html><code>io::Result</code></a>と<a class=notranslate href=#2../../std/fmt/type.Result.html><code>fmt::Result</code></a>の標準ライブラリで使用されます。</span> </p><br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Case study: A program to read population data</span>ケーススタディ：人口データを読み込むプログラム</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This section was long, and depending on your background, it might be rather dense.</span>このセクションは長く、あなたの背景にもよるが、それはむしろ密であるかもしれない。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">While there is plenty of example code to go along with the prose, most of it was specifically designed to be pedagogical.</span>散文と一緒に行くためのサンプルコードはたくさんありますが、そのほとんどは教育的であるように特別に設計されています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So, we&#39;re going to do something new: a case study.</span>だから、我々は新しいことをするつもりです：事例研究。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For this, we&#39;re going to build up a command line program that lets you query world population data.</span>このために、世界の人口データを照会するコマンドラインプログラムを構築します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The objective is simple: you give it a location and it will tell you the population.</span>目的は簡単です：あなたはそれに場所を与え、人口を教えてくれるでしょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Despite the simplicity, there is a lot that can go wrong!</span>シンプルさにもかかわらず、間違っていることがたくさんあります！</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The data we&#39;ll be using comes from the <a href=#311>Data Science Toolkit</a> .</span>使用するデータは、 <a href=#311>Data Science Toolkitに</a>基づいています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">I&#39;ve prepared some data from it for this exercise.</span>この演習では、いくつかのデータを用意しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can either grab the <a href=#312>world population data</a> (41MB gzip compressed, 145MB uncompressed) or only the <a href=#313>US population data</a> (2.2MB gzip compressed, 7.2MB uncompressed).</span> <a href=#312>世界人口データ</a> （41MB gzip圧縮、145MB非圧縮）または<a href=#313>米国人口データ</a> （2.2MB gzip圧縮、7.2MB非圧縮）だけを<a href=#313>取得できます</a> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Up until now, we&#39;ve kept the code limited to Rust&#39;s standard library.</span>これまでは、コードをRustの標準ライブラリに限定していました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For a real task like this though, we&#39;ll want to at least use something to parse CSV data, parse the program arguments and decode that stuff into Rust types automatically.</span>このような実際のタスクでは、少なくともCSVデータを解析し、プログラムの引数を解析し、その情報をRust型に自動的にデコードする必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For that, we&#39;ll use the <a class=notranslate href=#2https://crates.io/crates/csv><code>csv</code></a> , and <a class=notranslate href=#2https://crates.io/crates/rustc-serialize><code>rustc-serialize</code></a> crates.</span>そのために、 <a class=notranslate href=#2https://crates.io/crates/csv><code>csv</code></a>と<a class=notranslate href=#2https://crates.io/crates/rustc-serialize><code>rustc-serialize</code></a>使用します。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Initial setup</span>初期設定</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;re not going to spend a lot of time on setting up a project with Cargo because it is already covered well in <a href=#2getting-started.html#hello-cargo>the Cargo section</a> and <a href=#314>Cargo&#39;s documentation</a> .</span> Cargoのプロジェクトでは、すでに<a href=#2getting-started.html#hello-cargo>Cargoセクション</a>と<a href=#314>Cargoのドキュメンテーションで</a>十分にカバーされているため、プロジェクトを立ち上げるのに多くの時間を費やすつもりはありません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To get started from scratch, run <code>cargo new --bin city-pop</code> and make sure your <code>Cargo.toml</code> looks something like this:</span>ゼロから始めるには、 <code>cargo new --bin city-pop</code>を実行し、 <code>Cargo.toml</code>が次のようになっていることを確認してください：</span> </p><br><div data-lang=text><div data-l=[package]></div><div data-l="name = &quot;city-pop&quot;"></div><div data-l="version = &quot;0.1.0&quot;"></div><div data-l="authors = [&quot;Andrew Gallant &lt;jamslam@gmail.com&gt;&quot;]"></div><div data-l=""></div><div data-l=[[bin]]></div><div data-l="name = &quot;city-pop&quot;"></div><div data-l=""></div><div data-l=[dependencies]></div><div data-l="csv = &quot;0.*&quot;"></div><div data-l="rustc-serialize = &quot;0.*&quot;"></div><div data-l="getopts = &quot;0.*&quot;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You should already be able to run:</span>あなたはすでに実行することができます：</span> </p><br><div data-lang=text><div data-l="cargo build --release"></div><div data-l=./target/release/city-pop></div><div data-l="# Outputs: Hello, world!"></div></div><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Argument parsing</span>引数の解析</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s get argument parsing out of the way.</span>引き分けに引数の解析をしましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We won&#39;t go into too much detail on Getopts, but there is <a href=#315>some good documentation</a> describing it.</span>私たちはGetoptsについて詳しく説明しませんが、それを記述する<a href=#315>良い文書</a>があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The short story is that Getopts generates an argument parser and a help message from a vector of options (The fact that it is a vector is hidden behind a struct and a set of methods).</span>短い話は、Getoptsがオプションのベクトルから引数パーザとヘルプメッセージを生成することです（ベクトルであるという事実は、構造体とメソッドのセットの背後に隠されています）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Once the parsing is done, the parser returns a struct that records matches for defined options, and remaining &quot;free&quot; arguments.</span>解析が完了すると、パーサは、定義されたオプションと残りの &quot;空き&quot;引数との一致を記録する構造体を返します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">From there, we can get information about the flags, for instance, whether they were passed in, and what arguments they had.</span>そこから、フラグの情報、例えば、渡されたかどうか、どのような引数があるかなどの情報を取得できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here&#39;s our program with the appropriate <code>extern crate</code> statements, and the basic argument setup for Getopts:</span>ここでは、適切な<code>extern crate</code> crateステートメントとGetoptsの基本引数設定を使って、プログラムを紹介します：</span> </p><br><div data-lang=rust,ignore><div data-l="extern crate getopts;"></div><div data-l="extern crate rustc_serialize;"></div><div data-l=""></div><div data-l="use getopts::Options;"></div><div data-l="use std::env;"></div><div data-l=""></div><div data-l="fn print_usage(program: &amp;str, opts: Options) {"></div><div data-l="    println!(&quot;{}&quot;, opts.usage(&amp;format!(&quot;Usage: {} [options] &lt;data-path&gt; &lt;city&gt;&quot;, program)));"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let args: Vec&lt;String&gt; = env::args().collect();"></div><div data-l="    let program = &amp;args[0];"></div><div data-l=""></div><div data-l="    let mut opts = Options::new();"></div><div data-l="    opts.optflag(&quot;h&quot;, &quot;help&quot;, &quot;Show this usage message.&quot;);"></div><div data-l=""></div><div data-l="    let matches = match opts.parse(&amp;args[1..]) {"></div><div data-l="        Ok(m)  =&gt; { m }"></div><div data-l="        Err(e) =&gt; { panic!(e.to_string()) }"></div><div data-l="    };"></div><div data-l="    if matches.opt_present(&quot;h&quot;) {"></div><div data-l="        print_usage(&amp;program, opts);"></div><div data-l="        return;"></div><div data-l="    }"></div><div data-l="    let data_path = &amp;matches.free[0];"></div><div data-l="    let city: &amp;str = &amp;matches.free[1];"></div><div data-l=""></div><div data-l="#    // Do stuff with information."></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Do stuff with information.</span>情報を詰め込む</span> </div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">First, we get a vector of the arguments passed into our program.</span>まず、プログラムに渡された引数のベクトルを取得します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We then store the first one, knowing that it is our program&#39;s name.</span>次に、プログラムの名前であることを認識して、最初のものを保存します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Once that&#39;s done, we set up our argument flags, in this case a simplistic help message flag.</span>これが終わると、引数フラグを設定します。この場合、単純なヘルプメッセージフラグです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Once we have the argument flags set up, we use <code>Options.parse</code> to parse the argument vector (starting from index one, because index 0 is the program name).</span>引数フラグが設定されると、 <code>Options.parse</code>を使用して引数ベクトルを解析します（インデックス0はプログラム名です）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If this was successful, we assign matches to the parsed object, if not, we panic.</span>これが成功した場合、解析されたオブジェクトにマッチを割り当てます。そうでなければ、パニックになります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Once past that, we test if the user passed in the help flag, and if so print the usage message.</span>それを過ぎると、ユーザーがヘルプフラグを渡したかどうかテストし、もしそうなら、使用法のメッセージを出力します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The option help messages are constructed by Getopts, so all we have to do to print the usage message is tell it what we want it to print for the program name and template.</span>オプションのヘルプメッセージはGetoptsによって構築されるので、使用法のメッセージを出力するために必要なことは、プログラム名とテンプレートのために印刷することだけです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If the user has not passed in the help flag, we assign the proper variables to their corresponding arguments.</span>ユーザーがヘルプフラグを渡さなかった場合、適切な変数を対応する引数に割り当てます。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Writing the logic</span>論理を書く</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We all write code differently, but error handling is usually the last thing we want to think about.</span>私たちはすべてコードを違って書いていますが、通常はエラー処理が考えています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This isn&#39;t great for the overall design of a program, but it can be useful for rapid prototyping.</span>これはプログラム全体の設計にはあまり適していませんが、ラピッドプロトタイピングには役立ちます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because Rust forces us to be explicit about error handling (by making us call <code>unwrap</code> ), it is easy to see which parts of our program can cause errors.</span> Rustはエラー処理を明示的に（強制的に<code>unwrap</code>呼び出すことによって）強制するので、プログラムのどの部分がエラーを引き起こすかを簡単に知ることができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this case study, the logic is really simple.</span>このケーススタディでは、ロジックは本当に簡単です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">All we need to do is parse the CSV data given to us and print out a field in matching rows.</span>必要なのは、私たちに与えられたCSVデータを解析して、一致する行にフィールドを印刷することだけです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s do it.</span>やってみましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">(Make sure to add <code>extern crate csv;</code> to the top of your file.)</span> （ <code>extern crate csv;</code>をファイルの先頭に追加してください）</span> </p><br><div data-lang=rust,ignore><div data-l="use std::fs::File;"></div><div data-l=""></div><div data-l="#// This struct represents the data in each row of the CSV file."></div><div data-l="#// Type based decoding absolves us of a lot of the nitty-gritty error"></div><div data-l="#// handling, like parsing strings as integers or floats."></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This struct represents the data in each row of the CSV file.</span>この構造体は、CSVファイルの各行のデータを表します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Type based decoding absolves us of a lot of the nitty-gritty error handling, like parsing strings as integers or floats.</span>型に基づくデコードでは、文字列を整数または浮動小数点として解析するような、きめ細かなエラー処理がたくさんあります。</span> </div><div data-l="#[derive(Debug, RustcDecodable)]"></div><div data-l="struct Row {"></div><div data-l="    country: String,"></div><div data-l="    city: String,"></div><div data-l="    accent_city: String,"></div><div data-l="    region: String,"></div><div data-l=""></div><div data-l="#    // Not every row has data for the population, latitude or longitude!"></div><div data-l="#    // So we express them as `Option` types, which admits the possibility of"></div><div data-l="#    // absence. The CSV parser will fill in the correct value for us."></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Not every row has data for the population, latitude or longitude!</span>すべての行に人口、緯度、経度のデータがあるわけではありません！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So we express them as <code>Option</code> types, which admits the possibility of absence.</span>だから私たちは<code>Option</code> typesとしてそれらを表現します。これは欠如の可能性を認めています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The CSV parser will fill in the correct value for us.</span> CSVパーサーが正しい値を入力します。</span> </div><div data-l="    population: Option&lt;u64&gt;,"></div><div data-l="    latitude: Option&lt;f64&gt;,"></div><div data-l="    longitude: Option&lt;f64&gt;,"></div><div data-l=}></div><div data-l=""></div><div data-l="fn print_usage(program: &amp;str, opts: Options) {"></div><div data-l="    println!(&quot;{}&quot;, opts.usage(&amp;format!(&quot;Usage: {} [options] &lt;data-path&gt; &lt;city&gt;&quot;, program)));"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let args: Vec&lt;String&gt; = env::args().collect();"></div><div data-l="    let program = &amp;args[0];"></div><div data-l=""></div><div data-l="    let mut opts = Options::new();"></div><div data-l="    opts.optflag(&quot;h&quot;, &quot;help&quot;, &quot;Show this usage message.&quot;);"></div><div data-l=""></div><div data-l="    let matches = match opts.parse(&amp;args[1..]) {"></div><div data-l="        Ok(m)  =&gt; { m }"></div><div data-l="        Err(e) =&gt; { panic!(e.to_string()) }"></div><div data-l="    };"></div><div data-l=""></div><div data-l="    if matches.opt_present(&quot;h&quot;) {"></div><div data-l="        print_usage(&amp;program, opts);"></div><div data-l="        return;"></div><div data-l="    }"></div><div data-l=""></div><div data-l="    let data_path = &amp;matches.free[0];"></div><div data-l="    let city: &amp;str = &amp;matches.free[1];"></div><div data-l=""></div><div data-l="    let file = File::open(data_path).unwrap();"></div><div data-l="    let mut rdr = csv::Reader::from_reader(file);"></div><div data-l=""></div><div data-l="    for row in rdr.decode::&lt;Row&gt;() {"></div><div data-l="        let row = row.unwrap();"></div><div data-l=""></div><div data-l="        if row.city == city {"></div><div data-l="            println!(&quot;{}, {}: {:?}&quot;,"></div><div data-l="                row.city, row.country,"></div><div data-l="                row.population.expect(&quot;population count&quot;));"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s outline the errors.</span>エラーの概要を説明しましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can start with the obvious: the three places that <code>unwrap</code> is called:</span>明白なことから始めることができます。 <code>unwrap</code>と呼ばれる3つの場所は、</span> </p><br><div data-b=1.> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a class=notranslate href=#2../../std/fs/struct.File.html#method.open><code>File::open</code></a> can return an <a class=notranslate href=#2../../std/io/struct.Error.html><code>io::Error</code></a> .</span> <a class=notranslate href=#2../../std/fs/struct.File.html#method.open><code>File::open</code></a>は<a class=notranslate href=#2../../std/io/struct.Error.html><code>io::Error</code></a>返すことができます。</span> </div><div data-b=2.> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a class=notranslate href=#2http://burntsushi.net/rustdoc/csv/struct.Reader.html#method.decode><code>csv::Reader::decode</code></a> decodes one record at a time, and <a href=#2http://burntsushi.net/rustdoc/csv/struct.DecodedRecords.html>decoding a record</a> (look at the <code>Item</code> associated type on the <code>Iterator</code> impl) can produce a <a class=notranslate href=#2http://burntsushi.net/rustdoc/csv/enum.Error.html><code>csv::Error</code></a> .</span> <a class=notranslate href=#2http://burntsushi.net/rustdoc/csv/struct.Reader.html#method.decode><code>csv::Reader::decode</code></a>は一度に一つのレコードを<a href=#2http://burntsushi.net/rustdoc/csv/struct.DecodedRecords.html>デコードし、レコード</a>を<a href=#2http://burntsushi.net/rustdoc/csv/struct.DecodedRecords.html>デコードする</a>と（ <code>Iterator</code> implで<code>Item</code>関連タイプを調べると）、 <a class=notranslate href=#2http://burntsushi.net/rustdoc/csv/enum.Error.html><code>csv::Error</code></a>が生成されます。</span> </div><div data-b=3.> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If <code>row.population</code> is <code>None</code> , then calling <code>expect</code> will panic.</span> <code>row.population</code>が<code>None</code>場合、 <code>expect</code>を呼び出すとパニックになります。</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Are there any others?</span>他に何かありますか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">What if we can&#39;t find a matching city?</span>一致する都市が見つからない場合はどうすればよいですか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Tools like <code>grep</code> will return an error code, so we probably should too.</span> <code>grep</code>ようなツールはエラーコードを返すので、おそらくそれも必要です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So we have logic errors specific to our problem, IO errors and CSV parsing errors.</span>だから我々の問題に固有の論理エラー、IOエラー、CSV解析エラーがある。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;re going to explore two different ways to approach handling these errors.</span>これらのエラーを処理するための2つの異なる方法を検討します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">I&#39;d like to start with <code>Box&lt;Error&gt;</code> .</span>私は<code>Box&lt;Error&gt;</code>から始めたいと思います。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Later, we&#39;ll see how defining our own error type can be useful.</span>後で、独自のエラータイプの定義がどのように役立つかを見ていきます。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Error handling with <code>Box&lt;Error&gt;</code></span> <code>Box&lt;Error&gt;</code>エラー処理<code>Box&lt;Error&gt;</code></span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>Box&lt;Error&gt;</code> is nice because it <i>just works</i> .</span> <code>Box&lt;Error&gt;</code>それ<i>だけで動作します</i>ので、いいです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You don&#39;t need to define your own error types and you don&#39;t need any <code>From</code> implementations.</span>独自のエラータイプを定義する必要はなく、 <code>From</code>実装は必要ありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The downside is that since <code>Box&lt;Error&gt;</code> is a trait object, it <i>erases the type</i> , which means the compiler can no longer reason about its underlying type.</span>欠点は、 <code>Box&lt;Error&gt;</code>が特性オブジェクトであるため<i>、型を消去する</i>ということです。つまり、コンパイラは根本的な型を理由に考えることができなくなります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a class=notranslate href=#2#the-limits-of-combinators>Previously</a> we started refactoring our code by changing the type of our function from <code>T</code> to <code>Result&lt;T, OurErrorType&gt;</code> .</span> <a class=notranslate href=#2#the-limits-of-combinators>Previously</a>は、関数の型を<code>T</code>から<code>Result&lt;T, OurErrorType&gt;</code>変更して、コードをリファクタリングし始めました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this case, <code>OurErrorType</code> is only <code>Box&lt;Error&gt;</code> .</span>この場合、 <code>OurErrorType</code>は<code>Box&lt;Error&gt;</code>のみです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But what&#39;s <code>T</code> ?</span>しかし、 <code>T</code>何ですか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">And can we add a return type to <code>main</code> ?</span> <code>main</code>戻り値型を追加できますか？</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The answer to the second question is no, we can&#39;t.</span> 2番目の質問に対する答えは「いいえ、できません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That means we&#39;ll need to write a new function.</span>つまり、新しい関数を書く必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But what is <code>T</code> ?</span>しかし、 <code>T</code>とは何ですか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The simplest thing we can do is to return a list of matching <code>Row</code> values as a <code>Vec&lt;Row&gt;</code> .</span>一番簡単なのは、一致する<code>Row</code>値のリストを<code>Vec&lt;Row&gt;</code>として返すことです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">(Better code would return an iterator, but that is left as an exercise to the reader.)</span> （より良いコードはイテレータを返しますが、それは読者の練習として残されています）。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s refactor our code into its own function, but keep the calls to <code>unwrap</code> .</span>私たちのコードを独自の関数にリファクタリングしましょうが、呼び出しを<code>unwrap</code>するようにしましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that we opt to handle the possibility of a missing population count by simply ignoring that row.</span>その行を無視するだけで、人口不足の可能性を処理することに注意してください。</span> </p><br><div data-lang=rust,ignore><div data-l="use std::path::Path;"></div><div data-l=""></div><div data-l="struct Row {"></div><div data-l="#    // This struct remains unchanged."></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This struct remains unchanged.</span>この構造体は変更されません。</span> </div><div data-l=}></div><div data-l=""></div><div data-l="struct PopulationCount {"></div><div data-l="    city: String,"></div><div data-l="    country: String,"></div><div data-l="#    // This is no longer an `Option` because values of this type are only"></div><div data-l="#    // constructed if they have a population count."></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is no longer an <code>Option</code> because values of this type are only constructed if they have a population count.</span>これは、もはや<code>Option</code>はない。なぜなら、このタイプの値は、人口数がある場合にのみ構築されるからである。</span> </div><div data-l="    count: u64,"></div><div data-l=}></div><div data-l=""></div><div data-l="fn print_usage(program: &amp;str, opts: Options) {"></div><div data-l="    println!(&quot;{}&quot;, opts.usage(&amp;format!(&quot;Usage: {} [options] &lt;data-path&gt; &lt;city&gt;&quot;, program)));"></div><div data-l=}></div><div data-l=""></div><div data-l="fn search&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P, city: &amp;str) -&gt; Vec&lt;PopulationCount&gt; {"></div><div data-l="    let mut found = vec![];"></div><div data-l="    let file = File::open(file_path).unwrap();"></div><div data-l="    let mut rdr = csv::Reader::from_reader(file);"></div><div data-l="    for row in rdr.decode::&lt;Row&gt;() {"></div><div data-l="        let row = row.unwrap();"></div><div data-l="        match row.population {"></div><div data-l="#//            None =&gt; { } // Skip it."></div><div data-l="            None =&gt; { } // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Skip it.</span>それをスキップします。</span> </div><div data-l="            Some(count) =&gt; if row.city == city {"></div><div data-l="                found.push(PopulationCount {"></div><div data-l="                    city: row.city,"></div><div data-l="                    country: row.country,"></div><div data-l="                    count: count,"></div><div data-l="                });"></div><div data-l="            },"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l="    found"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let args: Vec&lt;String&gt; = env::args().collect();"></div><div data-l="    let program = &amp;args[0];"></div><div data-l=""></div><div data-l="    let mut opts = Options::new();"></div><div data-l="    opts.optflag(&quot;h&quot;, &quot;help&quot;, &quot;Show this usage message.&quot;);"></div><div data-l=""></div><div data-l="    let matches = match opts.parse(&amp;args[1..]) {"></div><div data-l="        Ok(m)  =&gt; { m }"></div><div data-l="        Err(e) =&gt; { panic!(e.to_string()) }"></div><div data-l="    };"></div><div data-l=""></div><div data-l="    if matches.opt_present(&quot;h&quot;) {"></div><div data-l="        print_usage(&amp;program, opts);"></div><div data-l="        return;"></div><div data-l="    }"></div><div data-l=""></div><div data-l="    let data_path = &amp;matches.free[0];"></div><div data-l="    let city: &amp;str = &amp;matches.free[1];"></div><div data-l=""></div><div data-l="    for pop in search(data_path, city) {"></div><div data-l="        println!(&quot;{}, {}: {:?}&quot;, pop.city, pop.country, pop.count);"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">While we got rid of one use of <code>expect</code> (which is a nicer variant of <code>unwrap</code> ), we still should handle the absence of any search results.</span> <code>expect</code>使い方（ <code>unwrap</code>ほうが良い）を取り除いていますが、検索結果が存在しない場合は処理する必要があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To convert this to proper error handling, we need to do the following:</span>これを適切なエラー処理に変換するには、以下を実行する必要があります。</span> </p><br><div data-b=1.> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Change the return type of <code>search</code> to be <code>Result&lt;Vec&lt;PopulationCount&gt;, Box&lt;Error&gt;&gt;</code> .</span> <code>search</code>の戻り値の型を<code>Result&lt;Vec&lt;PopulationCount&gt;, Box&lt;Error&gt;&gt;</code>ます。</span> </div><div data-b=2.> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Use the <a href=#2#code-try-def><code>try€</code> macro</a> so that errors are returned to the caller instead of panicking the program.</span>プログラムをパニックするのではなく、エラーが呼び出し元に返されるように<a href=#2#code-try-def><code>try€</code>マクロを</a>使用して<a href=#2#code-try-def><code>try€</code></a> 。</span> </div><div data-b=3.> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Handle the error in <code>main</code> .</span> <code>main</code>のエラーを処理します。</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s try it:</span>試してみよう：</span> </p><br><div data-lang=rust,ignore><div data-l="use std::error::Error;"></div><div data-l=""></div><div data-l="#// The rest of the code before this is unchanged."></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The rest of the code before this is unchanged.</span>それ以前のコードの残りの部分は変更されていません。</span> </div><div data-l=""></div><div data-l="fn search&lt;P: AsRef&lt;Path&gt;&gt;"></div><div data-l="         (file_path: P, city: &amp;str)"></div><div data-l="         -&gt; Result&lt;Vec&lt;PopulationCount&gt;, Box&lt;Error&gt;&gt; {"></div><div data-l="    let mut found = vec![];"></div><div data-l="    let file = try!(File::open(file_path));"></div><div data-l="    let mut rdr = csv::Reader::from_reader(file);"></div><div data-l="    for row in rdr.decode::&lt;Row&gt;() {"></div><div data-l="        let row = try!(row);"></div><div data-l="        match row.population {"></div><div data-l="#//            None =&gt; { } // Skip it."></div><div data-l="            None =&gt; { } // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Skip it.</span>それをスキップします。</span> </div><div data-l="            Some(count) =&gt; if row.city == city {"></div><div data-l="                found.push(PopulationCount {"></div><div data-l="                    city: row.city,"></div><div data-l="                    country: row.country,"></div><div data-l="                    count: count,"></div><div data-l="                });"></div><div data-l="            },"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l="    if found.is_empty() {"></div><div data-l="        Err(From::from(&quot;No matching cities with a population were found.&quot;))"></div><div data-l="    } else {"></div><div data-l="        Ok(found)"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Instead of <code>x.unwrap()</code> , we now have <code>try€(x)</code> .</span> <code>x.unwrap()</code>代わりに<code>try€(x)</code>て<code>try€(x)</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Since our function returns a <code>Result&lt;T, E&gt;</code> , the <code>try€</code> macro will return early from the function if an error occurs.</span>関数が<code>Result&lt;T, E&gt;</code>返すので、エラーが発生した場合、 <code>try€</code>マクロは関数の早い段階で返されます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">At the end of <code>search</code> we also convert a plain string to an error type by using the <a href=#2../../std/convert/trait.From.html>corresponding <code>From</code> impls</a> :</span> <code>search</code>の終わりに、 <a href=#2../../std/convert/trait.From.html>対応する<code>From</code> impls</a>を使用してプレーン文字列をエラータイプに変換します。</span> </p><br><div data-lang=rust,ignore><div data-l="#// We are making use of this impl in the code above, since we call `From::from`"></div><div data-l="#// on a `&amp;'static str`."></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We are making use of this impl in the code above, since we call <code>From::from</code> on a <code>&amp;&#39;static str</code> .</span>我々は呼んで以来、私たちは、上記のコードでは、このIMPLを利用している<code>From::from</code>の<code>&amp;&#39;static str</code> 。</span> </div><div data-l="impl&lt;'a&gt; From&lt;&amp;'a str&gt; for Box&lt;Error&gt;"></div><div data-l=""></div><div data-l="#// But this is also useful when you need to allocate a new string for an"></div><div data-l="#// error message, usually with `format!`."></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But this is also useful when you need to allocate a new string for an error message, usually with <code>format€</code> .</span>しかしこれは、エラーメッセージに新しい文字列を割り当てる必要がある場合にも便利です（通常は<code>format€</code> 。</span> </div><div data-l="impl From&lt;String&gt; for Box&lt;Error&gt;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Since <code>search</code> now returns a <code>Result&lt;T, E&gt;</code> , <code>main</code> should use case analysis when calling <code>search</code> :</span>以来<code>search</code>今や返す<code>Result&lt;T, E&gt;</code> 、 <code>main</code>呼び出し時にケースの分析を使用する必要があります<code>search</code> ：</span> </p><br><div data-lang=rust,ignore><div data-l=...></div><div data-l="    match search(data_path, city) {"></div><div data-l="        Ok(pops) =&gt; {"></div><div data-l="            for pop in pops {"></div><div data-l="                println!(&quot;{}, {}: {:?}&quot;, pop.city, pop.country, pop.count);"></div><div data-l="            }"></div><div data-l="        }"></div><div data-l="        Err(err) =&gt; println!(&quot;{}&quot;, err)"></div><div data-l="    }"></div><div data-l=...></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now that we&#39;ve seen how to do proper error handling with <code>Box&lt;Error&gt;</code> , let&#39;s try a different approach with our own custom error type.</span> <code>Box&lt;Error&gt;</code>で適切なエラー処理を行う方法を見てきたので、独自のカスタムエラータイプで別のアプローチを試してみましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But first, let&#39;s take a quick break from error handling and add support for reading from <code>stdin</code> .</span>しかし、まず、エラー処理から簡単に休みを取り、 <code>stdin</code>からの読み込みのサポートを追加しましょう。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Reading from stdin</span>スタンダードから読む</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In our program, we accept a single file for input and do one pass over the data.</span>私たちのプログラムでは、入力用に1つのファイルを受け入れ、データを1つのファイルに渡します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This means we probably should be able to accept input on stdin.</span>つまり、stdinの入力を受け入れることができるはずです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But maybe we like the current format too—so let&#39;s have both!</span>しかし、現在のフォーマットも好きかもしれません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Adding support for stdin is actually quite easy.</span> stdinのサポートを追加することは、実際には非常に簡単です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There are only three things we have to do:</span>私たちがしなければならないことは3つしかありません：</span> </p><br><div data-b=1.> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Tweak the program arguments so that a single parameter—the city—can be accepted while the population data is read from stdin.</span>母集団のデータをstdinから読み込んでいる間に、単一のパラメータ（都市）を受け入れることができるように、プログラムの引数を調整します。</span> </div><div data-b=2.> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Modify the program so that an option <code>-f</code> can take the file, if it is not passed into stdin.</span> stdinに渡されない場合、オプション<code>-f</code>がファイルを取り出せるようにプログラムを変更します。</span> </div><div data-b=3.> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Modify the <code>search</code> function to take an <i>optional</i> file path.</span> <i>オプションの</i>ファイルパスを<i>使用</i>するように<code>search</code>機能を変更します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When <code>None</code> , it should know to read from stdin.</span> <code>None</code>ときは、stdinから読むことを知るべきです。</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">First, here&#39;s the new usage:</span>まず、新しい使用法を次に示します。</span> </p><br><div data-lang=rust,ignore><div data-l="fn print_usage(program: &amp;str, opts: Options) {"></div><div data-l="    println!(&quot;{}&quot;, opts.usage(&amp;format!(&quot;Usage: {} [options] &lt;city&gt;&quot;, program)));"></div><div data-l=}></div></div><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Of course we need to adapt the argument handling code:</span>もちろん引数の処理コードを変更する必要があります。</span> </p><br><div data-lang=rust,ignore><div data-l=...></div><div data-l="    let mut opts = Options::new();"></div><div data-l="    opts.optopt(&quot;f&quot;, &quot;file&quot;, &quot;Choose an input file, instead of using STDIN.&quot;, &quot;NAME&quot;);"></div><div data-l="    opts.optflag(&quot;h&quot;, &quot;help&quot;, &quot;Show this usage message.&quot;);"></div><div data-l="    ..."></div><div data-l="    let data_path = matches.opt_str(&quot;f&quot;);"></div><div data-l=""></div><div data-l="    let city = if !matches.free.is_empty() {"></div><div data-l="        &amp;matches.free[0]"></div><div data-l="    } else {"></div><div data-l="        print_usage(&amp;program, opts);"></div><div data-l="        return;"></div><div data-l="    };"></div><div data-l=""></div><div data-l="    match search(&amp;data_path, city) {"></div><div data-l="        Ok(pops) =&gt; {"></div><div data-l="            for pop in pops {"></div><div data-l="                println!(&quot;{}, {}: {:?}&quot;, pop.city, pop.country, pop.count);"></div><div data-l="            }"></div><div data-l="        }"></div><div data-l="        Err(err) =&gt; println!(&quot;{}&quot;, err)"></div><div data-l="    }"></div><div data-l=...></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ve made the user experience a bit nicer by showing the usage message, instead of a panic from an out-of-bounds index, when <code>city</code> , the remaining free argument, is not present.</span>残りのフリーの引数<code>city</code>が存在しないときに、範囲外インデックスからのパニックではなく、使用法のメッセージを表示することで、ユーザーエクスペリエンスを少し改善しました。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Modifying <code>search</code> is slightly trickier.</span> <code>search</code>変更はややこしい。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>csv</code> crate can build a parser out of <a href=#2http://burntsushi.net/rustdoc/csv/struct.Reader.html#method.from_reader>any type that implements <code>io::Read</code></a> .</span> <code>csv</code>クレートは、 <a href=#2http://burntsushi.net/rustdoc/csv/struct.Reader.html#method.from_reader><code>io::Read</code>を実装する任意のタイプの</a>パーサーを構築できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But how can we use the same code over both types?</span>しかし、どのようにして両方の型で同じコードを使うことができますか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There&#39;s actually a couple ways we could go about this.</span>実際にはこれについていくつかの方法があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">One way is to write <code>search</code> such that it is generic on some type parameter <code>R</code> that satisfies <code>io::Read</code> .</span> 1つの方法は、 <code>io::Read</code>を満たすいくつかの型パラメータ<code>R</code>汎用であるように<code>search</code>を書くことです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Another way is to use trait objects:</span>別の方法は、特性オブジェクトを使用することです。</span> </p><br><div data-lang=rust,ignore><div data-l="use std::io;"></div><div data-l=""></div><div data-l="#// The rest of the code before this is unchanged."></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The rest of the code before this is unchanged.</span>それ以前のコードの残りの部分は変更されていません。</span> </div><div data-l=""></div><div data-l="fn search&lt;P: AsRef&lt;Path&gt;&gt;"></div><div data-l="         (file_path: &amp;Option&lt;P&gt;, city: &amp;str)"></div><div data-l="         -&gt; Result&lt;Vec&lt;PopulationCount&gt;, Box&lt;Error&gt;&gt; {"></div><div data-l="    let mut found = vec![];"></div><div data-l="    let input: Box&lt;io::Read&gt; = match *file_path {"></div><div data-l="        None =&gt; Box::new(io::stdin()),"></div><div data-l="        Some(ref file_path) =&gt; Box::new(try!(File::open(file_path))),"></div><div data-l="    };"></div><div data-l="    let mut rdr = csv::Reader::from_reader(input);"></div><div data-l="#    // The rest remains unchanged!"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The rest remains unchanged!</span>残りは変わりません！</span> </div><div data-l=}></div></div><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Error handling with a custom type</span>カスタムタイプによるエラー処理</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Previously, we learned how to <a href=#2#composing-custom-error-types>compose errors using a custom error type</a> .</span>以前は<a href=#2#composing-custom-error-types>、カスタムエラータイプを使用してエラーを構成する</a>方法を学習しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We did this by defining our error type as an <code>enum</code> and implementing <code>Error</code> and <code>From</code> .</span>これを行うには、エラータイプを<code>enum</code>型として定義し、 <code>Error</code>と<code>From</code>を実装します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Since we have three distinct errors (IO, CSV parsing and not found), let&#39;s define an <code>enum</code> with three variants:</span> 3つの異なるエラー（IO、CSV解析、見つからない）があるので、3つのバリアントを持つ<code>enum</code>を定義しましょう：</span> </p><br><div data-lang=rust,ignore><div data-l=#[derive(Debug)]></div><div data-l="enum CliError {"></div><div data-l="    Io(io::Error),"></div><div data-l="    Csv(csv::Error),"></div><div data-l="    NotFound,"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">And now for impls on <code>Display</code> and <code>Error</code> :</span>そして今、 <code>Display</code>と<code>Error</code>含意します：</span> </p><br><div data-lang=rust,ignore><div data-l="use std::fmt;"></div><div data-l=""></div><div data-l="impl fmt::Display for CliError {"></div><div data-l="    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {"></div><div data-l="        match *self {"></div><div data-l="            CliError::Io(ref err) =&gt; err.fmt(f),"></div><div data-l="            CliError::Csv(ref err) =&gt; err.fmt(f),"></div><div data-l="            CliError::NotFound =&gt; write!(f, &quot;No matching cities with a \"></div><div data-l="                                             population were found.&quot;),"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="impl Error for CliError {"></div><div data-l="    fn cause(&amp;self) -&gt; Option&lt;&amp;Error&gt; {"></div><div data-l="        match *self {"></div><div data-l="            CliError::Io(ref err) =&gt; Some(err),"></div><div data-l="            CliError::Csv(ref err) =&gt; Some(err),"></div><div data-l="#            // Our custom error doesn't have an underlying cause,"></div><div data-l="#            // but we could modify it so that it does."></div><div data-l="            // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Our custom error doesn&#39;t have an underlying cause, but we could modify it so that it does.</span>私たちのカスタムエラーには根本的な原因はありませんが、変更することができます。</span> </div><div data-l="            CliError::NotFound =&gt; None,"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Before we can use our <code>CliError</code> type in our <code>search</code> function, we need to provide a couple <code>From</code> impls.</span> <code>CliError</code>型を<code>search</code>関数で使用するには、 <code>CliError</code> 、 <code>From</code> implsというカップルを提供する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">How do we know which impls to provide?</span>どのようなインプラントが提供されるのかはどのようにわかりますか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Well, we&#39;ll need to convert from both <code>io::Error</code> and <code>csv::Error</code> to <code>CliError</code> .</span>さて、 <code>io::Error</code>と<code>csv::Error</code>両方を<code>CliError</code>に変換する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Those are the only external errors, so we&#39;ll only need two <code>From</code> impls for now:</span>これらは唯一の外部エラーであるため、ここ<code>From</code> 2つのインプレッションを必要とします：</span> </p><br><div data-lang=rust,ignore><div data-l="impl From&lt;io::Error&gt; for CliError {"></div><div data-l="    fn from(err: io::Error) -&gt; CliError {"></div><div data-l="        CliError::Io(err)"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="impl From&lt;csv::Error&gt; for CliError {"></div><div data-l="    fn from(err: csv::Error) -&gt; CliError {"></div><div data-l="        CliError::Csv(err)"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>From</code> impls are important because of how <a href=#2#code-try-def><code>try€</code> is defined</a> .</span> <code>From</code> implsは、 <a href=#2#code-try-def><code>try€</code></a>がどのように<a href=#2#code-try-def>定義されて</a>いるかによって重要です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In particular, if an error occurs, <code>From::from</code> is called on the error, which in this case, will convert it to our own error type <code>CliError</code> .</span>特に、エラーが発生した場合は、 <code>From::from</code>がエラーで呼び出されます。この場合、エラータイプ<code>CliError</code>変換されます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">With the <code>From</code> impls done, we only need to make two small tweaks to our <code>search</code> function: the return type and the “not found” error.</span> <code>From</code> impls doneを使用すると、 <code>search</code>関数の戻り値の型と &quot;見つからない&quot;という2つの小さな調整が必要になります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here it is in full:</span>ここにそれはいっぱいです：</span> </p><br><div data-lang=rust,ignore><div data-l="fn search&lt;P: AsRef&lt;Path&gt;&gt;"></div><div data-l="         (file_path: &amp;Option&lt;P&gt;, city: &amp;str)"></div><div data-l="         -&gt; Result&lt;Vec&lt;PopulationCount&gt;, CliError&gt; {"></div><div data-l="    let mut found = vec![];"></div><div data-l="    let input: Box&lt;io::Read&gt; = match *file_path {"></div><div data-l="        None =&gt; Box::new(io::stdin()),"></div><div data-l="        Some(ref file_path) =&gt; Box::new(try!(File::open(file_path))),"></div><div data-l="    };"></div><div data-l="    let mut rdr = csv::Reader::from_reader(input);"></div><div data-l="    for row in rdr.decode::&lt;Row&gt;() {"></div><div data-l="        let row = try!(row);"></div><div data-l="        match row.population {"></div><div data-l="#//            None =&gt; { } // Skip it."></div><div data-l="            None =&gt; { } // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Skip it.</span>それをスキップします。</span> </div><div data-l="            Some(count) =&gt; if row.city == city {"></div><div data-l="                found.push(PopulationCount {"></div><div data-l="                    city: row.city,"></div><div data-l="                    country: row.country,"></div><div data-l="                    count: count,"></div><div data-l="                });"></div><div data-l="            },"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l="    if found.is_empty() {"></div><div data-l="        Err(CliError::NotFound)"></div><div data-l="    } else {"></div><div data-l="        Ok(found)"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">No other changes are necessary.</span>その他の変更は必要ありません。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Adding functionality</span>機能の追加</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Writing generic code is great, because generalizing stuff is cool, and it can then be useful later.</span>一般的なコードを書くことは素晴らしいことです。一般化することはすばらしく、後で役に立ちます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But sometimes, the juice isn&#39;t worth the squeeze.</span>しかし時には、ジュースは圧搾に値するものではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Look at what we just did in the previous step:</span>前のステップで行ったことを見てください。</span> </p><br><div data-b=1.> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Defined a new error type.</span>新しいエラータイプを定義しました。</span> </div><div data-b=2.> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Added impls for <code>Error</code> , <code>Display</code> and two for <code>From</code> .</span>追加しましたimpls <code>Error</code> 、 <code>Display</code>とするための2つ<code>From</code> 。</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The big downside here is that our program didn&#39;t improve a whole lot.</span>ここでの大きな欠点は、私たちのプログラムが全体的に改善されなかったことです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There is quite a bit of overhead to representing errors with <code>enum</code> s, especially in short programs like this.</span> <code>enum</code>のエラーを表現するには、特にこのような短いプログラムではかなりのオーバーヘッドがあります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><i>One</i> useful aspect of using a custom error type like we&#39;ve done here is that the <code>main</code> function can now choose to handle errors differently.</span>ここで行ったようなカスタムエラータイプを使用する<i>1つの</i>有用な側面は、 <code>main</code>関数がエラーを別々に処理することを選択できるようにすることです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Previously, with <code>Box&lt;Error&gt;</code> , it didn&#39;t have much of a choice: just print the message.</span>以前は、 <code>Box&lt;Error&gt;</code>を使用していましたが、選択肢はあまりありませんでした。メッセージを印刷するだけです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;re still doing that here, but what if we wanted to, say, add a <code>--quiet</code> flag?</span>私たちはまだここでそれをやっていますが、もし<code>--quiet</code>フラグを追加したいとしたら？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>--quiet</code> flag should silence any verbose output.</span> <code>--quiet</code>フラグは冗長な出力を抑止します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Right now, if the program doesn&#39;t find a match, it will output a message saying so.</span>今のところ、プログラムが一致するものを見つけられなかった場合、それを示すメッセージが出力されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This can be a little clumsy, especially if you intend for the program to be used in shell scripts.</span>これは、特にあなたがシェルスクリプトでプログラムを使うつもりならば、ややこしいかもしれません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So let&#39;s start by adding the flags.</span>ですから、フラグを追加することから始めましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Like before, we need to tweak the usage string and add a flag to the Option variable.</span>前と同じように、使用文字列を調整し、Option変数にフラグを追加する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Once we&#39;ve done that, Getopts does the rest:</span>私たちがこれをしたら、Getoptsは残りを行います：</span> </p><br><div data-lang=rust,ignore><div data-l=...></div><div data-l="    let mut opts = Options::new();"></div><div data-l="    opts.optopt(&quot;f&quot;, &quot;file&quot;, &quot;Choose an input file, instead of using STDIN.&quot;, &quot;NAME&quot;);"></div><div data-l="    opts.optflag(&quot;h&quot;, &quot;help&quot;, &quot;Show this usage message.&quot;);"></div><div data-l="    opts.optflag(&quot;q&quot;, &quot;quiet&quot;, &quot;Silences errors and warnings.&quot;);"></div><div data-l=...></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now we only need to implement our “quiet” functionality.</span>これで &quot;静かな&quot;機能を実装するだけです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This requires us to tweak the case analysis in <code>main</code> :</span>これは、 <code>main</code>ケース分析を微調整する必要があります。</span> </p><br><div data-lang=rust,ignore><div data-l="use std::process;"></div><div data-l=...></div><div data-l="    match search(&amp;data_path, city) {"></div><div data-l="        Err(CliError::NotFound) if matches.opt_present(&quot;q&quot;) =&gt; process::exit(1),"></div><div data-l="        Err(err) =&gt; panic!(&quot;{}&quot;, err),"></div><div data-l="        Ok(pops) =&gt; for pop in pops {"></div><div data-l="            println!(&quot;{}, {}: {:?}&quot;, pop.city, pop.country, pop.count);"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=...></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Certainly, we don&#39;t want to be quiet if there was an IO error or if the data failed to parse.</span>確かに、私たちはIOエラーがあった場合、またはデータが解析できなかった場合には静かではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Therefore, we use case analysis to check if the error type is <code>NotFound</code> <i>and</i> if <code>--quiet</code> has been enabled.</span>したがって、我々は、エラーの種類があるかどうかを確認するためにケースの分析を使用し<code>NotFound</code>場合<i>と</i> <code>--quiet</code>有効になっています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If the search failed, we still quit with an exit code (following <code>grep</code> &#39;s convention).</span>検索が失敗した場合でも、終了コード（ <code>grep</code>の規則に従って）で終了します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we had stuck with <code>Box&lt;Error&gt;</code> , then it would be pretty tricky to implement the <code>--quiet</code> functionality.</span> <code>Box&lt;Error&gt;</code>で動かなかった場合、-- <code>--quiet</code>機能を実装するのはかなり難しいでしょう。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This pretty much sums up our case study.</span>これは私たちのケーススタディをかなり要約しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">From here, you should be ready to go out into the world and write your own programs and libraries with proper error handling.</span>ここから、あなたは世界に出かけて、適切なエラー処理をして独自のプログラムとライブラリを書く準備ができているはずです。</span> </p><br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The Short Story</span>ショート・ストーリー</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Since this section is long, it is useful to have a quick summary for error handling in Rust.</span>このセクションは長いので、Rustのエラー処理についての簡単な要約があると便利です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These are some good “rules of thumb.&quot; They are emphatically <i>not</i> commandments. There are probably good reasons to break every one of these heuristics!</span>これらは、いくつかの良い「経験則」です。これらは、重大な戒めではあり<i>ません</i> 。これらの経験則のすべてを破る良い理由があります。</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you&#39;re writing short example code that would be overburdened by error handling, it&#39;s probably fine to use <code>unwrap</code> (whether that&#39;s <a class=notranslate href=#2../../std/result/enum.Result.html#method.unwrap><code>Result::unwrap</code></a> , <a class=notranslate href=#2../../std/option/enum.Option.html#method.unwrap><code>Option::unwrap</code></a> or preferably <a class=notranslate href=#2../../std/option/enum.Option.html#method.expect><code>Option::expect</code></a> ).</span>エラー処理によって過負荷になるような短いサンプルコードを書いているのなら、おそらく<code>unwrap</code> （ <a class=notranslate href=#2../../std/result/enum.Result.html#method.unwrap><code>Result::unwrap</code></a> 、 <a class=notranslate href=#2../../std/option/enum.Option.html#method.unwrap><code>Option::unwrap</code></a>または<a class=notranslate href=#2../../std/option/enum.Option.html#method.expect><code>Option::expect</code></a> ）を使用しても問題ありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Consumers of your code should know to use proper error handling.</span>コードの消費者は、適切なエラー処理を使用することを知っている必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">(If they don&#39;t, send them here!)</span> （そうでない場合は、ここに送ってください！）</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you&#39;re writing a quick &#39;n&#39; dirty program, don&#39;t feel ashamed if you use <code>unwrap</code> .</span>クイックアンドダーティプログラムを書いているのなら、 <code>unwrap</code>を使うと恥ずかしがり屋ではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Be warned: if it winds up in someone else&#39;s hands, don&#39;t be surprised if they are agitated by poor error messages!</span>警告：誰かの手の中に巻き込まれている場合は、エラーメッセージが貧弱になっても驚かないでください！</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you&#39;re writing a quick &#39;n&#39; dirty program and feel ashamed about panicking anyway, then use either a <code>String</code> or a <code>Box&lt;Error&gt;</code> for your error type.</span>クイックアンドダーティープログラムを作成していて、とにかくパニックになるのを恥ずかしく思っているなら、あなたのエラータイプには<code>String</code>か<code>Box&lt;Error&gt;</code>を使います。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Otherwise, in a program, define your own error types with appropriate <a class=notranslate href=#2../../std/convert/trait.From.html><code>From</code></a> and <a class=notranslate href=#2../../std/error/trait.Error.html><code>Error</code></a> impls to make the <a class=notranslate href=#2../../std/macro.try.html><code>try€</code></a> macro more ergonomic.</span>それ以外の場合は、プログラム内で、適切な<a class=notranslate href=#2../../std/convert/trait.From.html><code>From</code></a>と<a class=notranslate href=#2../../std/error/trait.Error.html><code>Error</code></a> implsを使用して独自のエラータイプを定義し、 <a class=notranslate href=#2../../std/macro.try.html><code>try€</code></a> macroをより人間工学的にする。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you&#39;re writing a library and your code can produce errors, define your own error type and implement the <a class=notranslate href=#2../../std/error/trait.Error.html><code>std::error::Error</code></a> trait.</span>ライブラリを作成しているときにコードでエラーが発生する場合は、独自のエラータイプを定義し、 <a class=notranslate href=#2../../std/error/trait.Error.html><code>std::error::Error</code></a>特性を実装して<a class=notranslate href=#2../../std/error/trait.Error.html><code>std::error::Error</code></a> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Where appropriate, implement <a class=notranslate href=#2../../std/convert/trait.From.html><code>From</code></a> to make both your library code and the caller&#39;s code easier to write.</span>必要に応じて、 <a class=notranslate href=#2../../std/convert/trait.From.html><code>From</code></a>を実装して、ライブラリのコードと呼び出し元のコードの両方を簡単に書くことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">(Because of Rust&#39;s coherence rules, callers will not be able to impl <code>From</code> on your error type, so your library should do it.)</span> （Rustの一貫性の規則のため、呼び出し元はあなたのエラータイプ<code>From</code>インプリメントを行うことができないので、ライブラリはそれを行う必要があります。）</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Learn the combinators defined on <a class=notranslate href=#2../../std/option/enum.Option.html><code>Option</code></a> and <a class=notranslate href=#2../../std/result/enum.Result.html><code>Result</code></a> .</span> <a class=notranslate href=#2../../std/option/enum.Option.html><code>Option</code></a>と<a class=notranslate href=#2../../std/result/enum.Result.html><code>Result</code></a>定義されたコンビネータを学んでください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Using them exclusively can be a bit tiring at times, but I&#39;ve personally found a healthy mix of <code>try€</code> and combinators to be quite appealing.</span>それらを独占的に使用することは時々少し疲れることがありますが、私は個人的には魅力的な<code>try€</code>とcombinatorsの健康な組み合わせを見つけました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>and_then</code> , <code>map</code> and <code>unwrap_or</code> are my favorites.</span> <code>and_then</code> 、 <code>map</code>と<code>unwrap_or</code>は私のお気に入りです。</span> </div><br> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a class=notranslate href=#1patterns.html>1</a> <a class=notranslate href=#1../../std/option/enum.Option.html#method.map>2</a> <a class=notranslate href=#1../../std/option/enum.Option.html#method.unwrap_or>3</a> <a class=notranslate href=#1../../std/option/enum.Option.html#method.unwrap_or_else>4</a> <a class=notranslate href=#1../../std/option/enum.Option.html>5</a> <a class=notranslate href=#1../../std/result/index.html>6</a> <a class=notranslate href=#1../../std/result/enum.Result.html#method.unwrap>7</a> <a class=notranslate href=#1../../std/fmt/trait.Debug.html>8</a> <a class=notranslate href=#1../../std/primitive.str.html#method.parse>9</a> <a class=notranslate href=#1associated-types.html>10</a> <a class=notranslate href=#1https://github.com/petewarden/dstkdata>11</a> <a class=notranslate href=#1http://burntsushi.net/stuff/worldcitiespop.csv.gz>12</a> <a class=notranslate href=#1http://burntsushi.net/stuff/uscitiespop.csv.gz>13</a> <a class=notranslate href=#1http://doc.crates.io/guide.html>14</a> <a class=notranslate href=#1http://doc.rust-lang.org/getopts/getopts/index.html>15</a></span> <a class=notranslate href=#1patterns.html>1</a> <a class=notranslate href=#1../../std/option/enum.Option.html#method.map>2</a> <a class=notranslate href=#1../../std/option/enum.Option.html#method.unwrap_or>3</a> <a class=notranslate href=#1../../std/option/enum.Option.html#method.unwrap_or_else>4</a> <a class=notranslate href=#1../../std/option/enum.Option.html>5</a> <a class=notranslate href=#1../../std/result/index.html>6</a> <a class=notranslate href=#1../../std/result/enum.Result.html#method.unwrap>7</a> <a class=notranslate href=#1../../std/fmt/trait.Debug.html>8</a> <a class=notranslate href=#1../../std/primitive.str.html#method.parse>9</a> <a class=notranslate href=#1associated-types.html>10</a> <a class=notranslate href=#1https://github.com/petewarden/dstkdata>11</a> <a class=notranslate href=#1http://burntsushi.net/stuff/worldcitiespop.csv.gz>12</a> <a class=notranslate href=#1http://burntsushi.net/stuff/uscitiespop.csv.gz>13</a> <a class=notranslate href=#1http://doc.crates.io/guide.html>14</a> <a class=notranslate href=#1http://doc.rust-lang.org/getopts/getopts/index.html>15</a></span>
<script>_addload(function(){_setupIW('com');_csi('en','ja','error-handling-2.html');});</script>