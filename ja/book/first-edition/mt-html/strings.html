<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180709_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=strings.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Strings</span>文字列</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Strings are an important concept for any programmer to master.</span>文字列は、プログラマーがマスターするための重要な概念です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust&#39;s string handling system is a bit different from other languages, due to its systems focus.</span> Rustの文字列処理システムは、そのシステムの焦点のために、他の言語とは少し異なります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Any time you have a data structure of variable size, things can get tricky, and strings are a re-sizable data structure.</span>可変サイズのデータ​​構造を持つたびに、処理が複雑になり、文字列がサイズ変更可能なデータ構造になります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That being said, Rust&#39;s strings also work differently than in some other systems languages, such as C.</span>つまり、Rustの文字列は、Cなどの他のシステム言語とは異なる働きをします。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s dig into the details.</span>詳細を掘り下げてみましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A &#39;string&#39; is a sequence of Unicode scalar values encoded as a stream of UTF-8 bytes.</span> &#39;文字列&#39;は、UTF-8バイトのストリームとしてエンコードされたUnicodeスカラ値のシーケンスです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">All strings are guaranteed to be a valid encoding of UTF-8 sequences.</span>すべての文字列は、UTF-8シーケンスの有効なエンコーディングであることが保証されています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Additionally, unlike some systems languages, strings are not NUL-terminated and can contain NUL bytes.</span>さらに、いくつかのシステム言語とは異なり、文字列はNUL終端ではなく、NULバイトを含むことができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust has two main types of strings: <code>&amp;str</code> and <code>String</code> .</span> Rustには、 <code>&amp;str</code>と<code>String</code> 2つの主要な<code>&amp;str</code>あり<code>&amp;str</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s talk about <code>&amp;str</code> first.</span>まず<code>&amp;str</code>について話しましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These are called &#39;string slices&#39;.</span>これらは「文字列スライス」と呼ばれます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A string slice has a fixed size, and cannot be mutated.</span>文字列スライスは固定サイズであり、変更することはできません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It is a reference to a sequence of UTF-8 bytes.</span>これは、UTF-8バイトのシーケンスへの参照です。</span> </p><br><div data-lang=rust><div data-l="#//let greeting = &quot;Hello there.&quot;; // greeting: &amp;'static str"></div><div data-l="let greeting = &quot;Hello there.&quot;; // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">greeting: &amp;&#39;static str</span>グリーティング：＆ &#39;static str</span> </div></div><br><p> <code>&quot;Hello there.&quot;</code> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">is a string literal and its type is <code>&amp;&#39;static str</code> .</span>は文字列リテラルで、その型は<code>&amp;&#39;static str</code>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A string literal is a string slice that is statically allocated, meaning that it&#39;s saved inside our compiled program, and exists for the entire duration it runs.</span>文字列リテラルは、静的に割り当てられた文字列スライスです。つまり、コンパイルされたプログラム内に保存され、実行中の全期間にわたって存在します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>greeting</code> binding is a reference to this statically allocated string.</span> <code>greeting</code>バインディングは、この静的に割り当てられた文字列への参照です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Any function expecting a string slice will also accept a string literal.</span>文字列スライスを期待する関数も、文字列リテラルを受け入れます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">String literals can span multiple lines.</span>文字列リテラルは複数の行にまたがることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There are two forms.</span> 2つの形式があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The first will include the newline and the leading spaces:</span>最初の行には改行と先頭のスペースが含まれます：</span> </p><br><div data-lang=rust><div data-l="let s = &quot;foo"></div><div data-l="    bar&quot;;"></div><div data-l=""></div><div data-l="assert_eq!(&quot;foo\n    bar&quot;, s);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The second, with a <code>\</code> , trims the spaces and the newline:</span> <code>\</code>は空白と改行をトリミングします：</span> </p><br><div data-lang=rust><div data-l="let s = &quot;foo\"></div><div data-l="    bar&quot;;"></div><div data-l=""></div><div data-l="assert_eq!(&quot;foobar&quot;, s);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that you normally cannot access a <code>str</code> directly, but only through a <code>&amp;str</code> reference.</span>通常、 <code>str</code>直接アクセスすることはできませんが、 <code>&amp;str</code>参照を介してのみアクセスでき<code>&amp;str</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is because <code>str</code> is an unsized type which requires additional runtime information to be usable.</span>これは、 <code>str</code>がサイズ変更されていない型であり、追加の実行時情報を使用する必要があるためです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For more information see the chapter on <a href=#3ut>unsized types</a> .</span>詳細は、 <a href=#3ut>サイズ未定義</a>の章を参照してください。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust has more than only <code>&amp;str</code> s though.</span> Rustは<code>&amp;str</code>だけではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A <code>String</code> is a heap-allocated string.</span> <code>String</code>は、ヒープに割り当てられた文字列です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This string is growable, and is also guaranteed to be UTF-8.</span>この文字列は拡張可能で、UTF-8であることも保証されています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>String</code> s are commonly created by converting from a string slice using the <code>to_string</code> method.</span> <code>String</code>は、通常、 <code>to_string</code>メソッドを使用して<code>to_string</code>から変換することによって作成されます。</span> </p><br><div data-lang=rust><div data-l="#//let mut s = &quot;Hello&quot;.to_string(); // mut s: String"></div><div data-l="let mut s = &quot;Hello&quot;.to_string(); // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">mut s: String</span> mut s：文字列</span> </div><div data-l="println!(&quot;{}&quot;, s);"></div><div data-l=""></div><div data-l="s.push_str(&quot;, world.&quot;);"></div><div data-l="println!(&quot;{}&quot;, s);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>String</code> s will coerce into <code>&amp;str</code> with an <code>&amp;</code> :</span> <code>String</code> sがに強制します<code>&amp;str</code>と<code>&amp;</code> ：</span> </p><br><div data-lang=rust><div data-l="fn takes_slice(slice: &amp;str) {"></div><div data-l="    println!(&quot;Got: {}&quot;, slice);"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let s = &quot;Hello&quot;.to_string();"></div><div data-l="    takes_slice(&amp;s);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This coercion does not happen for functions that accept one of <code>&amp;str</code> &#39;s traits instead of <code>&amp;str</code> .</span>この強制は、 <code>&amp;str</code>の代わりに<code>&amp;str</code>の特性の1つを受け入れる関数では起こりません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, <a class=notranslate href=#3connect><code>TcpStream::connect</code></a> has a parameter of type <code>ToSocketAddrs</code> .</span>たとえば、 <a class=notranslate href=#3connect><code>TcpStream::connect</code></a>は<code>ToSocketAddrs</code>型のパラメータがあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A <code>&amp;str</code> is okay but a <code>String</code> must be explicitly converted using <code>&amp;*</code> .</span> <code>&amp;str</code>は大丈夫ですが、 <code>String</code>を<code>&amp;*</code>を使って明示的に変換する必要があります。</span> </p><br><div data-lang=rust,no_run><div data-l="use std::net::TcpStream;"></div><div data-l=""></div><div data-l="#//TcpStream::connect(&quot;192.168.0.1:3000&quot;); // Parameter is of type &amp;str."></div><div data-l="TcpStream::connect(&quot;192.168.0.1:3000&quot;); // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Parameter is of type &amp;str.</span>パラメータの型は＆strです。</span> </div><div data-l=""></div><div data-l="let addr_string = &quot;192.168.0.1:3000&quot;.to_string();"></div><div data-l="#//TcpStream::connect(&amp;*addr_string); // Convert `addr_string` to &amp;str."></div><div data-l="TcpStream::connect(&amp;*addr_string); // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Convert <code>addr_string</code> to &amp;str.</span> <code>addr_string</code>を＆strに変換します。</span> </div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Viewing a <code>String</code> as a <code>&amp;str</code> is cheap, but converting the <code>&amp;str</code> to a <code>String</code> involves allocating memory.</span>表示<code>String</code>として<code>&amp;str</code>安価であるが、変換<code>&amp;str</code>に<code>String</code>メモリを割り当てることを含みます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">No reason to do that unless you have to!</span>あなたがする必要がない限りそれを行う理由はありません！</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Indexing</span>インデックス作成</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because strings are valid UTF-8, they do not support indexing:</span>文字列は有効なUTF-8なので、索引付けはサポートされていません。</span> </p><br><div data-lang=rust,ignore><div data-l="let s = &quot;hello&quot;;"></div><div data-l=""></div><div data-l="#//println!(&quot;The first letter of s is {}&quot;, s[0]); // ERROR!!!"></div><div data-l="println!(&quot;The first letter of s is {}&quot;, s[0]); // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">ERROR!!!</span>エラー！！！</span> </div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Usually, access to a vector with <code>[]</code> is very fast.</span>通常、 <code>[]</code>ベクトルへのアクセスは非常に高速です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But, because each character in a UTF-8 encoded string can be multiple bytes, you have to walk over the string to find the nᵗʰ letter of a string.</span>しかし、UTF-8でエンコードされた文字列の各文字は複数のバイトになる可能性があるので、文字列のnᵗ文字を見つけるためには文字列の上を移動する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is a significantly more expensive operation, and we don&#39;t want to be misleading.</span>これははるかに高価な操作であり、私たちは誤解を招きたくありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Furthermore, &#39;letter&#39; isn&#39;t something defined in Unicode, exactly.</span>さらに、 &#39;文字&#39;はUnicodeで定義されたものではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can choose to look at a string as individual bytes, or as codepoints:</span>文字列を個々のバイトとして、またはコードポイントとして見ることができます。</span> </p><br><div data-lang=rust><div data-l="let hachiko = &quot;忠犬ハチ公&quot;;"></div><div data-l=""></div><div data-l="for b in hachiko.as_bytes() {"></div><div data-l="    print!(&quot;{}, &quot;, b);"></div><div data-l=}></div><div data-l=""></div><div data-l=println!(&quot;&quot;);></div><div data-l=""></div><div data-l="for c in hachiko.chars() {"></div><div data-l="    print!(&quot;{}, &quot;, c);"></div><div data-l=}></div><div data-l=""></div><div data-l=println!(&quot;&quot;);></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This prints:</span>これは印刷します：</span> </p><br><div data-lang=text><div data-l="229, 191, 160, 231, 138, 172, 227, 131, 143, 227, 131, 129, 229, 133, 172,"></div><div data-l="忠, 犬, ハ, チ, 公,"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As you can see, there are more bytes than <code>char</code> s.</span>ご覧のとおり、 <code>char</code>よりも多くのバイトがあります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can get something similar to an index like this:</span>次のようなインデックスに似たものを得ることができます：</span> </p><br><div data-lang=rust><div data-l="# let hachiko = &quot;忠犬ハチ公&quot;;"></div><div data-l="#//let dog = hachiko.chars().nth(1); // Kinda like `hachiko[1]`."></div><div data-l="let dog = hachiko.chars().nth(1); // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Kinda like <code>hachiko[1]</code> .</span> <code>hachiko[1]</code>みたいですね。</span> </div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This emphasizes that we have to walk from the beginning of the list of <code>chars</code> .</span>これは、 <code>chars</code>のリストの始めから歩かなければならないことを強調しています。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Slicing</span>スライス</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can get a slice of a string with the slicing syntax:</span>スライス構文で文字列のスライスを取得できます。</span> </p><br><div data-lang=rust><div data-l="let dog = &quot;hachiko&quot;;"></div><div data-l="let hachi = &amp;dog[0..5];"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But note that these are <s>byte</s> offsets, not <s>character</s> offsets.</span>ただし、これらは<s>バイト</s>オフセットであり、 <s>文字</s>オフセットではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So this will fail at runtime:</span>これは実行時に失敗します：</span> </p><br><div data-lang=rust,should_panic><div data-l="let dog = &quot;忠犬ハチ公&quot;;"></div><div data-l="let hachi = &amp;dog[0..2];"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">with this error:</span>このエラーが発生しました：</span> </p><br><div data-lang=text><div data-l="thread 'main' panicked at 'byte index 2 is not a char boundary; it is inside '忠'"></div><div data-l="(bytes 0..3) of `忠犬ハチ公`'"></div></div><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Concatenation</span>連結</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you have a <code>String</code> , you can concatenate a <code>&amp;str</code> to the end of it:</span> <code>String</code>を持っている場合は、 <code>&amp;str</code>を末尾に連結することができ<code>&amp;str</code> ：</span> </p><br><div data-lang=rust><div data-l="let hello = &quot;Hello &quot;.to_string();"></div><div data-l="let world = &quot;world!&quot;;"></div><div data-l=""></div><div data-l="let hello_world = hello + world;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But if you have two <code>String</code> s, you need an <code>&amp;</code> :</span>しかし、2つの<code>String</code>がある場合は、 <code>&amp;</code> ：</span> </p><br><div data-lang=rust><div data-l="let hello = &quot;Hello &quot;.to_string();"></div><div data-l="let world = &quot;world!&quot;.to_string();"></div><div data-l=""></div><div data-l="let hello_world = hello + &amp;world;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is because <code>&amp;String</code> can automatically coerce to a <code>&amp;str</code> .</span>これは<code>&amp;String</code>が<code>&amp;str</code>自動的に強制することができるからです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is a feature called &#39; <a href=#3dc><code>Deref</code> coercions</a> &#39;.</span>これは「 <a href=#3dc><code>Deref</code> coercions</a> 」と呼ばれる機能です。</span> </p><br> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a class=notranslate href=#1unsized-types.html>ut</a> <a class=notranslate href=#1deref-coercions.html>dc</a> <a class=notranslate href=#1../../std/net/struct.TcpStream.html#method.connect>connect</a></span> <a class=notranslate href=#1unsized-types.html>ut</a> <a class=notranslate href=#1deref-coercions.html>dc</a> <a class=notranslate href=#1../../std/net/struct.TcpStream.html#method.connect>connect</a></span><script>_addload(function(){_setupIW('com');_csi('en','ja','strings.html');});</script>