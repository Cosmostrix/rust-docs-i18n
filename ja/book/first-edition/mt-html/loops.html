<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180709_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=loops.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Loops</span>ループ</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust currently provides three approaches to performing some kind of iterative activity.</span> Rustは現在、何らかの反復アクティビティを実行するための3つのアプローチを提供しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">They are: <code>loop</code> , <code>while</code> and <code>for</code> .</span>それらは： <code>loop</code> 、 <code>while</code>と<code>for</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Each approach has its own set of uses.</span>各アプローチにはそれぞれ独自の使用法があります。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">loop</span>ループ</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The infinite <code>loop</code> is the simplest form of loop available in Rust.</span>無限<code>loop</code>は、Rustで利用可能な最も単純なループです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Using the keyword <code>loop</code> , Rust provides a way to loop indefinitely until some terminating statement is reached.</span> Rustは、キーワード<code>loop</code>を使用して、終了ステートメントに達するまで無期限にループする方法を提供します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust&#39;s infinite <code>loop</code> s look like this:</span>錆の無限<code>loop</code>のようになります：</span> </p><br><div data-lang=rust,ignore><div data-l="loop {"></div><div data-l="    println!(&quot;Loop forever!&quot;);"></div><div data-l=}></div></div><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">while</span> while</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust also has a <code>while</code> loop.</span>錆には<code>while</code>ループもあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It looks like this:</span>これは次のようになります。</span> </p><br><div data-lang=rust><div data-l="#//let mut x = 5; // mut x: i32"></div><div data-l="let mut x = 5; // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">mut x: i32</span> mut x：i32</span> </div><div data-l="#//let mut done = false; // mut done: bool"></div><div data-l="let mut done = false; // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">mut done: bool</span> mut done：bool</span> </div><div data-l=""></div><div data-l="while !done {"></div><div data-l="    x += x - 3;"></div><div data-l=""></div><div data-l="    println!(&quot;{}&quot;, x);"></div><div data-l=""></div><div data-l="    if x % 5 == 0 {"></div><div data-l="        done = true;"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>while</code> loops are the correct choice when you&#39;re not sure how many times you need to loop.</span> <code>while</code>ループは、ループする必要がある回数が不明な場合には正しい選択です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you need an infinite loop, you may be tempted to write this:</span>無限ループが必要な場合は、次のように書くことができます。</span> </p><br><div data-lang=rust,ignore><div data-l="while true {"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, <code>loop</code> is far better suited to handle this case:</span>しかし、このケースを処理するには<code>loop</code>がはるかに適しています。</span> </p><br><div data-lang=rust,ignore><div data-l="loop {"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust&#39;s control-flow analysis treats this construct differently than a <code>while true</code> , since we know that it will always loop.</span> Rustのコントロールフロー分析は、このループが常にループすることがわかっているので、この構成<code>while true</code>とは異なるものとして扱います。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In general, the more information we can give to the compiler, the better it can do with safety and code generation, so you should always prefer <code>loop</code> when you plan to loop infinitely.</span>一般的に、コンパイラに与えることができる情報が多くなればなるほど、安全性とコード生成が向上するので、無限<code>loop</code>ときは常に<code>loop</code>を優先する必要があります。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">for</span>ために</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>for</code> loop is used to loop a particular number of times.</span> <code>for</code>ループは、特定の回数のループに使用されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust&#39;s <code>for</code> loops work a bit differently than in other systems languages, however.</span>しかし、Rustの<code>for</code>ループは、他のシステム言語とは少し違って動作します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust&#39;s <code>for</code> loop doesn&#39;t look like this “C-style” <code>for</code> loop:</span> Rust&#39;s <code>for</code>ループは、この &quot;Cスタイル&quot; <code>for</code>ループのようには見えません：</span> </p><br><div data-lang=c><div data-l="for (x = 0; x &lt; 10; x++) {"></div><div data-l="    printf( &quot;%d\n&quot;, x );"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Instead, it looks like this:</span>代わりに、次のようになります。</span> </p><br><div data-lang=rust><div data-l="for x in 0..10 {"></div><div data-l="#//    println!(&quot;{}&quot;, x); // x: i32"></div><div data-l="    println!(&quot;{}&quot;, x); // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">x: i32</span> x：i32</span> </div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In slightly more abstract terms,</span>やや抽象的な言葉では、</span> </p><br><div data-lang=rust,ignore><div data-l="for var in expression {"></div><div data-l="    code"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The expression is an item that can be converted into an <a class=notranslate href=#4iterator>iterator</a> using <a class=notranslate href="#4`IntoIterator`">`IntoIterator`</a> .</span>式は<a class=notranslate href="#4`IntoIterator`">`IntoIterator`</a>を使って<a class=notranslate href=#4iterator>iterator</a>変換できるアイテムです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The iterator gives back a series of elements, one element per iteration of the loop.</span>イテレータは一連の要素を返します。ループの反復ごとに1つの要素が返されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That value is then bound to the name <code>var</code> , which is valid for the loop body.</span>その値はループ本体に有効な<code>var</code>という名前にバインドされます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Once the body is over, the next value is fetched from the iterator, and we loop another time.</span>ボディーが終了すると、イテレーターから次の値がフェッチされ、もう一度ループします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When there are no more values, the <code>for</code> loop is over.</span>それ以上の値がない場合、 <code>for</code>ループは終了します。</span> </p><br> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a class=notranslate href=#1iterators.html>iterator</a> <a class=notranslate href=#1../../std/iter/trait.IntoIterator.html>`IntoIterator`</a></span> <a class=notranslate href=#1iterators.html>iterator</a> <a class=notranslate href=#1../../std/iter/trait.IntoIterator.html>`IntoIterator`</a></span> <br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In our example, <code>0..10</code> is an expression that takes a start and an end position, and gives an iterator over those values.</span>この例では、 <code>0..10</code>は開始位置と終了位置をとり、それらの値を反復子とする式です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The upper bound is exclusive, though, so our loop will print <code>0</code> through <code>9</code> , not <code>10</code> .</span>上限は、しかし、排他的なので、私たちのループが印刷されます<code>0</code>を通じて<code>9</code> 、ではない<code>10</code> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust does not have the “C-style” <code>for</code> loop on purpose.</span> Rustには目的の<code>for</code> &quot;Cスタイル&quot; <code>for</code>ループはありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Manually controlling each element of the loop is complicated and error prone, even for experienced C developers.</span>経験豊富なC開発者であっても、ループの各要素を手動で制御することは複雑でエラーが発生しやすくなります。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Enumerate</span>列挙する</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When you need to keep track of how many times you have already looped, you can use the <code>.enumerate()</code> function.</span>ループした回数を追跡する必要がある場合は、 <code>.enumerate()</code>関数を使用できます。</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">On ranges:</span>オンレンジ：</span> </h4><br><div data-lang=rust><div data-l="for (index, value) in (5..10).enumerate() {"></div><div data-l="    println!(&quot;index = {} and value = {}&quot;, index, value);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Outputs:</span>出力：</span> </p><br><div data-lang=text><div data-l="index = 0 and value = 5"></div><div data-l="index = 1 and value = 6"></div><div data-l="index = 2 and value = 7"></div><div data-l="index = 3 and value = 8"></div><div data-l="index = 4 and value = 9"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Don&#39;t forget to add the parentheses around the range.</span>範囲の周りにかっこを追加することを忘れないでください。</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">On iterators:</span>イテレータでは：</span> </h4><br><div data-lang=rust><div data-l="let lines = &quot;hello\nworld&quot;.lines();"></div><div data-l=""></div><div data-l="for (linenumber, line) in lines.enumerate() {"></div><div data-l="    println!(&quot;{}: {}&quot;, linenumber, line);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Outputs:</span>出力：</span> </p><br><div data-lang=text><div data-l="0: hello"></div><div data-l="1: world"></div></div><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Ending iteration early</span>初期の反復の終了</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s take a look at that <code>while</code> loop we had earlier:</span>のは、その見てみましょう<code>while</code> 、我々は以前持っていたループを：</span> </p><br><div data-lang=rust><div data-l="let mut x = 5;"></div><div data-l="let mut done = false;"></div><div data-l=""></div><div data-l="while !done {"></div><div data-l="    x += x - 3;"></div><div data-l=""></div><div data-l="    println!(&quot;{}&quot;, x);"></div><div data-l=""></div><div data-l="    if x % 5 == 0 {"></div><div data-l="        done = true;"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We had to keep a dedicated <code>mut</code> boolean variable binding, <code>done</code> , to know when we should exit out of the loop.</span>私たちは、専用続けなければならなかった<code>mut</code> 、結合ブール変数を<code>done</code> 、我々はループの外に出る必要があるときに知っています、。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust has two keywords to help us with modifying iteration: <code>break</code> and <code>continue</code> .</span> Rustには、繰り返しを修正するのに役立つ2つのキーワード<code>break</code> ＆ <code>continue</code>ます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this case, we can write the loop in a better way with <code>break</code> :</span>この場合、 <code>break</code>を<code>break</code>てより良い方法でループを書くことができます：</span> </p><br><div data-lang=rust><div data-l="let mut x = 5;"></div><div data-l=""></div><div data-l="loop {"></div><div data-l="    x += x - 3;"></div><div data-l=""></div><div data-l="    println!(&quot;{}&quot;, x);"></div><div data-l=""></div><div data-l="    if x % 5 == 0 { break; }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We now loop forever with <code>loop</code> and use <code>break</code> to break out early.</span>私たちは今、ループで永遠に<code>loop</code> 、早めにブレークアウトする<code>break</code>にブレークを使います。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Issuing an explicit <code>return</code> statement will also serve to terminate the loop early.</span>明示的な<code>return</code>文を発行すると、ループを早期に終了させることもできます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>continue</code> is similar, but instead of ending the loop, it goes to the next iteration.</span> <code>continue</code>も同様ですが、ループを終了する代わりに、次の繰り返しに進みます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This will only print the odd numbers:</span>奇数のみが出力されます：</span> </p><br><div data-lang=rust><div data-l="for x in 0..10 {"></div><div data-l="    if x % 2 == 0 { continue; }"></div><div data-l=""></div><div data-l="    println!(&quot;{}&quot;, x);"></div><div data-l=}></div></div><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Loop labels</span>ループラベル</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You may also encounter situations where you have nested loops and need to specify which one your <code>break</code> or <code>continue</code> statement is for.</span>ネストされたループがあり、 <code>break</code>または<code>continue</code>ステートメントの対象となるステートメントを指定する必要がある場合もあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Like most other languages, Rust&#39;s <code>break</code> or <code>continue</code> apply to the innermost loop.</span>他のほとんどの言語と同様に、Rustの<code>break</code>または<code>continue</code>は最も内側のループに適用されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In a situation where you would like to <code>break</code> or <code>continue</code> for one of the outer loops, you can use labels to specify which loop the <code>break</code> or <code>continue</code> statement applies to.</span>外部ループの1つを<code>break</code>または<code>continue</code>したい場合は、ラベルを使用して<code>break</code>または<code>continue</code>ステートメントが適用されるループを指定できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In the example below, we <code>continue</code> to the next iteration of <code>outer</code> loop when <code>x</code> is even, while we <code>continue</code> to the next iteration of <code>inner</code> loop when y is even.</span>以下の例では、我々は、 <code>continue</code>の次の反復に<code>outer</code>ときループ<code>x</code>偶数で、我々はしながら、 <code>continue</code>の次の反復に<code>inner</code> yが偶数である場合、ループ。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So it will execute the <code>println€</code> when both <code>x</code> and <code>y</code> are odd.</span>したがって、 <code>x</code>と<code>y</code>両方が奇数であるときに<code>println€</code>を実行します。</span> </p><br><div data-lang=rust><div data-l="'outer: for x in 0..10 {"></div><div data-l="    'inner: for y in 0..10 {"></div><div data-l="#//        if x % 2 == 0 { continue 'outer; } // Continues the loop over `x`."></div><div data-l="        if x % 2 == 0 { continue 'outer; } // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Continues the loop over <code>x</code> .</span>ループを<code>x</code>続行します。</span> </div><div data-l="#//        if y % 2 == 0 { continue 'inner; } // Continues the loop over `y`."></div><div data-l="        if y % 2 == 0 { continue 'inner; } // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Continues the loop over <code>y</code> .</span>ループを<code>y</code>続行します。</span> </div><div data-l="        println!(&quot;x: {}, y: {}&quot;, x, y);"></div><div data-l="    }"></div><div data-l=}></div></div><script>_addload(function(){_setupIW('com');_csi('en','ja','loops.html');});</script>