<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180709_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=primitive-types.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Primitive Types</span>プリミティブ型</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The Rust language has a number of types that are considered &#39;primitive&#39;.</span> Rust言語には、「プリミティブ」と見なされる多くのタイプがあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This means that they&#39;re built-in to the language.</span>これは、それらが言語に組み込まれていることを意味します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust is structured in such a way that the standard library also provides a number of useful types built on top of these ones, as well, but these are the most primitive.</span>錆は、標準ライブラリがこれらのものの上に構築された多くの有用な型を提供するようにも構成されていますが、これらは最も基本的なものです。</span> </p><br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Booleans</span>ブール</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust has a built-in boolean type, named <code>bool</code> .</span>錆には<code>bool</code>という名前の<code>bool</code>型が組み込まれています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It has two values, <code>true</code> and <code>false</code> :</span> <code>true</code>と<code>false</code> 2つの値があり<code>false</code> 。</span> </p><br><div data-lang=rust><div data-l="let x = true;"></div><div data-l=""></div><div data-l="let y: bool = false;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A common use of booleans is in <a href=#3if><code>if</code> conditionals</a> .</span>ブール値の一般的な使用は<a href=#3if>条件付きの<code>if</code>です</a> 。</span> </p><br> <a class=notranslate href=#1if.html>if</a> <br> <p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can find more documentation for <code>bool</code> s <a href=#3bool>in the standard library documentation</a> .</span> <code>bool</code>の詳細<a href=#3bool>は、標準ライブラリのドキュメントを参照してください</a> 。</span> </p><br> <a class=notranslate href=#1../../std/primitive.bool.html>bool</a> <br> <h1> <code>char</code> </h1> <br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>char</code> type represents a single Unicode scalar value.</span> <code>char</code>型は、単一のUnicodeスカラー値を表します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can create <code>char</code> s with a single tick: ( <code>&#39;</code> )</span> 1つのチックで<code>char</code>を作成することができます：（ <code>&#39;</code> ）</span> </p><br><div data-lang=rust><div data-l="let x = 'x';"></div><div data-l="let two_hearts = '💕';"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Unlike some other languages, this means that Rust&#39;s <code>char</code> is not a single byte, but four.</span>他の言語とは異なり、これはRustの<code>char</code>が1バイトではなく4バイトであることを意味します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can find more documentation for <code>char</code> s <a href=#3char>in the standard library documentation</a> .</span> <code>char</code>の他のドキュメント<a href=#3char>は標準ライブラリのドキュメントにあります</a> 。</span> </p><br> <a class=notranslate href=#1../../std/primitive.char.html>char</a> <br> <h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Numeric types</span>数値型</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust has a variety of numeric types in a few categories: signed and unsigned, fixed and variable, floating-point and integer.</span> Rustは、符号付きおよび符号なし、固定および可変、浮動小数点および整数のいくつかのカテゴリでさまざまな数値型を持っています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These types consist of two parts: the category, and the size.</span>これらのタイプは、カテゴリとサイズの2つの部分で構成されています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, <code>u16</code> is an unsigned type with sixteen bits of size.</span>たとえば、 <code>u16</code>は16ビットのサイズを持つ符号なし型です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">More bits lets you have bigger numbers.</span>より多くのビットを使用すると、より大きな数を持つことができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If a number literal has nothing to cause its type to be inferred, it defaults:</span>数値リテラルが型の推論を引き起こさない場合は、デフォルトで次のようになります。</span> </p><br><div data-lang=rust><div data-l="#//let x = 42; // `x` has type `i32`."></div><div data-l="let x = 42; // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>x</code> has type <code>i32</code> .</span> <code>x</code>はタイプ<code>i32</code>です。</span> </div><div data-l=""></div><div data-l="#//let y = 1.0; // `y` has type `f64`."></div><div data-l="let y = 1.0; // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>y</code> has type <code>f64</code> .</span> <code>y</code>は<code>f64</code>型です。</span> </div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here&#39;s a list of the different numeric types, with links to their documentation in the standard library:</span>さまざまな数値型のリストがあり、標準ライブラリのドキュメントへのリンクがあります。</span> </p><br><div data-b=*> <a class=notranslate href=#2../../std/primitive.i8.html>i8</a> </div> <div data-b=*> <a class=notranslate href=#2../../std/primitive.i16.html>i16</a> </div> <div data-b=*> <a class=notranslate href=#2../../std/primitive.i32.html>i32</a> </div> <div data-b=*> <a class=notranslate href=#2../../std/primitive.i64.html>i64</a> </div> <div data-b=*> <a class=notranslate href=#2../../std/primitive.u8.html>u8</a> </div> <div data-b=*> <a class=notranslate href=#2../../std/primitive.u16.html>u16</a> </div> <div data-b=*> <a class=notranslate href=#2../../std/primitive.u32.html>u32</a> </div> <div data-b=*> <a class=notranslate href=#2../../std/primitive.u64.html>u64</a> </div> <div data-b=*> <a class=notranslate href=#2../../std/primitive.isize.html>isize</a> </div> <div data-b=*> <a class=notranslate href=#2../../std/primitive.usize.html>usize</a> </div> <div data-b=*> <a class=notranslate href=#2../../std/primitive.f32.html>f32</a> </div> <div data-b=*> <a class=notranslate href=#2../../std/primitive.f64.html>f64</a> </div> <br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s go over them by category:</span>カテゴリ別に見てみましょう：</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Signed and Unsigned</span>署名付きおよび署名なし</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Integer types come in two varieties: signed and unsigned.</span>整数型には、符号付きと符号なしの2種類があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To understand the difference, let&#39;s consider a number with four bits of size.</span>違いを理解するために、4ビットのサイズの数値を考えてみましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A signed, four-bit number would let you store numbers from <code>-8</code> to <code>+7</code> .</span>符号付きの4ビット数は、 <code>-8</code>から<code>+7</code>までの数値を格納できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Signed numbers use “two&#39;s complement representation”.</span>符号付き数値は「2の補数表現」を使用します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">An unsigned four bit number, since it does not need to store negatives, can store values from <code>0</code> to <code>+15</code> .</span>符号なしの4ビット数は、ネガを格納する必要がないため、 <code>0</code> <code>+15</code>値を格納できます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Unsigned types use a <code>u</code> for their category, and signed types use <code>i</code> .</span>符号なしタイプはそのカテゴリに<code>u</code>を使用し、符号付きタイプは<code>i</code>使用します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>i</code> is for &#39;integer&#39;.</span> <code>i</code>は整数である。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So <code>u8</code> is an eight-bit unsigned number, and <code>i8</code> is an eight-bit signed number.</span>したがって、 <code>u8</code>は8ビットの符号なしの数値で、 <code>i8</code>は8ビットの符号付き数値です。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Fixed-size types</span>固定サイズのタイプ</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Fixed-size types have a specific number of bits in their representation.</span>固定長タイプは、その表現に特定のビット数を持ちます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Valid bit sizes are <code>8</code> , <code>16</code> , <code>32</code> , and <code>64</code> .</span>有効ビットサイズは、 <code>8</code> 、 <code>16</code> 、 <code>32</code> 、及び<code>64</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So, <code>u32</code> is an unsigned, 32-bit integer, and <code>i64</code> is a signed, 64-bit integer.</span>したがって、 <code>u32</code>は符号なし32ビット整数で、 <code>i64</code>は符号付き64ビット整数です。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Variable-size types</span>可変サイズの型</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust also provides types whose particular size depends on the underlying machine architecture.</span> Rustは、その特定のサイズが基礎となるマシンアーキテクチャに依存するタイプも提供します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Their range is sufficient to express the size of any collection, so these types have &#39;size&#39; as the category.</span>それらの範囲は任意のコレクションのサイズを表現するのに十分なので、これらのタイプはカテゴリとして &#39;サイズ&#39;を持ちます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">They come in signed and unsigned varieties which account for two types: <code>isize</code> and <code>usize</code> .</span>彼らは、署名されたものと無署名のものがあります。 <code>isize</code> 、 <code>usize</code>と<code>usize</code> 2種類があります。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Floating-point types</span>浮動小数点型</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust also has two floating point types: <code>f32</code> and <code>f64</code> .</span>錆には、 <code>f32</code>と<code>f64</code> 2つの浮動小数点型もあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These correspond to IEEE-754 single and double precision numbers.</span>これらは、IEEE-754の単精度および倍精度の数値に対応します。</span> </p><br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Arrays</span>配列</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Like many programming languages, Rust has list types to represent a sequence of things.</span>多くのプログラミング言語と同様に、Rustは一連の事柄を表現するリスト型を持っています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The most basic is the <i>array</i> , a fixed-size list of elements of the same type.</span>最も基本的なのは、同じタイプの要素の固定サイズのリストである<i>配列</i>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">By default, arrays are immutable.</span>デフォルトでは、配列は不変です。</span> </p><br><div data-lang=rust><div data-l="#//let a = [1, 2, 3]; // a: [i32; 3]"></div><div data-l="let a = [1, 2, 3]; // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">a: <a class=notranslate href="#4i32; 3">i32; 3</a></span> a： <a class=notranslate href="#4i32; 3">i32; 3</a></span> <a class=notranslate href="#4i32; 3">i32; 3</a> </div><div data-l="#//let mut m = [1, 2, 3]; // m: [i32; 3]"></div><div data-l="let mut m = [1, 2, 3]; // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">m: <a class=notranslate href="#4i32; 3">i32; 3</a></span> m： <a class=notranslate href="#4i32; 3">i32; 3</a></span> <a class=notranslate href="#4i32; 3">i32; 3</a> </div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Arrays have type <code>[T; N]</code></span>配列には<code>[T; N]</code></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>[T; N]</code> .</span> <code>[T; N]</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll talk about this <code>T</code> notation <a href=#3generics>in the generics section</a> .</span> <a href=#3generics>ジェネリックスのセクションで、</a>この<code>T</code>表記について<a href=#3generics>説明し</a>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>N</code> is a compile-time constant, for the length of the array.</span> <code>N</code>は、配列の長さのコンパイル時定数です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There&#39;s a shorthand for initializing each element of an array to the same value.</span>配列の各要素を同じ値に初期化するための省略表現があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this example, each element of <code>a</code> will be initialized to <code>0</code> :</span>この例では<code>a</code>各要素は<code>0</code>に初期化され<code>0</code> 。</span> </p><br><div data-lang=rust><div data-l="#//let a = [0; 20]; // a: [i32; 20]"></div><div data-l="let a = [0; 20]; // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">a: <a class=notranslate href="#4i32; 20">i32; 20</a></span> a： <a class=notranslate href="#4i32; 20">i32; 20</a></span> <a class=notranslate href="#4i32; 20">i32; 20</a> </div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can get the number of elements in an array <code>a</code> with <code>a.len()</code> :</span> <code>a.len()</code>配列<code>a</code>要素数を得ることができます：</span> </p><br><div data-lang=rust><div data-l="let a = [1, 2, 3];"></div><div data-l=""></div><div data-l="println!(&quot;a has {} elements&quot;, a.len());"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can access a particular element of an array with <i>subscript notation</i> :</span> <i>添字表記</i>を使用して、配列の特定の要素にアクセスできます。</span> </p><br><div data-lang=rust><div data-l="#//let names = [&quot;Graydon&quot;, &quot;Brian&quot;, &quot;Niko&quot;]; // names: [&amp;str; 3]"></div><div data-l="let names = [&quot;Graydon&quot;, &quot;Brian&quot;, &quot;Niko&quot;]; // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">names: <a class=notranslate href="#4&amp;str; 3">&amp;str; 3</a></span>名前： <a class=notranslate href="#4&amp;str; 3">&amp;str; 3</a></span> <a class=notranslate href="#4&amp;str; 3">&amp;str; 3</a> </div><div data-l=""></div><div data-l="println!(&quot;The second name is: {}&quot;, names[1]);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Subscripts start at zero, like in most programming languages, so the first name is <code>names[0]</code> and the second name is <code>names[1]</code> .</span>ほとんどのプログラミング言語と同様に、添え字はゼロから始まります。したがって、最初の名前は<code>names[0]</code>で、2番目の名前は<code>names[1]</code>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The above example prints <code>The second name is: Brian</code> .</span>上記の例では<code>The second name is: Brian</code>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you try to use a subscript that is not in the array, you will get an error: array access is bounds-checked at run-time.</span>配列にない添字を使用しようとすると、エラーが発生します。配列アクセスは実行時に境界チェックされます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Such errant access is the source of many bugs in other systems programming languages.</span>このような誤ったアクセスは、他のシステムプログラミング言語の多くのバグの原因です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can find more documentation for <code>array</code> s <a href=#3array>in the standard library documentation</a> .</span> <code>array</code>のドキュメントについて<a href=#3array>は、標準ライブラリのドキュメントを参照してください</a> 。</span> </p><br> <a class=notranslate href=#1../../std/primitive.array.html>array</a> <br> <h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Slices</span>スライス</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A &#39;slice&#39; is a reference to (or “view” into) another data structure.</span> 「スライス」は、別のデータ構造への参照（または「参照」）です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">They are useful for allowing safe, efficient access to a portion of an array without copying.</span>これらは、コピーせずにアレイの一部に安全かつ効率的にアクセスできるようにするのに便利です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, you might want to reference only one line of a file read into memory.</span>たとえば、メモリに読み込まれたファイルの1行だけを参照することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">By nature, a slice is not created directly, but from an existing variable binding.</span>本来、スライスは直接作成されるのではなく、既存の変数バインディングから作成されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Slices have a defined length, and can be mutable or immutable.</span>スライスは定義された長さを持ち、可変または不変にすることができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Internally, slices are represented as a pointer to the beginning of the data and a length.</span>内部的には、スライスはデータの先頭と長さのポインタとして表されます。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Slicing syntax</span>スライス構文</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can use a combo of <code>&amp;</code> and <code>[]</code> to create a slice from various things.</span> <code>&amp;</code>と<code>[]</code>組み合わせを使用して、さまざまなものからスライスを作成できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>&amp;</code> indicates that slices are similar to <a class=notranslate href=#4references>references</a> , which we will cover in detail later in this section.</span> <code>&amp;</code>はスライスが<a class=notranslate href=#4references>references</a>に似ていることを示します。これについては後で詳しく説明します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>[]</code> s, with a range, let you define the length of the slice:</span>範囲を持つ<code>[]</code>はスライスの長さを定義します：</span> </p><br><div data-lang=rust><div data-l="let a = [0, 1, 2, 3, 4];"></div><div data-l="#//let complete = &amp;a[..]; // A slice containing all of the elements in `a`."></div><div data-l="let complete = &amp;a[..]; // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A slice containing all of the elements in <code>a</code> .</span>内のすべての要素を含むスライス。 <code>a</code></span> </div><div data-l="#//let middle = &amp;a[1..4]; // A slice of `a`: only the elements `1`, `2`, and `3`."></div><div data-l="let middle = &amp;a[1..4]; // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A slice of <code>a</code> : only the elements <code>1</code> , <code>2</code> , and <code>3</code> .</span>スライス：要素のみ<code>a</code> <code>1</code> 、 <code>2</code> 、および<code>3</code> 。</span> </div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Slices have type <code>&amp;[T]</code> .</span>スライスには<code>&amp;[T]</code>タイプがあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll talk about that <code>T</code> when we cover <a class=notranslate href=#3generics>generics</a> .</span>私たちは、そのことについて話しましょう<code>T</code>私たちがカバーしたときに<a class=notranslate href=#3generics>generics</a> 。</span> </p><br> <a class=notranslate href=#1generics.html>generics</a> <br> <p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can find more documentation for slices <a href=#3slice>in the standard library documentation</a> .</span>スライスに関するその他のドキュメント<a href=#3slice>は、標準ライブラリのドキュメントにあります</a> 。</span> </p><br> <a class=notranslate href=#1../../std/primitive.slice.html>slice</a> <br> <h1> <code>str</code> </h1> <br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust&#39;s <code>str</code> type is the most primitive string type.</span> Rustの<code>str</code>型は、最も基本的な文字列型です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As an <a href=#3dst>unsized type</a> , it&#39;s not very useful by itself, but becomes useful when placed behind a reference, like <code>&amp;str</code> .</span> <a href=#3dst>unsized型</a>として、それ自体はそれほど有用ではありませんが、 <code>&amp;str</code>ように参照の後に置くと便利になり<code>&amp;str</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll elaborate further when we cover <a class=notranslate href=#3strings>Strings</a> and <a class=notranslate href=#4references>references</a> .</span> <a class=notranslate href=#3strings>Strings</a>や<a class=notranslate href=#4references>references</a>をカバーするときはさらに詳しく説明し<a class=notranslate href=#4references>references</a> 。</span> </p><br> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a class=notranslate href=#1unsized-types.html>dst</a> <a class=notranslate href=#1strings.html>strings</a> <a class=notranslate href=#1references-and-borrowing.html>references</a></span> <a class=notranslate href=#1unsized-types.html>dst</a> <a class=notranslate href=#1strings.html>strings</a> <a class=notranslate href=#1references-and-borrowing.html>references</a></span> <br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can find more documentation for <code>str</code> <a href=#3str>in the standard library documentation</a> .</span> <code>str</code>に関するその他のドキュメント<a href=#3str>は、標準ライブラリのドキュメントを参照してください</a> 。</span> </p><br> <a class=notranslate href=#1../../std/primitive.str.html>str</a> <br> <h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Tuples</span>タプル</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A tuple is an ordered list of fixed size.</span>タプルは、固定サイズの順序付きリストです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Like this:</span>このような：</span> </p><br><div data-lang=rust><div data-l="let x = (1, &quot;hello&quot;);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The parentheses and commas form this two-length tuple.</span>括弧とカンマがこの2つの長さのタプルを形成します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here&#39;s the same code, but with the type annotated:</span>同じコードがありますが、注釈付きの型があります：</span> </p><br><div data-lang=rust><div data-l="let x: (i32, &amp;str) = (1, &quot;hello&quot;);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As you can see, the type of a tuple looks like the tuple, but with each position having a type name rather than the value.</span>ご覧のように、タプルの型はタプルのように見えますが、各位置は値ではなく型名を持ちます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Careful readers will also note that tuples are heterogeneous: we have an <code>i32</code> and a <code>&amp;str</code> in this tuple.</span>慎重な読者は、タプルは異種であることにも気付くでしょう：私たちはこのタプルに<code>i32</code>と<code>&amp;str</code>を持ってい<code>&amp;str</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In systems programming languages, strings are a bit more complex than in other languages.</span>システムプログラミング言語では、文字列は他の言語よりも少し複雑です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For now, read <code>&amp;str</code> as a <i>string slice</i> , and we&#39;ll learn more soon.</span>今のところ、 <i>文字列スライス</i>として<code>&amp;str</code>を読んでください。私たちはもっと早く学びます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can assign one tuple into another, if they have the same contained types and <a class=notranslate href=#4arity>arity</a> .</span> 1つのタプルが同じタイプと<a class=notranslate href=#4arity>arity</a>を持つ場合、そのタプルを別のタプルに割り当てることができ<a class=notranslate href=#4arity>arity</a> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Tuples have the same arity when they have the same length.</span>タプルは同じ長さのときに同じアリティを持ちます。</span> </p><br> <a class=notranslate href=#1glossary.html#arity>arity</a> <br> <div data-lang=rust><div data-l="#//let mut x = (1, 2); // x: (i32, i32)"></div><div data-l="let mut x = (1, 2); // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">x: (i32, i32)</span> x：（i32、i32）</span> </div><div data-l="#//let y = (2, 3); // y: (i32, i32)"></div><div data-l="let y = (2, 3); // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">y: (i32, i32)</span> y：（i32、i32）</span> </div><div data-l=""></div><div data-l="x = y;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can access the fields in a tuple through a <i>destructuring let</i> .</span>タプル内のフィールドには、非構造化<i>レットを</i>介してアクセスできます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here&#39;s an example:</span>ここに例があります：</span> </p><br><div data-lang=rust><div data-l="let (x, y, z) = (1, 2, 3);"></div><div data-l=""></div><div data-l="println!(&quot;x is {}&quot;, x);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Remember <a class=notranslate href=#3let>before</a> when I said the left-hand side of a <code>let</code> statement was more powerful than assigning a binding?</span>覚えておいてください<a class=notranslate href=#3let>before</a>私はの左側たとき<code>let</code>文はバインディングを割り当てるよりも強力でしたか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here we are.</span>ここにいるのです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can put a pattern on the left-hand side of the <code>let</code> , and if it matches up to the right-hand side, we can assign multiple bindings at once.</span> <code>let</code>の左側にパターンを置くことができ、右側に一致する場合は、複数のバインディングを一度に割り当てることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this case, <code>let</code> “destructures” or “breaks up” the tuple, and assigns the bits to three bindings.</span>この場合は、 <code>let</code> 「destructures」またはタプルを「壊す」、および3つのバインディングにビットを割り当てます。</span> </p><br> <a class=notranslate href=#1variable-bindings.html>let</a> <br> <p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This pattern is very powerful, and we&#39;ll see it repeated more later.</span>このパターンは非常に強力で、後で繰り返すことにします。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can disambiguate a single-element tuple from a value in parentheses with a comma:</span>単一要素のタプルを括弧でくくられた値からコンマで区別できます。</span> </p><br><div data-lang=rust><div data-l="#//(0,); // A single-element tuple."></div><div data-l="(0,); // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A single-element tuple.</span>単一要素タプル。</span> </div><div data-l="#//(0); // A zero in parentheses."></div><div data-l="(0); // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A zero in parentheses.</span>カッコ内は0です。</span> </div></div><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Tuple Indexing</span>タプルインデックス</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can also access fields of a tuple with indexing syntax:</span>また、インデックス構文でタプルのフィールドにアクセスすることもできます：</span> </p><br><br><div data-lang=rust><div data-l="let tuple = (1, 2, 3);"></div><div data-l=""></div><div data-l="let x = tuple.0;"></div><div data-l="let y = tuple.1;"></div><div data-l="let z = tuple.2;"></div><div data-l=""></div><div data-l="println!(&quot;x is {}&quot;, x);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Like array indexing, it starts at zero, but unlike array indexing, it uses a <code>.</code></span>配列のインデックスと同じように、それはゼロから始まりますが、配列のインデックスとは異なり、それが使用しています<code>.</code></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">, rather than <code>[]</code> s.</span> 、むしろ<code>[]</code> s。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can find more documentation for tuples <a href=#3tuple>in the standard library documentation</a> .</span>タプルに関するその他のドキュメント<a href=#3tuple>は、標準ライブラリのドキュメントにあります</a> 。</span> </p><br> <a class=notranslate href=#1../../std/primitive.tuple.html>tuple</a> <br> <h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Functions</span>機能</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Functions also have a type!</span>関数にも型があります！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">They look like this:</span>彼らはこのように見えます：</span> </p><br><div data-lang=rust><div data-l="fn foo(x: i32) -&gt; i32 { x }"></div><div data-l=""></div><div data-l="let x: fn(i32) -&gt; i32 = foo;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this case, <code>x</code> is a &#39;function pointer&#39; to a function that takes an <code>i32</code> and returns an <code>i32</code> .</span>この場合、 <code>x</code>取る関数に「関数ポインタ」で<code>i32</code>戻る<code>i32</code> 。</span> </p><script>_addload(function(){_setupIW('com');_csi('en','ja','primitive-types.html');});</script>