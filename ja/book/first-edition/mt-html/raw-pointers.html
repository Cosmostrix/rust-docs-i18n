<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180709_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=raw-pointers.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Raw Pointers</span>生ポインタ</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust has a number of different smart pointer types in its standard library, but there are two types that are extra-special.</span> Rustには、標準ライブラリにいくつかの異なるスマートポインタタイプがありますが、特別なものには2つのタイプがあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Much of Rust&#39;s safety comes from compile-time checks, but raw pointers don&#39;t have such guarantees, and are <a class=notranslate href=#3unsafe>unsafe</a> to use.</span> Rustの安全性の大部分はコンパイル時のチェックに由来しますが、生ポインタにはそのような保証は<a class=notranslate href=#3unsafe>unsafe</a> 、使用するのが<a class=notranslate href=#3unsafe>unsafe</a>ではあり<a class=notranslate href=#3unsafe>unsafe</a> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>*const T</code> and <code>*mut T</code> are called &#39;raw pointers&#39; in Rust.</span> <code>*const T</code>と<code>*mut T</code>は、Rustでは「生ポインタ」と呼ばれます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Sometimes, when writing certain kinds of libraries, you&#39;ll need to get around Rust&#39;s safety guarantees for some reason.</span>場合によっては、ある種の図書館を書くときに何らかの理由でRustの安全保証を回避する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this case, you can use raw pointers to implement your library, while exposing a safe interface for your users.</span>この場合、生のポインタを使用してライブラリを実装し、ユーザに安全なインタフェースを公開することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, <code>*</code> pointers are allowed to alias, allowing them to be used to write shared-ownership types, and even thread-safe shared memory types (the <code>Rc&lt;T&gt;</code> and <code>Arc&lt;T&gt;</code> types are both implemented entirely in Rust).</span>例えば、 <code>*</code>ポインタはエイリアス化が許され、共有所有権型やスレッドセーフな共有メモリ型（ <code>Rc&lt;T&gt;</code>と<code>Arc&lt;T&gt;</code>型はどちらも完全にRustで実装されています）を書くために使用できます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here are some things to remember about raw pointers that are different than other pointer types.</span>ここでは、他のポインタ型とは異なる生ポインタについて覚えておくべきことがいくつかあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">They:</span>彼ら：</span> </p><br><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">are not guaranteed to point to valid memory and are not even guaranteed to be non-NULL (unlike both <code>Box</code> and <code>&amp;</code> );</span>有効なメモリを指すことが保証されておらず、NULLでないことも保証されていません（ <code>Box</code>と<code>&amp;</code>両方と異なります）。</span> </div><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">do not have any automatic clean-up, unlike <code>Box</code> , and so require manual resource management;</span> <code>Box</code>と違って自動クリーンアップがないので、手動でリソースを管理する必要があります。</span> </div><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">are plain-old-data, that is, they don&#39;t move ownership, again unlike <code>Box</code> , hence the Rust compiler cannot protect against bugs like use-after-free;</span>プレーン、古いデータ、つまり、彼らは再びとは異なり、所有権を移動しないでくださいある<code>Box</code>ので、錆コンパイラは、後の使用の自由のようなバグを防ぐことはできません、。</span> </div><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">lack any form of lifetimes, unlike <code>&amp;</code> , and so the compiler cannot reason about dangling pointers;</span> <code>&amp;</code>とは異なり、生存期間の形が不足しているため、コンパイラはポインタをぶら下げることを理由に考えることはできません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">and</span>そして</span> </div><div data-b=-> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">have no guarantees about aliasing or mutability other than mutation not being allowed directly through a <code>*const T</code> .</span> <code>*const T</code>介して直接許可されていない突然変異以外のエイリアシングまたは可変性についての保証はない。</span> </div><br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Basics</span>基本</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Creating a raw pointer is perfectly safe:</span>生のポインタを作成することは完全に安全です：</span> </p><br><div data-lang=rust><div data-l="let x = 5;"></div><div data-l="let raw = &amp;x as *const i32;"></div><div data-l=""></div><div data-l="let mut y = 10;"></div><div data-l="let raw_mut = &amp;mut y as *mut i32;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, dereferencing one is not.</span>ただし、逆参照はありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This won&#39;t work:</span>これは動作しません：</span> </p><br><div data-lang=rust,ignore><div data-l="let x = 5;"></div><div data-l="let raw = &amp;x as *const i32;"></div><div data-l=""></div><div data-l="println!(&quot;raw points at {}&quot;, *raw);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It gives this error:</span>それはこのエラーを与える：</span> </p><br><div data-lang=text><div data-l="error: dereference of raw pointer requires unsafe function or block [E0133]"></div><div data-l="     println!(&quot;raw points at {}&quot;, *raw);"></div><div data-l="                                  ^~~~"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When you dereference a raw pointer, you&#39;re taking responsibility that it&#39;s not pointing somewhere that would be incorrect.</span>未処理のポインタを間接参照すると、間違った場所を指していないという責任を負うことになります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As such, you need <code>unsafe</code> :</span>したがって、あなたは<code>unsafe</code>ことが必要です：</span> </p><br><div data-lang=rust><div data-l="let x = 5;"></div><div data-l="let raw = &amp;x as *const i32;"></div><div data-l=""></div><div data-l="let points_at = unsafe { *raw };"></div><div data-l=""></div><div data-l="println!(&quot;raw points at {}&quot;, points_at);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For more operations on raw pointers, see <a href=#3rawapi>their API documentation</a> .</span>生ポインタに関するその他の操作については<a href=#3rawapi>、APIのマニュアルを</a>参照し<a href=#3rawapi>て</a>ください。</span> </p><br> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a class=notranslate href=#1unsafe.html>unsafe</a> <a class=notranslate href=#1../../std/primitive.pointer.html>rawapi</a></span> <a class=notranslate href=#1unsafe.html>unsafe</a> <a class=notranslate href=#1../../std/primitive.pointer.html>rawapi</a></span> <br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">FFI</span> FFI</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Raw pointers are useful for FFI: Rust&#39;s <code>*const T</code> and <code>*mut T</code> are similar to C&#39;s <code>const T*</code> and <code>T*</code> , respectively.</span>生ポインタはFFIにとって便利です：Rustの<code>*const T</code>と<code>*mut T</code>はそれぞれCの<code>const T*</code>と<code>T*</code>に似ています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For more about this use, consult the <a href=#3ffi>FFI chapter</a> .</span>この使用の詳細については、 <a href=#3ffi>FFIの章を</a>参照してください。</span> </p><br> <a class=notranslate href=#1ffi.html>ffi</a> <br> <h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">References and raw pointers</span>参照と生ポインタ</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">At runtime, a raw pointer <code>*</code> and a reference pointing to the same piece of data have an identical representation.</span>実行時には、生ポインタ<code>*</code>と同じデータを指す参照は同じ表現をしています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In fact, an <code>&amp;T</code> reference will implicitly coerce to an <code>*const T</code> raw pointer in safe code and similarly for the <code>mut</code> variants (both coercions can be performed explicitly with, respectively, <code>value as *const T</code> and <code>value as *mut T</code> ).</span>実際、 <code>&amp;T</code>リファレンスは、安全なコードの<code>*const T</code>生のポインタに暗黙的に強制します。また、 <code>mut</code>バリアントも同様です（両方の変換は<code>value as *const T</code>と<code>value as *mut T</code>明示的に実行できます）。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Going the opposite direction, from <code>*const</code> to a reference <code>&amp;</code> , is not safe.</span> <code>*const</code>から参照<code>&amp;</code>に反対方向に行くことは安全ではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A <code>&amp;T</code> is always valid, and so, at a minimum, the raw pointer <code>*const T</code> has to point to a valid instance of type <code>T</code> .</span> <code>&amp;T</code>は常に有効なので、少なくとも生ポインタ<code>*const T</code>はタイプ<code>T</code>有効なインスタンスを指していなければなりません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Furthermore, the resulting pointer must satisfy the aliasing and mutability laws of references.</span>さらに、結果として生じるポインタは、参照のエイリアシングおよび変更可能性の法則を満たさなければならない。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The compiler assumes these properties are true for any references, no matter how they are created, and so any conversion from raw pointers is asserting that they hold.</span>コンパイラーは、これらのプロパティーがどのような参照にも当てはまりますが、それらのプロパティーはどのように作成されるかにかかわらず、未処理のポインターからの変換ではそれらが保持されていると主張しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The programmer <i>must</i> guarantee this.</span>プログラマ<i>は</i>これを保証し<i>なければなりませ</i>ん。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The recommended method for the conversion is:</span>変換に推奨される方法は次のとおりです。</span> </p><br><div data-lang=rust><div data-l="#// Explicit cast:"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Explicit cast:</span>明示的なキャスト：</span> </div><div data-l="let i: u32 = 1;"></div><div data-l="let p_imm: *const u32 = &amp;i as *const u32;"></div><div data-l=""></div><div data-l="#// Implicit coercion:"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Implicit coercion:</span>暗黙の強制：</span> </div><div data-l="let mut m: u32 = 2;"></div><div data-l="let p_mut: *mut u32 = &amp;mut m;"></div><div data-l=""></div><div data-l="unsafe {"></div><div data-l="    let ref_imm: &amp;u32 = &amp;*p_imm;"></div><div data-l="    let ref_mut: &amp;mut u32 = &amp;mut *p_mut;"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>&amp;*x</code> dereferencing style is preferred to using a <code>transmute</code> .</span> <code>&amp;*x</code>逆参照スタイルは、 <code>transmute</code>を使用するよりも優先されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The latter is far more powerful than necessary, and the more restricted operation is harder to use incorrectly;</span>後者は必要以上に強力であり、操作の制限が厳しくなると誤った使い方が難しくなります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">for example, it requires that <code>x</code> is a pointer (unlike <code>transmute</code> ).</span>例えば、 <code>x</code>はポインタである必要があります（ <code>transmute</code>とは異なります）。</span> </p><script>_addload(function(){_setupIW('com');_csi('en','ja','raw-pointers.html');});</script>