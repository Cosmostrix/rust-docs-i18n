<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180709_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=macros.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Macros</span>マクロ</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">By now you&#39;ve learned about many of the tools Rust provides for abstracting and reusing code.</span>今では、Rustがコードを抽象化し再利用するために提供する多くのツールについて学びました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These units of code reuse have a rich semantic structure.</span>これらのコード再利用の単位は、豊富な意味構造を持っています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, functions have a type signature, type parameters have trait bounds, and overloaded functions must belong to a particular trait.</span>たとえば、関数は型シグネチャを持ち、型パラメータは特性境界を持ち、多重定義関数は特定の特性に属していなければなりません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This structure means that Rust&#39;s core abstractions have powerful compile-time correctness checking.</span>この構造は、Rustのコア抽象化が強力なコンパイル時の正しさチェックを持つことを意味します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But this comes at the price of reduced flexibility.</span>しかし、これは柔軟性の低下の代償を払っています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you visually identify a pattern of repeated code, you may find it&#39;s difficult or cumbersome to express that pattern as a generic function, a trait, or anything else within Rust&#39;s semantics.</span>繰り返されるコードのパターンを視覚的に特定すると、そのパターンをRustのセマンティクスの中でジェネリック関数、特性、またはその他のものとして表現することは困難または面倒です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Macros allow us to abstract at a syntactic level.</span>マクロを使用すると、構文レベルで抽象化することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A macro invocation is shorthand for an &quot;expanded&quot; syntactic form.</span>マクロ呼び出しは、 &quot;拡張された&quot;構文形式の略です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This expansion happens early in compilation, before any static checking.</span>この展開はコンパイルの初期、静的チェックの前に行われます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As a result, macros can capture many patterns of code reuse that Rust&#39;s core abstractions cannot.</span>その結果、マクロは、Rustのコア抽象化では不可能な、多くのコード再利用パターンをキャプチャできます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The drawback is that macro-based code can be harder to understand, because fewer of the built-in rules apply.</span>欠点は、マクロベースのコードを理解するのが難しいということです。なぜなら組み込み規則が少なくて済むからです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Like an ordinary function, a well-behaved macro can be used without understanding its implementation.</span>通常の関数と同様に、適切に動作するマクロは実装の理解なしに使用できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, it can be difficult to design a well-behaved macro!</span>ただし、正常に動作するマクロを設計するのは難しい場合があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Additionally, compiler errors in macro code are harder to interpret, because they describe problems in the expanded code, not the source-level form that developers use.</span>さらに、マクロコードのコンパイラエラーは、開発者が使用するソースレベルのフォームではなく、展開されたコードの問題を記述するため、解釈が難しくなります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These drawbacks make macros something of a &quot;feature of last resort&quot;.</span>これらの欠点は、マクロを「最後の手段」の何かにしている。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That&#39;s not to say that macros are bad;</span>それはマクロが悪いと言っているわけではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">they are part of Rust because sometimes they&#39;re needed for truly concise, well-abstracted code.</span>彼らは時には本当に簡潔で、よく抽象化されたコードのために必要なので、彼らはRustの一部です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Just keep this tradeoff in mind.</span>このトレードオフを念頭に置いてください。</span> </p><br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Defining a macro</span>マクロを定義する</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You may have seen the <code>vec€</code> macro, used to initialize a <a class=notranslate href=#3vector>vector</a> with any number of elements.</span>任意の数の要素を持つ<a class=notranslate href=#3vector>vector</a>を初期化するために使用される<code>vec€</code>マクロを見たことがあります。</span> </p><br> <a class=notranslate href=#1vectors.html>vector</a> <br> <div data-lang=rust><div data-l="let x: Vec&lt;u32&gt; = vec![1, 2, 3];"></div><div data-l="# assert_eq!(x, [1, 2, 3]);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This can&#39;t be an ordinary function, because it takes any number of arguments.</span>任意の数の引数を取るので、これは普通の関数とすることはできません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But we can imagine it as syntactic shorthand for</span>しかし、それを構文上の簡略表現として想像することができます</span> </p><br><div data-lang=rust><div data-l="let x: Vec&lt;u32&gt; = {"></div><div data-l="    let mut temp_vec = Vec::new();"></div><div data-l="    temp_vec.push(1);"></div><div data-l="    temp_vec.push(2);"></div><div data-l="    temp_vec.push(3);"></div><div data-l="    temp_vec"></div><div data-l=};></div><div data-l="# assert_eq!(x, [1, 2, 3]);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can implement this shorthand, using a macro: <a class=notranslate href=#4^actual>^actual</a></span>この略式を、マクロを使って実装することができます： <a class=notranslate href=#4^actual>^actual</a></span> </p><br> <a class=notranslate href="#1The actual definition of `vec!` in libcollections differs from the">^actual</a> <p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">one presented here, for reasons of efficiency and reusability.</span>効率性と再利用性の理由からここに示したものです。</span> </p><br><div data-lang=rust><div data-l="macro_rules! vec {"></div><div data-l="    ( $( $x:expr ),* ) =&gt; {"></div><div data-l="        {"></div><div data-l="            let mut temp_vec = Vec::new();"></div><div data-l="            $("></div><div data-l="                temp_vec.push($x);"></div><div data-l="            )*"></div><div data-l="            temp_vec"></div><div data-l="        }"></div><div data-l="    };"></div><div data-l=}></div><div data-l="# fn main() {"></div><div data-l="#     assert_eq!(vec![1,2,3], [1, 2, 3]);"></div><div data-l="# }"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Whoa, that&#39;s a lot of new syntax!</span>うわー、それは新しい構文の多くです！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s break it down.</span>それを分解しましょう。</span> </p><br><div data-lang=rust,ignore><div data-l="macro_rules! vec { ... }"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This says we&#39;re defining a macro named <code>vec</code> , much as <code>fn vec</code> would define a function named <code>vec</code> .</span>これは、 <code>fn vec</code>が<code>vec</code>という名前の関数を定義するのと同じように、 <code>vec</code>という名前のマクロを定義していることを示しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In prose, we informally write a macro&#39;s name with an exclamation point, eg <code>vec€</code> .</span>散文では、私たちは非公式に感嘆符でマクロの名前を書いています。例えば<code>vec€</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The exclamation point is part of the invocation syntax and serves to distinguish a macro from an ordinary function.</span>感嘆符は、呼び出し構文の一部であり、マクロを通常の関数と区別するのに役立ちます。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Matching</span>マッチング</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The macro is defined through a series of rules, which are pattern-matching cases.</span>マクロは、パターンマッチングのケースである一連のルールによって定義されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Above, we had</span>上記のとおり、</span> </p><br><div data-lang=rust,ignore><div data-l="( $( $x:expr ),* ) =&gt; { ... };"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is like a <code>match</code> expression arm, but the matching happens on Rust syntax trees, at compile time.</span>これは<code>match</code>式のようなものですが、コンパイル時にRust構文ツリーで一致します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The semicolon is optional on the last (here, only) case.</span>セミコロンは、最後の（ここでは、唯一の）ケースではオプションです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The &quot;pattern&quot; on the left-hand side of <code>=&gt;</code> is known as a &#39;matcher&#39;.</span> <code>=&gt;</code>左側の「パターン」は「マッチャー」と呼ばれます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These have <a class=notranslate href="#4their own little grammar">their own little grammar</a> within the language.</span>これらは、言語内に<a class=notranslate href="#4their own little grammar">their own little grammar</a>持っ<a class=notranslate href="#4their own little grammar">their own little grammar</a>います。</span> </p><br> <a class=notranslate href=#1../../reference/macros.html>their own little grammar</a> <br> <p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The matcher <code>$x:expr</code> will match any Rust expression, binding that syntax tree to the &#39;metavariable&#39; <code>$x</code> .</span>正規表現<code>$x:expr</code>は任意のRust式にマッチし、その構文木を &#39;metavariable&#39; <code>$x</code>に束縛します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The identifier <code>expr</code> is a &#39;fragment specifier&#39;;</span>識別子<code>expr</code>は &#39;フラグメント指定子&#39;です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">the full possibilities are enumerated later in this chapter.</span>完全な可能性がこの章の後半に列挙されています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Surrounding the matcher with <code>$(...),*</code> will match zero or more expressions, separated by commas.</span>マッチャーを<code>$(...),*</code>囲むと、0個以上の式がカンマで区切られます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Aside from the special matcher syntax, any Rust tokens that appear in a matcher must match exactly.</span>特別なマッチャーの構文とは別に、マッチャーに表示される任意の錆トークンは正確に一致しなければなりません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example,</span>例えば、</span> </p><br><div data-lang=rust,ignore><div data-l="macro_rules! foo {"></div><div data-l="    (x =&gt; $e:expr) =&gt; (println!(&quot;mode X: {}&quot;, $e));"></div><div data-l="    (y =&gt; $e:expr) =&gt; (println!(&quot;mode Y: {}&quot;, $e));"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    foo!(y =&gt; 3);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">will print</span>印刷する</span> </p><br><div data-lang=text><div data-l="mode Y: 3"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">With</span>と</span> </p><br><div data-lang=rust,ignore><div data-l="foo!(z =&gt; 3);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">we get the compiler error</span>コンパイラエラーが発生する</span> </p><br><div data-lang=text><div data-l="error: no rules expected the token `z`"></div></div><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Expansion</span>拡張</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The right-hand side of a macro rule is ordinary Rust syntax, for the most part.</span>マクロルールの右側は、ほとんどの場合、普通のRust構文です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But we can splice in bits of syntax captured by the matcher.</span>しかし、マッチャーによって捕捉された構文のビットでスプライスすることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">From the original example:</span>元の例から：</span> </p><br><div data-lang=rust,ignore><div data-l=$(></div><div data-l="    temp_vec.push($x);"></div><div data-l=)*></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Each matched expression <code>$x</code> will produce a single <code>push</code> statement in the macro expansion.</span>一致した各式<code>$x</code>は、マクロ展開で単一の<code>push</code>文を生成します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The repetition in the expansion proceeds in &quot;lockstep&quot; with repetition in the matcher (more on this in a moment).</span>展開の繰り返しは、マッチャーの繰り返しで「ロックステップ」に進みます（詳細はこちら）。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because <code>$x</code> was already declared as matching an expression, we don&#39;t repeat <code>:expr</code> on the right-hand side.</span> <code>$x</code>はすでに式にマッチすると宣言されているので、繰り返しはしません<code>:expr</code>右側は<code>:expr</code>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Also, we don&#39;t include a separating comma as part of the repetition operator.</span>また、繰り返し演算子の一部としてコンマを区切ることもありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Instead, we have a terminating semicolon within the repeated block.</span>代わりに、繰り返しブロック内にセミコロンを終端します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Another detail: the <code>vec€</code> macro has <i>two</i> pairs of braces on the right-hand side.</span>もう1つの詳細： <code>vec€</code>マクロには、右側に<i>2</i>組のカッコがあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">They are often combined like so:</span>それらはしばしば以下のように組み合わされます：</span> </p><br><div data-lang=rust,ignore><div data-l="macro_rules! foo {"></div><div data-l="    () =&gt; {{"></div><div data-l="        ..."></div><div data-l="    }}"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The outer braces are part of the syntax of <code>macro_rules€</code> .</span>外側の中カッコは、 <code>macro_rules€</code>構文の<code>macro_rules€</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In fact, you can use <code>()</code> or <code>[]</code> instead.</span>実際には、代わりに<code>()</code>または<code>[]</code>使用できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">They simply delimit the right-hand side as a whole.</span>彼らは単に右側全体を区切ります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The inner braces are part of the expanded syntax.</span>内括弧は拡張構文の一部です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Remember, the <code>vec€</code> macro is used in an expression context.</span> <code>vec€</code>マクロは式のコンテキストで使用されることを覚えておいてください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To write an expression with multiple statements, including <code>let</code> -bindings, we use a block.</span> <code>let</code> -bindingsを含む複数のステートメントで式を書くには、ブロックを使います。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If your macro expands to a single expression, you don&#39;t need this extra layer of braces.</span>あなたのマクロが単一の式に展開されている場合、この追加の中括弧は必要ありません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that we never <i>declared</i> that the macro produces an expression.</span>マクロが式を生成する<i>と宣言</i>したことはありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In fact, this is not determined until we use the macro as an expression.</span>実際、これは式としてマクロを使用するまで決定されません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">With care, you can write a macro whose expansion works in several contexts.</span>注意して、いくつかのコンテキストで拡張が機能するマクロを書くことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, shorthand for a data type could be valid as either an expression or a pattern.</span>たとえば、データ型の省略形は、式またはパターンのいずれかとして有効です。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Repetition</span>繰り返し</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The repetition operator follows two principal rules:</span>繰り返し演算子は、2つの主要な規則に従います。</span> </p><br><div data-b=1.> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>$(...)*</code> walks through one &quot;layer&quot; of repetitions, for all of the <code>$name</code> s it contains, in lockstep, and</span> <code>$(...)*</code>は、反復の1つの「レイヤー」を通ります。そのレイヤーに含まれる<code>$name</code>のすべてについて、ロックステップで</span> </div><div data-b=2.> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">each <code>$name</code> must be under at least as many <code>$(...)*</code> s as it was matched against.</span>それぞれの<code>$name</code>は、少なくとも一致した<code>$(...)*</code> s以下でなければなりません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If it is under more, it&#39;ll be duplicated, as appropriate.</span>それ以上の場合は、必要に応じて複製されます。</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This baroque macro illustrates the duplication of variables from outer repetition levels.</span>このバロックマクロは、外部繰り返しレベルからの変数の重複を示しています。</span> </p><br><div data-lang=rust><div data-l="macro_rules! o_O {"></div><div data-l="    ("></div><div data-l="        $("></div><div data-l="            $x:expr; [ $( $y:expr ),* ]"></div><div data-l="        );*"></div><div data-l="    ) =&gt; {"></div><div data-l="        &amp;[ $($( $x + $y ),*),* ]"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let a: &amp;[i32]"></div><div data-l="        = o_O!(10; [1, 2, 3];"></div><div data-l="               20; [4, 5, 6]);"></div><div data-l=""></div><div data-l="    assert_eq!(a, [11, 12, 13, 24, 25, 26]);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That&#39;s most of the matcher syntax.</span>それはマッチャーの構文の大部分です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These examples use <code>$(...)*</code> , which is a &quot;zero or more&quot; match.</span>これらの例では、 <code>$(...)*</code>使用してい<code>$(...)*</code>これは、「0以上の」一致です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Alternatively you can write <code>$(...)+</code> for a &quot;one or more&quot; match.</span>あるいは、「1つ以上の」一致に対して<code>$(...)+</code>を書くことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Both forms optionally include a separator, which can be any token except <code>+</code> or <code>*</code> .</span>両方の書式には、セパレータがオプションで含まれています。セパレータには、 <code>+</code>または<code>*</code>以外のトークンを使用できます</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This system is based on &quot; <a class=notranslate href=#2https://www.cs.indiana.edu/ftp/techreports/TR206.pdf>Macro-by-Example</a> &quot; (PDF link).</span>このシステムは、「 <a class=notranslate href=#2https://www.cs.indiana.edu/ftp/techreports/TR206.pdf>Macro-by-Example</a> 」（PDFリンク）に基づいています。</span> </p><br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Hygiene</span>衛生</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Some languages implement macros using simple text substitution, which leads to various problems.</span>いくつかの言語は、単純なテキスト置換を使用してマクロを実装するため、さまざまな問題が発生します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, this C program prints <code>13</code> instead of the expected <code>25</code> .</span>たとえば、このCプログラムは、予想される<code>25</code>代わりに<code>13</code>を出力します。</span> </p><br><div data-lang=text><div data-l="#define FIVE_TIMES(x) 5 * x"></div><div data-l=""></div><div data-l="int main() {"></div><div data-l="    printf(&quot;%d\n&quot;, FIVE_TIMES(2 + 3));"></div><div data-l="    return 0;"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">After expansion we have <code>5 * 2 + 3</code> , and multiplication has greater precedence than addition.</span>展開後、 <code>5 * 2 + 3</code>となり、乗算は加算より優先されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you&#39;ve used C macros a lot, you probably know the standard idioms for avoiding this problem, as well as five or six others.</span> Cマクロをたくさん使ったことがあるなら、おそらくこの問題を回避するための標準的なイディオムと、5つまたは6つの他のものを知っているでしょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In Rust, we don&#39;t have to worry about it.</span> Rustでは、心配する必要はありません。</span> </p><br><div data-lang=rust><div data-l="macro_rules! five_times {"></div><div data-l="    ($x:expr) =&gt; (5 * $x);"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    assert_eq!(25, five_times!(2 + 3));"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The metavariable <code>$x</code> is parsed as a single expression node, and keeps its place in the syntax tree even after substitution.</span>メタ変数<code>$x</code>は単一の式ノードとして解析され、置換後も構文木にその場所を保持します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Another common problem in macro systems is &#39;variable capture&#39;.</span>マクロシステムにおけるもう一つの共通の問題は、「変数キャプチャ」です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here&#39;s a C macro using a block with multiple statements.</span>以下は、複数のステートメントを含むブロックを使用するCマクロです。</span> </p><br><div data-lang=text><div data-l="#define LOG(msg) do { \"></div><div data-l="    int state = get_log_state(); \"></div><div data-l="    if (state &gt; 0) { \"></div><div data-l="        printf(&quot;log(%d): %s\n&quot;, state, msg); \"></div><div data-l="    } \"></div><div data-l="} while (0)"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here&#39;s a simple use case that goes terribly wrong:</span>ひどく間違っている単純なユースケースがあります：</span> </p><br><div data-lang=text><div data-l="const char *state = &quot;reticulating splines&quot;;"></div><div data-l=LOG(state);></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This expands to</span>これは</span> </p><br><div data-lang=text><div data-l="const char *state = &quot;reticulating splines&quot;;"></div><div data-l="do {"></div><div data-l="    int state = get_log_state();"></div><div data-l="    if (state &gt; 0) {"></div><div data-l="        printf(&quot;log(%d): %s\n&quot;, state, state);"></div><div data-l="    }"></div><div data-l="} while (0);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The second variable named <code>state</code> shadows the first one.</span> <code>state</code>という名前の2番目の変数は、最初の変数をシャドウします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is a problem because the print statement should refer to both of them.</span>これは、print文が両方を参照する必要があるため、問題です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The equivalent Rust macro has the desired behavior.</span>同等のRustマクロは、望ましい動作をします。</span> </p><br><div data-lang=rust><div data-l="# fn get_log_state() -&gt; i32 { 3 }"></div><div data-l="macro_rules! log {"></div><div data-l="    ($msg:expr) =&gt; {{"></div><div data-l="        let state: i32 = get_log_state();"></div><div data-l="        if state &gt; 0 {"></div><div data-l="            println!(&quot;log({}): {}&quot;, state, $msg);"></div><div data-l="        }"></div><div data-l="    }};"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let state: &amp;str = &quot;reticulating splines&quot;;"></div><div data-l="    log!(state);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This works because Rust has a <a class=notranslate href="#4hygienic macro system">hygienic macro system</a> .</span>これは、Rustが<a class=notranslate href="#4hygienic macro system">hygienic macro system</a>持っているために<a class=notranslate href="#4hygienic macro system">hygienic macro system</a>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Each macro expansion happens in a distinct &#39;syntax context&#39;, and each variable is tagged with the syntax context where it was introduced.</span>それぞれのマクロ展開は別々の「構文コンテキスト」で行われ、各変数にはその構文コンテキストがタグ付けされています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It&#39;s as though the variable <code>state</code> inside <code>main</code> is painted a different &quot;color&quot; from the variable <code>state</code> inside the macro, and therefore they don&#39;t conflict.</span>変数かのようです<code>state</code>内部の<code>main</code>変数と異なる「色」塗られている<code>state</code>マクロ内で、そのため彼らは競合しません。</span> </p><br> <a class=notranslate href=#1https://en.wikipedia.org/wiki/Hygienic_macro>hygienic macro system</a> <br> <p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This also restricts the ability of macros to introduce new bindings at the invocation site.</span>これはまた、呼び出しサイトで新しいバインディングを導入するマクロの機能を制限します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Code such as the following will not work:</span>次のようなコードは機能しません。</span> </p><br><div data-lang=rust,ignore><div data-l="macro_rules! foo {"></div><div data-l="    () =&gt; (let x = 3;);"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    foo!();"></div><div data-l="    println!(&quot;{}&quot;, x);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Instead you need to pass the variable name into the invocation, so that it&#39;s tagged with the right syntax context.</span>代わりに、変数名を呼び出しに渡す必要があります。そのため、正しい構文コンテキストでタグ付けされます。</span> </p><br><div data-lang=rust><div data-l="macro_rules! foo {"></div><div data-l="    ($v:ident) =&gt; (let $v = 3;);"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    foo!(x);"></div><div data-l="    println!(&quot;{}&quot;, x);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This holds for <code>let</code> bindings and loop labels, but not for <a class=notranslate href=#3items>items</a> .</span> <code>let</code>バインディングとループラベルは保持<code>let</code>ますが、 <a class=notranslate href=#3items>items</a>は保持されません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So the following code does compile:</span>したがって、次のコードはコンパイルされます。</span> </p><br><div data-lang=rust><div data-l="macro_rules! foo {"></div><div data-l="    () =&gt; (fn x() { });"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    foo!();"></div><div data-l="    x();"></div><div data-l=}></div></div><br> <a class=notranslate href=#1../../reference/items.html>items</a> <br> <h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Recursive macros</span>再帰マクロ</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A macro&#39;s expansion can include more macro invocations, including invocations of the very same macro being expanded.</span>マクロの展開には、同じマクロの呼び出しを拡張するなど、より多くのマクロ呼び出しを含めることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These recursive macros are useful for processing tree-structured input, as illustrated by this (simplistic) HTML shorthand:</span>これらの再帰マクロは、ツリー構造の入力を処理するのに便利です。</span> </p><br><div data-lang=rust><div data-l="# #![allow(unused_must_use)]"></div><div data-l="macro_rules! write_html {"></div><div data-l="    ($w:expr, ) =&gt; (());"></div><div data-l=""></div><div data-l="    ($w:expr, $e:tt) =&gt; (write!($w, &quot;{}&quot;, $e));"></div><div data-l=""></div><div data-l="    ($w:expr, $tag:ident [ $($inner:tt)* ] $($rest:tt)*) =&gt; {{"></div><div data-l="        write!($w, &quot;&lt;{}&gt;&quot;, stringify!($tag));"></div><div data-l="        write_html!($w, $($inner)*);"></div><div data-l="        write!($w, &quot;&lt;/{}&gt;&quot;, stringify!($tag));"></div><div data-l="        write_html!($w, $($rest)*);"></div><div data-l="    }};"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="#//#   // FIXME(#21826)"></div><div data-l="#   // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">FIXME(#21826)</span> FIXME（＃21826）</span> </div><div data-l="    use std::fmt::Write;"></div><div data-l="    let mut out = String::new();"></div><div data-l=""></div><div data-l="    write_html!(&amp;mut out,"></div><div data-l="        html["></div><div data-l="            head[title[&quot;Macros guide&quot;]]"></div><div data-l="            body[h1[&quot;Macros are the best!&quot;]]"></div><div data-l="        ]);"></div><div data-l=""></div><div data-l="    assert_eq!(out,"></div><div data-l="        &quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;Macros guide&lt;/title&gt;&lt;/head&gt;\"></div><div data-l="         &lt;body&gt;&lt;h1&gt;Macros are the best!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&quot;);"></div><div data-l=}></div></div><br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Debugging macro code</span>マクロコードのデバッグ</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To see the results of expanding macros, run <code>rustc --pretty expanded</code> .</span>マクロを展開した結果を見るには、 <code>rustc --pretty expanded</code>実行します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The output represents a whole crate, so you can also feed it back in to <code>rustc</code> , which will sometimes produce better error messages than the original compilation.</span>出力はクレート全体を表しているので、元のコンパイルよりも優れたエラーメッセージを生成する<code>rustc</code>フィードバックすることもできます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that the <code>--pretty expanded</code> output may have a different meaning if multiple variables of the same name (but different syntax contexts) are in play in the same scope.</span>同じ名前の複数の変数（構文コンテキストは異なる）が同じスコープ内で動作している場合、-- <code>--pretty expanded</code>出力は異なる意味を持つことに注意してください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this case <code>--pretty expanded,hygiene</code> will tell you about the syntax contexts.</span>この場合、-- <code>--pretty expanded,hygiene</code>は構文コンテキストについて教えてくれます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>rustc</code> provides two syntax extensions that help with macro debugging.</span> <code>rustc</code>は、マクロデバッグに役立つ2つの構文拡張を提供します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For now, they are unstable and require feature gates.</span>今のところ、それらは不安定であり、機能ゲートが必要です。</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>log_syntax€(...)</code> will print its arguments to standard output, at compile time, and &quot;expand&quot; to nothing.</span> <code>log_syntax€(...)</code>はコンパイル時に引数を標準出力に出力し、何も展開しません。</span> </div><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>trace_macros€(true)</code> will enable a compiler message every time a macro is expanded.</span> <code>trace_macros€(true)</code>は、マクロが展開されるたびにコンパイラのメッセージを有効にします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Use <code>trace_macros€(false)</code> later in expansion to turn it off.</span>後で展開時に<code>trace_macros€(false)</code>使用してオフにします。</span> </div><br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Syntactic requirements</span>構文上の要件</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Even when Rust code contains un-expanded macros, it can be parsed as a full <a href=#3ast>syntax tree</a> .</span> Rustコードに展開されていないマクロが含まれていても、完全な<a href=#3ast>構文ツリー</a>として解析できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This property can be very useful for editors and other tools that process code.</span>このプロパティは、コードを処理するエディタやその他のツールに非常に便利です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It also has a few consequences for the design of Rust&#39;s macro system.</span>また、Rustのマクロシステムの設計にはいくつかの影響があります。</span> </p><br> <a class=notranslate href=#1glossary.html#abstract-syntax-tree>ast</a> <br> <p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">One consequence is that Rust must determine, when it parses a macro invocation, whether the macro stands in for</span> 1つの結果として、Rustは、マクロの呼び出しを解析するときに、マクロが</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">zero or more items,</span>ゼロ個以上のアイテム、</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">zero or more methods,</span>ゼロ個以上のメソッド、</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">an expression,</span>表現、</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">a statement, or</span>ステートメント、または</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">a pattern.</span>パターン。</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A macro invocation within a block could stand for some items, or for an expression / statement.</span>ブロック内でのマクロ呼び出しは、いくつかの項目や式/ステートメントを表す可能性があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust uses a simple rule to resolve this ambiguity.</span>錆はこのあいまいさを解決するために単純なルールを使用します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A macro invocation that stands for items must be either</span>項目を表すマクロ呼び出しは、</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">delimited by curly braces, eg <code>foo€ { ... }</code> , or</span>中括弧で区切られたもの、例えば<code>foo€ { ... }</code> 、または</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">terminated by a semicolon, eg <code>foo€(...);</code></span>セミコロンで終わる、例えば<code>foo€(...);</code></span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Another consequence of pre-expansion parsing is that the macro invocation must consist of valid Rust tokens.</span>拡張前解析の別の結果は、マクロ呼び出しが有効な錆トークンで構成されていなければならないということです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Furthermore, parentheses, brackets, and braces must be balanced within a macro invocation.</span>さらに、かっこ、角かっこ、および中かっこは、マクロ呼び出し内でバランスをとる必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, <code>foo€([)</code> is forbidden.</span>たとえば、 <code>foo€([)</code>は禁止されています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This allows Rust to know where the macro invocation ends.</span>これにより、Rustはマクロの呼び出しがどこで終了するかを知ることができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">More formally, the macro invocation body must be a sequence of &#39;token trees&#39;.</span>より正式には、マクロ呼び出し本体は一連の &#39;トークンツリー&#39;でなければなりません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A token tree is defined recursively as either</span>トークンツリーは再帰的に</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">a sequence of token trees surrounded by matching <code>()</code> , <code>[]</code> , or <code>{}</code> , or</span> matching <code>()</code> 、 <code>[]</code> 、または<code>{}</code>で囲まれた一連のトークンツリー、または</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">any other single token.</span>他の単一のトークン。</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Within a matcher, each metavariable has a &#39;fragment specifier&#39;, identifying which syntactic form it matches.</span>マッチャー内では、各メタ変数には、それが一致する構文形式を識別する「フラグメント指定子」があります。</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>ident</code> : an identifier.</span> <code>ident</code> ：識別子。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Examples: <code>x</code> ;</span>例： <code>x</code> ;</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>foo</code> .</span> <code>foo</code> 。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>path</code> : a qualified name.</span> <code>path</code> ：修飾された名前。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Example: <code>T::SpecialA</code> .</span>例： <code>T::SpecialA</code> 。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>expr</code> : an expression.</span> <code>expr</code> ：式。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Examples: <code>2 + 2</code> ;</span>例： <code>2 + 2</code> ;</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>if true { 1 } else { 2 }</code> ;</span> <code>if true { 1 } else { 2 }</code> ;</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>f(42)</code> .</span> <code>f(42)</code> 。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>ty</code> : a type.</span> <code>ty</code> ：タイプ。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Examples: <code>i32</code> ;</span>例： <code>i32</code> ;</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>Vec&lt;(char, String)&gt;</code> ;</span> <code>Vec&lt;(char, String)&gt;</code> ;</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>&amp;T</code> .</span> <code>&amp;T</code> 。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>pat</code> : a pattern.</span> <code>pat</code> ：パターン。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Examples: <code>Some(t)</code> ;</span>例： <code>Some(t)</code> ;</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>(17, &#39;a&#39;)</code> ;</span> <code>(17, &#39;a&#39;)</code> ;</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>_</code> .</span> <code>_</code> 。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>stmt</code> : a single statement.</span> <code>stmt</code> ：単一のステートメント。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Example: <code>let x = 3</code> .</span>例： <code>let x = 3</code> 。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>block</code> : a brace-delimited sequence of statements and optionally an expression.</span> <code>block</code> ：中括弧で区切られた一連のステートメントとオプションで式。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Example: <code>{ log(error, &quot;hi&quot;); return 12; }</code></span>例： <code>{ log(error, &quot;hi&quot;); return 12; }</code></span> <code>{ log(error, &quot;hi&quot;); return 12; }</code> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>{ log(error, &quot;hi&quot;); return 12; }</code> .</span> <code>{ log(error, &quot;hi&quot;); return 12; }</code> 。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>item</code> : an <a class=notranslate href=#3item>item</a> .</span> <code>item</code> ： <a class=notranslate href=#3item>item</a> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Examples: <code>fn foo() { }</code> ;</span>例： <code>fn foo() { }</code> ;</span> <code>struct Bar;</code> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">.</span> 。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>meta</code> : a &quot;meta item&quot;, as found in attributes.</span> <code>meta</code> ：属性にある「メタアイテム」。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Example: <code>cfg(target_os = &quot;windows&quot;)</code> .</span>例： <code>cfg(target_os = &quot;windows&quot;)</code> 。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>tt</code> : a single token tree.</span> <code>tt</code> ：単一のトークンツリー。</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There are additional rules regarding the next token after a metavariable:</span>メタ変数の後の次のトークンに関する追加の規則があります。</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>expr</code> and <code>stmt</code> variables may only be followed by one of: <code>=&gt; , ;</code></span> <code>expr</code>および<code>stmt</code>変数の後には、 <code>=&gt; , ;</code> <code>stmt</code></span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>ty</code> and <code>path</code> variables may only be followed by one of: <code>=&gt; , = | ; : &gt; [ { as where</code></span> <code>ty</code>と<code>path</code>変数の後には、 <code>=&gt; , = | ; : &gt; [ { as where</code></span> <code>=&gt; , = | ; : &gt; [ { as where</code> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>pat</code> variables may only be followed by one of: <code>=&gt; , = | if in</code></span> <code>pat</code>変数の後には、次のいずれかが続くことがあります。 <code>=&gt; , = | if in</code></span> <code>=&gt; , = | if in</code> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Other variables may be followed by any token.</span>他の変数には任意のトークンを続けることができます。</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These rules provide some flexibility for Rust&#39;s syntax to evolve without breaking existing macros.</span>これらのルールは、Rustの構文が既存のマクロを壊さずに進化するための柔軟性を提供します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The macro system does not deal with parse ambiguity at all.</span>マクロシステムは解析のあいまいさをまったく扱っていません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, the grammar <code>$($i:ident)* $e:expr</code> will always fail to parse, because the parser would be forced to choose between parsing <code>$i</code> and parsing <code>$e</code> .</span>たとえば、文法<code>$($i:ident)* $e:expr</code>は、構文解析に失敗します。なぜなら、構文解析プログラムは<code>$i</code>解析と<code>$e</code>解析のどちらかを選択する必要があるからです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Changing the invocation syntax to put a distinctive token in front can solve the problem.</span>特有のトークンを前に置くように呼び出し構文を変更することで、問題を解決できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this case, you can write <code>$(I $i:ident)* E $e:expr</code> .</span>この場合、 <code>$(I $i:ident)* E $e:expr</code>書くことができます。</span> </p><br> <a class=notranslate href=#1../../reference/items.html>item</a> <br> <h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Scoping and macro import/export</span>スコーピングとマクロのインポート/エクスポート</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Macros are expanded at an early stage in compilation, before name resolution.</span>マクロは名前解決の前に、コンパイルの初期段階で展開されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">One downside is that scoping works differently for macros, compared to other constructs in the language.</span> 1つの欠点は、言語の他の構文と比較して、マクロのスコープが異なることです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Definition and expansion of macros both happen in a single depth-first, lexical-order traversal of a crate&#39;s source.</span>マクロの定義と拡張の両方は、クレートのソースの深さ優先、字句順トラバーサルで行われます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So a macro defined at module scope is visible to any subsequent code in the same module, which includes the body of any subsequent child <code>mod</code> items.</span>そのため、モジュールスコープで定義されたマクロは、後続の子<code>mod</code>アイテムのボディを含む同じモジュール内の後続のコードから見えます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you want to use your macro, which is defined in a different module, you need to use <code>macro_use</code> attribute <i>before</i> using the macro.</span>別のモジュールで定義されているマクロを使用する場合は、マクロを使用する<i>前に</i> <code>macro_use</code>属性を使用する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s say our macros are defined in module <code>macros</code> and we would like to use them inside module <code>client</code> .</span>私たちのマクロはモジュール<code>macros</code>定義されており、モジュール<code>client</code>内で使用したいとしましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is the required module definition order:</span>これは必須のモジュール定義順序です：</span> </p><br><div data-lang=rust><div data-l=#[macro_use]></div><div data-l="mod macros;"></div><div data-l="mod client;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The opposite order would result in a compilation failure:</span>逆の順序でコンパイルに失敗します。</span> </p><br><div data-lang=rust><div data-l="mod client;"></div><div data-l=#[macro_use]></div><div data-l="mod macros;"></div></div><br><div data-lang=bash><div data-l="error: cannot find macro `my_macro!` in this scope"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A macro defined within the body of a single <code>fn</code> , or anywhere else not at module scope, is visible only within that item.</span>単一の<code>fn</code>ボディー内に定義されたマクロ、またはモジュールスコープではない他の場所にあるマクロは、その項目内でのみ表示されます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If a module has the <code>macro_use</code> attribute, its macros are also visible in its parent module after the child&#39;s <code>mod</code> item.</span>モジュールがある場合は<code>macro_use</code>属性を、そのマクロは、子の後に親モジュールにも表示されている<code>mod</code>のアイテム。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If the parent also has <code>macro_use</code> then the macros will be visible in the grandparent after the parent&#39;s <code>mod</code> item, and so forth.</span>親にも<code>macro_use</code>場合、マクロは親の<code>mod</code>項目の後に祖父母で表示されます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>macro_use</code> attribute can also appear on <code>extern crate</code> .</span> <code>macro_use</code>属性は、 <code>extern crate</code> <code>macro_use</code>にも表示されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this context it controls which macros are loaded from the external crate, eg</span>このコンテキストでは、外部クレートからロードされるマクロを制御します。</span> </p><br><div data-lang=rust,ignore><div data-l="#[macro_use(foo, bar)]"></div><div data-l="extern crate baz;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If the attribute is given simply as <code>#[macro_use]</code> , all macros are loaded.</span>属性に<code>#[macro_use]</code>と指定した場合、すべてのマクロがロードされます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If there is no <code>#[macro_use]</code> attribute then no macros are loaded.</span> <code>#[macro_use]</code>属性がない場合、マクロはロードされません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Only macros defined with the <code>#[macro_export]</code> attribute may be loaded.</span> <code>#[macro_export]</code>属性で定義されたマクロだけが読み込まれます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To load a crate&#39;s macros without linking it into the output, use <code>#[no_link]</code> as well.</span>クレートのマクロを出力にリンクせずに読み込むには<code>#[no_link]</code>も使用します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">An example:</span>例：</span> </p><br><div data-lang=rust><div data-l="macro_rules! m1 { () =&gt; (()) }"></div><div data-l=""></div><div data-l="#// Visible here: `m1`."></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Visible here: <code>m1</code> .</span>ここに表示されます： <code>m1</code> 。</span> </div><div data-l=""></div><div data-l="mod foo {"></div><div data-l="#    // Visible here: `m1`."></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Visible here: <code>m1</code> .</span>ここに表示されます： <code>m1</code> 。</span> </div><div data-l=""></div><div data-l="    #[macro_export]"></div><div data-l="    macro_rules! m2 { () =&gt; (()) }"></div><div data-l=""></div><div data-l="#    // Visible here: `m1`, `m2`."></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Visible here: <code>m1</code> , <code>m2</code> .</span>ここに表示されます： <code>m1</code> 、 <code>m2</code> 。</span> </div><div data-l=}></div><div data-l=""></div><div data-l="#// Visible here: `m1`."></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Visible here: <code>m1</code> .</span>ここに表示されます： <code>m1</code> 。</span> </div><div data-l=""></div><div data-l="macro_rules! m3 { () =&gt; (()) }"></div><div data-l=""></div><div data-l="#// Visible here: `m1`, `m3`."></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Visible here: <code>m1</code> , <code>m3</code> .</span>ここに表示されます： <code>m1</code> 、 <code>m3</code> 。</span> </div><div data-l=""></div><div data-l=#[macro_use]></div><div data-l="mod bar {"></div><div data-l="#    // Visible here: `m1`, `m3`."></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Visible here: <code>m1</code> , <code>m3</code> .</span>ここに表示されます： <code>m1</code> 、 <code>m3</code> 。</span> </div><div data-l=""></div><div data-l="    macro_rules! m4 { () =&gt; (()) }"></div><div data-l=""></div><div data-l="#    // Visible here: `m1`, `m3`, `m4`."></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Visible here: <code>m1</code> , <code>m3</code> , <code>m4</code> .</span>ここに表示されます： <code>m1</code> 、 <code>m3</code> 、 <code>m4</code> 。</span> </div><div data-l=}></div><div data-l=""></div><div data-l="#// Visible here: `m1`, `m3`, `m4`."></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Visible here: <code>m1</code> , <code>m3</code> , <code>m4</code> .</span>ここに表示されます： <code>m1</code> 、 <code>m3</code> 、 <code>m4</code> 。</span> </div><div data-l="# fn main() { }"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When this library is loaded with <code>#[macro_use] extern crate</code> , only <code>m2</code> will be imported.</span>このライブラリに<code>#[macro_use] extern crate</code>がロードされると、 <code>m2</code>だけがインポートされます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The Rust Reference has a <a href=#2../../reference/attributes.html#macro-related-attributes>listing of macro-related attributes</a> .</span> Rust Referenceには、 <a href=#2../../reference/attributes.html#macro-related-attributes>マクロ関連の属性のリストがあります</a> 。</span> </p><br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The variable <code>$crate</code></span>変数<code>$crate</code></span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A further difficulty occurs when a macro is used in multiple crates.</span>マクロが複数のクレートで使用される場合、さらに難しい問題が発生します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Say that <code>mylib</code> defines</span> <code>mylib</code>定義すると言う</span> </p><br><div data-lang=rust><div data-l="pub fn increment(x: u32) -&gt; u32 {"></div><div data-l="    x + 1"></div><div data-l=}></div><div data-l=""></div><div data-l=#[macro_export]></div><div data-l="macro_rules! inc_a {"></div><div data-l="    ($x:expr) =&gt; ( ::increment($x) )"></div><div data-l=}></div><div data-l=""></div><div data-l=#[macro_export]></div><div data-l="macro_rules! inc_b {"></div><div data-l="    ($x:expr) =&gt; ( ::mylib::increment($x) )"></div><div data-l=}></div><div data-l="# fn main() { }"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>inc_a</code> only works within <code>mylib</code> , while <code>inc_b</code> only works outside the library.</span> <code>inc_a</code>内でのみ動作します<code>mylib</code>ながら、 <code>inc_b</code>唯一のライブラリーの外に動作します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Furthermore, <code>inc_b</code> will break if the user imports <code>mylib</code> under another name.</span>さらに、ユーザーが別の名前で<code>mylib</code>をインポートすると、 <code>inc_b</code>が壊れます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust does not (yet) have a hygiene system for crate references, but it does provide a simple workaround for this problem.</span>錆は、（まだ）箱の参照のための衛生システムを持っていませんが、この問題の簡単な回避策を提供しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Within a macro imported from a crate named <code>foo</code> , the special macro variable <code>$crate</code> will expand to <code>::foo</code> .</span> <code>foo</code>という名前の木枠からインポートされたマクロ内で、特別なマクロ変数<code>$crate</code>は<code>::foo</code>展開されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">By contrast, when a macro is defined and then used in the same crate, <code>$crate</code> will expand to nothing.</span>対照的に、マクロが定義され、同じ枠で使用されると、 <code>$crate</code>は何も展開しません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This means we can write</span>これは、</span> </p><br><div data-lang=rust><div data-l=#[macro_export]></div><div data-l="macro_rules! inc {"></div><div data-l="    ($x:expr) =&gt; ( $crate::increment($x) )"></div><div data-l=}></div><div data-l="# fn main() { }"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">to define a single macro that works both inside and outside our library.</span>私たちのライブラリの内部と外部の両方で動作する単一のマクロを定義します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The function name will expand to either <code>::increment</code> or <code>::mylib::increment</code> .</span>関数名は<code>::increment</code>または<code>::mylib::increment</code>展開され<code>::mylib::increment</code> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To keep this system simple and correct, <code>#[macro_use] extern crate ...</code> may only appear at the root of your crate, not inside <code>mod</code> .</span>このシステムをシンプルで正確に保つために、 <code>#[macro_use] extern crate ...</code>はあなたのクレートのルートにのみ表示され、 <code>mod</code>では表示されません。</span> </p><br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The deep end</span>深い終わり</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The introductory chapter mentioned recursive macros, but it did not give the full story.</span>入門の章では再帰マクロについて述べましたが、それは完全な話を与えませんでした。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Recursive macros are useful for another reason: Each recursive invocation gives you another opportunity to pattern-match the macro&#39;s arguments.</span>再帰マクロは別の理由で便利です：再帰呼び出しのたびに、マクロの引数にパターンマッチする別の機会が与えられます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As an extreme example, it is possible, though hardly advisable, to implement the <a href=#2https://esolangs.org/wiki/Bitwise_Cyclic_Tag>Bitwise Cyclic Tag</a> automaton within Rust&#39;s macro system.</span>極端な例として、Rustのマクロシステム内で<a href=#2https://esolangs.org/wiki/Bitwise_Cyclic_Tag>Bitwise Cyclic Tag</a>オートマトンを実装することは、ほとんどお勧めできませんが、可能です。</span> </p><br><div data-lang=rust><div data-l="macro_rules! bct {"></div><div data-l="#    // cmd 0:  d ... =&gt; ..."></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">cmd 0: d ... =&gt; ...</span> cmd 0：d ... =&gt; ...</span> </div><div data-l="    (0, $($ps:tt),* ; $_d:tt)"></div><div data-l="        =&gt; (bct!($($ps),*, 0 ; ));"></div><div data-l="    (0, $($ps:tt),* ; $_d:tt, $($ds:tt),*)"></div><div data-l="        =&gt; (bct!($($ps),*, 0 ; $($ds),*));"></div><div data-l=""></div><div data-l="#    // cmd 1p:  1 ... =&gt; 1 ... p"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">cmd 1p: 1 ... =&gt; 1 ... p</span> cmd 1p：1 ... =&gt; 1 ... p</span> </div><div data-l="    (1, $p:tt, $($ps:tt),* ; 1)"></div><div data-l="        =&gt; (bct!($($ps),*, 1, $p ; 1, $p));"></div><div data-l="    (1, $p:tt, $($ps:tt),* ; 1, $($ds:tt),*)"></div><div data-l="        =&gt; (bct!($($ps),*, 1, $p ; 1, $($ds),*, $p));"></div><div data-l=""></div><div data-l="#    // cmd 1p:  0 ... =&gt; 0 ..."></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">cmd 1p: 0 ... =&gt; 0 ...</span> cmd 1p：0 ... =&gt; 0 ...</span> </div><div data-l="    (1, $p:tt, $($ps:tt),* ; $($ds:tt),*)"></div><div data-l="        =&gt; (bct!($($ps),*, 1, $p ; $($ds),*));"></div><div data-l=""></div><div data-l="#    // Halt on empty data string:"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Halt on empty data string:</span>空のデータ文字列で停止：</span> </div><div data-l="    ( $($ps:tt),* ; )"></div><div data-l="        =&gt; (());"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Exercise: use macros to reduce duplication in the above definition of the <code>bct€</code> macro.</span>エクササイズ：マクロを使用して、上記の<code>bct€</code>マクロの定義における重複を減らします。</span> </p><br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Common macros</span>一般的なマクロ</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here are some common macros you&#39;ll see in Rust code.</span> Rustコードで表示される一般的なマクロをいくつか紹介します。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">panic!</span>パニック！</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This macro causes the current thread to panic.</span>このマクロは、現在のスレッドにパニックを引き起こします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can give it a message to panic with:</span>あなたはそれにパニックにメッセージを与えることができます：</span> </p><br><div data-lang=rust,should_panic><div data-l="panic!(&quot;oh no!&quot;);"></div></div><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">vec!</span> vec！</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>vec€</code> macro is used throughout the book, so you&#39;ve probably seen it already.</span> <code>vec€</code>マクロは本の中で使われているので、すでに見たことがあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It creates <code>Vec&lt;T&gt;</code> s with ease:</span> <code>Vec&lt;T&gt;</code>を簡単に作成します。</span> </p><br><div data-lang=rust><div data-l="let v = vec![1, 2, 3, 4, 5];"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It also lets you make vectors with repeating values.</span>繰り返し値を持つベクトルを作成することもできます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, a hundred zeroes:</span>たとえば、100個のゼロ：</span> </p><br><div data-lang=rust><div data-l="let v = vec![0; 100];"></div></div><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">assert!</span>アサート！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">and assert_eq!</span> assert_eq！</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These two macros are used in tests.</span>これらの2つのマクロはテストで使用されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>assert€</code> takes a boolean.</span> <code>assert€</code>はブール値を取る。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>assert_eq€</code> takes two values and checks them for equality.</span> <code>assert_eq€</code>は2つの値をとり、それらが等しいかどうかをチェックします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>true</code> passes, <code>false</code> <code>panic€</code> s.</span> <code>true</code>パス、 <code>false</code> <code>panic€</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Like this:</span>このような：</span> </p><br><div data-lang=rust,should_panic><div data-l="#// A-ok!"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A-ok!</span>いいよ！</span> </div><div data-l=""></div><div data-l=assert!(true);></div><div data-l="assert_eq!(5, 3 + 2);"></div><div data-l=""></div><div data-l="#// Nope :("></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Nope :(</span>いいえ:(</span> </div><div data-l=""></div><div data-l="assert!(5 &lt; 3);"></div><div data-l="assert_eq!(5, 3);"></div></div><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">try!</span>試してみて！</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>try€</code> is used for error handling.</span>エラー処理のために<code>try€</code>が使用されています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It takes something that can return a <code>Result&lt;T, E&gt;</code> , and gives <code>T</code> if it&#39;s a <code>Ok&lt;T&gt;</code> , and <code>return</code> s with the <code>Err(E)</code> if it&#39;s that.</span> <code>Result&lt;T, E&gt;</code>返すことができ、 <code>Ok&lt;T&gt;</code>の場合は<code>T</code>を<code>return</code> 、それが<code>Err(E)</code>場合はsを<code>return</code>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Like this:</span>このような：</span> </p><br><div data-lang=rust,no_run><div data-l="use std::fs::File;"></div><div data-l=""></div><div data-l="fn foo() -&gt; std::io::Result&lt;()&gt; {"></div><div data-l="    let f = try!(File::create(&quot;foo.txt&quot;));"></div><div data-l=""></div><div data-l="    Ok(())"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is cleaner than doing this:</span>これはこれを行うよりもきれいです：</span> </p><br><div data-lang=rust,no_run><div data-l="use std::fs::File;"></div><div data-l=""></div><div data-l="fn foo() -&gt; std::io::Result&lt;()&gt; {"></div><div data-l="    let f = File::create(&quot;foo.txt&quot;);"></div><div data-l=""></div><div data-l="    let f = match f {"></div><div data-l="        Ok(t) =&gt; t,"></div><div data-l="        Err(e) =&gt; return Err(e),"></div><div data-l="    };"></div><div data-l=""></div><div data-l="    Ok(())"></div><div data-l=}></div></div><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">unreachable!</span>到達不能！</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This macro is used when you think some code should never execute:</span>このマクロは、コードを決して実行しないと思うときに使用されます：</span> </p><br><div data-lang=rust><div data-l="if false {"></div><div data-l="    unreachable!();"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Sometimes, the compiler may make you have a different branch that you know will never, ever run.</span>時には、コンパイラはあなたが決して実行することのない別のブランチを持つようにするかもしれません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In these cases, use this macro, so that if you end up wrong, you&#39;ll get a <code>panic€</code> about it.</span>このような場合は、このマクロを使用してください。間違ってしまうと、そのマクロについて<code>panic€</code>ことがあります。</span> </p><br><div data-lang=rust><div data-l="let x: Option&lt;i32&gt; = None;"></div><div data-l=""></div><div data-l="match x {"></div><div data-l="    Some(_) =&gt; unreachable!(),"></div><div data-l="    None =&gt; println!(&quot;I know x is None!&quot;),"></div><div data-l=}></div></div><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">unimplemented!</span>実装されていない！</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>unimplemented€</code> macro can be used when you&#39;re trying to get your functions to typecheck, and don&#39;t want to worry about writing out the body of the function.</span> <code>unimplemented€</code>されていないマクロは、関数の型チェックをしようとしているときに使用することができます。また、関数本体の書き出しを心配する必要もありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">One example of this situation is implementing a trait with multiple required methods, where you want to tackle one at a time.</span>この状況の1つの例は、一度に1つずつ取り組む必要のある、複数の必須メソッドを持つ特性を実装することです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Define the others as <code>unimplemented€</code> until you&#39;re ready to write them.</span>作成する準備が整うまで、他のものを<code>unimplemented€</code>れていないものとして定義します。</span> </p><script>_addload(function(){_setupIW('com');_csi('en','ja','macros.html');});</script>