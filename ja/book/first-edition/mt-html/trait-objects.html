<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180709_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=trait-objects.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Trait Objects</span>特性オブジェクト</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When code involves polymorphism, there needs to be a mechanism to determine which specific version is actually run.</span>コードに多型が含まれている場合、実際にどのバージョンが実行されているかを判断するメカニズムが必要です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is called &#39;dispatch&#39;.</span>これは「ディスパッチ」と呼ばれます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There are two major forms of dispatch: static dispatch and dynamic dispatch.</span>ディスパッチには、静的ディスパッチと動的ディスパッチという2つの主要な形式があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">While Rust favors static dispatch, it also supports dynamic dispatch through a mechanism called &#39;trait objects&#39;.</span> Rustは静的なディスパッチを優先しますが、それは「特性オブジェクト」と呼ばれるメカニズムを介した動的ディスパッチもサポートしています。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Background</span>バックグラウンド</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For the rest of this chapter, we&#39;ll need a trait and some implementations.</span>この章の残りの部分では、特性といくつかの実装が必要です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s make a simple one, <code>Foo</code> .</span>シンプルなものを作りましょう、 <code>Foo</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It has one method that is expected to return a <code>String</code> .</span> <code>String</code>を返すことが期待されるメソッドが1つあります。</span> </p><br><div data-lang=rust><div data-l="trait Foo {"></div><div data-l="    fn method(&amp;self) -&gt; String;"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll also implement this trait for <code>u8</code> and <code>String</code> :</span> <code>u8</code>と<code>String</code>この特性も実装します：</span> </p><br><div data-lang=rust><div data-l="# trait Foo { fn method(&amp;self) -&gt; String; }"></div><div data-l="impl Foo for u8 {"></div><div data-l="    fn method(&amp;self) -&gt; String { format!(&quot;u8: {}&quot;, *self) }"></div><div data-l=}></div><div data-l=""></div><div data-l="impl Foo for String {"></div><div data-l="    fn method(&amp;self) -&gt; String { format!(&quot;string: {}&quot;, *self) }"></div><div data-l=}></div></div><br><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Static dispatch</span>静的なディスパッチ</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can use this trait to perform static dispatch with trait bounds:</span>この特性を使用して、特性境界で静的なディスパッチを実行することができます。</span> </p><br><div data-lang=rust><div data-l="# trait Foo { fn method(&amp;self) -&gt; String; }"></div><div data-l="# impl Foo for u8 { fn method(&amp;self) -&gt; String { format!(&quot;u8: {}&quot;, *self) } }"></div><div data-l="# impl Foo for String { fn method(&amp;self) -&gt; String { format!(&quot;string: {}&quot;, *self) } }"></div><div data-l="fn do_something&lt;T: Foo&gt;(x: T) {"></div><div data-l="    x.method();"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let x = 5u8;"></div><div data-l="    let y = &quot;Hello&quot;.to_string();"></div><div data-l=""></div><div data-l="    do_something(x);"></div><div data-l="    do_something(y);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust uses &#39;monomorphization&#39; to perform static dispatch here.</span> Rustはここで静的ディスパッチを実行するために「単一形態」を使用します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This means that Rust will create a special version of <code>do_something()</code> for both <code>u8</code> and <code>String</code> , and then replace the call sites with calls to these specialized functions.</span>これは、Rustが<code>u8</code>と<code>String</code>両方に対して<code>do_something()</code>特別なバージョンを作成し、これらの特殊な関数への呼び出しで呼び出しサイトを置き換えることを意味します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In other words, Rust generates something like this:</span>つまり、Rustは次のようなものを生成します。</span> </p><br><div data-lang=rust><div data-l="# trait Foo { fn method(&amp;self) -&gt; String; }"></div><div data-l="# impl Foo for u8 { fn method(&amp;self) -&gt; String { format!(&quot;u8: {}&quot;, *self) } }"></div><div data-l="# impl Foo for String { fn method(&amp;self) -&gt; String { format!(&quot;string: {}&quot;, *self) } }"></div><div data-l="fn do_something_u8(x: u8) {"></div><div data-l="    x.method();"></div><div data-l=}></div><div data-l=""></div><div data-l="fn do_something_string(x: String) {"></div><div data-l="    x.method();"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let x = 5u8;"></div><div data-l="    let y = &quot;Hello&quot;.to_string();"></div><div data-l=""></div><div data-l="    do_something_u8(x);"></div><div data-l="    do_something_string(y);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This has a great upside: static dispatch allows function calls to be inlined because the callee is known at compile time, and inlining is the key to good optimization.</span>静的なディスパッチでは、コンパイル時に呼び出し先がわかっており、インライン展開が最適な最適化の鍵であるため、関数呼び出しをインライン化することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Static dispatch is fast, but it comes at a tradeoff: &#39;code bloat&#39;, due to many copies of the same function existing in the binary, one for each type.</span>静的なディスパッチは高速ですが、バイナリに存在する同じ関数の多くのコピーが各タイプごとに1つずつ存在するため、「コードが膨らむ」というトレードオフが発生します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Furthermore, compilers aren&#39;t perfect and may “optimize” code to become slower.</span>さらに、コンパイラは完璧ではなく、コードを「最適化」して低速になる可能性があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, functions inlined too eagerly will bloat the instruction cache (cache rules everything around us).</span>たとえば、インライン化された関数は、命令キャッシュを膨らませてしまいます（キャッシュルールは私たちの周りのすべてを制御します）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is part of the reason that <code>#[inline]</code> and <code>#[inline(always)]</code> should be used carefully, and one reason why using a dynamic dispatch is sometimes more efficient.</span>これは、 <code>#[inline]</code>と<code>#[inline(always)]</code>を慎重に使用する必要がある理由の1つで、動的ディスパッチを使用する理由の1つがより効率的な理由の1つです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, the common case is that it is more efficient to use static dispatch, and one can always have a thin statically-dispatched wrapper function that does a dynamic dispatch, but not vice versa, meaning static calls are more flexible.</span>しかし、一般的なケースは、静的ディスパッチを使用する方が効率的であり、動的ディスパッチを行う静的にディスパッチされたラッパー関数を持つことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The standard library tries to be statically dispatched where possible for this reason.</span>このため、標準ライブラリは可能な場合は静的にディスパッチしようとします。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Dynamic dispatch</span>ダイナミックディスパッチ</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust provides dynamic dispatch through a feature called &#39;trait objects&#39;.</span> Rustは、「特性オブジェクト」と呼ばれる機能を通じて動的なディスパッチを提供します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Trait objects, like <code>&amp;Foo</code> or <code>Box&lt;Foo&gt;</code> , are normal values that store a value of <i>any</i> type that implements the given trait, where the precise type can only be known at runtime.</span> <code>&amp;Foo</code>や<code>Box&lt;Foo&gt;</code>などの特性オブジェクトは、指定された特性を実装する<i>任意の</i>型の値を格納する通常の値です。正確な型は実行時にしか知ることができません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A trait object can be obtained from a pointer to a concrete type that implements the trait by <i>casting</i> it (eg <code>&amp;x as &amp;Foo</code> ) or <i>coercing</i> it (eg using <code>&amp;x</code> as an argument to a function that takes <code>&amp;Foo</code> ).</span>形質オブジェクトは、それを<i>キャスト</i>することによって形質を実現する具体的な型へのポインタから得ることができる（例えば、 <code>&amp;x as &amp;Foo</code> ）又は（例えば、使用してそれを<i>強制する</i> <code>&amp;x</code>とる関数の引数として<code>&amp;Foo</code> ）。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These trait object coercions and casts also work for pointers like <code>&amp;mut T</code> to <code>&amp;mut Foo</code> and <code>Box&lt;T&gt;</code> to <code>Box&lt;Foo&gt;</code> , but that&#39;s all at the moment.</span>これらの特性オブジェクトの強制変換とキャストは、 <code>&amp;mut T</code>から<code>&amp;mut Foo</code> 、 <code>Box&lt;T&gt;</code>から<code>Box&lt;Foo&gt;</code> <code>&amp;mut Foo</code>へのポインターでも機能しますが、それはすべて現時点でのものです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Coercions and casts are identical.</span>強制とキャストは同じです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This operation can be seen as &#39;erasing&#39; the compiler&#39;s knowledge about the specific type of the pointer, and hence trait objects are sometimes referred to as &#39;type erasure&#39;.</span>この操作は、ポインタの特定の型に関するコンパイラの知識を「消去する」と見なすことができるため、特性オブジェクトは「型消去」と呼ばれることがあります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Coming back to the example above, we can use the same trait to perform dynamic dispatch with trait objects by casting:</span>上記の例に戻り、同じ特性を使用して、キャストによって特性オブジェクトを使用した動的ディスパッチを実行できます。</span> </p><br><div data-lang=rust><div data-l="# trait Foo { fn method(&amp;self) -&gt; String; }"></div><div data-l="# impl Foo for u8 { fn method(&amp;self) -&gt; String { format!(&quot;u8: {}&quot;, *self) } }"></div><div data-l="# impl Foo for String { fn method(&amp;self) -&gt; String { format!(&quot;string: {}&quot;, *self) } }"></div><div data-l="fn do_something(x: &amp;Foo) {"></div><div data-l="    x.method();"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let x = 5u8;"></div><div data-l="    do_something(&amp;x as &amp;Foo);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">or by coercing:</span>または強制することによって：</span> </p><br><div data-lang=rust><div data-l="# trait Foo { fn method(&amp;self) -&gt; String; }"></div><div data-l="# impl Foo for u8 { fn method(&amp;self) -&gt; String { format!(&quot;u8: {}&quot;, *self) } }"></div><div data-l="# impl Foo for String { fn method(&amp;self) -&gt; String { format!(&quot;string: {}&quot;, *self) } }"></div><div data-l="fn do_something(x: &amp;Foo) {"></div><div data-l="    x.method();"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let x = &quot;Hello&quot;.to_string();"></div><div data-l="    do_something(&amp;x);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A function that takes a trait object is not specialized to each of the types that implements <code>Foo</code> : only one copy is generated, often (but not always) resulting in less code bloat.</span> traitオブジェクトをとる関数は、 <code>Foo</code>を実装するそれぞれの型に特化していません。たった1つのコピーしか生成されませんが、常にそうであるとは限りません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, this comes at the cost of requiring slower virtual function calls, and effectively inhibiting any chance of inlining and related optimizations from occurring.</span>しかし、これは、より遅い仮想関数呼び出しを必要とし、インライン化および関連する最適化の発生を効果的に阻止することを犠牲にして行われる。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Why pointers?</span>なぜポインタ？</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust does not put things behind a pointer by default, unlike many managed languages, so types can have different sizes.</span> Rustは多くの管理言語と違って、デフォルトでポインタの後ろに物を置かないので、型のサイズが異なる可能性があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Knowing the size of the value at compile time is important for things like passing it as an argument to a function, moving it about on the stack and allocating (and deallocating) space on the heap to store it.</span>コンパイル時に値のサイズを知ることは、それを関数の引数として渡したり、スタック上でそれを移動したり、ヒープにスペースを割り当てて（割り当てを解除して）格納するなどの場合に重要です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For <code>Foo</code> , we would need to have a value that could be at least either a <code>String</code> (24 bytes) or a <code>u8</code> (1 byte), as well as any other type for which dependent crates may implement <code>Foo</code> (any number of bytes at all).</span> <code>Foo</code>場合、 <code>String</code> （24バイト）または<code>u8</code> （1バイト）のほか、 <code>Foo</code>実装する可能性のある他の型（バイト数はまったくありません） ）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There&#39;s no way to guarantee that this last point can work if the values are stored without a pointer, because those other types can be arbitrarily large.</span>値がポインタなしで格納されている場合、この最後の点が動作することを保証する方法はありません。これらの他の型は任意に大きくすることができるからです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Putting the value behind a pointer means the size of the value is not relevant when we are tossing a trait object around, only the size of the pointer itself.</span>値をポインタの後ろに置くということは、traitオブジェクトを投げているときに値のサイズが関係なく、ポインタ自体のサイズだけであることを意味します。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Representation</span>表現</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The methods of the trait can be called on a trait object via a special record of function pointers traditionally called a &#39;vtable&#39; (created and managed by the compiler).</span>特性のメソッドは、伝統的に「コンパイラによって作成され、管理される」vtableと呼ばれる特別な関数ポインタのレコードを介して特性オブジェクト上で呼び出すことができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Trait objects are both simple and complicated: their core representation and layout is quite straight-forward, but there are some curly error messages and surprising behaviors to discover.</span>特性オブジェクトはシンプルで複雑です。そのコア表現とレイアウトはかなり単純ですが、中にはいくつかのエラーメッセージと驚くべき動作があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s start simple, with the runtime representation of a trait object.</span> traitオブジェクトのランタイム表現を使って簡単に始めましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>std::raw</code> module contains structs with layouts that are the same as the complicated built-in types, <a href=#3stdraw>including trait objects</a> :</span> <code>std::raw</code>モジュールには、 <a href=#3stdraw>traitオブジェクトを含む</a>複雑な組み込み型と同じレイアウトの構造体が含まれてい<a href=#3stdraw>ます</a> 。</span> </p><br><div data-lang=rust><div data-l="# mod foo {"></div><div data-l="pub struct TraitObject {"></div><div data-l="    pub data: *mut (),"></div><div data-l="    pub vtable: *mut (),"></div><div data-l=}></div><div data-l="# }"></div></div><br> <a class=notranslate href=#1../../std/raw/struct.TraitObject.html>stdraw</a> <br> <p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That is, a trait object like <code>&amp;Foo</code> consists of a &#39;data&#39; pointer and a &#39;vtable&#39; pointer.</span>つまり、 <code>&amp;Foo</code>ような特性オブジェクトは、 &#39;data&#39;ポインタと &#39;vtable&#39;ポインタで構成されています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The data pointer addresses the data (of some unknown type <code>T</code> ) that the trait object is storing, and the vtable pointer points to the vtable (&#39;virtual method table&#39;) corresponding to the implementation of <code>Foo</code> for <code>T</code> .</span>データポインタは、特性オブジェクトが記憶している（未知のタイプ<code>T</code> ）データをアドレス指定し、vテーブルポインタは<code>T</code>の<code>Foo</code>の実装に対応するvテーブル（「仮想メソッドテーブル」）を指し示す。</span> </p><br><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A vtable is essentially a struct of function pointers, pointing to the concrete piece of machine code for each method in the implementation.</span> vtableは基本的には関数ポインタの構造体で、実装の各メソッドの具体的な機械コードを指しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A method call like <code>trait_object.method()</code> will retrieve the correct pointer out of the vtable and then do a dynamic call of it.</span> <code>trait_object.method()</code>ようなメソッド呼び出しは、vtableから正しいポインタを取り出してからそれを動的に呼び出します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example:</span>例えば：</span> </p><br><div data-lang=rust,ignore><div data-l="struct FooVtable {"></div><div data-l="    destructor: fn(*mut ()),"></div><div data-l="    size: usize,"></div><div data-l="    align: usize,"></div><div data-l="    method: fn(*const ()) -&gt; String,"></div><div data-l=}></div><div data-l=""></div><div data-l="#// u8:"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">u8:</span> u8：</span> </div><div data-l=""></div><div data-l="fn call_method_on_u8(x: *const ()) -&gt; String {"></div><div data-l="#    // The compiler guarantees that this function is only called"></div><div data-l="#    // with `x` pointing to a u8."></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The compiler guarantees that this function is only called with <code>x</code> pointing to a u8.</span>コンパイラは、この関数は<code>x</code>がu8を指している場合にのみ呼び出されることを保証します。</span> </div><div data-l="    let byte: &amp;u8 = unsafe { &amp;*(x as *const u8) };"></div><div data-l=""></div><div data-l="    byte.method()"></div><div data-l=}></div><div data-l=""></div><div data-l="static Foo_for_u8_vtable: FooVtable = FooVtable {"></div><div data-l="    destructor: /* compiler magic */,"></div><div data-l="    size: 1,"></div><div data-l="    align: 1,"></div><div data-l=""></div><div data-l="#    // Cast to a function pointer:"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Cast to a function pointer:</span>関数ポインタにキャスト：</span> </div><div data-l="    method: call_method_on_u8 as fn(*const ()) -&gt; String,"></div><div data-l=};></div><div data-l=""></div><div data-l=""></div><div data-l="#// String:"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">String:</span>文字列：</span> </div><div data-l=""></div><div data-l="fn call_method_on_String(x: *const ()) -&gt; String {"></div><div data-l="#    // The compiler guarantees that this function is only called"></div><div data-l="#    // with `x` pointing to a String."></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The compiler guarantees that this function is only called with <code>x</code> pointing to a String.</span>コンパイラは、この関数は、 <code>x</code>がStringを指している場合にのみ呼び出されることを保証します。</span> </div><div data-l="    let string: &amp;String = unsafe { &amp;*(x as *const String) };"></div><div data-l=""></div><div data-l="    string.method()"></div><div data-l=}></div><div data-l=""></div><div data-l="static Foo_for_String_vtable: FooVtable = FooVtable {"></div><div data-l="    destructor: /* compiler magic */,"></div><div data-l="#    // Values for a 64-bit computer, halve them for 32-bit ones."></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Values for a 64-bit computer, halve them for 32-bit ones.</span> 64ビットコンピュータの場合は32ビットの値を半分にします。</span> </div><div data-l="    size: 24,"></div><div data-l="    align: 8,"></div><div data-l=""></div><div data-l="    method: call_method_on_String as fn(*const ()) -&gt; String,"></div><div data-l=};></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>destructor</code> field in each vtable points to a function that will clean up any resources of the vtable&#39;s type: for <code>u8</code> it is trivial, but for <code>String</code> it will free the memory.</span> <code>destructor</code>のvtableのタイプのすべてのリソースをクリーンアップする関数への各vtableのポイントでのフィールド：のために<code>u8</code>それは簡単ですが、ために<code>String</code> 、それはメモリを解放します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is necessary for owning trait objects like <code>Box&lt;Foo&gt;</code> , which need to clean-up both the <code>Box</code> allocation as well as the internal type when they go out of scope.</span>これは、 <code>Box&lt;Foo&gt;</code>ような特性オブジェクトを所有するために必要です.Byte <code>Box&lt;Foo&gt;</code>は、範囲外に出たときに<code>Box</code>割り当てと内部型の両方をクリーンアップする必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>size</code> and <code>align</code> fields store the size of the erased type, and its alignment requirements.</span> <code>size</code>および<code>align</code>フィールドには、消去されたタイプのサイズと整列要件が格納されます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Suppose we&#39;ve got some values that implement <code>Foo</code> .</span> <code>Foo</code>を実装するいくつかの値があるとします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The explicit form of construction and use of <code>Foo</code> trait objects might look a bit like (ignoring the type mismatches: they&#39;re all pointers anyway):</span> <code>Foo</code>特性オブジェクトの明示的な構成と使用方法は少し違って見えるかもしれません（型の不一致は無視されます：とにかくすべてのポインタです）。</span> </p><br><div data-lang=rust,ignore><div data-l="let a: String = &quot;foo&quot;.to_string();"></div><div data-l="let x: u8 = 1;"></div><div data-l=""></div><div data-l="#// let b: &amp;Foo = &amp;a;"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">let b: &amp;Foo = &amp;a;</span> let b：＆Foo =＆a;</span> </div><div data-l="let b = TraitObject {"></div><div data-l="#    // Store the data:"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Store the data:</span>データを保存する：</span> </div><div data-l="    data: &amp;a,"></div><div data-l="#    // Store the methods:"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Store the methods:</span>メソッドを格納します。</span> </div><div data-l="    vtable: &amp;Foo_for_String_vtable"></div><div data-l=};></div><div data-l=""></div><div data-l="#// let y: &amp;Foo = x;"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">let y: &amp;Foo = x;</span> let y：＆Foo = x;</span> </div><div data-l="let y = TraitObject {"></div><div data-l="#    // Store the data:"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Store the data:</span>データを保存する：</span> </div><div data-l="    data: &amp;x,"></div><div data-l="#    // Store the methods:"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Store the methods:</span>メソッドを格納します。</span> </div><div data-l="    vtable: &amp;Foo_for_u8_vtable"></div><div data-l=};></div><div data-l=""></div><div data-l="#// b.method();"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">b.method();</span> b.method（）;</span> </div><div data-l=(b.vtable.method)(b.data);></div><div data-l=""></div><div data-l="#// y.method();"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">y.method();</span> y.method（）;</span> </div><div data-l=(y.vtable.method)(y.data);></div></div><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Object Safety</span>オブジェクトの安全</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Not every trait can be used to make a trait object.</span>すべての形質を特性オブジェクトの作成に使用することはできません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, vectors implement <code>Clone</code> , but if we try to make a trait object:</span>たとえば、ベクターは<code>Clone</code>実装しますが、traitオブジェクトを作成しようとすると、次のようになります。</span> </p><br><div data-lang=rust,ignore><div data-l="let v = vec![1, 2, 3];"></div><div data-l="let o = &amp;v as &amp;Clone;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We get an error:</span>エラーが表示されます。</span> </p><br><div data-lang=text><div data-l="error: cannot convert to a trait object because trait `core::clone::Clone` is not object-safe [E0038]"></div><div data-l="let o = &amp;v as &amp;Clone;"></div><div data-l="        ^~"></div><div data-l="note: the trait cannot require that `Self : Sized`"></div><div data-l="let o = &amp;v as &amp;Clone;"></div><div data-l="        ^~"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The error says that <code>Clone</code> is not &#39;object-safe&#39;.</span>エラーは、 <code>Clone</code>は「オブジェクトセーフ」ではないと言います。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Only traits that are object-safe can be made into trait objects.</span>オブジェクトセーフである形質のみを形質オブジェクトにすることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A trait is object-safe if both of these are true:</span>これらの両方が真である場合、形質はオブジェクトセーフです。</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">the trait does not require that <code>Self: Sized</code></span>その特性はそれを必要としません<code>Self: Sized</code></span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">all of its methods are object-safe</span>すべてのメソッドはオブジェクトセーフです</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So what makes a method object-safe?</span>だから、メソッドをオブジェクトセーフにするには？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Each method must require that <code>Self: Sized</code> or all of the following:</span>各メソッドは、 <code>Self: Sized</code>または以下のすべてを必要とする必要があります。</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">must not have any type parameters</span>型パラメータを持たない</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">must not use <code>Self</code></span> <code>Self</code>使用してはいけません</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Whew!</span>すごい！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As we can see, almost all of these rules talk about <code>Self</code> .</span>わかるように、これらの規則のほとんどすべてが<code>Self</code>について語ります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A good intuition is “except in special circumstances, if your trait&#39;s method uses <code>Self</code> , it is not object-safe.”</span>良い直感は、「特殊な状況を除いて、あなたの形質の方法が<code>Self</code>使用する場合、それはオブジェクトセーフではありません」。</span> </p><script>_addload(function(){_setupIW('com');_csi('en','ja','trait-objects.html');});</script>