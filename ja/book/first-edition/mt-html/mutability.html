<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180709_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=mutability.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Mutability</span>変異性</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Mutability, the ability to change something, works a bit differently in Rust than in other languages.</span> Mutabilityは何かを変更する能力で、Rustでは他の言語とは少し違って動作します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The first aspect of mutability is its non-default status:</span>変更可能性の第1の側面は、デフォルトではない状態です。</span> </p><br><div data-lang=rust,ignore><div data-l="let x = 5;"></div><div data-l="#//x = 6; // Error!"></div><div data-l="x = 6; // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Error!</span>エラー！</span> </div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can introduce mutability with the <code>mut</code> keyword:</span> <code>mut</code>キーワードでmutabilityを導入することができます：</span> </p><br><div data-lang=rust><div data-l="let mut x = 5;"></div><div data-l=""></div><div data-l="#//x = 6; // No problem!"></div><div data-l="x = 6; // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">No problem!</span>問題ない！</span> </div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is a mutable <a href=#3vb>variable binding</a> .</span>これは<a href=#3vb>可変バインディング</a>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When a binding is mutable, it means you&#39;re allowed to change what the binding points to.</span>バインディングが変更可能な場合は、バインディングが指しているものを変更することが許可されていることを意味します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So in the above example, it&#39;s not so much that the value at <code>x</code> is changing, but that the binding changed from one <code>i32</code> to another.</span>上記の例では、 <code>x</code>の値が変化しているのではなく、バインディングが1つの<code>i32</code>から別の<code>i32</code>に変更されています。</span> </p><br> <a class=notranslate href=#1variable-bindings.html>vb</a> <br> <p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can also create a <a class=notranslate href=#3ref>reference</a> to it, using <code>&amp;x</code> , but if you want to use the reference to change it, you will need a mutable reference:</span>また、 <code>&amp;x</code>を使用して<a class=notranslate href=#3ref>reference</a>を作成することもできますが、 <a class=notranslate href=#3ref>reference</a>を使用して変更する場合は、変更可能な参照が必要です。</span> </p><br><div data-lang=rust><div data-l="let mut x = 5;"></div><div data-l="let y = &amp;mut x;"></div></div><br> <a class=notranslate href=#1references-and-borrowing.html>ref</a> <br> <p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>y</code> is an immutable binding to a mutable reference, which means that you can&#39;t bind &#39;y&#39; to something else ( <code>y = &amp;mut z</code> ), but <code>y</code> can be used to bind <code>x</code> to something else ( <code>*y = 5</code> ).</span> <code>y</code>は可変参照への不変のバインディングです。つまり、yを他のもの（ <code>y = &amp;mut z</code> ）にバインドすることはできませんが、 <code>y</code>を使用して<code>x</code>を他のもの（ <code>*y = 5</code> ）にバインドすることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A subtle distinction.</span>微妙な違い。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Of course, if you need both:</span>もちろん、両方が必要な場合：</span> </p><br><div data-lang=rust><div data-l="let mut x = 5;"></div><div data-l="let mut y = &amp;mut x;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now <code>y</code> can be bound to another value, and the value it&#39;s referencing can be changed.</span> <code>y</code>は別の値にバインドすることができ、参照している値を変更することができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It&#39;s important to note that <code>mut</code> is part of a <a class=notranslate href=#3pattern>pattern</a> , so you can do things like this:</span> <code>mut</code>は<a class=notranslate href=#3pattern>pattern</a>一部であることに注意することが重要なので、次のようなことができます：</span> </p><br><div data-lang=rust><div data-l="let (mut x, y) = (5, 6);"></div><div data-l=""></div><div data-l="fn foo(mut x: i32) {"></div><div data-l="# }"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that here, the <code>x</code> is mutable, but not the <code>y</code> .</span>ここでは、 <code>x</code>は変更可能ですが、 <code>y</code>は変更できません。</span> </p><br> <a class=notranslate href=#1patterns.html>pattern</a> <br> <h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Interior vs. Exterior Mutability</span>インテリア対外の相互関係</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, when we say something is &#39;immutable&#39; in Rust, that doesn&#39;t mean that it&#39;s not able to be changed: we are referring to its &#39;exterior mutability&#39; that in this case is immutable.</span>しかし、Rustに何かが「不変」であると言うとき、それは変更できないということを意味するわけではありません。この場合の「外部の変更可能性」を指しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Consider, for example, <a class=notranslate href=#3arc><code>Arc&lt;T&gt;</code></a> :</span>たとえば、 <a class=notranslate href=#3arc><code>Arc&lt;T&gt;</code></a>考えてみましょう。</span> </p><br><div data-lang=rust><div data-l="use std::sync::Arc;"></div><div data-l=""></div><div data-l="let x = Arc::new(5);"></div><div data-l="let y = x.clone();"></div></div><br> <a class=notranslate href=#1../../std/sync/struct.Arc.html>arc</a> <br> <p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When we call <code>clone()</code> , the <code>Arc&lt;T&gt;</code> needs to update the reference count.</span> <code>clone()</code>を呼び出すと、 <code>Arc&lt;T&gt;</code>は参照カウントを更新する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Yet we&#39;ve not used any <code>mut</code> s here, <code>x</code> is an immutable binding, and we didn&#39;t take <code>&amp;mut 5</code> or anything.</span>しかし、ここでは<code>mut</code>使用していないので、 <code>x</code>は不変の束縛であり、 <code>&amp;mut 5</code>や何も取らなかった。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So what gives?</span>だから何を与える？</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To understand this, we have to go back to the core of Rust&#39;s guiding philosophy, memory safety, and the mechanism by which Rust guarantees it, the <a class=notranslate href=#3ownership>ownership</a> system, and more specifically, <a class=notranslate href=#3borrowing>borrowing</a> :</span>これを理解するためには、Rustの指導哲学、記憶の安全性、Rustがそれを保証するメカニズム、 <a class=notranslate href=#3ownership>ownership</a>システム、より具体的には<a class=notranslate href=#3borrowing>borrowing</a>の中核に戻る必要があります。</span> </p><br><blockquote><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You may have one or the other of these two kinds of borrows, but not both at the same time:</span>あなたはこれら2種類の借用のどちらか一方を持っているかもしれませんが、同時に両方ではありません：</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">one or more references ( <code>&amp;T</code> ) to a resource,</span> 1つまたは複数のリソースへの参照（ <code>&amp;T</code> ）</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">exactly one mutable reference ( <code>&amp;mut T</code> ).</span>正確に1つの可変参照（ <code>&amp;mut T</code> ）。</span> </div></blockquote><br> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a class=notranslate href=#1ownership.html>ownership</a> <a class=notranslate href=#1references-and-borrowing.html#borrowing>borrowing</a></span> <a class=notranslate href=#1ownership.html>ownership</a> <a class=notranslate href=#1references-and-borrowing.html#borrowing>borrowing</a></span> <br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So, that&#39;s the real definition of &#39;immutability&#39;: is this safe to have two pointers to?</span>それは、「不変性」の本当の定義です：これは2つの指針を持つのが安全でしょうか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In <code>Arc&lt;T&gt;</code> &#39;s case, yes: the mutation is entirely contained inside the structure itself.</span> <code>Arc&lt;T&gt;</code>の場合、はい：突然変異は構造体自体の内部に完全に含まれています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It&#39;s not user facing.</span>ユーザーが直面しているのではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For this reason, it hands out <code>&amp;T</code> with <code>clone()</code> .</span>このため、 <code>&amp;T</code>を<code>clone()</code>で渡します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If it handed out <code>&amp;mut T</code> s, though, that would be a problem.</span>しかし、 <code>&amp;mut T</code>渡した場合、それが問題になります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Other types, like the ones in the <a class=notranslate href=#3stdcell><code>std::cell</code></a> module, have the opposite: interior mutability.</span>他の型は、 <a class=notranslate href=#3stdcell><code>std::cell</code></a>モジュールのものと同様に、逆の内部の可変性を持っています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example:</span>例えば：</span> </p><br><div data-lang=rust><div data-l="use std::cell::RefCell;"></div><div data-l=""></div><div data-l="let x = RefCell::new(42);"></div><div data-l=""></div><div data-l="let y = x.borrow_mut();"></div></div><br> <a class=notranslate href=#1../../std/cell/index.html>stdcell</a> <br> <p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">RefCell hands out <code>&amp;mut</code> references to what&#39;s inside of it with the <code>borrow_mut()</code> method.</span> RefCellは、 <code>borrow_mut()</code>メソッドを使用して、内部にあるものへの参照と<code>&amp;mut</code>参照を行います。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Isn&#39;t that dangerous?</span>それは危険ではないですか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">What if we do:</span>もし私たちがすれば：</span> </p><br><div data-lang=rust,ignore><div data-l="use std::cell::RefCell;"></div><div data-l=""></div><div data-l="let x = RefCell::new(42);"></div><div data-l=""></div><div data-l="let y = x.borrow_mut();"></div><div data-l="let z = x.borrow_mut();"></div><div data-l="# (y, z);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This will in fact panic, at runtime.</span>これは実際には実行時にパニックになります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is what <code>RefCell</code> does: it enforces Rust&#39;s borrowing rules at runtime, and <code>panic€</code> s if they&#39;re violated.</span> <code>RefCell</code>はこれを実行します。実行時にRustの借用ルールを強制し、侵害された場合は<code>panic€</code>なります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This allows us to get around another aspect of Rust&#39;s mutability rules.</span>これにより、Rustの変更可能ルールの別の側面を取り上げることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s talk about it first.</span>まずそれについて話しましょう。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Field-level mutability</span>フィールドレベルの可変性</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Mutability is a property of either a borrow ( <code>&amp;mut</code> ) or a binding ( <code>let mut</code> ).</span> mutabilityは、borrow（ <code>&amp;mut</code> ）またはbinding（ <code>let mut</code> ）のいずれかのプロパティです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This means that, for example, you cannot have a <a class=notranslate href=#3struct><code>struct</code></a> with some fields mutable and some immutable:</span>これは、たとえば、いくつかのフィールドを変更可能なものと変更できないものがある<a class=notranslate href=#3struct><code>struct</code></a>を持つことができないことを意味します。</span> </p><br><div data-lang=rust,ignore><div data-l="struct Point {"></div><div data-l="    x: i32,"></div><div data-l="#//    mut y: i32, // Nope."></div><div data-l="    mut y: i32, // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Nope.</span>いいえ。</span> </div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The mutability of a struct is in its binding:</span>構造体の可変性はその束縛にあります：</span> </p><br><div data-lang=rust,ignore><div data-l="struct Point {"></div><div data-l="    x: i32,"></div><div data-l="    y: i32,"></div><div data-l=}></div><div data-l=""></div><div data-l="let mut a = Point { x: 5, y: 6 };"></div><div data-l=""></div><div data-l="a.x = 10;"></div><div data-l=""></div><div data-l="let b = Point { x: 5, y: 6 };"></div><div data-l=""></div><div data-l="#//b.x = 10; // Error: cannot assign to immutable field `b.x`."></div><div data-l="b.x = 10; // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Error: cannot assign to immutable field <code>bx</code> .</span>エラー：不変フィールド<code>bx</code>代入することはできません。</span> </div></div><br> <a class=notranslate href=#1structs.html>struct</a> <br> <p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, by using <a class=notranslate href=#3cell><code>Cell&lt;T&gt;</code></a> , you can emulate field-level mutability:</span>ただし、 <a class=notranslate href=#3cell><code>Cell&lt;T&gt;</code></a>を使用すると、フィールドレベルの可変性をエミュレートできます。</span> </p><br><div data-lang=rust><div data-l="use std::cell::Cell;"></div><div data-l=""></div><div data-l="struct Point {"></div><div data-l="    x: i32,"></div><div data-l="    y: Cell&lt;i32&gt;,"></div><div data-l=}></div><div data-l=""></div><div data-l="let point = Point { x: 5, y: Cell::new(6) };"></div><div data-l=""></div><div data-l=point.y.set(7);></div><div data-l=""></div><div data-l="println!(&quot;y: {:?}&quot;, point.y);"></div></div><br> <a class=notranslate href=#1../../std/cell/struct.Cell.html>cell</a> <br> <p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This will print <code>y: Cell { value: 7 }</code> .</span>これは<code>y: Cell { value: 7 }</code>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ve successfully updated <code>y</code> .</span> <code>y</code>を正常に更新しました。</span> </p><script>_addload(function(){_setupIW('com');_csi('en','ja','mutability.html');});</script>