<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180709_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=choosing-your-guarantees.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Choosing your Guarantees</span>保証の選択</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">One important feature of Rust is that it lets us control the costs and guarantees of a program.</span> Rustの重要な特徴の1つは、プログラムのコストと保証を制御できることです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There are various &amp;ldquo;wrapper type&amp;rdquo;</span>さまざまな＆ldquo;ラッパータイプ＆rdquo;があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">abstractions in the Rust standard library which embody a multitude of trade-offs between cost, ergonomics, and guarantees.</span>コスト、人間工学、および保証の間の多数のトレードオフを具現化するRust標準ライブラリの抽象化。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Many let one choose between run-time and compile-time enforcement.</span>多くの場合、実行時とコンパイル時のどちらを選択するかを選択できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This section will explain a few selected abstractions in detail.</span>このセクションでは、いくつかの選択された抽象化について詳しく説明します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Before proceeding, it is highly recommended that one reads about <a class=notranslate href=#3ownership>ownership</a> and <a class=notranslate href=#3borrowing>borrowing</a> in Rust.</span>先に進む前に、Rustの<a class=notranslate href=#3ownership>ownership</a>と<a class=notranslate href=#3borrowing>borrowing</a>について読むことを強くお勧めします。</span> </p><br> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a class=notranslate href=#1ownership.html>ownership</a> <a class=notranslate href=#1references-and-borrowing.html>borrowing</a></span> <a class=notranslate href=#1ownership.html>ownership</a> <a class=notranslate href=#1references-and-borrowing.html>borrowing</a></span> <br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Basic pointer types</span>基本的なポインタ型</span> </h1><br><h2> <code>Box&lt;T&gt;</code> </h2> <br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a class=notranslate href=#3box><code>Box&lt;T&gt;</code></a> is an &amp;ldquo;owned&amp;rdquo;</span> <a class=notranslate href=#3box><code>Box&lt;T&gt;</code></a>は＆ldquo;所有＆rdquo;</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">pointer, or a &amp;ldquo;box&amp;rdquo;.</span>ポインタ、または＆ldquo;ボックス＆rdquo;</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">While it can hand out references to the contained data, it is the only owner of the data.</span>含まれているデータへの参照を渡すことはできますが、それはデータの唯一の所有者です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In particular, consider the following:</span>特に、次の点を考慮してください。</span> </p><br><div data-lang=rust><div data-l="let x = Box::new(1);"></div><div data-l="let y = x;"></div><div data-l="#// `x` is no longer accessible here."></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>x</code> is no longer accessible here.</span> <code>x</code>はここではアクセスできなくなりました。</span> </div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here, the box was <s>moved</s> into <code>y</code> .</span>ここでは、ボックスを<code>y</code>に<s>移動</s>しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As <code>x</code> no longer owns it, the compiler will no longer allow the programmer to use <code>x</code> after this.</span> <code>x</code>はもはやそれを所有していないので、コンパイラはもはやプログラマがこれの後に<code>x</code>を使うことを許さないでしょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A box can similarly be moved <s>out</s> of a function by returning it.</span>同様に、ボックスを返すことで、関数<s>から</s>ボックスを移動<s>する</s>ことができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When a box (that hasn&#39;t been moved) goes out of scope, destructors are run.</span>移動されていないボックスが範囲外になると、デストラクタが実行されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These destructors take care of deallocating the inner data.</span>これらのデストラクタは内部データの割り当てを解除します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is a zero-cost abstraction for dynamic allocation.</span>これは、動的割り当てのためのゼロコストの抽象化です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you want to allocate some memory on the heap and safely pass around a pointer to that memory, this is ideal.</span>ヒープ上にいくつかのメモリを割り当て、そのメモリへのポインタを安全に渡したい場合は、これが理想的です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that you will only be allowed to share references to this by the regular borrowing rules, checked at compile time.</span>コンパイル時にチェックされる通常の借用ルールによってのみ、これへの参照を共有することができます。</span> </p><br> <a class=notranslate href=#1../../std/boxed/struct.Box.html>box</a> <br> <h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>&amp;T</code> and <code>&amp;mut T</code></span> <code>&amp;T</code>と<code>&amp;mut T</code></span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These are immutable and mutable references respectively.</span>これらはそれぞれ不変で変更可能な参照です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">They follow the &amp;ldquo;read-write lock&amp;rdquo;</span>それらは＆ldquo;読み書きロック＆rdquo;の後に続きます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">pattern, such that one may either have only one mutable reference to some data, or any number of immutable ones, but not both.</span>あるデータに対する1つの可変参照、または任意の数の不変の参照を持つことができますが、両方ではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This guarantee is enforced at compile time, and has no visible cost at runtime.</span>この保証はコンパイル時に強制され、実行時に表示されるコストはありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In most cases these two pointer types suffice for sharing cheap references between sections of code.</span>ほとんどの場合、これらの2つのポインタ型は、コードのセクション間で安価な参照を共有するのに十分です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These pointers cannot be copied in such a way that they outlive the lifetime associated with them.</span>これらのポインタは、それらのポインタに関連付けられた存続期間を超えてコピーすることはできません。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>*const T</code> and <code>*mut T</code></span> <code>*const T</code>と<code>*mut T</code></span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These are C-like raw pointers with no lifetime or ownership attached to them.</span>これらは生涯や所有権がないCのような生ポインタです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">They point to some location in memory with no other restrictions.</span>彼らは他の制限なしでメモリ内のある場所を指しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The only guarantee that these provide is that they cannot be dereferenced except in code marked <code>unsafe</code> .</span>これらが提供する唯一の保証は、 <code>unsafe</code>マークされたコードを除き、参照解除することができないことです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These are useful when building safe, low cost abstractions like <code>Vec&lt;T&gt;</code> , but should be avoided in safe code.</span>これらは<code>Vec&lt;T&gt;</code>ような安全で低コストな抽象化を構築する場合には便利ですが、安全なコードでは避けるべきです。</span> </p><br><h2> <code>Rc&lt;T&gt;</code> </h2> <br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is the first wrapper we will cover that has a runtime cost.</span>これはランタイムコストを持つ最初のラッパーです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a class=notranslate href=#3rc><code>Rc&lt;T&gt;</code></a> is a reference counted pointer.</span> <a class=notranslate href=#3rc><code>Rc&lt;T&gt;</code></a>は参照カウントポインタである。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In other words, this lets us have multiple &quot;owning&quot; pointers to the same data, and the data will be dropped (destructors will be run) when all pointers are out of scope.</span>つまり、これにより、同じデータへの複数の「所有」ポインタを持つことができ、すべてのポインタが有効範囲外になるとデータが破棄されます（デストラクタが実行されます）。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Internally, it contains a shared &amp;ldquo;reference count&amp;rdquo;</span>内部的には、＆ldquo;参照カウントが共有されています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">(also called &amp;ldquo;refcount&amp;rdquo;), which is incremented each time the <code>Rc</code> is cloned, and decremented each time one of the <code>Rc</code> s goes out of scope.</span> <code>Rc</code>がクローンされるたびにインクリメントされ、 <code>Rc</code>の1つが範囲外になるたびにデクリメントされます（＆ldquo; refcount＆rdquo;とも呼ばれます）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The main responsibility of <code>Rc&lt;T&gt;</code> is to ensure that destructors are called for shared data.</span> <code>Rc&lt;T&gt;</code>の主な責任は、デストラクタが共有データのために呼び出されるようにすることです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The internal data here is immutable, and if a cycle of references is created, the data will be leaked.</span>ここの内部データは不変であり、参照のサイクルが作成された場合、データはリークされます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we want data that doesn&#39;t leak when there are cycles, we need a garbage collector.</span>サイクルがあるときにリークしないデータが必要な場合は、ガベージコレクタが必要です。</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Guarantees</span>保証</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The main guarantee provided here is that the data will not be destroyed until all references to it are out of scope.</span>ここで提供される主な保証は、データへのすべての参照が範囲外になるまでデータが破棄されないことです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This should be used when we wish to dynamically allocate and share some data (read-only) between various portions of your program, where it is not certain which portion will finish using the pointer last.</span>これは、プログラムのさまざまな部分の間でデータを動的に割り当てたり共有したりする場合に使用します。ポインタが最後に使用される部分がわからない場合は、この部分を使用してください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It&#39;s a viable alternative to <code>&amp;T</code> when <code>&amp;T</code> is either impossible to statically check for correctness, or creates extremely unergonomic code where the programmer does not wish to spend the development cost of working with.</span>これは、する実行可能な代案だ<code>&amp;T</code> <code>&amp;T</code>静的正しさを確認するためのいずれかに不可能である、またはプログラマが作業の開発コストを費やすしたくない極めてunergonomicコードを作成します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This pointer is <s>not</s> thread-safe, and Rust will not let it be sent or shared with other threads.</span>このポインタはスレッドセーフでは<s>なく</s> 、Rustは他のスレッドとの共有や共有を許可しません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This lets one avoid the cost of atomics in situations where they are unnecessary.</span>これにより、不要な状況でのアトミックスのコストを回避できます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There is a sister smart pointer to this one, <code>Weak&lt;T&gt;</code> .</span>これに姉妹のスマートポインタ<code>Weak&lt;T&gt;</code>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is a non-owning, but also non-borrowed, smart pointer.</span>これは所有していないが、借りていないスマートポインタです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It is also similar to <code>&amp;T</code> , but it is not restricted in lifetime&amp;mdash;a <code>Weak&lt;T&gt;</code> can be held on to forever.</span>また、 <code>&amp;T</code>と似ていますが、生涯に制限されず、 <code>Weak&lt;T&gt;</code>が永遠に保持されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, it is possible that an attempt to access the inner data may fail and return <code>None</code> , since this can outlive the owned <code>Rc</code> s.</span>しかし、内部データにアクセスしようとする試みが失敗し、 <code>None</code>返される可能性があります。これは、所有されている<code>Rc</code>よりも長くなる可能性があるためです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is useful for cyclic data structures and other things.</span>これは、周期的なデータ構造などに役立ちます。</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Cost</span>コスト</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As far as memory goes, <code>Rc&lt;T&gt;</code> is a single allocation, though it will allocate two extra words (ie two <code>usize</code> values) as compared to a regular <code>Box&lt;T&gt;</code> (for &quot;strong&quot; and &quot;weak&quot; refcounts).</span>メモリが移動する限り、 <code>Rc&lt;T&gt;</code>は単一の割り当てですが、通常の<code>Box&lt;T&gt;</code> （ &quot;強い&quot;と &quot;弱い&quot;参照）と比べて2つの余分な単語（つまり2つの<code>usize</code>値）を<code>usize</code>ます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>Rc&lt;T&gt;</code> has the computational cost of incrementing/decrementing the refcount whenever it is cloned or goes out of scope respectively.</span> <code>Rc&lt;T&gt;</code>は、それがクローンされるかまたはスコープ外になるたびに、refcountをインクリメント/デクリメントする計算コストを有する。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that a clone will not do a deep copy, rather it will simply increment the inner reference count and return a copy of the <code>Rc&lt;T&gt;</code> .</span>クローンはディープコピーを行いません。内部参照カウントをインクリメントして<code>Rc&lt;T&gt;</code>コピーを返します。</span> </p><br> <a class=notranslate href=#1../../std/rc/struct.Rc.html>rc</a> <br> <h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Cell types</span>細胞の種類</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>Cell</code> s provide interior mutability.</span> <code>Cell</code>は内部の変異性を提供する。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In other words, they contain data which can be manipulated even if the type cannot be obtained in a mutable form (for example, when it is behind an <code>&amp;</code> -ptr or <code>Rc&lt;T&gt;</code> ).</span>言い換えれば、型が変更可能な形式で取得できない場合でも（たとえば、 <code>&amp;</code> ptrまたは<code>Rc&lt;T&gt;</code>後ろにある場合など）、操作できるデータが含まれています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a href=#3cell-mod>The documentation for the <code>cell</code> module has a pretty good explanation for these</a> .</span> <a href=#3cell-mod><code>cell</code>モジュールのドキュメントには、これらの説明があります</a> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These types are <s>generally</s> found in struct fields, but they may be found elsewhere too.</span>これらの型は<s>一般</s>に構造体フィールドにありますが、他の場所にもあります。</span> </p><br><h2> <code>Cell&lt;T&gt;</code> </h2> <br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a class=notranslate href=#3cell><code>Cell&lt;T&gt;</code></a> is a type that provides zero-cost interior mutability by moving data in and out of the cell.</span> <a class=notranslate href=#3cell><code>Cell&lt;T&gt;</code></a>は、セルの内外にデータを移動することによってゼロコストの内部の変更可能性を提供する型です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Since the compiler knows that all the data owned by the contained value is on the stack, there&#39;s no worry of leaking any data behind references (or worse!) by simply replacing the data.</span>コンパイラは、格納された値が所有するすべてのデータがスタック上にあることを知っているので、単にデータを置き換えるだけで、参照の背後にあるデータが漏れる（または悪化する）心配はありません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It is still possible to violate your own invariants using this wrapper, so be careful when using it.</span>このラッパーを使用して独自のインバリアントに違反する可能性があるので、使用する際は注意してください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If a field is wrapped in <code>Cell</code> , it&#39;s a nice indicator that the chunk of data is mutable and may not stay the same between the time you first read it and when you intend to use it.</span>フィールドが<code>Cell</code>にラップされている場合は、データのチャンクが変更可能であり、最初に読み込んだときから使用する予定までの間に変更されないという良い指標です。</span> </p><br><div data-lang=rust><div data-l="use std::cell::Cell;"></div><div data-l=""></div><div data-l="let x = Cell::new(1);"></div><div data-l="let y = &amp;x;"></div><div data-l="let z = &amp;x;"></div><div data-l=x.set(2);></div><div data-l=y.set(3);></div><div data-l=z.set(4);></div><div data-l="println!(&quot;{}&quot;, x.get());"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that here we were able to mutate the same value from various immutable references.</span>ここでは、さまざまな不変参照から同じ値を変更することができたことに注意してください。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This has the same runtime cost as the following:</span>これは以下のランタイムコストと同じです：</span> </p><br><div data-lang=rust,ignore><div data-l="let mut x = 1;"></div><div data-l="let y = &amp;mut x;"></div><div data-l="let z = &amp;mut x;"></div><div data-l="x = 2;"></div><div data-l="*y = 3;"></div><div data-l="*z = 4;"></div><div data-l="println!(&quot;{}&quot;, x);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">but it has the added benefit of actually compiling successfully.</span>実際に正常にコンパイルするという利点があります。</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Guarantees</span>保証</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This relaxes the &amp;ldquo;no aliasing with mutability&amp;rdquo;</span>これにより、＆ldquo; mutability＆rdquoのエイリアシングが緩和されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">restriction in places where it&#39;s unnecessary.</span>それが不要な場所での制限。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, this also relaxes the guarantees that the restriction provides;</span>ただし、これにより、制限によって提供される保証が緩和されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">so if your invariants depend on data stored within <code>Cell</code> , you should be careful.</span>したがって、invariantが<code>Cell</code>内に格納されたデータに依存する場合は、注意が必要です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is useful for mutating primitives and other types when there is no easy way of doing it in line with the static rules of <code>&amp;</code> and <code>&amp;mut</code> .</span>これは、 <code>&amp;</code>と<code>&amp;mut</code>静的規則に沿って簡単に行うことができない場合に、プリミティブやその他の型を変更する場合に便利です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>Cell</code> does not let you obtain interior references to the data, which makes it safe to freely mutate.</span> <code>Cell</code>は、データへの内部参照を取得することはできません。自由に変異させることができます。</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Cost</span>コスト</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There is no runtime cost to using <code>Cell&lt;T&gt;</code> , however if you are using it to wrap larger structs, it might be worthwhile to instead wrap individual fields in <code>Cell&lt;T&gt;</code> since each write is otherwise a full copy of the struct.</span> <code>Cell&lt;T&gt;</code>を使用するためのランタイム・コストはありませんが、より大きな構造体をラップするために使用している場合は、 <code>Cell&lt;T&gt;</code>内の個々のフィールドをラップする代わりに、各書き込みが構造体のフル・コピーであるため、</span> </p><br><br><h2> <code>RefCell&lt;T&gt;</code> </h2> <br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a class=notranslate href=#3refcell><code>RefCell&lt;T&gt;</code></a> also provides interior mutability, but doesn&#39;t move data in and out of the cell.</span> <a class=notranslate href=#3refcell><code>RefCell&lt;T&gt;</code></a>は内部の<a class=notranslate href=#3refcell><code>RefCell&lt;T&gt;</code></a>も提供しますが、セル内外のデータは移動しません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, it has a runtime cost.</span>ただし、ランタイムコストがあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>RefCell&lt;T&gt;</code> enforces the read-write lock pattern at runtime (it&#39;s like a single-threaded mutex), unlike <code>&amp;T</code> / <code>&amp;mut T</code> which do so at compile time.</span> <code>RefCell&lt;T&gt;</code>は、コンパイル時に実行する<code>&amp;T</code> / <code>&amp;mut T</code>とは異なり、実行時に読み書き可能なロックパターンを強制します（単一スレッドのミューテックスのようなものです）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is done by the <code>borrow()</code> and <code>borrow_mut()</code> functions, which modify an internal reference count and return smart pointers which can be dereferenced immutably and mutably respectively.</span>これは<code>borrow_mut()</code> <code>borrow()</code>と<code>borrow_mut()</code>関数によって行われ、内部参照カウントを変更してスマートポインタを返します。これらのスマートポインタはそれぞれ参照不可能で可変的に変更可能です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The refcount is restored when the smart pointers go out of scope.</span>スマートポインタが範囲外になると、refcountが復元されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">With this system, we can dynamically ensure that there are never any other borrows active when a mutable borrow is active.</span>このシステムでは、変更可能な借用がアクティブなときに他の借用がアクティブでないことを動的に保証することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If the programmer attempts to make such a borrow, the thread will panic.</span>プログラマーがそのような借用をしようとすると、スレッドはパニックに陥ります。</span> </p><br><div data-lang=rust><div data-l="use std::cell::RefCell;"></div><div data-l=""></div><div data-l="let x = RefCell::new(vec![1,2,3,4]);"></div><div data-l={></div><div data-l="    println!(&quot;{:?}&quot;, *x.borrow())"></div><div data-l=}></div><div data-l=""></div><div data-l={></div><div data-l="    let mut my_ref = x.borrow_mut();"></div><div data-l="    my_ref.push(1);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Similar to <code>Cell</code> , this is mainly useful for situations where it&#39;s hard or impossible to satisfy the borrow checker.</span> <code>Cell</code>と同様に、これは主に借用チェッカーを満たすことが困難または不可能な状況で役に立ちます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Generally we know that such mutations won&#39;t happen in a nested form, but it&#39;s good to check.</span>一般的に、このような突然変異はネストされた形では起こりませんが、確認するのは良いことです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For large, complicated programs, it becomes useful to put some things in <code>RefCell</code> s to make things simpler.</span>大規模で複雑なプログラムの場合、 <code>RefCell</code>にいくつかの事柄を入れて物事をより簡単にすることが有用になります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, a lot of the maps in the <code>ctxt</code> struct in the Rust compiler internals are inside this wrapper.</span>たとえば、Rustコンパイラ内部の<code>ctxt</code>構造体のマップの多くは、このラッパーの内側にあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These are only modified once (during creation, which is not right after initialization) or a couple of times in well-separated places.</span>これらは一度だけ（作成中は初期化直後ではない）一度変更されるか、または十分に離れた場所で数回修正されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, since this struct is pervasively used everywhere, juggling mutable and immutable pointers would be hard (perhaps impossible) and probably form a soup of <code>&amp;</code> -ptrs which would be hard to extend.</span>しかし、この構造体はどこにでも普遍的に使用されているので、変更可能なポインタと変更不能なポインタを扱うのは難しいかもしれません（たぶん不可能です）。おそらく拡張が困難な<code>&amp;</code> -ptrのスープを形成します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">On the other hand, the <code>RefCell</code> provides a cheap (not zero-cost) way of safely accessing these.</span>一方、 <code>RefCell</code>は安価な（ゼロコストではない）方法でこれらに安全にアクセスします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In the future, if someone adds some code that attempts to modify the cell when it&#39;s already borrowed, it will cause a (usually deterministic) panic which can be traced back to the offending borrow.</span>将来、誰かがすでに借用しているときにセルを修正しようとするコードを追加した場合、それは原因となる借りにさかのぼることができる（通常は確定的な）パニックを引き起こします。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Similarly, in Servo&#39;s DOM there is a lot of mutation, most of which is local to a DOM type, but some of which crisscrosses the DOM and modifies various things.</span>同様にServoのDOMには多くの変異がありますが、その大部分はDOM型の局所ですが、DOMの中には十字架があり、さまざまなものが変更されています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Using <code>RefCell</code> and <code>Cell</code> to guard all mutation lets us avoid worrying about mutability everywhere, and it simultaneously highlights the places where mutation is <s>actually</s> happening.</span> <code>RefCell</code>と<code>Cell</code>を使用してすべての変異を守ることで、あらゆる場所での変異の心配を避けることができ、突然変異が<s>実際に</s>起こっている場所を同時にハイライトすることができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that <code>RefCell</code> should be avoided if a mostly simple solution is possible with <code>&amp;</code> pointers.</span> <code>&amp;</code>ポインタを使ってほとんど単純な解決策が可能な場合、 <code>RefCell</code>は避けるべきです。</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Guarantees</span>保証</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>RefCell</code> relaxes the <s>static</s> restrictions preventing aliased mutation, and replaces them with <s>dynamic</s> ones.</span> <code>RefCell</code>は、エイリアシングされた変異を防ぐ<s>静的な</s>制限を緩和し、それらを<s>動的な</s>ものに置き換えます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As such the guarantees have not changed.</span>そのような保証は変更されていません。</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Cost</span>コスト</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>RefCell</code> does not allocate, but it contains an additional &quot;borrow state&quot; indicator (one word in size) along with the data.</span> <code>RefCell</code>は<code>RefCell</code>ませんが、データとともに、追加の「ボロー状態」インジケーター（サイズは1ワード）が含まれています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">At runtime each borrow causes a modification/check of the refcount.</span>実行時に、それぞれの借り入れによって参照カウントの変更/チェックが行われます。</span> </p><br> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a class=notranslate href=#1../../std/cell/index.html>cell-mod</a> <a class=notranslate href=#1../../std/cell/struct.Cell.html>cell</a> <a class=notranslate href=#1../../std/cell/struct.RefCell.html>refcell</a></span> <a class=notranslate href=#1../../std/cell/index.html>cell-mod</a> <a class=notranslate href=#1../../std/cell/struct.Cell.html>cell</a> <a class=notranslate href=#1../../std/cell/struct.RefCell.html>refcell</a> <a class=notranslate href=#1../../std/cell/struct.Cell.html>cell</a></span> <br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Synchronous types</span>同期型</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Many of the types above cannot be used in a threadsafe manner.</span>上記のタイプの多くは、スレッドセーフな方法で使用することはできません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Particularly, <code>Rc&lt;T&gt;</code> and <code>RefCell&lt;T&gt;</code> , which both use non-atomic reference counts ( <s>atomic</s> reference counts are those which can be incremented from multiple threads without causing a data race), cannot be used this way.</span>特に、非原子参照カウント（ <s>原子</s>参照カウントはデータ競合を引き起こすことなく複数のスレッドからインクリメントできるもの）を使用する<code>Rc&lt;T&gt;</code>および<code>RefCell&lt;T&gt;</code> 、このように使用することはできません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This makes them cheaper to use, but we need thread-safe versions of these too.</span>これにより、使用するのが安くなりますが、スレッドセーフなバージョンも必要になります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">They exist, in the form of <code>Arc&lt;T&gt;</code> and <code>Mutex&lt;T&gt;</code> / <code>RwLock&lt;T&gt;</code></span>それらは、 <code>Arc&lt;T&gt;</code>および<code>Mutex&lt;T&gt;</code> / <code>RwLock&lt;T&gt;</code>の形で存在し、</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that the non-threadsafe types <s>cannot</s> be sent between threads, and this is checked at compile time.</span>スレッドセーフで<s>はない</s>タイプ<s>は</s>スレッド間で送信<s>できない</s>ことに注意してください。これはコンパイル時にチェックされます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There are many useful wrappers for concurrent programming in the <a class=notranslate href=#3sync>sync</a> module, but only the major ones will be covered below.</span> <a class=notranslate href=#3sync>sync</a>モジュールの並列プログラミングには多くの有用なラッパーがありますが、主要なものだけを以下で説明します。</span> </p><br> <a class=notranslate href=#1../../std/sync/index.html>sync</a> <br> <h2> <code>Arc&lt;T&gt;</code> </h2> <br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a class=notranslate href=#3arc><code>Arc&lt;T&gt;</code></a> is a version of <code>Rc&lt;T&gt;</code> that uses an atomic reference count (hence, &quot;Arc&quot;).</span> <a class=notranslate href=#3arc><code>Arc&lt;T&gt;</code></a>は原子参照カウント（したがって &quot;Arc&quot;）を使用する<code>Rc&lt;T&gt;</code>バージョンです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This can be sent freely between threads.</span>これはスレッド間で自由に送信できます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">C++&#39;s <code>shared_ptr</code> is similar to <code>Arc</code> , however in the case of C++ the inner data is always mutable.</span> C ++の<code>shared_ptr</code>は<code>Arc</code>と似ていますが、C ++の場合、内部データは常に変更可能です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For semantics similar to that from C++, we should use <code>Arc&lt;Mutex&lt;T&gt;&gt;</code> , <code>Arc&lt;RwLock&lt;T&gt;&gt;</code> , or <code>Arc&lt;UnsafeCell&lt;T&gt;&gt;</code> <a class=notranslate href=#4^4>^4</a> ( <code>UnsafeCell&lt;T&gt;</code> is a cell type that can be used to hold any data and has no runtime cost, but accessing it requires <code>unsafe</code> blocks).</span> <code>Arc&lt;Mutex&lt;T&gt;&gt;</code> 、 <code>Arc&lt;RwLock&lt;T&gt;&gt;</code> 、または<code>Arc&lt;UnsafeCell&lt;T&gt;&gt;</code> <a class=notranslate href=#4^4>^4</a>使用する必要があります（ <code>UnsafeCell&lt;T&gt;</code>は、使用可能なセルタイプですデータを保持し、実行時コストはありませんが、アクセスには<code>unsafe</code>ブロックが必要です）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The last one should only be used if we are certain that the usage won&#39;t cause any memory unsafety.</span>最後のものは、その使用がメモリー不足の原因とならないことが確かな場合にのみ使用してください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Remember that writing to a struct is not an atomic operation, and many functions like <code>vec.push()</code> can reallocate internally and cause unsafe behavior, so even monotonicity may not be enough to justify <code>UnsafeCell</code> .</span>構造体への書き込みはアトミックな操作ではなく、 <code>vec.push()</code>などの多くの関数は内部的に再割り当てして安全でない動作を引き起こすことがあるので、単調性でさえ<code>UnsafeCell</code>を正当化するには不十分かもしれません。</span> </p><br> <a class=notranslate href="#1`Arc&lt;UnsafeCell&lt;T&gt;&gt;` actually won&#39;t compile since `UnsafeCell&lt;T&gt;` isn&#39;t `Send` or `Sync`, but we can wrap it in a type and implement `Send`/`Sync` for it manually to get `Arc&lt;Wrapper&lt;T&gt;&gt;` where `Wrapper` is `struct Wrapper&lt;T&gt;(UnsafeCell&lt;T&gt;)`.">^4</a> <br> <h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Guarantees</span>保証</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Like <code>Rc</code> , this provides the (thread-safe) guarantee that the destructor for the internal data will be run when the last <code>Arc</code> goes out of scope (barring any cycles).</span> <code>Rc</code>と同様に、これは、最後の<code>Arc</code>がスコープ外に出たとき（内部サイクルを除く）、内部データのデストラクタが実行される（スレッドセーフである）ことを保証します。</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Cost</span>コスト</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This has the added cost of using atomics for changing the refcount (which will happen whenever it is cloned or goes out of scope).</span>これは、参照カウントを変更するためにアトミックを使用するコストが追加されます（クローンが作成されるかスコープ外になるたびに発生します）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When sharing data from an <code>Arc</code> in a single thread, it is preferable to share <code>&amp;</code> pointers whenever possible.</span>以下からのデータを共有するときに<code>Arc</code>シングルスレッドでは、共有することが好ましい<code>&amp;</code>できるだけポインタ。</span> </p><br> <a class=notranslate href=#1../../std/sync/struct.Arc.html>arc</a> <br> <h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>Mutex&lt;T&gt;</code> and <code>RwLock&lt;T&gt;</code></span> <code>Mutex&lt;T&gt;</code>および<code>RwLock&lt;T&gt;</code></span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a class=notranslate href=#3mutex><code>Mutex&lt;T&gt;</code></a> and <a class=notranslate href=#3rwlock><code>RwLock&lt;T&gt;</code></a> provide mutual-exclusion via RAII guards (guards are objects which maintain some state, like a lock, until their destructor is called).</span> <a class=notranslate href=#3mutex><code>Mutex&lt;T&gt;</code></a>と<a class=notranslate href=#3rwlock><code>RwLock&lt;T&gt;</code></a>は、RAIIガード（ガードは、デストラクタが呼び出されるまでロックのような状態を維持するオブジェクトです）を介して相互排除を提供します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For both of these, the mutex is opaque until we call <code>lock()</code> on it, at which point the thread will block until a lock can be acquired, and then a guard will be returned.</span>どちらの場合でも、mutexは<code>lock()</code>を呼び出すまでは不透明で、ロックが獲得できるまでスレッドはブロックし、ガードが返されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This guard can be used to access the inner data (mutably), and the lock will be released when the guard goes out of scope.</span>このガードを使用して内側のデータにアクセスすることができ（変更可能）、ガードが有効範囲外になるとロックが解除されます。</span> </p><br><div data-lang=rust,ignore><div data-l={></div><div data-l="    let guard = mutex.lock();"></div><div data-l="#    // `guard` dereferences mutably to the inner type."></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>guard</code> dereferences mutably to the inner type.</span>内側の型に変更可能なdereferencesを<code>guard</code>ます。</span> </div><div data-l="    *guard += 1;"></div><div data-l="#//} // Lock is released when destructor runs."></div><div data-l="} // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Lock is released when destructor runs.</span>ロックは、デストラクタが実行されるときに解放されます。</span> </div></div><br><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>RwLock</code> has the added benefit of being efficient for multiple reads.</span> <code>RwLock</code>は、複数の読み取りに効率的であるという利点があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It is always safe to have multiple readers to shared data as long as there are no writers;</span>ライターがいない限り、共有データに複数のリーダーを置くことは常に安全です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">and <code>RwLock</code> lets readers acquire a &quot;read lock&quot;.</span> <code>RwLock</code>使用すると、読者は「読み取りロック」を取得できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Such locks can be acquired concurrently and are kept track of via a reference count.</span>このようなロックは同時に取得することができ、参照カウントによって追跡することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Writers must obtain a &quot;write lock&quot; which can only be obtained when all readers have gone out of scope.</span>ライターは、すべての読者が範囲外になった場合にのみ得られる「書込みロック」を取得する必要があります。</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Guarantees</span>保証</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Both of these provide safe shared mutability across threads, however they are prone to deadlocks.</span>これらの両方は、スレッド間で安全な共有の変更を提供しますが、デッドロックが発生しやすくなります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Some level of additional protocol safety can be obtained via the type system.</span>タイプ・システムを介して、あるレベルの追加のプロトコル安全性を得ることができる。</span> </p><br><h4> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Costs</span>コスト</span> </h4><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These use internal atomic-like types to maintain the locks, which are pretty costly (they can block all memory reads across processors till they&#39;re done).</span>これらは内部原子型の型を使用してロックを維持しますが、これは非常にコストがかかります（処理が完了するまですべてのメモリ読み込みをプロセッサ間でブロックすることができます）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Waiting on these locks can also be slow when there&#39;s a lot of concurrent access happening.</span>並行アクセスが頻繁に発生すると、これらのロックの待機も遅くなる可能性があります。</span> </p><br> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a class=notranslate href=#1../../std/sync/struct.RwLock.html>rwlock</a> <a class=notranslate href=#1../../std/sync/struct.Mutex.html>mutex</a> <a class=notranslate href=#1https://github.com/Munksgaard/rust-sessions>sessions</a></span> <a class=notranslate href=#1../../std/sync/struct.RwLock.html>rwlock</a> <a class=notranslate href=#1../../std/sync/struct.Mutex.html>mutex</a> <a class=notranslate href=#1https://github.com/Munksgaard/rust-sessions>sessions</a></span> <br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Composition</span>組成</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A common gripe when reading Rust code is with types like <code>Rc&lt;RefCell&lt;Vec&lt;T&gt;&gt;&gt;</code> (or even more complicated compositions of such types).</span>錆コードを読み取るときの一般的な不満は、 <code>Rc&lt;RefCell&lt;Vec&lt;T&gt;&gt;&gt;</code> （またはそのようなタイプのさらに複雑な構成）のようなタイプです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It&#39;s not always clear what the composition does, or why the author chose one like this (and when one should be using such a composition in one&#39;s own code)</span>コンポジションが何をしているのか、作者がこのようなものを選んだ理由（そして自分自身のコードでそのようなコンポジションを使用する必要がある場合）</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Usually, it&#39;s a case of composing together the guarantees that you need, without paying for stuff that is unnecessary.</span>通常、不要なものを払うことなく、必要な保証を一緒に構成することがあります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, <code>Rc&lt;RefCell&lt;T&gt;&gt;</code> is one such composition.</span>例えば、 <code>Rc&lt;RefCell&lt;T&gt;&gt;</code>はそのような構成の1つである。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>Rc&lt;T&gt;</code> itself can&#39;t be dereferenced mutably;</span> <code>Rc&lt;T&gt;</code>自体は、逆参照することはできません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">because <code>Rc&lt;T&gt;</code> provides sharing and shared mutability can lead to unsafe behavior, so we put <code>RefCell&lt;T&gt;</code> inside to get dynamically verified shared mutability.</span> <code>Rc&lt;T&gt;</code>は共有を提供し、共有の変更は安全ではない動作につながる可能性があるため、内部で<code>RefCell&lt;T&gt;</code>を動的に検証された共有の変更可能にします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now we have shared mutable data, but it&#39;s shared in a way that there can only be one mutator (and no readers) or multiple readers.</span>ここでは、変更可能なデータを共有しましたが、ミューテータが1つだけ（および読者なし）または複数の読者のみが存在するように共有されています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now, we can take this a step further, and have <code>Rc&lt;RefCell&lt;Vec&lt;T&gt;&gt;&gt;</code> or <code>Rc&lt;Vec&lt;RefCell&lt;T&gt;&gt;&gt;</code> .</span>これをさらに進めて、 <code>Rc&lt;RefCell&lt;Vec&lt;T&gt;&gt;&gt;</code>または<code>Rc&lt;Vec&lt;RefCell&lt;T&gt;&gt;&gt;</code>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These are both shareable, mutable vectors, but they&#39;re not the same.</span>これらは共有可能な可変ベクトルですが、同じではありません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">With the former, the <code>RefCell&lt;T&gt;</code> is wrapping the <code>Vec&lt;T&gt;</code> , so the <code>Vec&lt;T&gt;</code> in its entirety is mutable.</span>前者の場合、 <code>RefCell&lt;T&gt;</code>は<code>Vec&lt;T&gt;</code>ラッピングしているため、 <code>Vec&lt;T&gt;</code>全体が変更可能です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">At the same time, there can only be one mutable borrow of the whole <code>Vec</code> at a given time.</span>同時に、 <code>Vec</code>全体を一度に1つだけ変更することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This means that your code cannot simultaneously work on different elements of the vector from different <code>Rc</code> handles.</span>これは、コードが異なる<code>Rc</code>ハンドルからのベクトルの異なる要素で同時に動作できないことを意味します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, we are able to push and pop from the <code>Vec&lt;T&gt;</code> at will.</span>しかし、私たちは<code>Vec&lt;T&gt;</code>を押すことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is similar to a <code>&amp;mut Vec&lt;T&gt;</code> with the borrow checking done at runtime.</span>これは実行時に借用チェックが行われる<code>&amp;mut Vec&lt;T&gt;</code>似ています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">With the latter, the borrowing is of individual elements, but the overall vector is immutable.</span>後者の場合、借用は個々の要素で行われますが、全体のベクトルは不変です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Thus, we can independently borrow separate elements, but we cannot push or pop from the vector.</span>したがって、独立した要素を別々に借りることはできますが、ベクトルからプッシュまたはポップすることはできません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is similar to a <code>&amp;mut [T]</code> <a class=notranslate href=#4^3>^3</a> , but, again, the borrow checking is at runtime.</span>これは<code>&amp;mut [T]</code> <a class=notranslate href=#4^3>^3</a>と似ていますが、もう一度、借用チェックは実行時に行われます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In concurrent programs, we have a similar situation with <code>Arc&lt;Mutex&lt;T&gt;&gt;</code> , which provides shared mutability and ownership.</span>並行プログラムでは、 <code>Arc&lt;Mutex&lt;T&gt;&gt;</code>と同様の状況があります。これは、共有の変更と所有権を提供します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When reading code that uses these, go in step by step and look at the guarantees/costs provided.</span>これらを使用するコードを読むときは、段階的に進み、提供された保証/コストを見てください。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When choosing a composed type, we must do the reverse;</span>複合型を選択するときは、その逆を行う必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">figure out which guarantees we want, and at which point of the composition we need them.</span>私たちが望む保証と、それが必要な構成のどの時点であるかを把握します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, if there is a choice between <code>Vec&lt;RefCell&lt;T&gt;&gt;</code> and <code>RefCell&lt;Vec&lt;T&gt;&gt;</code> , we should figure out the trade-offs as done above and pick one.</span>たとえば、 <code>Vec&lt;RefCell&lt;T&gt;&gt;</code>と<code>RefCell&lt;Vec&lt;T&gt;&gt;</code>間に選択肢がある場合は、上記のようにトレードオフを把握して選択する必要があります。</span> </p><br> <a class=notranslate href="#1`&amp;[T]` and `&amp;mut [T]` are _slices_; they consist of a pointer and a length and can refer to a portion of a vector or array. `&amp;mut [T]` can have its elements mutated, however its length cannot be touched.">^3</a><script>_addload(function(){_setupIW('com');_csi('en','ja','choosing-your-guarantees.html');});</script>