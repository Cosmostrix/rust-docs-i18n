<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180709_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=structs.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Structs</span>構造</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>struct</code> s are a way of creating more complex data types.</span> <code>struct</code>はより複雑なデータ型を作成する方法です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, if we were doing calculations involving coordinates in 2D space, we would need both an <code>x</code> and a <code>y</code> value:</span>たとえば、2D空間で座標を含む計算を行う場合、 <code>x</code>と<code>y</code>両方の値が必要です。</span> </p><br><div data-lang=rust><div data-l="let origin_x = 0;"></div><div data-l="let origin_y = 0;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A <code>struct</code> lets us combine these two into a single, unified datatype with <code>x</code> and <code>y</code> as field labels:</span> <code>struct</code>使用すると、これらの2つを、フィールドラベルとして<code>x</code>と<code>y</code>を持つ単一の統一データ型に結合できます。</span> </p><br><div data-lang=rust><div data-l="struct Point {"></div><div data-l="    x: i32,"></div><div data-l="    y: i32,"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="#//    let origin = Point { x: 0, y: 0 }; // origin: Point"></div><div data-l="    let origin = Point { x: 0, y: 0 }; // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">origin: Point</span>起点：ポイント</span> </div><div data-l=""></div><div data-l="    println!(&quot;The origin is at ({}, {})&quot;, origin.x, origin.y);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There&#39;s a lot going on here, so let&#39;s break it down.</span>ここにはたくさんのことがあるので、それを分解してみましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We declare a <code>struct</code> with the <code>struct</code> keyword, and then with a name.</span> <code>struct</code>を<code>struct</code>キーワードで宣言してから、名前を付けて宣言します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">By convention, <code>struct</code> s begin with a capital letter and are camel cased: <code>PointInSpace</code> , not <code>Point_In_Space</code> .</span>規約では、 <code>struct</code>は大文字で始まり、ラクダ化されます： <code>PointInSpace</code>ではなく<code>Point_In_Space</code>です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can create an instance of our <code>struct</code> via <code>let</code> , as usual, but we use a <code>key: value</code> style syntax to set each field.</span>通常通り、 <code>let</code>を使って<code>struct</code>インスタンスを作成できますが、 <code>key: value</code>スタイルの構文を使用して各フィールドを設定します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The order doesn&#39;t need to be the same as in the original declaration.</span>順序は元の宣言と同じである必要はありません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Finally, because fields have names, we can access them through dot notation: <code>origin.x</code> .</span>最後に、フィールドには名前があるため、ドット表記<code>origin.x</code>アクセスできます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The values in <code>struct</code> s are immutable by default, like other bindings in Rust.</span> <code>struct</code>の値は、デフォルトでは不変です（Rustの他のバインディングと同じです）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Use <code>mut</code> to make them mutable:</span>それらを変更可能にするには<code>mut</code>を使用します：</span> </p><br><div data-lang=rust><div data-l="struct Point {"></div><div data-l="    x: i32,"></div><div data-l="    y: i32,"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let mut point = Point { x: 0, y: 0 };"></div><div data-l=""></div><div data-l="    point.x = 5;"></div><div data-l=""></div><div data-l="    println!(&quot;The point is at ({}, {})&quot;, point.x, point.y);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This will print <code>The point is at (5, 0)</code> .</span> <code>The point is at (5, 0)</code>印刷されます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust does not support field mutability at the language level, so you cannot write something like this:</span> Rustは言語レベルでのフィールドの変更をサポートしていないので、次のような記述はできません：</span> </p><br><div data-lang=rust,ignore><div data-l="struct Point {"></div><div data-l="#//    mut x: i32, // This causes an error."></div><div data-l="    mut x: i32, // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This causes an error.</span>これにより、エラーが発生します。</span> </div><div data-l="    y: i32,"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Mutability is a property of the binding, not of the structure itself.</span>変異性は、構造そのものではなく、結合の特性です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you&#39;re used to field-level mutability, this may seem strange at first, but it significantly simplifies things.</span>フィールドレベルの可変性に慣れていれば、これは最初は奇妙に思えるかもしれませんが、大幅に単純化します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It even lets you make things mutable on a temporary basis:</span>一時的に変更可能にすることさえできます：</span> </p><br><div data-lang=rust,ignore><div data-l="struct Point {"></div><div data-l="    x: i32,"></div><div data-l="    y: i32,"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let mut point = Point { x: 0, y: 0 };"></div><div data-l=""></div><div data-l="    point.x = 5;"></div><div data-l=""></div><div data-l="#//    let point = point; // `point` is now immutable."></div><div data-l="    let point = point; // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>point</code> is now immutable.</span> <code>point</code>は現在不変です。</span> </div><div data-l=""></div><div data-l="#//    point.y = 6; // This causes an error."></div><div data-l="    point.y = 6; // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This causes an error.</span>これにより、エラーが発生します。</span> </div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Your structure can still contain <code>&amp;mut</code> references, which will let you do some kinds of mutation:</span>あなたの構造には<code>&amp;mut</code>リファレンスが含まれていることがあります。これにより、いくつかの種類の突然変異をさせることができます：</span> </p><br><div data-lang=rust><div data-l="struct Point {"></div><div data-l="    x: i32,"></div><div data-l="    y: i32,"></div><div data-l=}></div><div data-l=""></div><div data-l="struct PointRef&lt;'a&gt; {"></div><div data-l="    x: &amp;'a mut i32,"></div><div data-l="    y: &amp;'a mut i32,"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let mut point = Point { x: 0, y: 0 };"></div><div data-l=""></div><div data-l="    {"></div><div data-l="        let r = PointRef { x: &amp;mut point.x, y: &amp;mut point.y };"></div><div data-l=""></div><div data-l="        *r.x = 5;"></div><div data-l="        *r.y = 6;"></div><div data-l="    }"></div><div data-l=""></div><div data-l="    assert_eq!(5, point.x);"></div><div data-l="    assert_eq!(6, point.y);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Initialization of a data structure (struct, enum, union) can be simplified when fields of the data structure are initialized with variables of the same names as the fields.</span>データ構造のフィールド（struct、enum、union）の初期化は、データ構造のフィールドがフィールドと同じ名前の変数で初期化されるときに簡略化できます。</span> </p><br><div data-lang=rust><div data-l=#[derive(Debug)]></div><div data-l="struct Person&lt;'a&gt; {"></div><div data-l="    name: &amp;'a str,"></div><div data-l="    age: u8"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="#    // Create struct with field init shorthand"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Create struct with field init shorthand</span>フィールドinitを省略した構造体を作成する</span> </div><div data-l="    let name = &quot;Peter&quot;;"></div><div data-l="    let age = 27;"></div><div data-l="    let peter = Person { name, age };"></div><div data-l=""></div><div data-l="#    // Debug-print struct"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Debug-print struct</span>デバッグ印刷の構造体</span> </div><div data-l="    println!(&quot;{:?}&quot;, peter);"></div><div data-l=}></div></div><br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Update syntax</span>構文の更新</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A <code>struct</code> can include <code>..</code> to indicate that you want to use a copy of some other <code>struct</code> for some of the values.</span> <code>struct</code>は、いくつかの値に対して他の<code>struct</code>コピーを使用することを示すために<code>..</code>を含めることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example:</span>例えば：</span> </p><br><div data-lang=rust><div data-l="struct Point3d {"></div><div data-l="    x: i32,"></div><div data-l="    y: i32,"></div><div data-l="    z: i32,"></div><div data-l=}></div><div data-l=""></div><div data-l="let mut point = Point3d { x: 0, y: 0, z: 0 };"></div><div data-l="point = Point3d { y: 1, .. point };"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This gives <code>point</code> a new <code>y</code> , but keeps the old <code>x</code> and <code>z</code> values.</span>これにより、 <code>point</code>に新しい<code>y</code>が与えられますが、古い<code>x</code>と<code>z</code>値は保持されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It doesn&#39;t have to be the same <code>struct</code> either, you can use this syntax when making new ones, and it will copy the values you don&#39;t specify:</span>同じ<code>struct</code>である必要はなく、新しい構文を作成するときにこの構文を使用できます。指定しない場合は、この構文を使用してコピーします。</span> </p><br><div data-lang=rust><div data-l="# struct Point3d {"></div><div data-l="#     x: i32,"></div><div data-l="#     y: i32,"></div><div data-l="#     z: i32,"></div><div data-l="# }"></div><div data-l="let origin = Point3d { x: 0, y: 0, z: 0 };"></div><div data-l="let point = Point3d { z: 1, x: 2, .. origin };"></div></div><br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Tuple structs</span>タプル構造体</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust has another data type that&#39;s like a hybrid between a <a class=notranslate href=#3tuple>tuple</a> and a <code>struct</code> , called a &#39;tuple struct&#39;.</span> Rustには、 <a class=notranslate href=#3tuple>tuple</a>と<code>struct</code>間のハイブリッドのような、 &#39;タプル構造体&#39;と呼ばれる別のデータ型があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Tuple structs have a name, but their fields don&#39;t.</span>タプル構造体は名前を持っていますが、フィールドはありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">They are declared with the <code>struct</code> keyword, and then with a name followed by a tuple:</span>それらは<code>struct</code>キーワードで宣言され、その後にタプルが続く名前で宣言されます。</span> </p><br> <a class=notranslate href=#1primitive-types.html#tuples>tuple</a> <br> <div data-lang=rust><div data-l="struct Color(i32, i32, i32);"></div><div data-l="struct Point(i32, i32, i32);"></div><div data-l=""></div><div data-l="let black = Color(0, 0, 0);"></div><div data-l="let origin = Point(0, 0, 0);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here, <code>black</code> and <code>origin</code> are not the same type, even though they contain the same values.</span>ここで、 <code>black</code>と<code>origin</code>は同じ値を含んでいても同じ型ではありません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The members of a tuple struct may be accessed by dot notation or destructuring <code>let</code> , just like regular tuples:</span>タプル構造体のメンバは、通常のタプルと同じように、ドット表記またはdestructuring <code>let</code>によってアクセスできます。</span> </p><br><div data-lang=rust><div data-l="# struct Color(i32, i32, i32);"></div><div data-l="# struct Point(i32, i32, i32);"></div><div data-l="# let black = Color(0, 0, 0);"></div><div data-l="# let origin = Point(0, 0, 0);"></div><div data-l="let black_r = black.0;"></div><div data-l="let Point(_, origin_y, origin_z) = origin;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Patterns like <code>Point(_, origin_y, origin_z)</code> are also used in <a href=#3match>match expressions</a> .</span> <code>Point(_, origin_y, origin_z)</code>ようなパターンも<a href=#3match>マッチ式で</a>使用され<a href=#3match>ます</a> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">One case when a tuple struct is very useful is when it has only one element.</span>タプル構造体が非常に有用な場合は、要素が1つしかない場合です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We call this the &#39;newtype&#39; pattern, because it allows you to create a new type that is distinct from its contained value and also expresses its own semantic meaning:</span>これを &#39;newtype&#39;パターンと呼びます。これは、新しい型をその含まれた値とは異なり、独自の意味的意味を表現できるようにするためです。</span> </p><br><div data-lang=rust><div data-l="struct Inches(i32);"></div><div data-l=""></div><div data-l="let length = Inches(10);"></div><div data-l=""></div><div data-l="let Inches(integer_length) = length;"></div><div data-l="println!(&quot;length is {} inches&quot;, integer_length);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As above, you can extract the inner integer type through a destructuring <code>let</code> .</span>上記のように、内部整数型は、非構造化<code>let</code>抽出できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this case, the <code>let Inches(integer_length)</code> assigns <code>10</code> to <code>integer_length</code> .</span>この場合、 <code>let Inches(integer_length)</code>は<code>integer_length</code> <code>10</code>を割り当てます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We could have used dot notation to do the same thing:</span>同じことをするためにドット表記法を使うことができました：</span> </p><br><div data-lang=rust><div data-l="# struct Inches(i32);"></div><div data-l="# let length = Inches(10);"></div><div data-l="let integer_length = length.0;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It&#39;s always possible to use a <code>struct</code> instead of a tuple struct, and can be clearer.</span>タプル構造<code>struct</code>代わりに<code>struct</code>を使用することは常に可能であり、より明確にすることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We could write <code>Color</code> and <code>Point</code> like this instead:</span>代わりに次のように<code>Color</code>と<code>Point</code>書くことができます：</span> </p><br><div data-lang=rust><div data-l="struct Color {"></div><div data-l="    red: i32,"></div><div data-l="    blue: i32,"></div><div data-l="    green: i32,"></div><div data-l=}></div><div data-l=""></div><div data-l="struct Point {"></div><div data-l="    x: i32,"></div><div data-l="    y: i32,"></div><div data-l="    z: i32,"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Good names are important, and while values in a tuple struct can be referenced with dot notation as well, a <code>struct</code> gives us actual names, rather than positions.</span>良い名前は重要で、タプル構造体の値はドット表記でも参照できますが、 <code>struct</code>は位置ではなく実際の名前を与えます。</span> </p><br> <a class=notranslate href=#1match.html>match</a> <br> <h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Unit-like structs</span>ユニットのような構造体</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can define a <code>struct</code> with no members at all:</span>メンバーを一切持たない<code>struct</code>を定義することができます：</span> </p><br><div data-lang=rust,ignore><div data-l="#//struct Electron {} // Use empty braces..."></div><div data-l="struct Electron {} // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Use empty braces...</span>空の中カッコを使う...</span> </div><div data-l="#//struct Proton;     // ...or just a semicolon."></div><div data-l="struct Proton;     // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">...or just a semicolon.</span> ...またはちょうどセミコロン。</span> </div><div data-l=""></div><div data-l="#// Use the same notation when creating an instance."></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Use the same notation when creating an instance.</span>インスタンスを作成するときは、同じ表記法を使用します。</span> </div><div data-l="let x = Electron {};"></div><div data-l="let y = Proton;"></div><div data-l="#//let z = Electron; // Error"></div><div data-l="let z = Electron; // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Error</span>エラー</span> </div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Such a <code>struct</code> is called &#39;unit-like&#39; because it resembles the empty tuple, <code>()</code> , sometimes called &#39;unit&#39;.</span>このような<code>struct</code>は空のタプル<code>()</code> 「ユニット」と呼ばれることもあります<code>()</code>に似ているため、「ユニットのような」と呼ばれます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Like a tuple struct, it defines a new type.</span>タプル構造体のように、新しい型を定義します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is rarely useful on its own (although sometimes it can serve as a marker type), but in combination with other features, it can become useful.</span>これはめったに役に立ちませんが（マーカータイプになることもありますが）、他の機能と組み合わせると便利になることがあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For instance, a library may ask you to create a structure that implements a certain <a class=notranslate href=#3trait>trait</a> to handle events.</span>たとえば、ライブラリは、イベントを処理するために特定の<a class=notranslate href=#3trait>trait</a>を実装する構造体を作成するよう要求することがあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you don&#39;t have any data you need to store in the structure, you can create a unit-like <code>struct</code> .</span>構造体に格納する必要があるデータがない場合は、ユニットのような<code>struct</code>作成できます。</span> </p><br> <a class=notranslate href=#1traits.html>trait</a><script>_addload(function(){_setupIW('com');_csi('en','ja','structs.html');});</script>