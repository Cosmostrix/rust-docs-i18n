<!DOCTYPE html>
<br>
<h1>RawVec</h1>
<br>
<p>We've actually reached an interesting situation here: we've duplicated the logic
for specifying a buffer and freeing its memory in Vec and IntoIter. Now that
we've implemented it and identified <i>actual</i> logic duplication, this is a good
time to perform some logic compression.</p>
<br>
<p>We're going to abstract out the <code>(ptr, cap)</code> pair and give them the logic for
allocating, growing, and freeing:</p>
<br>
<div data-lang="rust,ignore"><div data-l="struct RawVec&lt;T&gt; {"></div><div data-l="    ptr: Unique&lt;T&gt;,"></div><div data-l="    cap: usize,"></div><div data-l="}"></div><div data-l=""></div><div data-l="impl&lt;T&gt; RawVec&lt;T&gt; {"></div><div data-l="    fn new() -&gt; Self {"></div><div data-l="        assert!(mem::size_of::&lt;T&gt;() != 0, &quot;TODO: implement ZST support&quot;);"></div><div data-l="        RawVec { ptr: Unique::empty(), cap: 0 }"></div><div data-l="    }"></div><div data-l=""></div><div data-l="#    // unchanged from Vec"></div><div data-l="    // ">unchanged from Vec</div><div data-l="    fn grow(&amp;mut self) {"></div><div data-l="        unsafe {"></div><div data-l="            let align = mem::align_of::&lt;T&gt;();"></div><div data-l="            let elem_size = mem::size_of::&lt;T&gt;();"></div><div data-l=""></div><div data-l="            let (new_cap, ptr) = if self.cap == 0 {"></div><div data-l="                let ptr = heap::allocate(elem_size, align);"></div><div data-l="                (1, ptr)"></div><div data-l="            } else {"></div><div data-l="                let new_cap = 2 * self.cap;"></div><div data-l="                let ptr = heap::reallocate(self.ptr.as_ptr() as *mut _,"></div><div data-l="                                            self.cap * elem_size,"></div><div data-l="                                            new_cap * elem_size,"></div><div data-l="                                            align);"></div><div data-l="                (new_cap, ptr)"></div><div data-l="            };"></div><div data-l=""></div><div data-l="#            // If allocate or reallocate fail, we'll get `null` back"></div><div data-l="            // ">If allocate or reallocate fail, we'll get <code>null</code> back</div><div data-l="            if ptr.is_null() { oom() }"></div><div data-l=""></div><div data-l="            self.ptr = Unique::new(ptr as *mut _);"></div><div data-l="            self.cap = new_cap;"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l="}"></div><div data-l=""></div><div data-l=""></div><div data-l="impl&lt;T&gt; Drop for RawVec&lt;T&gt; {"></div><div data-l="    fn drop(&amp;mut self) {"></div><div data-l="        if self.cap != 0 {"></div><div data-l="            let align = mem::align_of::&lt;T&gt;();"></div><div data-l="            let elem_size = mem::size_of::&lt;T&gt;();"></div><div data-l="            let num_bytes = elem_size * self.cap;"></div><div data-l="            unsafe {"></div><div data-l="                heap::deallocate(self.ptr.as_mut() as *mut _, num_bytes, align);"></div><div data-l="            }"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l="}"></div></div>
<br>
<p>And change Vec as follows:</p>
<br>
<div data-lang="rust,ignore"><div data-l="pub struct Vec&lt;T&gt; {"></div><div data-l="    buf: RawVec&lt;T&gt;,"></div><div data-l="    len: usize,"></div><div data-l="}"></div><div data-l=""></div><div data-l="impl&lt;T&gt; Vec&lt;T&gt; {"></div><div data-l="    fn ptr(&amp;self) -&gt; *mut T { self.buf.ptr.as_ptr() }"></div><div data-l=""></div><div data-l="    fn cap(&amp;self) -&gt; usize { self.buf.cap }"></div><div data-l=""></div><div data-l="    pub fn new() -&gt; Self {"></div><div data-l="        Vec { buf: RawVec::new(), len: 0 }"></div><div data-l="    }"></div><div data-l=""></div><div data-l="#    // push/pop/insert/remove largely unchanged:"></div><div data-l="#    // * `self.ptr -&gt; self.ptr()`"></div><div data-l="#    // * `self.cap -&gt; self.cap()`"></div><div data-l="#    // * `self.grow -&gt; self.buf.grow()`"></div><div data-l="    // ">push/pop/insert/remove largely unchanged: * <code>self.ptr -&gt; self.ptr()</code> * <code>self.cap -&gt; self.cap()</code> * <code>self.grow -&gt; self.buf.grow()</code></div><div data-l="}"></div><div data-l=""></div><div data-l="impl&lt;T&gt; Drop for Vec&lt;T&gt; {"></div><div data-l="    fn drop(&amp;mut self) {"></div><div data-l="        while let Some(_) = self.pop() {}"></div><div data-l="#        // deallocation is handled by RawVec"></div><div data-l="        // ">deallocation is handled by RawVec</div><div data-l="    }"></div><div data-l="}"></div></div>
<br>
<p>And finally we can really simplify IntoIter:</p>
<br>
<div data-lang="rust,ignore"><div data-l="struct IntoIter&lt;T&gt; {"></div><div data-l="#//    _buf: RawVec&lt;T&gt;, // we don't actually care about this. Just need it to live."></div><div data-l="    _buf: RawVec&lt;T&gt;, // ">we don't actually care about this. Just need it to live.</div><div data-l="    start: *const T,"></div><div data-l="    end: *const T,"></div><div data-l="}"></div><div data-l=""></div><div data-l="#// next and next_back literally unchanged since they never referred to the buf"></div><div data-l="// ">next and next_back literally unchanged since they never referred to the buf</div><div data-l=""></div><div data-l="impl&lt;T&gt; Drop for IntoIter&lt;T&gt; {"></div><div data-l="    fn drop(&amp;mut self) {"></div><div data-l="#        // only need to ensure all our elements are read;"></div><div data-l="#        // buffer will clean itself up afterwards."></div><div data-l="        // ">only need to ensure all our elements are read; buffer will clean itself up afterwards.</div><div data-l="        for _ in &amp;mut *self {}"></div><div data-l="    }"></div><div data-l="}"></div><div data-l=""></div><div data-l="impl&lt;T&gt; Vec&lt;T&gt; {"></div><div data-l="    pub fn into_iter(self) -&gt; IntoIter&lt;T&gt; {"></div><div data-l="        unsafe {"></div><div data-l="#            // need to use ptr::read to unsafely move the buf out since it's"></div><div data-l="#            // not Copy, and Vec implements Drop (so we can't destructure it)."></div><div data-l="            // ">need to use ptr::read to unsafely move the buf out since it's not Copy, and Vec implements Drop (so we can't destructure it).</div><div data-l="            let buf = ptr::read(&amp;self.buf);"></div><div data-l="            let len = self.len;"></div><div data-l="            mem::forget(self);"></div><div data-l=""></div><div data-l="            IntoIter {"></div><div data-l="                start: *buf.ptr,"></div><div data-l="                end: buf.ptr.offset(len as isize),"></div><div data-l="                _buf: buf,"></div><div data-l="            }"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l="}"></div></div>
<br>
<p>Much better.</p>