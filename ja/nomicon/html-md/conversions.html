<!DOCTYPE html>
<h1>Type Conversions</h1>
<br>
<p>At the end of the day, everything is just a pile of bits somewhere, and type
systems are just there to help us use those bits right. There are two common
problems with typing bits: needing to reinterpret those exact bits as a
different type, and needing to change the bits to have equivalent meaning for
a different type. Because Rust encourages encoding important properties in the
type system, these problems are incredibly pervasive. As such, Rust
consequently gives you several ways to solve them.</p>
<br>
<p>First we'll look at the ways that Safe Rust gives you to reinterpret values.
The most trivial way to do this is to just destructure a value into its
constituent parts and then build a new type out of them. e.g.</p>
<br>
<div data-lang="rust"><div data-l="struct Foo {"></div><div data-l="    x: u32,"></div><div data-l="    y: u16,"></div><div data-l="}"></div><div data-l=""></div><div data-l="struct Bar {"></div><div data-l="    a: u32,"></div><div data-l="    b: u16,"></div><div data-l="}"></div><div data-l=""></div><div data-l="fn reinterpret(foo: Foo) -&gt; Bar {"></div><div data-l="    let Foo { x, y } = foo;"></div><div data-l="    Bar { a: x, b: y }"></div><div data-l="}"></div></div>
<br>
<p>But this is, at best, annoying. For common conversions, Rust provides
more ergonomic alternatives.</p>
<br>