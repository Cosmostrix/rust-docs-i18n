<!DOCTYPE html>
<h1>Drain</h1>
<br>
<p>Let's move on to Drain. Drain is largely the same as IntoIter, except that
instead of consuming the Vec, it borrows the Vec and leaves its allocation
untouched. For now we'll only implement the &quot;basic&quot; full-range version.</p>
<br>
<div data-lang="rust,ignore"><div data-l="use std::marker::PhantomData;"></div><div data-l=""></div><div data-l="struct Drain&lt;'a, T: 'a&gt; {"></div><div data-l="#    // Need to bound the lifetime here, so we do it with `&amp;'a mut Vec&lt;T&gt;`"></div><div data-l="#    // because that's semantically what we contain. We're &quot;just&quot; calling"></div><div data-l="#    // `pop()` and `remove(0)`."></div><div data-l="    // ">Need to bound the lifetime here, so we do it with <code>&amp;'a mut Vec&lt;T&gt;</code> because that's semantically what we contain. We're &quot;just&quot; calling <code>pop()</code> and <code>remove(0)</code>.</div><div data-l="    vec: PhantomData&lt;&amp;'a mut Vec&lt;T&gt;&gt;,"></div><div data-l="    start: *const T,"></div><div data-l="    end: *const T,"></div><div data-l="}"></div><div data-l=""></div><div data-l="impl&lt;'a, T&gt; Iterator for Drain&lt;'a, T&gt; {"></div><div data-l="    type Item = T;"></div><div data-l="    fn next(&amp;mut self) -&gt; Option&lt;T&gt; {"></div><div data-l="        if self.start == self.end {"></div><div data-l="            None"></div></div>
<br>
<p>-- wait, this is seeming familiar. Let's do some more compression. Both
IntoIter and Drain have the exact same structure, let's just factor it out.</p>
<br>
<div data-lang="rust"><div data-l="struct RawValIter&lt;T&gt; {"></div><div data-l="    start: *const T,"></div><div data-l="    end: *const T,"></div><div data-l="}"></div><div data-l=""></div><div data-l="impl&lt;T&gt; RawValIter&lt;T&gt; {"></div><div data-l="#    // unsafe to construct because it has no associated lifetimes."></div><div data-l="#    // This is necessary to store a RawValIter in the same struct as"></div><div data-l="#    // its actual allocation. OK since it's a private implementation"></div><div data-l="#    // detail."></div><div data-l="    // ">unsafe to construct because it has no associated lifetimes. This is necessary to store a RawValIter in the same struct as its actual allocation. OK since it's a private implementation detail.</div><div data-l="    unsafe fn new(slice: &amp;[T]) -&gt; Self {"></div><div data-l="        RawValIter {"></div><div data-l="            start: slice.as_ptr(),"></div><div data-l="            end: if slice.len() == 0 {"></div><div data-l="#                // if `len = 0`, then this is not actually allocated memory."></div><div data-l="#                // Need to avoid offsetting because that will give wrong"></div><div data-l="#                // information to LLVM via GEP."></div><div data-l="                // ">if <code>len = 0</code>, then this is not actually allocated memory. Need to avoid offsetting because that will give wrong information to LLVM via GEP.</div><div data-l="                slice.as_ptr()"></div><div data-l="            } else {"></div><div data-l="                slice.as_ptr().offset(slice.len() as isize)"></div><div data-l="            }"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l="}"></div><div data-l=""></div><div data-l="#// Iterator and DoubleEndedIterator impls identical to IntoIter."></div><div data-l="// ">Iterator and DoubleEndedIterator impls identical to IntoIter.</div></div>
<br>
<p>And IntoIter becomes the following:</p>
<br>
<div data-lang="rust,ignore"><div data-l="pub struct IntoIter&lt;T&gt; {"></div><div data-l="#//    _buf: RawVec&lt;T&gt;, // we don't actually care about this. Just need it to live."></div><div data-l="    _buf: RawVec&lt;T&gt;, // ">we don't actually care about this. Just need it to live.</div><div data-l="    iter: RawValIter&lt;T&gt;,"></div><div data-l="}"></div><div data-l=""></div><div data-l="impl&lt;T&gt; Iterator for IntoIter&lt;T&gt; {"></div><div data-l="    type Item = T;"></div><div data-l="    fn next(&amp;mut self) -&gt; Option&lt;T&gt; { self.iter.next() }"></div><div data-l="    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) { self.iter.size_hint() }"></div><div data-l="}"></div><div data-l=""></div><div data-l="impl&lt;T&gt; DoubleEndedIterator for IntoIter&lt;T&gt; {"></div><div data-l="    fn next_back(&amp;mut self) -&gt; Option&lt;T&gt; { self.iter.next_back() }"></div><div data-l="}"></div><div data-l=""></div><div data-l="impl&lt;T&gt; Drop for IntoIter&lt;T&gt; {"></div><div data-l="    fn drop(&amp;mut self) {"></div><div data-l="        for _ in &amp;mut self.iter {}"></div><div data-l="    }"></div><div data-l="}"></div><div data-l=""></div><div data-l="impl&lt;T&gt; Vec&lt;T&gt; {"></div><div data-l="    pub fn into_iter(self) -&gt; IntoIter&lt;T&gt; {"></div><div data-l="        unsafe {"></div><div data-l="            let iter = RawValIter::new(&amp;self);"></div><div data-l=""></div><div data-l="            let buf = ptr::read(&amp;self.buf);"></div><div data-l="            mem::forget(self);"></div><div data-l=""></div><div data-l="            IntoIter {"></div><div data-l="                iter: iter,"></div><div data-l="                _buf: buf,"></div><div data-l="            }"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l="}"></div></div>
<br>
<p>Note that I've left a few quirks in this design to make upgrading Drain to work
with arbitrary subranges a bit easier. In particular we <i>could</i> have RawValIter
drain itself on drop, but that won't work right for a more complex Drain.
We also take a slice to simplify Drain initialization.</p>
<br>
<p>Alright, now Drain is really easy:</p>
<br>
<div data-lang="rust,ignore"><div data-l="use std::marker::PhantomData;"></div><div data-l=""></div><div data-l="pub struct Drain&lt;'a, T: 'a&gt; {"></div><div data-l="    vec: PhantomData&lt;&amp;'a mut Vec&lt;T&gt;&gt;,"></div><div data-l="    iter: RawValIter&lt;T&gt;,"></div><div data-l="}"></div><div data-l=""></div><div data-l="impl&lt;'a, T&gt; Iterator for Drain&lt;'a, T&gt; {"></div><div data-l="    type Item = T;"></div><div data-l="    fn next(&amp;mut self) -&gt; Option&lt;T&gt; { self.iter.next() }"></div><div data-l="    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) { self.iter.size_hint() }"></div><div data-l="}"></div><div data-l=""></div><div data-l="impl&lt;'a, T&gt; DoubleEndedIterator for Drain&lt;'a, T&gt; {"></div><div data-l="    fn next_back(&amp;mut self) -&gt; Option&lt;T&gt; { self.iter.next_back() }"></div><div data-l="}"></div><div data-l=""></div><div data-l="impl&lt;'a, T&gt; Drop for Drain&lt;'a, T&gt; {"></div><div data-l="    fn drop(&amp;mut self) {"></div><div data-l="        for _ in &amp;mut self.iter {}"></div><div data-l="    }"></div><div data-l="}"></div><div data-l=""></div><div data-l="impl&lt;T&gt; Vec&lt;T&gt; {"></div><div data-l="    pub fn drain(&amp;mut self) -&gt; Drain&lt;T&gt; {"></div><div data-l="        unsafe {"></div><div data-l="            let iter = RawValIter::new(&amp;self);"></div><div data-l=""></div><div data-l="#            // this is a mem::forget safety thing. If Drain is forgotten, we just"></div><div data-l="#            // leak the whole Vec's contents. Also we need to do this *eventually*"></div><div data-l="#            // anyway, so why not do it now?"></div><div data-l="            // ">this is a mem::forget safety thing. If Drain is forgotten, we just leak the whole Vec's contents. Also we need to do this <i>eventually</i> anyway, so why not do it now?</div><div data-l="            self.len = 0;"></div><div data-l=""></div><div data-l="            Drain {"></div><div data-l="                iter: iter,"></div><div data-l="                vec: PhantomData,"></div><div data-l="            }"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l="}"></div></div>
<br>
<p>For more details on the <code>mem::forget</code> problem, see the
<a href="#3leaks">section on leaks</a>.</p>
<br>
<a class="notranslate" href="#1leaking.html">leaks</a>