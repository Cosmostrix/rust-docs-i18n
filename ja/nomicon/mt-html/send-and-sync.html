<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180723_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=send-and-sync.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Send and Sync</span>送信と同期</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Not everything obeys inherited mutability, though.</span>しかし、すべてが継承された変異性に従うわけではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Some types allow you to have multiple aliases of a location in memory while mutating it.</span>いくつかの型では、場所を変更しながらメモリ内の複数のエイリアスを持つことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Unless these types use synchronization to manage this access, they are absolutely not thread-safe.</span>これらのタイプがこのアクセスを管理するために同期を使用しない限り、スレッドセーフではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust captures this through the <code>Send</code> and <code>Sync</code> traits.</span>錆は、 <code>Send</code>と<code>Sync</code>特性によってこれを捕捉します。</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A type is Send if it is safe to send it to another thread.</span>他のスレッドに送信するのが安全な場合は、タイプは「送信」です。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A type is Sync if it is safe to share between threads ( <code>&amp;T</code> is Send).</span>スレッド間で共有することが安全であれば、タイプは同期です（ <code>&amp;T</code>は送信）。</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Send and Sync are fundamental to Rust&#39;s concurrency story.</span>送信と同期はRustの並行処理の基本です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As such, a substantial amount of special tooling exists to make them work right.</span>そのようなものとして、それらを正しく機能させるための相当量の特殊工具が存在します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">First and foremost, they&#39;re <a class=notranslate href="#4unsafe traits">unsafe traits</a> .</span>まず第一に、彼らは<a class=notranslate href="#4unsafe traits">unsafe traits</a>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This means that they are unsafe to implement, and other unsafe code can assume that they are correctly implemented.</span>これは、実装が安全でないことを意味し、他の安全でないコードは、それらが正しく実装されていると見なすことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Since they&#39;re <i>marker traits</i> (they have no associated items like methods), correctly implemented simply means that they have the intrinsic properties an implementor should have.</span>それらは<i>マーカーの特性</i> （メソッドのような関連項目はありません）であるため、正しく実装されているということは、単に実装者が持つべき固有のプロパティを持つことを意味します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Incorrectly implementing Send or Sync can cause Undefined Behavior.</span>送信または同期を誤って実装すると、未定義の動作が発生する可能性があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Send and Sync are also automatically derived traits.</span>送信と同期も自動的に導出された特性です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This means that, unlike every other trait, if a type is composed entirely of Send or Sync types, then it is Send or Sync.</span>これは、他のすべての特性とは異なり、タイプが送信または同期のタイプで完全に構成されている場合は、送信または同期であることを意味します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Almost all primitives are Send and Sync, and as a consequence pretty much all types you&#39;ll ever interact with are Send and Sync.</span>ほとんどのプリミティブはSendとSyncです。その結果、あなたがやりとりするすべてのタイプは、SendとSyncです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Major exceptions include:</span>主な例外は次のとおりです。</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">raw pointers are neither Send nor Sync (because they have no safety guards).</span>生ポインタは、送信ガードも同期もしません（セーフガードがないため）。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>UnsafeCell</code> isn&#39;t Sync (and therefore <code>Cell</code> and <code>RefCell</code> aren&#39;t).</span> <code>UnsafeCell</code>は同期ではありません（したがって、 <code>Cell</code>と<code>RefCell</code>は同期していません）。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>Rc</code> isn&#39;t Send or Sync (because the refcount is shared and unsynchronized).</span> <code>Rc</code>はSendまたはSyncではありません（refcountが共有され、同期していないため）。</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>Rc</code> and <code>UnsafeCell</code> are very fundamentally not thread-safe: they enable unsynchronized shared mutable state.</span> <code>Rc</code>と<code>UnsafeCell</code>は、基本的にスレッドセーフではありません。これらは、非同期の共有可能な可変状態を有効にします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However raw pointers are, strictly speaking, marked as thread-unsafe as more of a <i>lint</i> .</span>しかし、生のポインタは、厳密に言えば、スレッドセーフでない<i>糸くず</i>のよりなどとしてマークされています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Doing anything useful with a raw pointer requires dereferencing it, which is already unsafe.</span>未処理のポインタで役に立つものを実行するには、それを逆参照する必要があります。これはすでに安全ではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In that sense, one could argue that it would be &quot;fine&quot; for them to be marked as thread safe.</span>その意味では、スレッドセーフとしてマークするのは「罰金」であると主張することができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However it&#39;s important that they aren&#39;t thread-safe to prevent types that contain them from being automatically marked as thread-safe.</span>ただし、スレッドセーフではないことが重要です。スレッドセーフでないと、自動的にスレッドセーフとしてマークされません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These types have non-trivial untracked ownership, and it&#39;s unlikely that their author was necessarily thinking hard about thread safety.</span>これらのタイプは、非自明なトラッキングされていない所有権を持ちます。スレッドの安全性について、作者が必然的に考えているとは考えにくいです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In the case of <code>Rc</code> , we have a nice example of a type that contains a <code>*mut</code> that is definitely not thread-safe.</span> <code>Rc</code>の場合、確実にスレッドセーフではない<code>*mut</code>を含む型の良い例があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Types that aren&#39;t automatically derived can simply implement them if desired:</span>自動的に導出されないタイプは、必要に応じて簡単に実装できます。</span> </p><br><div data-lang=rust><div data-l="struct MyBox(*mut u8);"></div><div data-l=""></div><div data-l="unsafe impl Send for MyBox {}"></div><div data-l="unsafe impl Sync for MyBox {}"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In the <i>incredibly rare</i> case that a type is inappropriately automatically derived to be Send or Sync, then one can also unimplement Send and Sync:</span> <i>非常にまれな</i>ケースでは、タイプがSendまたはSyncに自動的に不適切に誘導された場合、SendおよびSyncも実装できません。</span> </p><br><div data-lang=rust><div data-l=#![feature(optin_builtin_traits)]></div><div data-l=""></div><div data-l="#// I have some magic semantics for some synchronization primitive!"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">I have some magic semantics for some synchronization primitive!</span>私はいくつかの同期プリミティブのいくつかの魔法のセマンティクスを持っています！</span> </div><div data-l="struct SpecialThreadToken(u8);"></div><div data-l=""></div><div data-l="impl !Send for SpecialThreadToken {}"></div><div data-l="impl !Sync for SpecialThreadToken {}"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that <i>in and of itself</i> it is impossible to incorrectly derive Send and Sync.</span>送信と同期を間違って派生させることは不可能<i>である</i>ことに注意してください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Only types that are ascribed special meaning by other unsafe code can possible cause trouble by being incorrectly Send or Sync.</span>他の安全でないコードによって特別な意味が与えられているタイプだけが、間違って送信または同期することによって問題を引き起こす可能性があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Most uses of raw pointers should be encapsulated behind a sufficient abstraction that Send and Sync can be derived.</span>生ポインタのほとんどの使用法は、SendとSyncを導出するのに十分な抽象化の背後にカプセル化する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For instance all of Rust&#39;s standard collections are Send and Sync (when they contain Send and Sync types) in spite of their pervasive use of raw pointers to manage allocations and complex ownership.</span>たとえば、Rustの標準コレクションのすべては、割り当てや複雑な所有権を管理するために生ポインタを広範囲に使用しているにもかかわらず、SendとSync（SendタイプとSyncタイプが含まれている場合）です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Similarly, most iterators into these collections are Send and Sync because they largely behave like an <code>&amp;</code> or <code>&amp;mut</code> into the collection.</span>同様に、これらのコレクションのほとんどのイテレータは、SendおよびSyncです。これは、大部分がコレクションの<code>&amp;</code>または<code>&amp;mut</code>ように動作するためです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">TODO: better explain what can or can&#39;t be Send or Sync.</span> TODO：送信または同期ができるかどうかを詳しく説明します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Sufficient to appeal only to data races?</span>データレースだけにアピールするには十分ですか？</span> </p><br> <a class=notranslate href=#1safe-unsafe-meaning.html>unsafe traits</a><script>_addload(function(){_setupIW('com');_csi('en','ja','send-and-sync.html');});</script>