<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180723_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=vec-raw.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">RawVec</span> RawVec</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ve actually reached an interesting situation here: we&#39;ve duplicated the logic for specifying a buffer and freeing its memory in Vec and IntoIter.</span> VecとIntoIterでバッファを指定し、そのメモリを解放するロジックを複製しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now that we&#39;ve implemented it and identified <i>actual</i> logic duplication, this is a good time to perform some logic compression.</span>これを実装し、 <i>実際の</i>ロジックの重複を特定したので、これはロジック圧縮を行う良いタイミングです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;re going to abstract out the <code>(ptr, cap)</code> pair and give them the logic for allocating, growing, and freeing:</span>私たちは<code>(ptr, cap)</code>ペアを抽象化して、割り当て、成長、解放のロジックを与えます：</span> </p><br><div data-lang=rust,ignore><div data-l="struct RawVec&lt;T&gt; {"></div><div data-l="    ptr: Unique&lt;T&gt;,"></div><div data-l="    cap: usize,"></div><div data-l=}></div><div data-l=""></div><div data-l="impl&lt;T&gt; RawVec&lt;T&gt; {"></div><div data-l="    fn new() -&gt; Self {"></div><div data-l="        assert!(mem::size_of::&lt;T&gt;() != 0, &quot;TODO: implement ZST support&quot;);"></div><div data-l="        RawVec { ptr: Unique::empty(), cap: 0 }"></div><div data-l="    }"></div><div data-l=""></div><div data-l="#    // unchanged from Vec"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">unchanged from Vec</span> Vecから変わらない</span> </div><div data-l="    fn grow(&amp;mut self) {"></div><div data-l="        unsafe {"></div><div data-l="            let align = mem::align_of::&lt;T&gt;();"></div><div data-l="            let elem_size = mem::size_of::&lt;T&gt;();"></div><div data-l=""></div><div data-l="            let (new_cap, ptr) = if self.cap == 0 {"></div><div data-l="                let ptr = heap::allocate(elem_size, align);"></div><div data-l="                (1, ptr)"></div><div data-l="            } else {"></div><div data-l="                let new_cap = 2 * self.cap;"></div><div data-l="                let ptr = heap::reallocate(self.ptr.as_ptr() as *mut _,"></div><div data-l="                                            self.cap * elem_size,"></div><div data-l="                                            new_cap * elem_size,"></div><div data-l="                                            align);"></div><div data-l="                (new_cap, ptr)"></div><div data-l="            };"></div><div data-l=""></div><div data-l="#            // If allocate or reallocate fail, we'll get `null` back"></div><div data-l="            // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If allocate or reallocate fail, we&#39;ll get <code>null</code> back</span> allocateまたはreallocateが失敗すると、 <code>null</code>戻されます。</span> </div><div data-l="            if ptr.is_null() { oom() }"></div><div data-l=""></div><div data-l="            self.ptr = Unique::new(ptr as *mut _);"></div><div data-l="            self.cap = new_cap;"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l=""></div><div data-l="impl&lt;T&gt; Drop for RawVec&lt;T&gt; {"></div><div data-l="    fn drop(&amp;mut self) {"></div><div data-l="        if self.cap != 0 {"></div><div data-l="            let align = mem::align_of::&lt;T&gt;();"></div><div data-l="            let elem_size = mem::size_of::&lt;T&gt;();"></div><div data-l="            let num_bytes = elem_size * self.cap;"></div><div data-l="            unsafe {"></div><div data-l="                heap::deallocate(self.ptr.as_mut() as *mut _, num_bytes, align);"></div><div data-l="            }"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">And change Vec as follows:</span> Vecを次のように変更します。</span> </p><br><div data-lang=rust,ignore><div data-l="pub struct Vec&lt;T&gt; {"></div><div data-l="    buf: RawVec&lt;T&gt;,"></div><div data-l="    len: usize,"></div><div data-l=}></div><div data-l=""></div><div data-l="impl&lt;T&gt; Vec&lt;T&gt; {"></div><div data-l="    fn ptr(&amp;self) -&gt; *mut T { self.buf.ptr.as_ptr() }"></div><div data-l=""></div><div data-l="    fn cap(&amp;self) -&gt; usize { self.buf.cap }"></div><div data-l=""></div><div data-l="    pub fn new() -&gt; Self {"></div><div data-l="        Vec { buf: RawVec::new(), len: 0 }"></div><div data-l="    }"></div><div data-l=""></div><div data-l="#    // push/pop/insert/remove largely unchanged:"></div><div data-l="#    // * `self.ptr -&gt; self.ptr()`"></div><div data-l="#    // * `self.cap -&gt; self.cap()`"></div><div data-l="#    // * `self.grow -&gt; self.buf.grow()`"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">push/pop/insert/remove largely unchanged: * <code>self.ptr -&gt; self.ptr()</code> * <code>self.cap -&gt; self.cap()</code> * <code>self.grow -&gt; self.buf.grow()</code></span> * <code>self.ptr -&gt; self.ptr()</code> * <code>self.cap -&gt; self.cap()</code> * <code>self.grow -&gt; self.buf.grow()</code></span> </div><div data-l=}></div><div data-l=""></div><div data-l="impl&lt;T&gt; Drop for Vec&lt;T&gt; {"></div><div data-l="    fn drop(&amp;mut self) {"></div><div data-l="        while let Some(_) = self.pop() {}"></div><div data-l="#        // deallocation is handled by RawVec"></div><div data-l="        // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">deallocation is handled by RawVec</span>割り当て解除はRawVecによって処理されます</span> </div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">And finally we can really simplify IntoIter:</span>そして最後に、IntoIterを実際に単純化することができます：</span> </p><br><div data-lang=rust,ignore><div data-l="struct IntoIter&lt;T&gt; {"></div><div data-l="#//    _buf: RawVec&lt;T&gt;, // we don't actually care about this. Just need it to live."></div><div data-l="    _buf: RawVec&lt;T&gt;, // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">we don&#39;t actually care about this.</span>私たちは実際にこれに気をつけません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Just need it to live.</span>ただそれが生きるために必要です。</span> </div><div data-l="    start: *const T,"></div><div data-l="    end: *const T,"></div><div data-l=}></div><div data-l=""></div><div data-l="#// next and next_back literally unchanged since they never referred to the buf"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">next and next_back literally unchanged since they never referred to the buf</span> nextとnext_backはbufを参照していないので文字通り変更されません</span> </div><div data-l=""></div><div data-l="impl&lt;T&gt; Drop for IntoIter&lt;T&gt; {"></div><div data-l="    fn drop(&amp;mut self) {"></div><div data-l="#        // only need to ensure all our elements are read;"></div><div data-l="#        // buffer will clean itself up afterwards."></div><div data-l="        // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">only need to ensure all our elements are read;</span>すべての要素を確実に読み取る必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">buffer will clean itself up afterwards.</span>バッファは後で自身をクリーンアップします。</span> </div><div data-l="        for _ in &amp;mut *self {}"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="impl&lt;T&gt; Vec&lt;T&gt; {"></div><div data-l="    pub fn into_iter(self) -&gt; IntoIter&lt;T&gt; {"></div><div data-l="        unsafe {"></div><div data-l="#            // need to use ptr::read to unsafely move the buf out since it's"></div><div data-l="#            // not Copy, and Vec implements Drop (so we can't destructure it)."></div><div data-l="            // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">need to use ptr::read to unsafely move the buf out since it&#39;s not Copy, and Vec implements Drop (so we can&#39;t destructure it).</span>それはコピーではないのでbufを安全に動かすためにptr :: readを使う必要があります.VecはDropを実装していますので、それを解体することはできません。</span> </div><div data-l="            let buf = ptr::read(&amp;self.buf);"></div><div data-l="            let len = self.len;"></div><div data-l="            mem::forget(self);"></div><div data-l=""></div><div data-l="            IntoIter {"></div><div data-l="                start: *buf.ptr,"></div><div data-l="                end: buf.ptr.offset(len as isize),"></div><div data-l="                _buf: buf,"></div><div data-l="            }"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Much better.</span>ずっといい。</span> </p><script>_addload(function(){_setupIW('com');_csi('en','ja','vec-raw.html');});</script>