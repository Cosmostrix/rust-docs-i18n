<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180723_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=coercions.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Coercions</span>強制</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Types can implicitly be coerced to change in certain contexts.</span>型は、暗黙のうちに特定のコンテキストで変更するように強制できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These changes are generally just <i>weakening</i> of types, largely focused around pointers and lifetimes.</span>これらの変更は、一般的にポインタの種類やライフタイムに焦点を当てたタイプの<i>弱さ</i>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">They mostly exist to make Rust &quot;just work&quot; in more cases, and are largely harmless.</span>彼らはほとんどの場合、Rustを &quot;ちょうど仕事&quot;にするために存在し、ほとんど無害です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here&#39;s all the kinds of coercion:</span>ここにはすべての種類の強制があります：</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Coercion is allowed between the following types:</span>以下のタイプの間で強制が許されます：</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Transitivity: <code>T_1</code> to <code>T_3</code> where <code>T_1</code> coerces to <code>T_2</code> and <code>T_2</code> coerces to <code>T_3</code></span>推移性： <code>T_1</code>へ<code>T_3</code> <code>T_1</code>に強制変換<code>T_2</code>と<code>T_2</code>に強制し<code>T_3</code></span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Pointer Weakening:</span>ポインタの弱化：</span> </div><div data-b="    *"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>&amp;mut T</code> to <code>&amp;T</code></span> <code>&amp;mut T</code>から<code>&amp;T</code>への<code>&amp;mut T</code></span> </div><div data-b="    *"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>*mut T</code> to <code>*const T</code></span> <code>*mut T</code>から<code>*const T</code></span> </div><div data-b="    *"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>&amp;T</code> to <code>*const T</code></span> <code>&amp;T</code>から<code>*const T</code></span> </div><div data-b="    *"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>&amp;mut T</code> to <code>*mut T</code></span> <code>&amp;mut T</code>から<code>*mut T</code></span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Unsizing: <code>T</code> to <code>U</code> if <code>T</code> implements <code>CoerceUnsized&lt;U&gt;</code></span> Unsizing： <code>T</code>へ<code>U</code>あれば<code>T</code>実装<code>CoerceUnsized&lt;U&gt;</code></span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Deref coercion: Expression <code>&amp;x</code> of type <code>&amp;T</code> to <code>&amp;*x</code> of type <code>&amp;U</code> if <code>T</code> derefs to <code>U</code> (ie <code>T: Deref&lt;Target=U&gt;</code> )</span> DEREF強制：式<code>&amp;x</code>タイプの<code>&amp;T</code>する<code>&amp;*x</code>タイプの<code>&amp;U</code>の場合<code>T</code>へderefs <code>U</code> （すなわち<code>T: Deref&lt;Target=U&gt;</code></span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>CoerceUnsized&lt;Pointer&lt;U&gt;&gt; for Pointer&lt;T&gt; where T: Unsize&lt;U&gt;</code> is implemented for all pointer types (including smart pointers like Box and Rc).</span> <code>CoerceUnsized&lt;Pointer&lt;U&gt;&gt; for Pointer&lt;T&gt; where T: Unsize&lt;U&gt;</code>は、すべてのポインタ型（BoxやRcのようなスマートポインタを含む）に対して実装されています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Unsize is only implemented automatically, and enables the following transformations:</span>サイズの変更は自動的にのみ実装され、次の変換が有効になります。</span> </p><br><div data-b=*> <code>[T; n]</code> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>[T; n]</code> =&gt; <code>[T]</code></span> <code>[T; n]</code> =&gt; <code>[T]</code></span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>T</code> =&gt; <code>Trait</code> where <code>T: Trait</code></span> <code>T</code> =&gt; <code>Trait</code>ここで、 <code>T: Trait</code></span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>Foo&lt;..., T, ...&gt;</code> =&gt; <code>Foo&lt;..., U, ...&gt;</code> where:</span> <code>Foo&lt;..., T, ...&gt;</code> =&gt; <code>Foo&lt;..., U, ...&gt;</code>ここで、</span> </div><div data-b="    *"> <code>T: Unsize&lt;U&gt;</code> </div> <div data-b="    *"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>Foo</code> is a struct</span> <code>Foo</code>は構造体です</span> </div><div data-b="    *"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Only the last field of <code>Foo</code> has type involving <code>T</code></span> <code>Foo</code>の最後のフィールドだけが<code>T</code></span> </div><div data-b="    *"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>T</code> is not part of the type of any other fields</span> <code>T</code>は他のフィールドの型の一部ではありません</span> </div><div data-b="    *"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>Bar&lt;T&gt;: Unsize&lt;Bar&lt;U&gt;&gt;</code> , if the last field of <code>Foo</code> has type <code>Bar&lt;T&gt;</code></span> <code>Bar&lt;T&gt;: Unsize&lt;Bar&lt;U&gt;&gt;</code> <code>Foo</code>の最後のフィールドが<code>Bar&lt;T&gt;</code>型の場合、</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Coercions occur at a <i>coercion site</i> .</span>強制は<i>強要現場で行われる</i> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Any location that is explicitly typed will cause a coercion to its type.</span>明示的に型指定された場所は、その型へ強制変換されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If inference is necessary, the coercion will not be performed.</span>推論が必要な場合、強制は実行されません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Exhaustively, the coercion sites for an expression <code>e</code> to type <code>U</code> are:</span>徹底的に言えば、式<code>e</code>が<code>U</code>型に変換された強制変換サイトは次のとおりです。</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">let statements, statics, and consts: <code>let x: U = e</code></span> let文、statics、constを<code>let x: U = e</code></span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Arguments to functions: <code>takes_a_U(e)</code></span>関数への引数： <code>takes_a_U(e)</code></span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Any expression that will be returned: <code>fn foo() -&gt; U { e }</code></span>返される式： <code>fn foo() -&gt; U { e }</code></span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Struct literals: <code>Foo { some_u: e }</code></span>構造体リテラル： <code>Foo { some_u: e }</code></span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Array literals: <code>let x: [U; 10] = [e, ..]</code></span>配列リテラル： <code>let x: [U; 10] = [e, ..]</code></span> <code>let x: [U; 10] = [e, ..]</code> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Tuple literals: <code>let x: (U, ..) = (e, ..)</code></span>タプルリテラル： <code>let x: (U, ..) = (e, ..)</code></span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The last expression in a block: <code>let x: U = { ..; e }</code></span>ブロック内の最後の式： <code>let x: U = { ..; e }</code></span> <code>let x: U = { ..; e }</code> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that we do not perform coercions when matching traits (except for receivers, see below).</span>特性をマッチングするときに強制的に変換を実行しないことに注意してください（レシーバを除く、以下を参照）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If there is an impl for some type <code>U</code> and <code>T</code> coerces to <code>U</code> , that does not constitute an implementation for <code>T</code> .</span>いくつかのタイプのIMPLがある場合に<code>U</code>及び<code>T</code>に強制変換<code>U</code> 、それがの実装構成しない<code>T</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, the following will not type check, even though it is OK to coerce <code>t</code> to <code>&amp;T</code> and there is an impl for <code>&amp;T</code> :</span>たとえば、次の例は、強制するOKであっても、型チェックはありません<code>t</code>に<code>&amp;T</code>とのための独自の実装があり<code>&amp;T</code> ：</span> </p><br><div data-lang=rust,ignore><div data-l="trait Trait {}"></div><div data-l=""></div><div data-l="fn foo&lt;X: Trait&gt;(t: X) {}"></div><div data-l=""></div><div data-l="impl&lt;'a&gt; Trait for &amp;'a i32 {}"></div><div data-l=""></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let t: &amp;mut i32 = &amp;mut 0;"></div><div data-l="    foo(t);"></div><div data-l=}></div></div><br><div data-lang=text><div data-l="&lt;anon&gt;:10:5: 10:8 error: the trait bound `&amp;mut i32 : Trait` is not satisfied [E0277]"></div><div data-l="&lt;anon&gt;:10     foo(t);"></div><div data-l="              ^~~"></div></div><script>_addload(function(){_setupIW('com');_csi('en','ja','coercions.html');});</script>