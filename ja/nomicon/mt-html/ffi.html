<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180723_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=ffi.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Foreign Function Interface</span>外部関数インタフェース</span> </h1><br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Introduction</span>前書き</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This guide will use the <a class=notranslate href=#2https://github.com/google/snappy>snappy</a> compression/decompression library as an introduction to writing bindings for foreign code.</span>このガイドでは、外部コード用のバインディングを作成するための紹介として、 <a class=notranslate href=#2https://github.com/google/snappy>snappy</a>圧縮/解凍ライブラリを使用します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust is currently unable to call directly into a C++ library, but snappy includes a C interface (documented in <a class=notranslate href=#2https://github.com/google/snappy/blob/master/snappy-c.h><code>snappy-ch</code></a> ).</span> Rustは現在のところC ++ライブラリに直接呼び出すことはできませんが、スナッピーにはCインターフェイス（ <a class=notranslate href=#2https://github.com/google/snappy/blob/master/snappy-c.h><code>snappy-ch</code></a>記載されています）が含まれています。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A note about libc</span> libcについての注意</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Many of these examples use <a href=#3libc>the <code>libc</code> crate</a> , which provides various type definitions for C types, among other things.</span>これらの例の多くは<a href=#3libc>、 <code>libc</code> crateを</a>使用し<a href=#3libc>て</a>います<a href=#3libc><code>libc</code> crateは</a> 、Cタイプなどのさまざまな型定義を提供します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you&#39;re trying these examples yourself, you&#39;ll need to add <code>libc</code> to your <code>Cargo.toml</code> :</span>これらの例を自分で試しているのであれば、 <code>Cargo.toml</code> <code>libc</code>を追加する必要があります：</span> </p><br><div data-lang=toml><div data-l=[dependencies]></div><div data-l="libc = &quot;0.2.0&quot;"></div></div><br> <a class=notranslate href=#1https://crates.io/crates/libc>libc</a> <br> <p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">and add <code>extern crate libc;</code></span> <code>extern crate libc;</code>を追加し<code>extern crate libc;</code></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">to your crate root.</span>あなたのクレートの根に。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Calling foreign functions</span>外国の関数を呼び出す</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The following is a minimal example of calling a foreign function which will compile if snappy is installed:</span>以下は、snappyがインストールされている場合にコンパイルする外部関数を呼び出す最小限の例です。</span> </p><br><div data-lang=rust,ignore><div data-l="extern crate libc;"></div><div data-l="use libc::size_t;"></div><div data-l=""></div><div data-l="#[link(name = &quot;snappy&quot;)]"></div><div data-l="extern {"></div><div data-l="    fn snappy_max_compressed_length(source_length: size_t) -&gt; size_t;"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let x = unsafe { snappy_max_compressed_length(100) };"></div><div data-l="    println!(&quot;max compressed length of a 100 byte buffer: {}&quot;, x);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>extern</code> block is a list of function signatures in a foreign library, in this case with the platform&#39;s C ABI.</span> <code>extern</code>ブロックは、外部ライブラリの関数シグネチャのリストです（この場合、プラットフォームのC ABIが使用されます）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>#[link(...)]</code> attribute is used to instruct the linker to link against the snappy library so the symbols are resolved.</span> <code>#[link(...)]</code>属性は、シンボルが解決されるようにスナッピーライブラリとリンクするようリンカーに指示するために使用されます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Foreign functions are assumed to be unsafe so calls to them need to be wrapped with <code>unsafe {}</code> as a promise to the compiler that everything contained within truly is safe.</span>外部関数は安全ではないと想定されているため、コンパイラに対する約束として<code>unsafe {}</code>で<code>unsafe {}</code>で<code>unsafe {}</code>必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">C libraries often expose interfaces that aren&#39;t thread-safe, and almost any function that takes a pointer argument isn&#39;t valid for all possible inputs since the pointer could be dangling, and raw pointers fall outside of Rust&#39;s safe memory model.</span> Cライブラリはスレッドセーフではないインターフェイスを頻繁に公開し、ポインタ引数をとるほとんどすべての関数は、ポインタがぶら下がっている可能性があり、生ポインタがRustの安全メモリモデルの外にあるため、すべての可能な入力に対して有効ではありません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When declaring the argument types to a foreign function, the Rust compiler cannot check if the declaration is correct, so specifying it correctly is part of keeping the binding correct at runtime.</span>引数型を外部関数に宣言するとき、Rustコンパイラは宣言が正しいかどうかをチェックすることはできません。したがって、正しく指定することは実行時にバインディングを正しく保持することの一部です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>extern</code> block can be extended to cover the entire snappy API:</span> <code>extern</code>ブロックは、スナッピーAPI全体をカバーするように拡張することができます：</span> </p><br><div data-lang=rust,ignore><div data-l="extern crate libc;"></div><div data-l="use libc::{c_int, size_t};"></div><div data-l=""></div><div data-l="#[link(name = &quot;snappy&quot;)]"></div><div data-l="extern {"></div><div data-l="    fn snappy_compress(input: *const u8,"></div><div data-l="                       input_length: size_t,"></div><div data-l="                       compressed: *mut u8,"></div><div data-l="                       compressed_length: *mut size_t) -&gt; c_int;"></div><div data-l="    fn snappy_uncompress(compressed: *const u8,"></div><div data-l="                         compressed_length: size_t,"></div><div data-l="                         uncompressed: *mut u8,"></div><div data-l="                         uncompressed_length: *mut size_t) -&gt; c_int;"></div><div data-l="    fn snappy_max_compressed_length(source_length: size_t) -&gt; size_t;"></div><div data-l="    fn snappy_uncompressed_length(compressed: *const u8,"></div><div data-l="                                  compressed_length: size_t,"></div><div data-l="                                  result: *mut size_t) -&gt; c_int;"></div><div data-l="    fn snappy_validate_compressed_buffer(compressed: *const u8,"></div><div data-l="                                         compressed_length: size_t) -&gt; c_int;"></div><div data-l=}></div><div data-l="# fn main() {}"></div></div><br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Creating a safe interface</span>安全なインターフェースを作成する</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The raw C API needs to be wrapped to provide memory safety and make use of higher-level concepts like vectors.</span>生のC APIは、メモリの安全性を提供し、ベクトルのようなより高いレベルの概念を利用するためにラップする必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A library can choose to expose only the safe, high-level interface and hide the unsafe internal details.</span>ライブラリは、安全で高水準のインタフェースだけを公開し、安全ではない内部の詳細を隠すことを選択できます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Wrapping the functions which expect buffers involves using the <code>slice::raw</code> module to manipulate Rust vectors as pointers to memory.</span>バッファを必要とする関数をラップするには、 <code>slice::raw</code>モジュールを使ってメモリへのポインタとしてのルースベクトルを操作する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust&#39;s vectors are guaranteed to be a contiguous block of memory.</span> Rustのベクトルは、連続したメモリブロックであることが保証されています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The length is the number of elements currently contained, and the capacity is the total size in elements of the allocated memory.</span>長さは現在含まれている要素の数であり、容量は割り当てられたメモリの要素の合計サイズです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The length is less than or equal to the capacity.</span>長さは容量以下です。</span> </p><br><div data-lang=rust,ignore><div data-l="# extern crate libc;"></div><div data-l="# use libc::{c_int, size_t};"></div><div data-l="# unsafe fn snappy_validate_compressed_buffer(_: *const u8, _: size_t) -&gt; c_int { 0 }"></div><div data-l="# fn main() {}"></div><div data-l="pub fn validate_compressed_buffer(src: &amp;[u8]) -&gt; bool {"></div><div data-l="    unsafe {"></div><div data-l="        snappy_validate_compressed_buffer(src.as_ptr(), src.len() as size_t) == 0"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>validate_compressed_buffer</code> wrapper above makes use of an <code>unsafe</code> block, but it makes the guarantee that calling it is safe for all inputs by leaving off <code>unsafe</code> from the function signature.</span>上記の<code>validate_compressed_buffer</code>ラッパーは<code>unsafe</code>ブロックを使用しますが、関数シグニチャーから<code>unsafe</code>ままにすることで、すべての入力に対して安全であることを保証します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>snappy_compress</code> and <code>snappy_uncompress</code> functions are more complex, since a buffer has to be allocated to hold the output too.</span> <code>snappy_compress</code>と<code>snappy_uncompress</code>バッファがあまりにも出力を保持するために割り当てられなければならないので機能は、より複雑です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>snappy_max_compressed_length</code> function can be used to allocate a vector with the maximum required capacity to hold the compressed output.</span> <code>snappy_max_compressed_length</code>関数を使用すると、圧縮出力を保持するために必要な最大容量のベクトルを割り当てることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The vector can then be passed to the <code>snappy_compress</code> function as an output parameter.</span>その後、出力パラメータとして<code>snappy_compress</code>関数に渡すことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">An output parameter is also passed to retrieve the true length after compression for setting the length.</span>長さを設定するために圧縮後に真の長さを取り出すために、出力パラメータも渡されます。</span> </p><br><div data-lang=rust,ignore><div data-l="# extern crate libc;"></div><div data-l="# use libc::{size_t, c_int};"></div><div data-l="# unsafe fn snappy_compress(a: *const u8, b: size_t, c: *mut u8,"></div><div data-l="#                           d: *mut size_t) -&gt; c_int { 0 }"></div><div data-l="# unsafe fn snappy_max_compressed_length(a: size_t) -&gt; size_t { a }"></div><div data-l="# fn main() {}"></div><div data-l="pub fn compress(src: &amp;[u8]) -&gt; Vec&lt;u8&gt; {"></div><div data-l="    unsafe {"></div><div data-l="        let srclen = src.len() as size_t;"></div><div data-l="        let psrc = src.as_ptr();"></div><div data-l=""></div><div data-l="        let mut dstlen = snappy_max_compressed_length(srclen);"></div><div data-l="        let mut dst = Vec::with_capacity(dstlen as usize);"></div><div data-l="        let pdst = dst.as_mut_ptr();"></div><div data-l=""></div><div data-l="        snappy_compress(psrc, srclen, pdst, &amp;mut dstlen);"></div><div data-l="        dst.set_len(dstlen as usize);"></div><div data-l="        dst"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Decompression is similar, because snappy stores the uncompressed size as part of the compression format and <code>snappy_uncompressed_length</code> will retrieve the exact buffer size required.</span> <code>snappy_uncompressed_length</code>は圧縮されていないサイズを圧縮フォーマットの一部として格納し、 <code>snappy_uncompressed_length</code>は必要な正確なバッファサイズを取得するため、圧縮<code>snappy_uncompressed_length</code>ます。</span> </p><br><div data-lang=rust,ignore><div data-l="# extern crate libc;"></div><div data-l="# use libc::{size_t, c_int};"></div><div data-l="# unsafe fn snappy_uncompress(compressed: *const u8,"></div><div data-l="#                             compressed_length: size_t,"></div><div data-l="#                             uncompressed: *mut u8,"></div><div data-l="#                             uncompressed_length: *mut size_t) -&gt; c_int { 0 }"></div><div data-l="# unsafe fn snappy_uncompressed_length(compressed: *const u8,"></div><div data-l="#                                      compressed_length: size_t,"></div><div data-l="#                                      result: *mut size_t) -&gt; c_int { 0 }"></div><div data-l="# fn main() {}"></div><div data-l="pub fn uncompress(src: &amp;[u8]) -&gt; Option&lt;Vec&lt;u8&gt;&gt; {"></div><div data-l="    unsafe {"></div><div data-l="        let srclen = src.len() as size_t;"></div><div data-l="        let psrc = src.as_ptr();"></div><div data-l=""></div><div data-l="        let mut dstlen: size_t = 0;"></div><div data-l="        snappy_uncompressed_length(psrc, srclen, &amp;mut dstlen);"></div><div data-l=""></div><div data-l="        let mut dst = Vec::with_capacity(dstlen as usize);"></div><div data-l="        let pdst = dst.as_mut_ptr();"></div><div data-l=""></div><div data-l="        if snappy_uncompress(psrc, srclen, pdst, &amp;mut dstlen) == 0 {"></div><div data-l="            dst.set_len(dstlen as usize);"></div><div data-l="            Some(dst)"></div><div data-l="        } else {"></div><div data-l="#//            None // SNAPPY_INVALID_INPUT"></div><div data-l="            None // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">SNAPPY_INVALID_INPUT</span> SNAPPY_INVALID_INPUT</span> </div><div data-l="        }"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then, we can add some tests to show how to use them.</span>次に、それらを使用する方法を示すいくつかのテストを追加することができます。</span> </p><br><div data-lang=rust,ignore><div data-l="# extern crate libc;"></div><div data-l="# use libc::{c_int, size_t};"></div><div data-l="# unsafe fn snappy_compress(input: *const u8,"></div><div data-l="#                           input_length: size_t,"></div><div data-l="#                           compressed: *mut u8,"></div><div data-l="#                           compressed_length: *mut size_t)"></div><div data-l="#                           -&gt; c_int { 0 }"></div><div data-l="# unsafe fn snappy_uncompress(compressed: *const u8,"></div><div data-l="#                             compressed_length: size_t,"></div><div data-l="#                             uncompressed: *mut u8,"></div><div data-l="#                             uncompressed_length: *mut size_t)"></div><div data-l="#                             -&gt; c_int { 0 }"></div><div data-l="# unsafe fn snappy_max_compressed_length(source_length: size_t) -&gt; size_t { 0 }"></div><div data-l="# unsafe fn snappy_uncompressed_length(compressed: *const u8,"></div><div data-l="#                                      compressed_length: size_t,"></div><div data-l="#                                      result: *mut size_t)"></div><div data-l="#                                      -&gt; c_int { 0 }"></div><div data-l="# unsafe fn snappy_validate_compressed_buffer(compressed: *const u8,"></div><div data-l="#                                             compressed_length: size_t)"></div><div data-l="#                                             -&gt; c_int { 0 }"></div><div data-l="# fn main() { }"></div><div data-l=""></div><div data-l=#[cfg(test)]></div><div data-l="mod tests {"></div><div data-l="    use super::*;"></div><div data-l=""></div><div data-l="    #[test]"></div><div data-l="    fn valid() {"></div><div data-l="        let d = vec![0xde, 0xad, 0xd0, 0x0d];"></div><div data-l="        let c: &amp;[u8] = &amp;compress(&amp;d);"></div><div data-l="        assert!(validate_compressed_buffer(c));"></div><div data-l="        assert!(uncompress(c) == Some(d));"></div><div data-l="    }"></div><div data-l=""></div><div data-l="    #[test]"></div><div data-l="    fn invalid() {"></div><div data-l="        let d = vec![0, 0, 0, 0];"></div><div data-l="        assert!(!validate_compressed_buffer(&amp;d));"></div><div data-l="        assert!(uncompress(&amp;d).is_none());"></div><div data-l="    }"></div><div data-l=""></div><div data-l="    #[test]"></div><div data-l="    fn empty() {"></div><div data-l="        let d = vec![];"></div><div data-l="        assert!(!validate_compressed_buffer(&amp;d));"></div><div data-l="        assert!(uncompress(&amp;d).is_none());"></div><div data-l="        let c = compress(&amp;d);"></div><div data-l="        assert!(validate_compressed_buffer(&amp;c));"></div><div data-l="        assert!(uncompress(&amp;c) == Some(d));"></div><div data-l="    }"></div><div data-l=}></div></div><br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Destructors</span>デストラクタ</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Foreign libraries often hand off ownership of resources to the calling code.</span>外国の図書館は、しばしば呼び出しコードにリソースの所有権を渡します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When this occurs, we must use Rust&#39;s destructors to provide safety and guarantee the release of these resources (especially in the case of panic).</span>これが発生すると、Rustのデストラクタを使用して安全性を確保し、これらのリソースの解放を保証する必要があります（特にパニックの場合）。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For more about destructors, see the <a href=#2../std/ops/trait.Drop.html>Drop trait</a> .</span>デストラクタの詳細については、 <a href=#2../std/ops/trait.Drop.html>Drop特性を</a>参照してください。</span> </p><br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Callbacks from C code to Rust functions</span> CコードからRust関数へのコールバック</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Some external libraries require the usage of callbacks to report back their current state or intermediate data to the caller.</span>一部の外部ライブラリでは、現在の状態または中間データを呼び出し元に報告するためにコールバックを使用する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It is possible to pass functions defined in Rust to an external library.</span> Rustで定義された関数を外部ライブラリに渡すことは可能です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The requirement for this is that the callback function is marked as <code>extern</code> with the correct calling convention to make it callable from C code.</span>このために必要なのは、コールバック関数がCコードから呼び出し可能にする正しい呼び出し規約で<code>extern</code>としてマークされていることです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The callback function can then be sent through a registration call to the C library and afterwards be invoked from there.</span>コールバック関数は、Cライブラリへの登録呼び出しによって送信され、その後、そこから呼び出されます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A basic example is:</span>基本的な例は次のとおりです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust code:</span>錆のコード：</span> </p><br><div data-lang=rust,no_run><div data-l="extern fn callback(a: i32) {"></div><div data-l="    println!(&quot;I'm called from C with value {0}&quot;, a);"></div><div data-l=}></div><div data-l=""></div><div data-l="#[link(name = &quot;extlib&quot;)]"></div><div data-l="extern {"></div><div data-l="   fn register_callback(cb: extern fn(i32)) -&gt; i32;"></div><div data-l="   fn trigger_callback();"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    unsafe {"></div><div data-l="        register_callback(callback);"></div><div data-l="#//        trigger_callback(); // Triggers the callback."></div><div data-l="        trigger_callback(); // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Triggers the callback.</span>コールバックをトリガーします。</span> </div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">C code:</span> Cコード：</span> </p><br><div data-lang=c><div data-l="typedef void (*rust_callback)(int32_t);"></div><div data-l="rust_callback cb;"></div><div data-l=""></div><div data-l="int32_t register_callback(rust_callback callback) {"></div><div data-l="    cb = callback;"></div><div data-l="    return 1;"></div><div data-l=}></div><div data-l=""></div><div data-l="void trigger_callback() {"></div><div data-l="#//  cb(7); // Will call callback(7) in Rust."></div><div data-l="  cb(7); // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Will call callback(7) in Rust.</span> Rustのコールバック（7）を呼び出します。</span> </div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this example Rust&#39;s <code>main()</code> will call <code>trigger_callback()</code> in C, which would, in turn, call back to <code>callback()</code> in Rust.</span>この例では、Rustの<code>main()</code>はCで<code>trigger_callback()</code>を呼び出し、Rustの<code>callback()</code>にコールバックし<code>callback()</code> 。</span> </p><br><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Targeting callbacks to Rust objects</span> Rustオブジェクトへのコールバックのターゲット設定</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The former example showed how a global function can be called from C code.</span>前者の例では、Cコードからグローバル関数を呼び出す方法を示しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However it is often desired that the callback is targeted to a special Rust object.</span>しかし、しばしばコールバックが特別なRustオブジェクトを対象とすることが望まれます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This could be the object that represents the wrapper for the respective C object.</span>これは、それぞれのCオブジェクトのラッパーを表すオブジェクトである可能性があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This can be achieved by passing a raw pointer to the object down to the C library.</span>これは、オブジェクトへの生ポインタをCライブラリに渡すことで実現できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The C library can then include the pointer to the Rust object in the notification.</span> Cライブラリは、通知内のRustオブジェクトへのポインタを含めることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This will allow the callback to unsafely access the referenced Rust object.</span>これによりコールバックは参照されているRustオブジェクトに安全にアクセスできなくなります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust code:</span>錆のコード：</span> </p><br><div data-lang=rust,no_run><div data-l=#[repr(C)]></div><div data-l="struct RustObject {"></div><div data-l="    a: i32,"></div><div data-l="#    // Other members..."></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Other members...</span>他のメンバー...</span> </div><div data-l=}></div><div data-l=""></div><div data-l="extern &quot;C&quot; fn callback(target: *mut RustObject, a: i32) {"></div><div data-l="    println!(&quot;I'm called from C with value {0}&quot;, a);"></div><div data-l="    unsafe {"></div><div data-l="#        // Update the value in RustObject with the value received from the callback:"></div><div data-l="        // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Update the value in RustObject with the value received from the callback:</span> RustObjectの値をコールバックから受け取った値で更新します。</span> </div><div data-l="        (*target).a = a;"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="#[link(name = &quot;extlib&quot;)]"></div><div data-l="extern {"></div><div data-l="   fn register_callback(target: *mut RustObject,"></div><div data-l="                        cb: extern fn(*mut RustObject, i32)) -&gt; i32;"></div><div data-l="   fn trigger_callback();"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="#    // Create the object that will be referenced in the callback:"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Create the object that will be referenced in the callback:</span>コールバックで参照されるオブジェクトを作成します。</span> </div><div data-l="    let mut rust_object = Box::new(RustObject { a: 5 });"></div><div data-l=""></div><div data-l="    unsafe {"></div><div data-l="        register_callback(&amp;mut *rust_object, callback);"></div><div data-l="        trigger_callback();"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">C code:</span> Cコード：</span> </p><br><div data-lang=c><div data-l="typedef void (*rust_callback)(void*, int32_t);"></div><div data-l="void* cb_target;"></div><div data-l="rust_callback cb;"></div><div data-l=""></div><div data-l="int32_t register_callback(void* callback_target, rust_callback callback) {"></div><div data-l="    cb_target = callback_target;"></div><div data-l="    cb = callback;"></div><div data-l="    return 1;"></div><div data-l=}></div><div data-l=""></div><div data-l="void trigger_callback() {"></div><div data-l="#//  cb(cb_target, 7); // Will call callback(&amp;rustObject, 7) in Rust."></div><div data-l="  cb(cb_target, 7); // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Will call callback(&amp;rustObject, 7) in Rust.</span> Rustのコールバック（＆rustObject、7）を呼び出します。</span> </div><div data-l=}></div></div><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Asynchronous callbacks</span>非同期コールバック</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In the previously given examples the callbacks are invoked as a direct reaction to a function call to the external C library.</span>前述の例では、コールバックは外部Cライブラリへの関数呼び出しへの直接的な反応として呼び出されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The control over the current thread is switched from Rust to C to Rust for the execution of the callback, but in the end the callback is executed on the same thread that called the function which triggered the callback.</span>現在のスレッドに対する制御は、コールバックの実行のためにRustからCへRustに切り替えられますが、コールバックは、コールバックをトリガした関数を呼び出したスレッドと同じスレッドで実行されます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Things get more complicated when the external library spawns its own threads and invokes callbacks from there.</span>外部ライブラリが独自のスレッドを生成し、そこからコールバックを呼び出すと、状況はより複雑になります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In these cases access to Rust data structures inside the callbacks is especially unsafe and proper synchronization mechanisms must be used.</span>これらの場合、コールバック内のRustデータ構造へのアクセスは特に安全ではなく、適切な同期メカニズムを使用する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Besides classical synchronization mechanisms like mutexes, one possibility in Rust is to use channels (in <code>std::sync::mpsc</code> ) to forward data from the C thread that invoked the callback into a Rust thread.</span> mutexのような古典的な同期メカニズムの他に、Rustの1つの可能性は、チャネルを使って（ <code>std::sync::mpsc</code> ）コールバックを呼び出したCスレッドからRustスレッドにデータを転送することです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If an asynchronous callback targets a special object in the Rust address space it is also absolutely necessary that no more callbacks are performed by the C library after the respective Rust object gets destroyed.</span>非同期コールバックがRustアドレス空間の特別なオブジェクトをターゲットにしている場合は、それぞれのRustオブジェクトが破棄された後に、Cライブラリがこれ以上コールバックを実行しないことも絶対必要です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This can be achieved by unregistering the callback in the object&#39;s destructor and designing the library in a way that guarantees that no callback will be performed after deregistration.</span>これは、オブジェクトのデストラクタでコールバックの登録を解除し、登録解除後にコールバックが実行されないようにライブラリを設計することで実現できます。</span> </p><br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Linking</span>リンクする</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>link</code> attribute on <code>extern</code> blocks provides the basic building block for instructing rustc how it will link to native libraries.</span> <code>extern</code>ブロックの<code>link</code>属性は、ネイティブライブラリへのリンク方法をrustcに指示するための基本的なビルディングブロックを提供します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There are two accepted forms of the link attribute today:</span>今日、リンク属性には2つの形式があります。</span> </p><br><div data-b=*> <code>#[link(name = &quot;foo&quot;)]</code> </div> <div data-b=*> <code>#[link(name = &quot;foo&quot;, kind = &quot;bar&quot;)]</code> </div> <br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In both of these cases, <code>foo</code> is the name of the native library that we&#39;re linking to, and in the second case <code>bar</code> is the type of native library that the compiler is linking to.</span>どちらの場合も、 <code>foo</code>はリンク先のネイティブライブラリの名前です.2番目の例では、 <code>bar</code>は、コンパイラがリンクしているネイティブライブラリのタイプです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There are currently three known types of native libraries:</span>現在、3つのタイプのネイティブライブラリがあります。</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Dynamic - <code>#[link(name = &quot;readline&quot;)]</code></span>動的 - <code>#[link(name = &quot;readline&quot;)]</code></span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Static - <code>#[link(name = &quot;my_build_dependency&quot;, kind = &quot;static&quot;)]</code></span>静的 - <code>#[link(name = &quot;my_build_dependency&quot;, kind = &quot;static&quot;)]</code></span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Frameworks - <code>#[link(name = &quot;CoreFoundation&quot;, kind = &quot;framework&quot;)]</code></span>フレームワーク - <code>#[link(name = &quot;CoreFoundation&quot;, kind = &quot;framework&quot;)]</code></span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that frameworks are only available on macOS targets.</span>フレームワークはmacOSターゲットでのみ利用可能であることに注意してください。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The different <code>kind</code> values are meant to differentiate how the native library participates in linkage.</span>異なる<code>kind</code>値は、ネイティブライブラリがリンケージにどのように関与するかを区別するためのものです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">From a linkage perspective, the Rust compiler creates two flavors of artifacts: partial (rlib/staticlib) and final (dylib/binary).</span>リンケージの観点から、Rustコンパイラは、部分（rlib / staticlib）と最終（dylib / binary）という2つのアーティファクトのフレーバを作成します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Native dynamic library and framework dependencies are propagated to the final artifact boundary, while static library dependencies are not propagated at all, because the static libraries are integrated directly into the subsequent artifact.</span>静的ライブラリは後続の成果物に直接統合されるため、ネイティブの動的ライブラリとフレームワークの依存関係は最終的な成果物の境界に伝播され、静的ライブラリの依存関係はまったく伝播されません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A few examples of how this model can be used are:</span>このモデルの使用方法の例をいくつか示します。</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A native build dependency.</span>ネイティブビルドの依存関係。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Sometimes some C/C++ glue is needed when writing some Rust code, but distribution of the C/C++ code in a library format is a burden.</span>いくつかのC / C ++グルーがいくつかの錆コードを書くときに必要になることがありますが、C / C ++コードをライブラリ形式で配布することは負担です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this case, the code will be archived into <code>libfoo.a</code> and then the Rust crate would declare a dependency via <code>#[link(name = &quot;foo&quot;, kind = &quot;static&quot;)]</code> .</span>この場合、コードは<code>libfoo.a</code>にアーカイブされ、Rustの<code>libfoo.a</code> <code>#[link(name = &quot;foo&quot;, kind = &quot;static&quot;)]</code>介して依存関係を宣言します。</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Regardless of the flavor of output for the crate, the native static library will be included in the output, meaning that distribution of the native static library is not necessary.</span>クレートの出力のフレーバにかかわらず、ネイティブのスタティックライブラリが出力に含まれます。つまり、ネイティブのスタティックライブラリの配布は不要です。</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A normal dynamic dependency.</span>通常の動的依存関係。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Common system libraries (like <code>readline</code> ) are available on a large number of systems, and often a static copy of these libraries cannot be found.</span>一般的なシステムライブラリ（ <code>readline</code> ）は多数のシステムで利用可能で、しばしばこれらのライブラリの静的なコピーが見つかりません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When this dependency is included in a Rust crate, partial targets (like rlibs) will not link to the library, but when the rlib is included in a final target (like a binary), the native library will be linked in.</span>この依存関係がRustクレートに含まれていると、部分ターゲット（rlibなど）はライブラリにリンクされませんが、最終ターゲット（バイナリなど）に含まれると、ネイティブライブラリがリンクされます。</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">On macOS, frameworks behave with the same semantics as a dynamic library.</span> macOSでは、フレームワークはダイナミックライブラリと同じセマンティクスで動作します。</span> </p><br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Unsafe blocks</span>安全でないブロック</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Some operations, like dereferencing raw pointers or calling functions that have been marked unsafe are only allowed inside unsafe blocks.</span>生ポインタや安全でないとマークされた関数を参照解除するような操作は、安全でないブロックの中でのみ許可されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Unsafe blocks isolate unsafety and are a promise to the compiler that the unsafety does not leak out of the block.</span>安全でないブロックは安全でないものを分離し、安全ではないブロックから漏れないことをコンパイラーに約束します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Unsafe functions, on the other hand, advertise it to the world.</span>一方、安全でない関数は、それを世界に宣伝します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">An unsafe function is written like this:</span>安全でない関数は次のように書かれています：</span> </p><br><div data-lang=rust><div data-l="unsafe fn kaboom(ptr: *const i32) -&gt; i32 { *ptr }"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This function can only be called from an <code>unsafe</code> block or another <code>unsafe</code> function.</span>この関数は、 <code>unsafe</code>ブロックまたは別の<code>unsafe</code>関数からのみ呼び出すことができます。</span> </p><br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Accessing foreign globals</span>海外のグローバルにアクセスする</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Foreign APIs often export a global variable which could do something like track global state.</span>外部APIは、しばしばグローバル状態を追跡するような何かをする可能性のあるグローバル変数をエクスポートします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In order to access these variables, you declare them in <code>extern</code> blocks with the <code>static</code> keyword:</span>これらの変数にアクセスするには、 <code>static</code>キーワードを使用して<code>extern</code>ブロックで宣言します。</span> </p><br><div data-lang=rust,ignore><div data-l="extern crate libc;"></div><div data-l=""></div><div data-l="#[link(name = &quot;readline&quot;)]"></div><div data-l="extern {"></div><div data-l="    static rl_readline_version: libc::c_int;"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    println!(&quot;You have readline version {} installed.&quot;,"></div><div data-l="             unsafe { rl_readline_version as i32 });"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Alternatively, you may need to alter global state provided by a foreign interface.</span>あるいは、外部インタフェースによって提供されるグローバル状態を変更する必要があるかもしれません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To do this, statics can be declared with <code>mut</code> so we can mutate them.</span>これを行うには、静的<code>mut</code>を<code>mut</code>で宣言して、それらを突然変異させることができます。</span> </p><br><div data-lang=rust,ignore><div data-l="extern crate libc;"></div><div data-l=""></div><div data-l="use std::ffi::CString;"></div><div data-l="use std::ptr;"></div><div data-l=""></div><div data-l="#[link(name = &quot;readline&quot;)]"></div><div data-l="extern {"></div><div data-l="    static mut rl_prompt: *const libc::c_char;"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let prompt = CString::new(&quot;[my-awesome-shell] $&quot;).unwrap();"></div><div data-l="    unsafe {"></div><div data-l="        rl_prompt = prompt.as_ptr();"></div><div data-l=""></div><div data-l="        println!(&quot;{:?}&quot;, rl_prompt);"></div><div data-l=""></div><div data-l="        rl_prompt = ptr::null();"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that all interaction with a <code>static mut</code> is unsafe, both reading and writing.</span> <code>static mut</code>とのやりとりはすべて、読み書きの両方が安全でないことに注意してください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Dealing with global mutable state requires a great deal of care.</span>グローバルな可変状態を扱うには、大きな注意が必要です。</span> </p><br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Foreign calling conventions</span>外国の呼び出し規約</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Most foreign code exposes a C ABI, and Rust uses the platform&#39;s C calling convention by default when calling foreign functions.</span>ほとんどの外部コードはC ABIを公開し、Rustは外部関数を呼び出すときにデフォルトでプラットフォームのC呼び出し規約を使用します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Some foreign functions, most notably the Windows API, use other calling conventions.</span>一部の外部関数、特にWindows APIは、他の呼び出し規約を使用しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust provides a way to tell the compiler which convention to use:</span> Rustはコンパイラにどのような規約を使用するかを伝える方法を提供します：</span> </p><br><div data-lang=rust,ignore><div data-l="extern crate libc;"></div><div data-l=""></div><div data-l="#[cfg(all(target_os = &quot;win32&quot;, target_arch = &quot;x86&quot;))]"></div><div data-l="#[link(name = &quot;kernel32&quot;)]"></div><div data-l=#[allow(non_snake_case)]></div><div data-l="extern &quot;stdcall&quot; {"></div><div data-l="    fn SetEnvironmentVariableA(n: *const u8, v: *const u8) -&gt; libc::c_int;"></div><div data-l=}></div><div data-l="# fn main() { }"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This applies to the entire <code>extern</code> block.</span>これは<code>extern</code>ブロック全体に適用されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The list of supported ABI constraints are:</span>サポートされているABI制約のリストは次のとおりです。</span> </p><br><div data-b=*> <code>stdcall</code> </div> <div data-b=*> <code>aapcs</code> </div> <div data-b=*> <code>cdecl</code> </div> <div data-b=*> <code>fastcall</code> </div> <div data-b=*> <code>vectorcall</code> </div> <p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is currently hidden behind the <code>abi_vectorcall</code> gate and is subject to change.</span>これは現在、 <code>abi_vectorcall</code>ゲートの裏に隠されており、変更される可能性があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">* <code>Rust</code> * <code>rust-intrinsic</code> * <code>system</code> * <code>C</code> * <code>win64</code> * <code>sysv64</code></span> * <code>Rust</code> * <code>rust-intrinsic</code> * <code>system</code> * <code>C</code> * <code>win64</code> * <code>sysv64</code></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Most of the abis in this list are self-explanatory, but the <code>system</code> abi may seem a little odd.</span>このリストのほとんどのabisは自明であるが、 <code>system</code> abiはちょっと奇妙に思えるかもしれない。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This constraint selects whatever the appropriate ABI is for interoperating with the target&#39;s libraries.</span>この制約は、ターゲットのライブラリと相互運用するための適切なABIが何であれ選択します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, on win32 with a x86 architecture, this means that the abi used would be <code>stdcall</code> .</span>たとえば、x86アーキテクチャのwin32では、これはabiが<code>stdcall</code>ことを意味します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">On x86_64, however, windows uses the <code>C</code> calling convention, so <code>C</code> would be used.</span>しかし、x86_64では、ウィンドウは<code>C</code>呼び出し規約を使用しているため、 <code>C</code>が使用されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This means that in our previous example, we could have used <code>extern &quot;system&quot; { ... }</code> to define a block for all windows systems, not only x86 ones.</span>つまり、前の例では、 <code>extern &quot;system&quot; { ... }</code>を使用して、x86システムだけでなく、すべてのWindowsシステム用のブロックを定義することができました。</span> </p><br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Interoperability with foreign code</span>外部コードとの相互運用性</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust guarantees that the layout of a <code>struct</code> is compatible with the platform&#39;s representation in C only if the <code>#[repr(C)]</code> attribute is applied to it.</span> Rustは、 <code>#[repr(C)]</code>属性が適用されている場合に限り、 <code>struct</code>のレイアウトがC言語でのプラットフォームの表現と互換性があることを保証します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>#[repr(C, packed)]</code> can be used to lay out struct members without padding.</span> <code>#[repr(C, packed)]</code>は<code>#[repr(C, packed)]</code>パディングなしで構造体メンバをレイアウトするために使用できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>#[repr(C)]</code> can also be applied to an enum.</span> <code>#[repr(C)]</code>はenumにも適用できます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust&#39;s owned boxes ( <code>Box&lt;T&gt;</code> ) use non-nullable pointers as handles which point to the contained object.</span> Rustの所有ボックス（ <code>Box&lt;T&gt;</code> ）は、含まれているオブジェクトを指すハンドルとしてnullableではないポインタを使用します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, they should not be manually created because they are managed by internal allocators.</span>ただし、内部のアロケータによって管理されるため、手動で作成するべきではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">References can safely be assumed to be non-nullable pointers directly to the type.</span>参照は、その型に直接的にnull値ではないポインタであると見なすことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, breaking the borrow checking or mutability rules is not guaranteed to be safe, so prefer using raw pointers ( <code>*</code> ) if that&#39;s needed because the compiler can&#39;t make as many assumptions about them.</span>しかし、借用検査または変更可能ルールを破ることは安全であるとは保証されていないため、コンパイラはそれらについて多くの仮定を行うことができないため、必要な場合は生ポインタ（ <code>*</code> ）を使用することをお勧めします。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Vectors and strings share the same basic memory layout, and utilities are available in the <code>vec</code> and <code>str</code> modules for working with C APIs.</span>ベクトルと文字列は同じ基本的なメモリレイアウトを共有し、C APIを扱うための<code>vec</code>と<code>str</code>モジュールでユーティリティが利用できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, strings are not terminated with <code>\0</code> .</span>ただし、文字列は<code>\0</code>終了しません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you need a NUL-terminated string for interoperability with C, you should use the <code>CString</code> type in the <code>std::ffi</code> module.</span> Cとの相互運用性のためにNULで終了する文字列が必要な場合は、 <code>std::ffi</code>モジュールで<code>CString</code>型を使用する必要があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <a href=#3libc><code>libc</code> crate on crates.io</a> includes type aliases and function definitions for the C standard library in the <code>libc</code> module, and Rust links against <code>libc</code> and <code>libm</code> by default.</span> <a href=#3libc>crates.io</a>の<a href=#3libc><code>libc</code> crateに</a>は、 <code>libc</code>モジュールのC標準ライブラリのタイプ別名と関数定義、およびデフォルトで<code>libc</code>と<code>libm</code>に対するRustリンクが含まれています。</span> </p><br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Variadic functions</span>バリアント関数</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In C, functions can be &#39;variadic&#39;, meaning they accept a variable number of arguments.</span> Cでは、関数は可変的な数の引数を受け入れることを意味する &#39;variadic&#39;にすることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This can be achieved in Rust by specifying <code>...</code> within the argument list of a foreign function declaration:</span>これは、外部関数宣言の引数リスト内で<code>...</code>を指定することで、Rustで実現できます。</span> </p><br><div data-lang=no_run><div data-l="extern {"></div><div data-l="    fn foo(x: i32, ...);"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    unsafe {"></div><div data-l="        foo(10, 20, 30, 40, 50);"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Normal Rust functions can <i>not</i> be variadic:</span>通常の錆関数は可変ではあり<i>ませ</i>ん：</span> </p><br><div data-lang=ignore><div data-l="#// This will not compile"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This will not compile</span>これはコンパイルされません</span> </div><div data-l=""></div><div data-l="fn foo(x: i32, ...) { }"></div></div><br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The &quot;nullable pointer optimization&quot;</span> 「ヌル可能ポインタ最適化」は、</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Certain Rust types are defined to never be <code>null</code> .</span>特定の錆タイプは、決して<code>null</code>にならないように定義されてい<code>null</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This includes references ( <code>&amp;T</code> , <code>&amp;mut T</code> ), boxes ( <code>Box&lt;T&gt;</code> ), and function pointers ( <code>extern &quot;abi&quot; fn()</code> ).</span>これには、参照（ <code>&amp;T</code> 、 <code>&amp;mut T</code> ）、ボックス（ <code>Box&lt;T&gt;</code> ）、および関数ポインタ（ <code>extern &quot;abi&quot; fn()</code> ）が含まれます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When interfacing with C, pointers that might be <code>null</code> are often used, which would seem to require some messy <code>transmute</code> s and/or unsafe code to handle conversions to/from Rust types.</span> C言語とのインタフェースでは、 <code>null</code>可能性があるポインタが頻繁に使用されるため、Rust型への変換やRust型からの変換を処理するために、乱雑な<code>transmute</code>や安全でないコードが必要になるようです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, the language provides a workaround.</span>ただし、この言語は回避策を提供します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As a special case, an <code>enum</code> is eligible for the &quot;nullable pointer optimization&quot; if it contains exactly two variants, one of which contains no data and the other contains a field of one of the non-nullable types listed above.</span>特別なケースとして、 <code>enum</code>型に2つのバリアントが含まれていて、そのうちの1つにデータが含まれておらず、もう1つには上記のnull不可能な型のフィールドが含まれている場合、 &quot;nullable pointer optimization&quot;の対象となります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This means no extra space is required for a discriminant;</span>これは、判別式に余分なスペースが必要ないことを意味します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">rather, the empty variant is represented by putting a <code>null</code> value into the non-nullable field.</span>むしろ、空のバリアントは、 <code>null</code>値を非ヌル可能フィールドに入れることによって表される。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is called an &quot;optimization&quot;, but unlike other optimizations it is guaranteed to apply to eligible types.</span>これは「最適化」と呼ばれますが、他の最適化とは異なり、対象となるタイプに適用されることが保証されています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The most common type that takes advantage of the nullable pointer optimization is <code>Option&lt;T&gt;</code> , where <code>None</code> corresponds to <code>null</code> .</span> null可能なポインタの最適化を利用する最も一般的な型は<code>Option&lt;T&gt;</code>です。ここで<code>None</code>は<code>null</code>対応し<code>null</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So <code>Option&lt;extern &quot;C&quot; fn(c_int) -&gt; c_int&gt;</code> is a correct way to represent a nullable function pointer using the C ABI (corresponding to the C type <code>int (*)(int)</code> ).</span>したがって、 <code>Option&lt;extern &quot;C&quot; fn(c_int) -&gt; c_int&gt;</code>は、C ABI（Cの型<code>int (*)(int)</code>対応）を使用してnull可能な関数ポインタを表す正しい方法です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here is a contrived example.</span>ここには工夫した例があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s say some C library has a facility for registering a callback, which gets called in certain situations.</span>ある種の状況で呼び出されるコールバックを登録する機能をCライブラリが持っているとしましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The callback is passed a function pointer and an integer and it is supposed to run the function with the integer as a parameter.</span>コールバックには関数ポインタと整数が渡され、その整数をパラメータとして実行することになっています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So we have function pointers flying across the FFI boundary in both directions.</span>したがって、FFI境界をまたがって両方向に飛ぶ関数ポインタがあります。</span> </p><br><div data-lang=rust,ignore><div data-l="extern crate libc;"></div><div data-l="use libc::c_int;"></div><div data-l=""></div><div data-l="# #[cfg(hidden)]"></div><div data-l="extern &quot;C&quot; {"></div><div data-l="#//    /// Registers the callback."></div><div data-l="    /// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Registers the callback.</span>コールバックを登録します。</span> </div><div data-l="    fn register(cb: Option&lt;extern &quot;C&quot; fn(Option&lt;extern &quot;C&quot; fn(c_int) -&gt; c_int&gt;, c_int) -&gt; c_int&gt;);"></div><div data-l=}></div><div data-l="# unsafe fn register(_: Option&lt;extern &quot;C&quot; fn(Option&lt;extern &quot;C&quot; fn(c_int) -&gt; c_int&gt;,"></div><div data-l="#                                            c_int) -&gt; c_int&gt;)"></div><div data-l="# {}"></div><div data-l=""></div><div data-l="#///// This fairly useless function receives a function pointer and an integer"></div><div data-l="/// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This fairly useless function receives a function pointer and an integer</span>この無駄な関数は関数ポインタと整数を受け取ります</span> </div><div data-l="#///// from C, and returns the result of calling the function with the integer."></div><div data-l="/// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">from C, and returns the result of calling the function with the integer.</span> Cから取り出し、その関数を整数で呼び出した結果を返します。</span> </div><div data-l="#///// In case no function is provided, it squares the integer by default."></div><div data-l="/// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In case no function is provided, it squares the integer by default.</span>関数が提供されていない場合は、デフォルトで整数に二乗されます。</span> </div><div data-l="extern &quot;C&quot; fn apply(process: Option&lt;extern &quot;C&quot; fn(c_int) -&gt; c_int&gt;, int: c_int) -&gt; c_int {"></div><div data-l="    match process {"></div><div data-l="        Some(f) =&gt; f(int),"></div><div data-l="        None    =&gt; int * int"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    unsafe {"></div><div data-l="        register(Some(apply));"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">And the code on the C side looks like this:</span> C側のコードは次のようになります。</span> </p><br><div data-lang=c><div data-l="void register(void (*f)(void (*)(int), int)) {"></div><div data-l="    ..."></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">No <code>transmute</code> required!</span> <code>transmute</code>不要！</span> </p><br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Calling Rust code from C</span> Cから錆​​のコードを呼び出す</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You may wish to compile Rust code in a way so that it can be called from C. This is fairly easy, but requires a few things:</span> RustコードをCから呼び出せるようにコンパイルすることもできます。これはかなり簡単ですが、いくつか必要です。</span> </p><br><div data-lang=rust><div data-l=#[no_mangle]></div><div data-l="pub extern fn hello_rust() -&gt; *const u8 {"></div><div data-l="    &quot;Hello, world!\0&quot;.as_ptr()"></div><div data-l=}></div><div data-l="# fn main() {}"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>extern</code> makes this function adhere to the C calling convention, as discussed above in &quot; <a href=#2ffi.html#foreign-calling-conventions>Foreign Calling Conventions</a> &quot;.</span> <code>extern</code>は、上記の「 <a href=#2ffi.html#foreign-calling-conventions>外部呼び出し規約</a> 」で説明したように、この関数をC呼び出し規約に従わせます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>no_mangle</code> attribute turns off Rust&#39;s name mangling, so that it is easier to link to.</span> <code>no_mangle</code>属性はRustの名前の変更を無効にします。リンクする方が簡単です。</span> </p><br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">FFI and panics</span> FFIとパニック</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It&#39;s important to be mindful of <code>panic€</code> s when working with FFI.</span> FFIと一緒に働くときは、 <code>panic€</code>に気をつけることが重要です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A <code>panic€</code> across an FFI boundary is undefined behavior.</span> FFI境界を横切る<code>panic€</code>は未定義の動作です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you&#39;re writing code that may panic, you should run it in a closure with <a class=notranslate href="#4`catch_unwind`">`catch_unwind`</a> :</span>パニックに陥るかもしれないコードを書いているなら、 <a class=notranslate href="#4`catch_unwind`">`catch_unwind`</a>てクロージャーで実行するべき<a class=notranslate href="#4`catch_unwind`">`catch_unwind`</a> ：</span> </p><br><div data-lang=rust><div data-l="use std::panic::catch_unwind;"></div><div data-l=""></div><div data-l=#[no_mangle]></div><div data-l="pub extern fn oh_no() -&gt; i32 {"></div><div data-l="    let result = catch_unwind(|| {"></div><div data-l="        panic!(&quot;Oops!&quot;);"></div><div data-l="    });"></div><div data-l="    match result {"></div><div data-l="        Ok(_) =&gt; 0,"></div><div data-l="        Err(_) =&gt; 1,"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {}"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Please note that <a class=notranslate href="#4`catch_unwind`">`catch_unwind`</a> will only catch unwinding panics, not those who abort the process.</span> <a class=notranslate href="#4`catch_unwind`">`catch_unwind`</a>はプロセスを中止する人ではなく、巻き戻すパニックを<a class=notranslate href="#4`catch_unwind`">`catch_unwind`</a>するだけであることに注意してください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">See the documentation of <a class=notranslate href="#4`catch_unwind`">`catch_unwind`</a> for more information.</span>詳細は<a class=notranslate href="#4`catch_unwind`">`catch_unwind`</a>のドキュメントを参照してください。</span> </p><br> <a class=notranslate href=#1../std/panic/fn.catch_unwind.html>`catch_unwind`</a> <br> <h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Representing opaque structs</span>不透明な構造体を表現する</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Sometimes, a C library wants to provide a pointer to something, but not let you know the internal details of the thing it wants.</span>時々、Cライブラリは何かへのポインタを提供したいが、あなたが望むものの内部の詳細を知らせない。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The simplest way is to use a <code>void *</code> argument:</span>最も簡単な方法は<code>void *</code>引数を使うことです：</span> </p><br><div data-lang=c><div data-l="void foo(void *arg);"></div><div data-l="void bar(void *arg);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can represent this in Rust with the <code>c_void</code> type:</span>これを<code>c_void</code>で表すことができます：</span> </p><br><div data-lang=rust,ignore><div data-l="extern crate libc;"></div><div data-l=""></div><div data-l="extern &quot;C&quot; {"></div><div data-l="    pub fn foo(arg: *mut libc::c_void);"></div><div data-l="    pub fn bar(arg: *mut libc::c_void);"></div><div data-l=}></div><div data-l="# fn main() {}"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is a perfectly valid way of handling the situation.</span>これは状況を処理するための完全に有効な方法です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, we can do a bit better.</span>しかし、少し上手くいくことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To solve this, some C libraries will instead create a <code>struct</code> , where the details and memory layout of the struct are private.</span>これを解決するために、Cライブラリの中には<code>struct</code>を作成するものがあります。 <code>struct</code>の詳細とメモリレイアウトはprivateです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This gives some amount of type safety.</span>これにより、ある程度の型の安全性が得られます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These structures are called &#39;opaque&#39;.</span>これらの構造は「不透明」と呼ばれます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here&#39;s an example, in C:</span>ここではCの例を示します：</span> </p><br><div data-lang=c><div data-l="struct Foo; /* Foo is a structure, but its contents are not part of the public interface */"></div><div data-l="struct Bar;"></div><div data-l="void foo(struct Foo *arg);"></div><div data-l="void bar(struct Bar *arg);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To do this in Rust, let&#39;s create our own opaque types with <code>enum</code> :</span> Rustでこれを行うには、 <code>enum</code>独自の不透明な型を作成しましょう：</span> </p><br><div data-lang=rust><div data-l="pub enum Foo {}"></div><div data-l="pub enum Bar {}"></div><div data-l=""></div><div data-l="extern &quot;C&quot; {"></div><div data-l="    pub fn foo(arg: *mut Foo);"></div><div data-l="    pub fn bar(arg: *mut Bar);"></div><div data-l=}></div><div data-l="# fn main() {}"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">By using an <code>enum</code> with no variants, we create an opaque type that we can&#39;t instantiate, as it has no variants.</span>バリアントを持たない<code>enum</code>を使用することで、バリアントが存在しないため、インスタンス化できない不透明な型を作成します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But because our <code>Foo</code> and <code>Bar</code> types are different, we&#39;ll get type safety between the two of them, so we cannot accidentally pass a pointer to <code>Foo</code> to <code>bar()</code> .</span>しかし、 <code>Foo</code>と<code>Bar</code>型が異なるため、2つの型の間で型の安全性が確保されるため、 <code>Foo</code>へのポインタを<code>bar()</code>渡すことはできません。</span> </p><script>_addload(function(){_setupIW('com');_csi('en','ja','ffi.html');});</script>