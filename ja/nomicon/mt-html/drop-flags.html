<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180723_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=drop-flags.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Drop Flags</span>ドロップフラグ</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The examples in the previous section introduce an interesting problem for Rust.</span>前のセクションの例では、Rustの興味深い問題を紹介しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We have seen that it&#39;s possible to conditionally initialize, deinitialize, and reinitialize locations of memory totally safely.</span>条件付きでメモリの位置を完全に安全に初期化、初期化解除、再初期化することが可能であることがわかりました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For Copy types, this isn&#39;t particularly notable since they&#39;re just a random pile of bits.</span>コピータイプの場合、これは単なるランダムなビットなので、特に注目に値しません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However types with destructors are a different story: Rust needs to know whether to call a destructor whenever a variable is assigned to, or a variable goes out of scope.</span>しかし、デストラクタの型は別の話です：Rustは、変数が割り当てられるたびにデストラクタを呼び出すか、変数がスコープから外れるかを知る必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">How can it do this with conditional initialization?</span>これを条件付き初期化でどのように行うことができますか？</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that this is not a problem that all assignments need worry about.</span>これはすべての割り当てが心配する必要があるという問題ではないことに注意してください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In particular, assigning through a dereference unconditionally drops, and assigning in a <code>let</code> unconditionally doesn&#39;t drop:</span>特に、逆参照によって無条件に割り振ることで割り振り、無条件に<code>let</code>代入することは中止しません。</span> </p><br><div data-lang=""><div data-l="#//let mut x = Box::new(0); // let makes a fresh variable, so never need to drop"></div><div data-l="let mut x = Box::new(0); // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">let makes a fresh variable, so never need to drop</span>新鮮な変数を作るので、決して落とす必要はありません</span> </div><div data-l="let y = &amp;mut x;"></div><div data-l="#//*y = Box::new(1); // Deref assumes the referent is initialized, so always drops"></div><div data-l="*y = Box::new(1); // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Deref assumes the referent is initialized, so always drops</span> Derefは参照対象が初期化されていると仮定しているため、常にドロップされます</span> </div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is only a problem when overwriting a previously initialized variable or one of its subfields.</span>これは、以前に初期化された変数またはそのサブフィールドの1つを上書きする場合にのみ問題になります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It turns out that Rust actually tracks whether a type should be dropped or not <i>at runtime</i> .</span> Rustは実際にタイプを削除するかどうか<i>を実行時</i>に追跡<i>します</i> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As a variable becomes initialized and uninitialized, a <i>drop flag</i> for that variable is toggled.</span>変数が初期化され、初期化されなくなると、その変数の<i>ドロップフラグ</i>がトグルされます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When a variable might need to be dropped, this flag is evaluated to determine if it should be dropped.</span>変数を削除する必要がある場合、このフラグを評価して、削除する必要があるかどうかを判断します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Of course, it is often the case that a value&#39;s initialization state can be statically known at every point in the program.</span>もちろん、値の初期化状態をプログラムのすべての点で静的に知ることができるケースがよくあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If this is the case, then the compiler can theoretically generate more efficient code!</span>この場合、コンパイラは理論的にはより効率的なコードを生成できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For instance, straight- line code has such <i>static drop semantics</i> :</span>例えば、直線コードは<i>静的なドロップセマンティクスを</i>持ってい<i>ます</i> ：</span> </p><br><div data-lang=rust><div data-l="#//let mut x = Box::new(0); // x was uninit; just overwrite."></div><div data-l="let mut x = Box::new(0); // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">x was uninit;</span> xは無事だった。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">just overwrite.</span>ただ上書きする。</span> </div><div data-l="#//let mut y = x;           // y was uninit; just overwrite and make x uninit."></div><div data-l="let mut y = x;           // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">y was uninit;</span> yは無事だった。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">just overwrite and make x uninit.</span>上書きしてxをuninitにするだけです。</span> </div><div data-l="#//x = Box::new(0);         // x was uninit; just overwrite."></div><div data-l="x = Box::new(0);         // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">x was uninit;</span> xは無事だった。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">just overwrite.</span>ただ上書きする。</span> </div><div data-l="#//y = x;                   // y was init; Drop y, overwrite it, and make x uninit!"></div><div data-l="#                         // y goes out of scope; y was init; Drop y!"></div><div data-l="#                         // x goes out of scope; x was uninit; do nothing."></div><div data-l="y = x;                   // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">y was init;</span> yはinitです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Drop y, overwrite it, and make x uninit!</span>それを上書きし、xをuninitにする！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">y goes out of scope;</span> yは範囲外になります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">y was init;</span> yはinitです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Drop y!</span> Drop y！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">x goes out of scope;</span> xは範囲外になります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">x was uninit;</span> xは無事だった。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">do nothing.</span>何もしない。</span> </div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Similarly, branched code where all branches have the same behavior with respect to initialization has static drop semantics:</span>同様に、すべてのブランチが初期化に関して同じ挙動を有する分岐コードは、静的なドロップセマンティクスを有する：</span> </p><br><div data-lang=rust><div data-l="# let condition = true;"></div><div data-l="#//let mut x = Box::new(0);    // x was uninit; just overwrite."></div><div data-l="let mut x = Box::new(0);    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">x was uninit;</span> xは無事だった。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">just overwrite.</span>ただ上書きする。</span> </div><div data-l="if condition {"></div><div data-l="#//    drop(x)                 // x gets moved out; make x uninit."></div><div data-l="    drop(x)                 // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">x gets moved out;</span> xは移動します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">make x uninit.</span> xをuninitにする。</span> </div><div data-l="} else {"></div><div data-l="    println!(&quot;{}&quot;, x);"></div><div data-l="#//    drop(x)                 // x gets moved out; make x uninit."></div><div data-l="    drop(x)                 // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">x gets moved out;</span> xは移動します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">make x uninit.</span> xをuninitにする。</span> </div><div data-l=}></div><div data-l="#//x = Box::new(0);            // x was uninit; just overwrite."></div><div data-l="#                            // x goes out of scope; x was init; Drop x!"></div><div data-l="x = Box::new(0);            // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">x was uninit;</span> xは無事だった。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">just overwrite.</span>ただ上書きする。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">x goes out of scope;</span> xは範囲外になります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">x was init;</span> xはinitでした。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Drop x!</span>ドロップx！</span> </div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However code like this <i>requires</i> runtime information to correctly Drop:</span>しかし、このようなコードで<i>は、</i>ランタイム情報が正しく削除される<i>必要があり</i>ます。</span> </p><br><div data-lang=rust><div data-l="# let condition = true;"></div><div data-l="let x;"></div><div data-l="if condition {"></div><div data-l="#//    x = Box::new(0);        // x was uninit; just overwrite."></div><div data-l="    x = Box::new(0);        // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">x was uninit;</span> xは無事だった。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">just overwrite.</span>ただ上書きする。</span> </div><div data-l="    println!(&quot;{}&quot;, x);"></div><div data-l=}></div><div data-l="#                            // x goes out of scope; x might be uninit;"></div><div data-l="#                            // check the flag!"></div><div data-l="                            // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">x goes out of scope;</span> xは範囲外になります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">x might be uninit;</span> xはuninitかもしれません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">check the flag!</span>フラグをチェック！</span> </div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Of course, in this case it&#39;s trivial to retrieve static drop semantics:</span>もちろん、この場合、静的なドロップセマンティクスを取得するのは簡単です。</span> </p><br><div data-lang=rust><div data-l="# let condition = true;"></div><div data-l="if condition {"></div><div data-l="    let x = Box::new(0);"></div><div data-l="    println!(&quot;{}&quot;, x);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The drop flags are tracked on the stack and no longer stashed in types that implement drop.</span>ドロップフラグはスタック上で追跡され、ドロップを実装する型ではもはや隠されません。</span> </p><script>_addload(function(){_setupIW('com');_csi('en','ja','drop-flags.html');});</script>