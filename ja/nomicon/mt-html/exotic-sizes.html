<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180723_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=exotic-sizes.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Exotically Sized Types</span>外来サイズのタイプ</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Most of the time, we think in terms of types with a fixed, positive size.</span>ほとんどの場合、固定サイズの正のサイズの型の点で考えています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is not always the case, however.</span>しかし、必ずしもそうではありません。</span> </p><br><br><br><br><br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Dynamically Sized Types (DSTs)</span>動的にサイズ設定された型（DST）</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust in fact supports Dynamically Sized Types (DSTs): types without a statically known size or alignment.</span>実際には、Rustは、動的にサイズが指定された型（DST）をサポートしています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">On the surface, this is a bit nonsensical: Rust <i>must</i> know the size and alignment of something in order to correctly work with it!</span>表面では、これはちょっと無意味です：錆<i>は</i> 、正しく動作するために、何かのサイズと位置合わせを知ってい<i>なければなりません</i> ！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this regard, DSTs are not normal types.</span>これに関して、DSTは通常のタイプではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Due to their lack of a statically known size, these types can only exist behind some kind of pointer.</span>静的に既知のサイズがないため、これらの型はある種のポインタの後ろにしか存在できません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Any pointer to a DST consequently becomes a <i>fat</i> pointer consisting of the pointer and the information that &quot;completes&quot; them (more on this below).</span>その結果、DSTへのポインターは、ポインターとそれらを「完了する」情報からなる<i>太い</i>ポインターになります（詳細は後述）。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There are two major DSTs exposed by the language: trait objects, and slices.</span>言語によって公開される主要なDSTには、特性オブジェクトとスライスの2つがあります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A trait object represents some type that implements the traits it specifies.</span>特性オブジェクトは、それが指定する特性を実装するいくつかのタイプを表します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The exact original type is <i>erased</i> in favor of runtime reflection with a vtable containing all the information necessary to use the type.</span>正確なオリジナルタイプは、タイプを使用するのに必要なすべての情報を含むvtableを使用して、実行時リフレクションのために<i>消去さ</i>れます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is the information that completes a trait object: a pointer to its vtable.</span>これは、traitオブジェクトを完成させる情報です：vtableへのポインタ。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A slice is simply a view into some contiguous storage -- typically an array or <code>Vec</code> .</span>スライスは、連続したいくつかのストレージ（通常はアレイまたは<code>Vec</code>への単純なビューです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The information that completes a slice is just the number of elements it points to.</span>スライスを完成させる情報は、それが指す要素の数だけです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Structs can actually store a single DST directly as their last field, but this makes them a DST as well:</span>構造体は実際には単一のDSTを最後のフィールドとして直接格納することができますが、これによってDSTにもなります。</span> </p><br><div data-lang=rust><div data-l="#// Can't be stored on the stack directly"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Can&#39;t be stored on the stack directly</span>スタックに直接格納することはできません</span> </div><div data-l="struct Foo {"></div><div data-l="    info: u32,"></div><div data-l="    data: [u8],"></div><div data-l=}></div></div><br><br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Zero Sized Types (ZSTs)</span>ゼロサイズタイプ（ZST）</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust actually allows types to be specified that occupy no space:</span> Rustは実際にはスペースを使わない型を指定することを可能にします：</span> </p><br><div data-lang=rust><div data-l="#//struct Foo; // No fields = no size"></div><div data-l="struct Foo; // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">No fields = no size</span>フィールドなし=サイズなし</span> </div><div data-l=""></div><div data-l="#// All fields have no size = no size"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">All fields have no size = no size</span>すべてのフィールドにサイズはありません=サイズはありません</span> </div><div data-l="struct Baz {"></div><div data-l="    foo: Foo,"></div><div data-l="#//    qux: (),      // empty tuple has no size"></div><div data-l="    qux: (),      // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">empty tuple has no size</span>空のタプルにサイズがありません</span> </div><div data-l="#//    baz: [u8; 0], // empty array has no size"></div><div data-l="    baz: [u8; 0], // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">empty array has no size</span>空の配列にはサイズがありません</span> </div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">On their own, Zero Sized Types (ZSTs) are, for obvious reasons, pretty useless.</span>明らかに、Zero Sized Types（ZST）は無意味です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However as with many curious layout choices in Rust, their potential is realized in a generic context: Rust largely understands that any operation that produces or stores a ZST can be reduced to a no-op.</span>しかし、Rustの多くの興味深いレイアウトの選択肢と同様に、それらの可能性は一般的なコンテキストで実現されます.Rustは、ZSTを生成または格納する操作をノーオペレーションに減らすことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">First off, storing it doesn&#39;t even make sense -- it doesn&#39;t occupy any space.</span>最初に、それを格納することは意味をなさない - それはスペースを占有しません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Also there&#39;s only one value of that type, so anything that loads it can just produce it from the aether -- which is also a no-op since it doesn&#39;t occupy any space.</span>また、そのタイプの値は1つだけなので、ロードするものはどれもaetherから生成できます。これはスペースを占有しないため、ノーオペレーションでもあります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">One of the most extreme example&#39;s of this is Sets and Maps.</span>これの最も極端な例の1つは、セットとマップです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Given a <code>Map&lt;Key, Value&gt;</code> , it is common to implement a <code>Set&lt;Key&gt;</code> as just a thin wrapper around <code>Map&lt;Key, UselessJunk&gt;</code> .</span> <code>Map&lt;Key, Value&gt;</code>を指定すると、 <code>Map&lt;Key, UselessJunk&gt;</code>周りに薄いラッパーとして<code>Set&lt;Key&gt;</code>を実装するのが一般的です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In many languages, this would necessitate allocating space for UselessJunk and doing work to store and load UselessJunk only to discard it.</span>多くの言語では、これは、UselessJunkにスペースを割り当て、それを破棄するためにUselessJunkを保存しロードする作業を必要とします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Proving this unnecessary would be a difficult analysis for the compiler.</span>これが不必要であることを証明することは、コンパイラにとって難しい分析です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However in Rust, we can just say that <code>Set&lt;Key&gt; = Map&lt;Key, ()&gt;</code> .</span>しかし、Rustでは<code>Set&lt;Key&gt; = Map&lt;Key, ()&gt;</code>としか言いようがありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now Rust statically knows that every load and store is useless, and no allocation has any size.</span>現在、Rustはすべての負荷とストアが役に立たず、割り当てにサイズがないことを静的に知っています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The result is that the monomorphized code is basically a custom implementation of a HashSet with none of the overhead that HashMap would have to support values.</span>その結果、単体化されたコードは基本的に、HashMapが値をサポートしなければならないオーバーヘッドのないHashSetのカスタム実装です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Safe code need not worry about ZSTs, but <i>unsafe</i> code must be careful about the consequence of types with no size.</span>安全なコードはZSTについて心配する必要はありませんが、 <i>安全でない</i>コードはサイズのない型の結果に注意する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In particular, pointer offsets are no-ops, and standard allocators (including jemalloc, the one used by default in Rust) may return <code>nullptr</code> when a zero-sized allocation is requested, which is indistinguishable from out of memory.</span>特に、ポインタオフセットはno-opsであり、標準アロケータ（rustでデフォルトで使用されるjemallocを含む）は、サイズがゼロの割り当てが要求されたときに<code>nullptr</code>返すことがあります。これはメモリ不足と区別できません。</span> </p><br><br><br><br><br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Empty Types</span>空のタイプ</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust also enables types to be declared that <i>cannot even be instantiated</i> .</span>錆はまた、 <i>インスタンス化さえできない</i>型を宣言する<i>こと</i>を<i>可能にします</i> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These types can only be talked about at the type level, and never at the value level.</span>これらのタイプは、タイプレベルでのみ話すことができ、決して値レベルでは話せません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Empty types can be declared by specifying an enum with no variants:</span>空の型は、バリアントのないenumを指定することで宣言できます：</span> </p><br><div data-lang=rust><div data-l="#//enum Void {} // No variants = EMPTY"></div><div data-l="enum Void {} // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">No variants = EMPTY</span>バリエーションはありません= EMPTY</span> </div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Empty types are even more marginal than ZSTs.</span>空のタイプはZSTよりもはるかに限界です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The primary motivating example for Void types is type-level unreachability.</span> Void型の主要な動機付けの例は、型レベルの到達不能性です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For instance, suppose an API needs to return a Result in general, but a specific case actually is infallible.</span>たとえば、APIが一般的にResultを返す必要があるとしますが、具体的なケースは実際には間違いありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It&#39;s actually possible to communicate this at the type level by returning a <code>Result&lt;T, Void&gt;</code> .</span> <code>Result&lt;T, Void&gt;</code>返すことで、これを型レベルで通信することは実際可能です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Consumers of the API can confidently unwrap such a Result knowing that it&#39;s <i>statically impossible</i> for this value to be an <code>Err</code> , as this would require providing a value of type <code>Void</code> .</span> APIの消費者は、この値が<code>Err</code>であることが<i>静的に不可能</i>であることを知って、このような結果を確実にアンラップできます。これは、 <code>Void</code>型の値を提供する必要があるためです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In principle, Rust can do some interesting analyses and optimizations based on this fact.</span>原則として、Rustはこの事実に基づいていくつかの興味深い分析と最適化を行うことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For instance, <code>Result&lt;T, Void&gt;</code> could be represented as just <code>T</code> , because the <code>Err</code> case doesn&#39;t actually exist.</span>たとえば、 <code>Err</code>場合は実際には存在しないため、 <code>Result&lt;T, Void&gt;</code>は<code>T</code>として表すことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The following <i>could</i> also compile:</span>次もコンパイル<i>でき</i>ます：</span> </p><br><div data-lang=rust,ignore><div data-l="enum Void {}"></div><div data-l=""></div><div data-l="let res: Result&lt;u32, Void&gt; = Ok(0);"></div><div data-l=""></div><div data-l="#// Err doesn't exist anymore, so Ok is actually irrefutable."></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Err doesn&#39;t exist anymore, so Ok is actually irrefutable.</span> Errはもう存在しないので、Okは実際には反駁できません。</span> </div><div data-l="let Ok(num) = res;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But neither of these tricks work today, so all Void types get you is the ability to be confident that certain situations are statically impossible.</span>しかし、これらの仕掛けは今日でも機能しないので、すべてのVoidタイプは、特定の状況が静的に不可能であることを確信する能力です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">One final subtle detail about empty types is that raw pointers to them are actually valid to construct, but dereferencing them is Undefined Behavior because that doesn&#39;t actually make sense.</span>空の型に関する最後の微妙な詳細の1つは、それらの生ポインタが実際に構築するのに有効ですが、それらを逆参照することは、実際には意味がないため、未定義の動作です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That is, you could model C&#39;s <code>void *</code> type with <code>*const Void</code> , but this doesn&#39;t necessarily gain anything over using eg <code>*const ()</code> , which <i>is</i> safe to randomly dereference.</span>それはあなたがCのモデル化ができ、ある<code>void *</code>とタイプ<code>*const Void</code> 、これは必ずしもなどを使用しての上に何かを得ることはありません<code>*const ()</code>ランダムに間接参照に安全<i>です</i> 、。</span> </p><br><br> <a class=notranslate href=#1https://github.com/rust-lang/rust/issues/26403>dst-issue</a><script>_addload(function(){_setupIW('com');_csi('en','ja','exotic-sizes.html');});</script>