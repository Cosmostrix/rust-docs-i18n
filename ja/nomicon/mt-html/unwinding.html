<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180723_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=unwinding.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Unwinding</span>巻き戻す</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust has a <i>tiered</i> error-handling scheme:</span> Rustには<i>段階的な</i>エラー処理スキームがあります。</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If something might reasonably be absent, Option is used.</span>合理的に何かが存在しない場合は、Optionが使用されます。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If something goes wrong and can reasonably be handled, Result is used.</span>何かがうまくいかず合理的に処理できる場合は、Resultが使用されます。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If something goes wrong and cannot reasonably be handled, the thread panics.</span>何かがうまくいかず、合理的に処理できない場合、スレッドはパニックに陥ります。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If something catastrophic happens, the program aborts.</span>何か致命的な事態が発生した場合、プログラムは打ち切られます。</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Option and Result are overwhelmingly preferred in most situations, especially since they can be promoted into a panic or abort at the API user&#39;s discretion.</span>オプションと結果は、ほとんどの状況で圧倒的に好まれます。特に、APIユーザーの裁量でパニックまたはアボートに昇格する可能性があるためです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Panics cause the thread to halt normal execution and unwind its stack, calling destructors as if every function instantly returned.</span>パニックにより、スレッドは通常の実行を停止し、スタックを巻き戻し、すべての関数が即座に返されたかのようにデストラクタを呼び出します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As of 1.0, Rust is of two minds when it comes to panics.</span> 1.0の時点で、パニックになるとRustは2つの心のものです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In the long-long-ago, Rust was much more like Erlang.</span>長い間、RustはErlangによく似ていました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Like Erlang, Rust had lightweight tasks, and tasks were intended to kill themselves with a panic when they reached an untenable state.</span> Erlangのように、Rustは軽量のタスクを持っていました。タスクは、容赦のない状態になったときにパニックで自分自身を殺すことを意図していました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Unlike an exception in Java or C++, a panic could not be caught at any time.</span> JavaやC ++の例外とは異なり、いつでもパニックをキャッチすることはできませんでした。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Panics could only be caught by the owner of the task, at which point they had to be handled or <i>that</i> task would itself panic.</span>パニックは、タスクの所有者だけが捕まえることができ、その時点でそれらを処理しなければならない、または<i>その</i>タスク自体がパニックになる可能性があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Unwinding was important to this story because if a task&#39;s destructors weren&#39;t called, it would cause memory and other system resources to leak.</span>タスクのデストラクタが呼び出されなかった場合、メモリやその他のシステムリソースがリークする可能性があるため、巻き戻しはこのストーリーにとって重要でした。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Since tasks were expected to die during normal execution, this would make Rust very poor for long-running systems!</span>タスクは通常の実行中に消滅することが予想されていたため、これは長時間実行されるシステムではRustを非常に悪くします。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As the Rust we know today came to be, this style of programming grew out of fashion in the push for less-and-less abstraction.</span>今日知られている錆が現れたので、このスタイルのプログラミングは、抽象的でない抽象化のためにファッションから成長しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Light-weight tasks were killed in the name of heavy-weight OS threads.</span>軽量のタスクは、重量のあるOSスレッドの名前で殺されました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Still, on stable Rust as of 1.0 panics can only be caught by the parent thread.</span>それでも、1.0パニックの安定したRustでは、親スレッドだけが捕まえることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This means catching a panic requires spinning up an entire OS thread!</span>つまり、パニックを起こすには、OSスレッド全体を回転させる必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This unfortunately stands in conflict to Rust&#39;s philosophy of zero-cost abstractions.</span>これは残念なことに、Rustのゼロコスト抽象化の哲学と矛盾している。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There is an unstable API called <code>catch_panic</code> that enables catching a panic without spawning a thread.</span>スレッドを生成せずにパニックをキャッチできる<code>catch_panic</code>という不安定なAPIがあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Still, we would encourage you to only do this sparingly.</span>それでも、私たちはこれを慎重に行うことをお勧めします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In particular, Rust&#39;s current unwinding implementation is heavily optimized for the &quot;doesn&#39;t unwind&quot; case.</span>特に、Rustの現在の巻き戻しの実装は、 &quot;unwind unwind&quot;の場合に大きく最適化されています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If a program doesn&#39;t unwind, there should be no runtime cost for the program being <i>ready</i> to unwind.</span>プログラムが巻き戻されない場合、プログラムが巻き戻す<i>準備</i>が<i>でき</i>ているランタイム・コストはないはずです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As a consequence, actually unwinding will be more expensive than in eg Java.</span>結果として、実際に巻き戻すことは、たとえばJavaの場合よりも高価になります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Don&#39;t build your programs to unwind under normal circumstances.</span>通常の状況下では、プログラムを作成しないでください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Ideally, you should only panic for programming errors or <i>extreme</i> problems.</span>理想的には、プログラミングエラーや<i>極端な</i>問題のみを慌てるべきです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust&#39;s unwinding strategy is not specified to be fundamentally compatible with any other language&#39;s unwinding.</span> Rustの解き放つ戦略は、他の言語の解きほぐしと基本的に互換性があるとは指定されていません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As such, unwinding into Rust from another language, or unwinding into another language from Rust is Undefined Behavior.</span>したがって、別の言語からRustに巻き戻したり、Rustから別の言語に戻したりすることは未定義の動作です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You must <i>absolutely</i> catch any panics at the FFI boundary!</span>あなたは<i>絶対に</i> FFI境界でパニックをキャッチする必要があります！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">What you do at that point is up to you, but <i>something</i> must be done.</span>その時点であなたがすることはあなた次第ですが、 <i>何かをする</i>必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you fail to do this, at best, your application will crash and burn.</span>これをしないと、せいぜいアプリケーションがクラッシュして焼いてしまうだけです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">At worst, your application <i>won&#39;t</i> crash and burn, and will proceed with completely clobbered state.</span>最悪の場合、アプリケーション<i>は</i>クラッシュ<i>せず</i> 、焼き付かず、完全に閉塞状態になります。</span> </p><script>_addload(function(){_setupIW('com');_csi('en','ja','unwinding.html');});</script>