<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180723_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=unchecked-uninit.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Unchecked Uninitialized Memory</span>チェックされていない初期化されていないメモリ</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">One interesting exception to this rule is working with arrays.</span>このルールの1つの興味深い例外は、配列の操作です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Safe Rust doesn&#39;t permit you to partially initialize an array.</span> Safe Rustでは、配列を部分的に初期化することはできません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When you initialize an array, you can either set every value to the same thing with <code>let x = [val; N]</code></span>配列を初期化するときは、 <code>let x = [val; N]</code></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>let x = [val; N]</code> , or you can specify each member individually with <code>let x = [val1, val2, val3]</code> .</span> <code>let x = [val; N]</code> 、または<code>let x = [val1, val2, val3]</code>個々に各メンバーを指定することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Unfortunately this is pretty rigid, especially if you need to initialize your array in a more incremental or dynamic way.</span>残念ながら、これは非常に堅牢です。特に、配列をより漸進的または動的な方法で初期化する必要がある場合は、</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Unsafe Rust gives us a powerful tool to handle this problem: <code>mem::uninitialized</code> .</span> Unsafe Rustはこの問題を処理するための強力なツールを提供します： <code>mem::uninitialized</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This function pretends to return a value when really it does nothing at all.</span>この関数は実際に何もしないときに値を返すふりをします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Using it, we can convince Rust that we have initialized a variable, allowing us to do trickier things with conditional and incremental initialization.</span>それを使って、変数を初期化したことをRustに説得させることができ、条件付き初期化とインクリメンタル初期化を使ってより厄介なことを行うことができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Unfortunately, this opens us up to all kinds of problems.</span>残念ながら、これは私たちにあらゆる種類の問題を引き起こします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Assignment has a different meaning to Rust based on whether it believes that a variable is initialized or not.</span>代入は、変数が初期化されているかどうかに基づいて、Rustとは異なる意味を持ちます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If it&#39;s believed uninitialized, then Rust will semantically just memcopy the bits over the uninitialized ones, and do nothing else.</span>初期化されていないと信じられている場合、Rustは意味論的に、ビットを初期化されていないものにmemcopyし、他に何もしません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However if Rust believes a value to be initialized, it will try to <code>Drop</code> the old value!</span>錆が初期化される値を信じている場合しかし、それはしようとします<code>Drop</code>古い値を！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Since we&#39;ve tricked Rust into believing that the value is initialized, we can no longer safely use normal assignment.</span>値が初期化されたと信じるようにRustを騙したので、もはや安全に通常の割り当てを使用することはできません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is also a problem if you&#39;re working with a raw system allocator, which returns a pointer to uninitialized memory.</span>これは、初期化されていないメモリへのポインタを返すローシステムアロケータを使用している場合にも問題になります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To handle this, we must use the <code>ptr</code> module.</span>これを処理するには、 <code>ptr</code>モジュールを使用する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In particular, it provides three functions that allow us to assign bytes to a location in memory without dropping the old value: <code>write</code> , <code>copy</code> , and <code>copy_nonoverlapping</code> .</span>特に、この関数は3つの関数を提供しています。これにより、古い値を削除せずに、 <code>write</code> 、 <code>copy</code> 、および<code>copy_nonoverlapping</code>というメモリ内の場所にバイトを割り当てることができます。</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>ptr::write(ptr, val)</code> takes a <code>val</code> and moves it into the address pointed to by <code>ptr</code> .</span> <code>ptr::write(ptr, val)</code>は<code>val</code>をとり、それを<code>ptr</code>指すアドレスに移動します。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>ptr::copy(src, dest, count)</code> copies the bits that <code>count</code> T&#39;s would occupy from src to dest.</span> <code>ptr::copy(src, dest, count)</code>ビットのコピー<code>count</code> Tさんは、SRCからDESTに占めます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">(this is equivalent to memmove -- note that the argument order is reversed!)</span> （これはmemmoveと同じです - 引数の順序が逆になっていることに注意してください）。</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>ptr::copy_nonoverlapping(src, dest, count)</code> does what <code>copy</code> does, but a little faster on the assumption that the two ranges of memory don&#39;t overlap.</span> <code>ptr::copy_nonoverlapping(src, dest, count)</code>は<code>copy</code>の動作を行いますが、メモリの2つの範囲が重複しないという前提で少し速くなります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">(this is equivalent to memcpy -- note that the argument order is reversed!)</span> （これはmemcpyに相当します - 引数の順序が逆になっていることに注意してください）。</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It should go without saying that these functions, if misused, will cause serious havoc or just straight up Undefined Behavior.</span>これらの機能が悪用されると、深刻な混乱を引き起こすか、まったくまっすぐな未定義の行動を引き起こすことは言うまでもない。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The only things that these functions <i>themselves</i> require is that the locations you want to read and write are allocated.</span>これらの関数<i>自体が</i>必要とするのは、読み書きする場所が割り当てられることだけです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However the ways writing arbitrary bits to arbitrary locations of memory can break things are basically uncountable!</span>しかし、任意のビットをメモリの任意の場所に書き込む方法は、基本的には不可能です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Putting this all together, we get the following:</span>これをすべてまとめると、次のようになります。</span> </p><br><div data-lang=rust><div data-l="use std::mem;"></div><div data-l="use std::ptr;"></div><div data-l=""></div><div data-l="#// size of the array is hard-coded but easy to change. This means we can't"></div><div data-l="#// use [a, b, c] syntax to initialize the array, though!"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">size of the array is hard-coded but easy to change.</span>アレイのサイズはハードコードされていますが、変更が容易です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This means we can&#39;t use <a class=notranslate href="#4a, b, c">a, b, c</a> syntax to initialize the array, though!</span>これは、配列を初期化する<a class=notranslate href="#4a, b, c">a, b, c</a>構文を使うことはできないということです。</span> </div><div data-l="const SIZE: usize = 10;"></div><div data-l=""></div><div data-l="let mut x: [Box&lt;u32&gt;; SIZE];"></div><div data-l=""></div><div data-l="unsafe {"></div><div data-l="#//	// convince Rust that x is Totally Initialized"></div><div data-l="	// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">convince Rust that x is Totally Initialized</span> xが完全に初期化されたとRustに説得する</span> </div><div data-l="	x = mem::uninitialized();"></div><div data-l="	for i in 0..SIZE {"></div><div data-l="#//		// very carefully overwrite each index without reading it"></div><div data-l="		// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">very carefully overwrite each index without reading it</span>各索引を読まずに非常に注意深く上書きする</span> </div><div data-l="#//		// NOTE: exception safety is not a concern; Box can't panic"></div><div data-l="		// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">NOTE: exception safety is not a concern;</span>注：例外の安全性は問題ではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Box can&#39;t panic</span>ボックスはパニックにならない</span> </div><div data-l="		ptr::write(&amp;mut x[i], Box::new(i as u32));"></div><div data-l="	}"></div><div data-l=}></div><div data-l=""></div><div data-l="println!(&quot;{:?}&quot;, x);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It&#39;s worth noting that you don&#39;t need to worry about <code>ptr::write</code> -style shenanigans with types which don&#39;t implement <code>Drop</code> or contain <code>Drop</code> types, because Rust knows not to try to drop them.</span>それはあなたが心配する必要がないことは注目に値します<code>ptr::write</code>実装していない種類のスタイルのペテンを<code>Drop</code>か、含まれている<code>Drop</code>錆がそれらをドロップしようとしないことを知っているので、種類を。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Similarly you should be able to assign to fields of partially initialized structs directly if those fields don&#39;t contain any <code>Drop</code> types.</span>同様に、部分的に初期化された構造体のフィールドに、 <code>Drop</code>型が含まれていない場合は直接割り当てることができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However when working with uninitialized memory you need to be ever-vigilant for Rust trying to drop values you make like this before they&#39;re fully initialized.</span>しかし、初期化されていないメモリを扱うときは、完全に初期化される前に、このようにして値を落とそうとするRustに常に注意する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Every control path through that variable&#39;s scope must initialize the value before it ends, if it has a destructor.</span>その変数のスコープ内のすべての制御パスは、デストラクタがある場合は、終了する前に値を初期化する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><i>[This includes code panicking](unwinding.html)</i> .</span> <i>[これはコードパニックを含む]（unwinding.html）</i> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">And that&#39;s about it for working with uninitialized memory!</span>それは初期化されていないメモリを扱うためのものです！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Basically nothing anywhere expects to be handed uninitialized memory, so if you&#39;re going to pass it around at all, be sure to be <i>really</i> careful.</span>基本的にどこでも初期化されていないメモリが渡されることを期待しているわけではないので、まったく渡すつもりならば、 <i>本当に</i>注意してください。</span> </p><script>_addload(function(){_setupIW('com');_csi('en','ja','unchecked-uninit.html');});</script>