<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180723_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=atomics.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Atomics</span>アトミック</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust pretty blatantly just inherits C11&#39;s memory model for atomics.</span>錆はC11のアトミック用メモリモデルをちょうど継承しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is not due to this model being particularly excellent or easy to understand.</span>これは、このモデルが特に優れているか、または理解しやすいためではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Indeed, this model is quite complex and known to have <a href=#3C11-busted>several flaws</a> .</span>実際、このモデルは非常に複雑で、 <a href=#3C11-busted>いくつかの欠陥がある</a>ことが知られています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rather, it is a pragmatic concession to the fact that <i>everyone</i> is pretty bad at modeling atomics.</span>むしろ、 <i>誰も</i>がアトミックをモデリングするのがかなり悪いということは、実用的な譲歩です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">At very least, we can benefit from existing tooling and research around C.</span>少なくとも、Cを中心とした既存のツーリングや研究の恩恵を受けることができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Trying to fully explain the model in this book is fairly hopeless.</span>この本の中のモデルを完全に説明しようとするとかなり希望はありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It&#39;s defined in terms of madness-inducing causality graphs that require a full book to properly understand in a practical way.</span>これは、実践的な方法で正しく理解するための完全な本を必要とする狂気誘発因果関係グラフの観点から定義されています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you want all the nitty-gritty details, you should check out <a href=#3C11-model>C&#39;s specification (Section 7.17)</a> .</span>根深い詳細をすべて知りたい場合は、 <a href=#3C11-model>Cの仕様（7.17節）</a>をチェックしてください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Still, we&#39;ll try to cover the basics and some of the problems Rust developers face.</span>それでも、我々はRustの開発者が直面するいくつかの基本事項といくつかの問題をカバーしようとします。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The C11 memory model is fundamentally about trying to bridge the gap between the semantics we want, the optimizations compilers want, and the inconsistent chaos our hardware wants.</span> C11メモリモデルは、基本的に、私たちが望むセマンティクス、最適化コンパイラが望むもの、そしてハードウェアが望む矛盾した混乱の間のギャップを埋めようとすることです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><i>We</i> would like to just write programs and have them do exactly what we said but, you know, fast.</span> <i>私たち</i>はプログラムを書いて、 <i>私たち</i>が言ったこととまったく同じようにしたいと思いますが、あなたは知っています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Wouldn&#39;t that be great?</span>それは素晴らしいことではないでしょうか？</span> </p><br><br><br><br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Compiler Reordering</span>コンパイラの並べ替え</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Compilers fundamentally want to be able to do all sorts of complicated transformations to reduce data dependencies and eliminate dead code.</span>コンパイラは基本的に、あらゆる種類の複雑な変換を行い、データの依存関係を減らし、デッドコードを排除したいと考えています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In particular, they may radically change the actual order of events, or make events never occur!</span>特に、イベントの実際の順序を根本的に変更したり、イベントが発生しないようにすることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we write something like</span>私たちが</span> </p><br><div data-lang=rust,ignore><div data-l="x = 1;"></div><div data-l="y = 3;"></div><div data-l="x = 2;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The compiler may conclude that it would be best if your program did</span>コンパイラは、あなたのプログラムが</span> </p><br><div data-lang=rust,ignore><div data-l="x = 2;"></div><div data-l="y = 3;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This has inverted the order of events and completely eliminated one event.</span>これはイベントの順序を逆転させ、1つのイベントを完全に排除しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">From a single-threaded perspective this is completely unobservable: after all the statements have executed we are in exactly the same state.</span>シングルスレッドの観点からは、これは完全に観測できません。すべてのステートメントが実行された後、まったく同じ状態になります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But if our program is multi-threaded, we may have been relying on <code>x</code> to actually be assigned to 1 before <code>y</code> was assigned.</span>しかし、私たちのプログラムがマルチスレッドの場合、 <code>y</code>が割り当てられる前に実際に<code>x</code>に1を代入している可能性があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We would like the compiler to be able to make these kinds of optimizations, because they can seriously improve performance.</span>パフォーマンスを大幅に向上させることができるので、これらの最適化を行うことができるようにしたいと考えています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">On the other hand, we&#39;d also like to be able to depend on our program <i>doing the thing we said</i> .</span>一方、私たちは、私たちが<i>言ったことを</i>してプログラムに頼ることもできるようにしたいと考え<i>てい</i>ます。</span> </p><br><br><br><br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Hardware Reordering</span>ハードウェア並べ替え</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">On the other hand, even if the compiler totally understood what we wanted and respected our wishes, our hardware might instead get us in trouble.</span>一方、たとえコンパイラが私たちの望みを尊重し、尊重したものを完全に理解したとしても、私たちのハードウェアは代わりに困ってしまうかもしれません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Trouble comes from CPUs in the form of memory hierarchies.</span>メモリ階層の形でCPUから問題が発生します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There is indeed a global shared memory space somewhere in your hardware, but from the perspective of each CPU core it is <i>so very far away</i> and <i>so very slow</i> .</span>ハードウェアのどこかにグローバルな共有メモリ空間がありますが、各CPUコアの観点からは<i>非常に遠く</i> <i>、非常に遅い</i>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Each CPU would rather work with its local cache of the data and only go through all the anguish of talking to shared memory only when it doesn&#39;t actually have that memory in cache.</span>各CPUはむしろデータのローカルキャッシュを扱い、実際にそのメモリをキャッシュに持っていないときにのみ共有メモリとの対話に苦労します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">After all, that&#39;s the whole point of the cache, right?</span>結局のところ、それはキャッシュ全体のポイントなのですよね？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If every read from the cache had to run back to shared memory to double check that it hadn&#39;t changed, what would the point be?</span>キャッシュからのすべての読み込みが変更されていないことを二重チェックするために共有メモリに戻さなければならない場合、何が重要なのでしょうか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The end result is that the hardware doesn&#39;t guarantee that events that occur in the same order on <i>one</i> thread, occur in the same order on <i>another</i> thread.</span>最終的な結果として、ハードウェアは、 <i>ある</i>スレッドで同じ順序で発生するイベントが<i>別の</i>スレッドで同じ順序で発生することを保証しません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To guarantee this, we must issue special instructions to the CPU telling it to be a bit less smart.</span>これを保証するには、CPUに特別な指示を出して、少しスマートにするよう指示する必要があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For instance, say we convince the compiler to emit this logic:</span>たとえば、このロジックを出すようにコンパイラに説得してみましょう。</span> </p><br><div data-lang=text><div data-l="initial state: x = 0, y = 1"></div><div data-l=""></div><div data-l="THREAD 1        THREAD2"></div><div data-l="y = 3;          if x == 1 {"></div><div data-l="x = 1;              y *= 2;"></div><div data-l="                }"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Ideally this program has 2 possible final states:</span>理想的には、このプログラムには2つの可能な最終状態があります。</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>y = 3</code> : (thread 2 did the check before thread 1 completed)</span> <code>y = 3</code> ：（スレッド1が完了する前にスレッド2がチェックを行った）</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>y = 6</code> : (thread 2 did the check after thread 1 completed)</span> <code>y = 6</code> ：（スレッド1が完了した後にスレッド2がチェックを行った）</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However there&#39;s a third potential state that the hardware enables:</span>しかし、ハードウェアが可能にする第3の潜在的な状態があります：</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>y = 2</code> : (thread 2 saw <code>x = 1</code> , but not <code>y = 3</code> , and then overwrote <code>y = 3</code> )</span> <code>y = 2</code> ：（スレッド2鋸<code>x = 1</code>ではなく、 <code>y = 3</code> 、及びその後は上書き<code>y = 3</code> ）</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It&#39;s worth noting that different kinds of CPU provide different guarantees.</span>異なる種類のCPUが異なる保証を提供することは注目に値する。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It is common to separate hardware into two categories: strongly-ordered and weakly- ordered.</span>ハードウェアを2つのカテゴリに分類するのが一般的です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Most notably x86/64 provides strong ordering guarantees, while ARM provides weak ordering guarantees.</span>特に、x86 / 64は強力な発注保証を提供し、ARMは弱い発注保証を提供します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This has two consequences for concurrent programming:</span>これは並行プログラミングに2つの結果をもたらします。</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Asking for stronger guarantees on strongly-ordered hardware may be cheap or even free because they already provide strong guarantees unconditionally.</span>強く注文されたハードウェアに対するより強い保証を求めることは、既に無条件に強力な保証を提供しているので安価であるか、または無料でさえあり得る。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Weaker guarantees may only yield performance wins on weakly-ordered hardware.</span>弱い保証は、弱く注文されたハードウェアでのみパフォーマンスが向上する可能性があります。</span> </div><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Asking for guarantees that are too weak on strongly-ordered hardware is more likely to <i>happen</i> to work, even though your program is strictly incorrect.</span>強く注文したハードウェア上では弱すぎるの保証のために頼むことはあなたのプログラムは、厳密に間違っているにもかかわらず、仕事に<i>起こる</i>可能性が高いです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If possible, concurrent algorithms should be tested on weakly-ordered hardware.</span>可能であれば、並行アルゴリズムは弱く順序付けられたハードウェアでテストする必要があります。</span> </div><br><br><br><br><br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Data Accesses</span>データアクセス</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The C11 memory model attempts to bridge the gap by allowing us to talk about the <i>causality</i> of our program.</span> C11メモリモデルは、私たちのプログラムの<i>因果関係</i>について話すことを可能にすることによってギャップを埋めようとします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Generally, this is by establishing a <i>happens before</i> relationship between parts of the program and the threads that are running them.</span>一般的に、これは、プログラムの部分とそれを実行しているスレッドとの間の関係を確立する<i>こと</i>によって確立されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This gives the hardware and compiler room to optimize the program more aggressively where a strict happens-before relationship isn&#39;t established, but forces them to be more careful where one is established.</span>これによりハードウェアとコンパイルルームは、厳密な先験的関係が確立されていない場合に、より積極的にプログラムを最適化することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The way we communicate these relationships are through <i>data accesses</i> and <i>atomic accesses</i> .</span>これらの関係を伝える方法は、 <i>データアクセス</i>と<i>アトミックアクセスによるもの</i>です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Data accesses are the bread-and-butter of the programming world.</span>データへのアクセスは、プログラミング世界のパンとバターです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">They are fundamentally unsynchronized and compilers are free to aggressively optimize them.</span>基本的に非同期であり、コンパイラは積極的にそれらを最適化することは自由です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In particular, data accesses are free to be reordered by the compiler on the assumption that the program is single-threaded.</span>特に、プログラムがシングルスレッドであると仮定して、コンパイラによってデータアクセスを自由に並べ替えることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The hardware is also free to propagate the changes made in data accesses to other threads as lazily and inconsistently as it wants.</span>また、ハードウェアは、データアクセスで行われた変更を他のスレッドにゆっくりと一貫して伝播させることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Most critically, data accesses are how data races happen.</span>最も重要なのは、データアクセスはデータ競合の発生方法です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Data accesses are very friendly to the hardware and compiler, but as we&#39;ve seen they offer <i>awful</i> semantics to try to write synchronized code with.</span>データアクセスは、ハードウェアとコンパイラにとって非常に親切ですが、われわれが見てきたように、それらは同期コードを書くために<i>ひどい</i>意味を提供します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Actually, that&#39;s too weak.</span>実際、それは弱すぎます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><b>It is literally impossible to write correct synchronized code using only data accesses.</b></span> <b>データアクセスのみを使用して正しい同期コードを書くことは文字通り不可能です。</b></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Atomic accesses are how we tell the hardware and compiler that our program is multi-threaded.</span>アトミックアクセスは、プログラムがマルチスレッドであることをハードウェアとコンパイラに伝える方法です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Each atomic access can be marked with an <i>ordering</i> that specifies what kind of relationship it establishes with other accesses.</span>各アトミック・アクセスには、他のアクセスとどのような関係を確立するかを指定する<i>順序付け</i>を<i>付ける</i>ことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In practice, this boils down to telling the compiler and hardware certain things they <i>can&#39;t</i> do.</span>実際には、これは、コンパイラとハードウェアに何も<i>できない</i>ことを伝えることになります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For the compiler, this largely revolves around re-ordering of instructions.</span>コンパイラの場合、これは主に命令の並べ替えを中心に行われます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For the hardware, this largely revolves around how writes are propagated to other threads.</span>ハードウェアの場合、これは主に書き込みが他のスレッドに伝播する方法を中心に行われます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The set of orderings Rust exposes are:</span> Rustの注文のセットは次のとおりです。</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Sequentially Consistent (SeqCst)</span>順不同（SeqCst）</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Release</span>リリース</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Acquire</span>獲得する</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Relaxed</span>リラックス</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">(Note: We explicitly do not expose the C11 <i>consume</i> ordering)</span> （注：明示的にC11の<i>消費</i>順序を公開していません）</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">TODO: negative reasoning vs positive reasoning?</span> TODO：否定的推論対肯定的推論？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">TODO: &quot;can&#39;t forget to synchronize&quot;</span> TODO： &quot;同期するのを忘れることはできない&quot;</span> </p><br><br><br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Sequentially Consistent</span>順不同</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Sequentially Consistent is the most powerful of all, implying the restrictions of all other orderings.</span>シーケンシャルに一貫性があり、他のすべての注文の制限を意味します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Intuitively, a sequentially consistent operation cannot be reordered: all accesses on one thread that happen before and after a SeqCst access stay before and after it.</span>直観的に、シーケンシャルに一貫性のある操作を並べ替えることはできません.SeqCstアクセスの前後に発生する1つのスレッド上のすべてのアクセスは、その前後にとどまります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A data-race-free program that uses only sequentially consistent atomics and data accesses has the very nice property that there is a single global execution of the program&#39;s instructions that all threads agree on.</span>逐次的に一貫性のあるアトミックおよびデータアクセスのみを使用するデータ競争のないプログラムは、すべてのスレッドが同意するプログラムの命令の単一のグローバル実行があるという非常に良い特性を持っています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This execution is also particularly nice to reason about: it&#39;s just an interleaving of each thread&#39;s individual executions.</span>この実行はまた、理由があるので特に好都合です。それは、各スレッドの個々の実行のインタリーブです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This does not hold if you start using the weaker atomic orderings.</span>より弱い原子の順序を使い始めると、これは成立しません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The relative developer-friendliness of sequential consistency doesn&#39;t come for free.</span>相対的な一貫性のある開発者の利便性は無料ではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Even on strongly-ordered platforms sequential consistency involves emitting memory fences.</span>強く秩序のあるプラットフォームでさえ、逐次整合性はメモリフェンスを放出することを含む。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In practice, sequential consistency is rarely necessary for program correctness.</span>実際には、プログラムの正確さのために逐次整合性はほとんど必要ありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However sequential consistency is definitely the right choice if you&#39;re not confident about the other memory orders.</span>しかし、他のメモリオーダーについて確信が持てない場合は、逐次整合性が正しい選択です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Having your program run a bit slower than it needs to is certainly better than it running incorrectly!</span>あなたのプログラムは、それが間違って実行されているよりも確かに優れている必要があるよりも少し遅く実行すること！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It&#39;s also mechanically trivial to downgrade atomic operations to have a weaker consistency later on.</span>後で弱い整合性を持つように原子操作をダウングレードすることも機械的には些細なことです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Just change <code>SeqCst</code> to <code>Relaxed</code> and you&#39;re done!</span> <code>SeqCst</code>を<code>Relaxed</code>変更するだけで完了です！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Of course, proving that this transformation is <i>correct</i> is a whole other matter.</span>もちろん、この変換が<i>正しい</i>ことを証明することは、まったく別の問題です。</span> </p><br><br><br><br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Acquire-Release</span>取得 - リリース</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Acquire and Release are largely intended to be paired.</span> AcquireとReleaseは主にペアになるように意図されています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Their names hint at their use case: they&#39;re perfectly suited for acquiring and releasing locks, and ensuring that critical sections don&#39;t overlap.</span>彼らの名前はユースケースを暗示しています。ロックの取得と解放、クリティカルセクションの重複を避けることができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Intuitively, an acquire access ensures that every access after it stays after it.</span>直感的には、アクセスアクセスは、それ以降のすべてのアクセスが確実に維持されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However operations that occur before an acquire are free to be reordered to occur after it.</span>しかし、買収前に発生した事業は、買収後に再注文することが自由である。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Similarly, a release access ensures that every access before it stays before it.</span>同様に、リリースアクセスは、それがその前に存在する前にすべてのアクセスが確実に行われるようにします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However operations that occur after a release are free to be reordered to occur before it.</span>しかし、リリース後に発生する操作は、その前に発生するように自由に並べ替えることができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When thread A releases a location in memory and then thread B subsequently acquires <i>the same</i> location in memory, causality is established.</span>スレッドAがメモリ内の場所を解放し、次にスレッドBがメモリ内<i>の同じ</i>場所を取得<i>すると</i> 、因果関係が確立されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Every write that happened before A&#39;s release will be observed by B after its acquisition.</span> Aのリリース前に起こったすべての書き込みは、Bの取得後に観察されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However no causality is established with any other threads.</span>しかし、他のスレッドとの因果関係は確立されていません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Similarly, no causality is established if A and B access <i>different</i> locations in memory.</span>同様に、AとBがメモリ内の<i>異なる</i>場所にアクセスすると、因果関係は確立されません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Basic use of release-acquire is therefore simple: you acquire a location of memory to begin the critical section, and then release that location to end it.</span>したがって、release-acquireの基本的な使用は簡単です。クリティカルセクションを開始するメモリの場所を取得し、その場所を解放して終了します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For instance, a simple spinlock might look like:</span>たとえば、単純なスピンロックは次のようになります。</span> </p><br><div data-lang=rust><div data-l="use std::sync::Arc;"></div><div data-l="use std::sync::atomic::{AtomicBool, Ordering};"></div><div data-l="use std::thread;"></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="#//    let lock = Arc::new(AtomicBool::new(false)); // value answers &quot;am I locked?&quot;"></div><div data-l="    let lock = Arc::new(AtomicBool::new(false)); // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">value answers &quot;am I locked?&quot;</span>価値のある答え &quot;私はロックされていますか？&quot;</span> </div><div data-l=""></div><div data-l="#    // ... distribute lock to threads somehow ..."></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">... distribute lock to threads somehow ...</span>何とかロックをスレッドに配布しています...</span> </div><div data-l=""></div><div data-l="#    // Try to acquire the lock by setting it to true"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Try to acquire the lock by setting it to true</span>それをtrueに設定してロックを獲得しようとする</span> </div><div data-l="    while lock.compare_and_swap(false, true, Ordering::Acquire) { }"></div><div data-l="#    // broke out of the loop, so we successfully acquired the lock!"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">broke out of the loop, so we successfully acquired the lock!</span>ループから勃発したので、我々はロックを成功裏に獲得しました！</span> </div><div data-l=""></div><div data-l="#    // ... scary data accesses ..."></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">... scary data accesses ...</span> ...怖いデータへのアクセス...</span> </div><div data-l=""></div><div data-l="#    // ok we're done, release the lock"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">ok we&#39;re done, release the lock</span>私たちはやったよ、ロックを解除する</span> </div><div data-l="    lock.store(false, Ordering::Release);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">On strongly-ordered platforms most accesses have release or acquire semantics, making release and acquire often totally free.</span>強く秩序立ったプラットフォームでは、ほとんどのアクセスが解放または獲得のセマンティクスを持ち、リリースと獲得を完全に無料にすることがあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is not the case on weakly-ordered platforms.</span>弱順のプラットフォームではそうではありません。</span> </p><br><br><br><br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Relaxed</span>リラックス</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Relaxed accesses are the absolute weakest.</span>リラックスしたアクセスは絶対的に弱いです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">They can be freely re-ordered and provide no happens-before relationship.</span>彼らは自由に並べ替えることができ、起こることのない関係を提供することはできません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Still, relaxed operations are still atomic.</span>それでも、リラックスした操作はまだアトミックです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That is, they don&#39;t count as data accesses and any read-modify-write operations done to them occur atomically.</span>つまり、データアクセスとしてカウントされず、リード - モディファイ - ライト操作が原子的に発生します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Relaxed operations are appropriate for things that you definitely want to happen, but don&#39;t particularly otherwise care about.</span>リラックスした操作は、確実に起こりたいことに適していますが、特に気にすることはありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For instance, incrementing a counter can be safely done by multiple threads using a relaxed <code>fetch_add</code> if you&#39;re not using the counter to synchronize any other accesses.</span>たとえば、他のアクセスを同期させるためにカウンタを使用していない場合は、緩やかな<code>fetch_add</code>を使用して複数のスレッドによってカウンタをインクリメントすることができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There&#39;s rarely a benefit in making an operation relaxed on strongly-ordered platforms, since they usually provide release-acquire semantics anyway.</span>とにかくリリース取得のセマンティクスを提供するため、強く発注されたプラットフォームで操作を緩和することはめったにありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However relaxed operations can be cheaper on weakly-ordered platforms.</span>しかし、リラックスした操作は弱い順序のプラットフォームでは安くなる可能性があります。</span> </p><br><br><br><br><br> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a class=notranslate href=#1http://plv.mpi-sws.org/c11comp/popl15.pdf>C11-busted</a> <a class=notranslate href=#1http://www.open-std.org/jtc1/sc22/wg14/www/standards.html#9899>C11-model</a></span> <a class=notranslate href=#1http://plv.mpi-sws.org/c11comp/popl15.pdf>C11-busted</a> <a class=notranslate href=#1http://www.open-std.org/jtc1/sc22/wg14/www/standards.html#9899>C11-model</a></span><script>_addload(function(){_setupIW('com');_csi('en','ja','atomics.html');});</script>