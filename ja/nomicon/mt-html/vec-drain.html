<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180723_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=vec-drain.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Drain</span>ドレイン</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s move on to Drain.</span>ドレインに移動しましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Drain is largely the same as IntoIter, except that instead of consuming the Vec, it borrows the Vec and leaves its allocation untouched.</span>ドレインは、Vecを消費するのではなく、Vecを借りてその割り当てを変更しないという点を除いて、IntoIterとほぼ同じです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For now we&#39;ll only implement the &quot;basic&quot; full-range version.</span>今のところ、 &quot;基本的な&quot;フルレンジバージョンだけを実装します。</span> </p><br><div data-lang=rust,ignore><div data-l="use std::marker::PhantomData;"></div><div data-l=""></div><div data-l="struct Drain&lt;'a, T: 'a&gt; {"></div><div data-l="#    // Need to bound the lifetime here, so we do it with `&amp;'a mut Vec&lt;T&gt;`"></div><div data-l="#    // because that's semantically what we contain. We're &quot;just&quot; calling"></div><div data-l="#    // `pop()` and `remove(0)`."></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Need to bound the lifetime here, so we do it with <code>&amp;&#39;a mut Vec&lt;T&gt;</code> because that&#39;s semantically what we contain.</span>生涯をここに<code>&amp;&#39;a mut Vec&lt;T&gt;</code>必要があるので、それは意味的に私たちが含んでいるので、 <code>&amp;&#39;a mut Vec&lt;T&gt;</code>行います。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;re &quot;just&quot; calling <code>pop()</code> and <code>remove(0)</code> .</span>私たちは<code>pop()</code>と<code>remove(0)</code>呼び出すだけです。</span> </div><div data-l="    vec: PhantomData&lt;&amp;'a mut Vec&lt;T&gt;&gt;,"></div><div data-l="    start: *const T,"></div><div data-l="    end: *const T,"></div><div data-l=}></div><div data-l=""></div><div data-l="impl&lt;'a, T&gt; Iterator for Drain&lt;'a, T&gt; {"></div><div data-l="    type Item = T;"></div><div data-l="    fn next(&amp;mut self) -&gt; Option&lt;T&gt; {"></div><div data-l="        if self.start == self.end {"></div><div data-l="            None"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">-- wait, this is seeming familiar.</span> - 待って、これはおなじみのようです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s do some more compression.</span>もう少し圧縮してみましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Both IntoIter and Drain have the exact same structure, let&#39;s just factor it out.</span> IntoIterとDrainは全く同じ構造をしています。</span> </p><br><div data-lang=rust><div data-l="struct RawValIter&lt;T&gt; {"></div><div data-l="    start: *const T,"></div><div data-l="    end: *const T,"></div><div data-l=}></div><div data-l=""></div><div data-l="impl&lt;T&gt; RawValIter&lt;T&gt; {"></div><div data-l="#    // unsafe to construct because it has no associated lifetimes."></div><div data-l="#    // This is necessary to store a RawValIter in the same struct as"></div><div data-l="#    // its actual allocation. OK since it's a private implementation"></div><div data-l="#    // detail."></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">unsafe to construct because it has no associated lifetimes.</span>関連する生存期間がないため構築が安全ではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is necessary to store a RawValIter in the same struct as its actual allocation.</span>これはRawValIterを実際の割り当てと同じ構造体に格納するために必要です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">OK since it&#39;s a private implementation detail.</span>それは私的な実装の詳細なのでOKです。</span> </div><div data-l="    unsafe fn new(slice: &amp;[T]) -&gt; Self {"></div><div data-l="        RawValIter {"></div><div data-l="            start: slice.as_ptr(),"></div><div data-l="            end: if slice.len() == 0 {"></div><div data-l="#                // if `len = 0`, then this is not actually allocated memory."></div><div data-l="#                // Need to avoid offsetting because that will give wrong"></div><div data-l="#                // information to LLVM via GEP."></div><div data-l="                // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">if <code>len = 0</code> , then this is not actually allocated memory.</span> <code>len = 0</code>場合、これは実際に割り当てられたメモリではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Need to avoid offsetting because that will give wrong information to LLVM via GEP.</span> GEPを介してLLVMに間違った情報を与えるため、オフセットを避ける必要があります。</span> </div><div data-l="                slice.as_ptr()"></div><div data-l="            } else {"></div><div data-l="                slice.as_ptr().offset(slice.len() as isize)"></div><div data-l="            }"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="#// Iterator and DoubleEndedIterator impls identical to IntoIter."></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Iterator and DoubleEndedIterator impls identical to IntoIter.</span> IteratorとDoubleEndedIteratorはIntoIterと同じです。</span> </div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">And IntoIter becomes the following:</span> IntoIterは次のようになります。</span> </p><br><div data-lang=rust,ignore><div data-l="pub struct IntoIter&lt;T&gt; {"></div><div data-l="#//    _buf: RawVec&lt;T&gt;, // we don't actually care about this. Just need it to live."></div><div data-l="    _buf: RawVec&lt;T&gt;, // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">we don&#39;t actually care about this.</span>私たちは実際にこれに気をつけません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Just need it to live.</span>ただそれが生きるために必要です。</span> </div><div data-l="    iter: RawValIter&lt;T&gt;,"></div><div data-l=}></div><div data-l=""></div><div data-l="impl&lt;T&gt; Iterator for IntoIter&lt;T&gt; {"></div><div data-l="    type Item = T;"></div><div data-l="    fn next(&amp;mut self) -&gt; Option&lt;T&gt; { self.iter.next() }"></div><div data-l="    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) { self.iter.size_hint() }"></div><div data-l=}></div><div data-l=""></div><div data-l="impl&lt;T&gt; DoubleEndedIterator for IntoIter&lt;T&gt; {"></div><div data-l="    fn next_back(&amp;mut self) -&gt; Option&lt;T&gt; { self.iter.next_back() }"></div><div data-l=}></div><div data-l=""></div><div data-l="impl&lt;T&gt; Drop for IntoIter&lt;T&gt; {"></div><div data-l="    fn drop(&amp;mut self) {"></div><div data-l="        for _ in &amp;mut self.iter {}"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="impl&lt;T&gt; Vec&lt;T&gt; {"></div><div data-l="    pub fn into_iter(self) -&gt; IntoIter&lt;T&gt; {"></div><div data-l="        unsafe {"></div><div data-l="            let iter = RawValIter::new(&amp;self);"></div><div data-l=""></div><div data-l="            let buf = ptr::read(&amp;self.buf);"></div><div data-l="            mem::forget(self);"></div><div data-l=""></div><div data-l="            IntoIter {"></div><div data-l="                iter: iter,"></div><div data-l="                _buf: buf,"></div><div data-l="            }"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that I&#39;ve left a few quirks in this design to make upgrading Drain to work with arbitrary subranges a bit easier.</span>この設計では、ドレインをアップグレードして、任意の部分範囲を少し簡単に扱えるようにするため、いくつかの欠点を残しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In particular we <i>could</i> have RawValIter drain itself on drop, but that won&#39;t work right for a more complex Drain.</span>特にRawValIterのドレイン自体をドロップする<i>こと</i>は<i>でき</i>ますが、それはもっと複雑なドレインの場合は正しく機能しません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We also take a slice to simplify Drain initialization.</span>ドレインの初期化を簡素化するためにスライスも使用します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Alright, now Drain is really easy:</span>さて、今すぐ排水は簡単です：</span> </p><br><div data-lang=rust,ignore><div data-l="use std::marker::PhantomData;"></div><div data-l=""></div><div data-l="pub struct Drain&lt;'a, T: 'a&gt; {"></div><div data-l="    vec: PhantomData&lt;&amp;'a mut Vec&lt;T&gt;&gt;,"></div><div data-l="    iter: RawValIter&lt;T&gt;,"></div><div data-l=}></div><div data-l=""></div><div data-l="impl&lt;'a, T&gt; Iterator for Drain&lt;'a, T&gt; {"></div><div data-l="    type Item = T;"></div><div data-l="    fn next(&amp;mut self) -&gt; Option&lt;T&gt; { self.iter.next() }"></div><div data-l="    fn size_hint(&amp;self) -&gt; (usize, Option&lt;usize&gt;) { self.iter.size_hint() }"></div><div data-l=}></div><div data-l=""></div><div data-l="impl&lt;'a, T&gt; DoubleEndedIterator for Drain&lt;'a, T&gt; {"></div><div data-l="    fn next_back(&amp;mut self) -&gt; Option&lt;T&gt; { self.iter.next_back() }"></div><div data-l=}></div><div data-l=""></div><div data-l="impl&lt;'a, T&gt; Drop for Drain&lt;'a, T&gt; {"></div><div data-l="    fn drop(&amp;mut self) {"></div><div data-l="        for _ in &amp;mut self.iter {}"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="impl&lt;T&gt; Vec&lt;T&gt; {"></div><div data-l="    pub fn drain(&amp;mut self) -&gt; Drain&lt;T&gt; {"></div><div data-l="        unsafe {"></div><div data-l="            let iter = RawValIter::new(&amp;self);"></div><div data-l=""></div><div data-l="#            // this is a mem::forget safety thing. If Drain is forgotten, we just"></div><div data-l="#            // leak the whole Vec's contents. Also we need to do this *eventually*"></div><div data-l="#            // anyway, so why not do it now?"></div><div data-l="            // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">this is a mem::forget safety thing.</span>これはmem :: safe thingを忘れる。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If Drain is forgotten, we just leak the whole Vec&#39;s contents.</span> Drainを忘れた場合、Vecの内容全体が漏れてしまいます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Also we need to do this <i>eventually</i> anyway, so why not do it now?</span>また、 <i>最終的</i>にはこれをやる必要があるので、今はどうしたらいいですか？</span> </div><div data-l="            self.len = 0;"></div><div data-l=""></div><div data-l="            Drain {"></div><div data-l="                iter: iter,"></div><div data-l="                vec: PhantomData,"></div><div data-l="            }"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For more details on the <code>mem::forget</code> problem, see the <a href=#3leaks>section on leaks</a> .</span> <code>mem::forget</code>問題の詳細については<a href=#3leaks>、リーク</a>の<a href=#3leaks>セクションを</a>参照してください。</span> </p><br> <a class=notranslate href=#1leaking.html>leaks</a><script>_addload(function(){_setupIW('com');_csi('en','ja','vec-drain.html');});</script>