<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180723_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=other-reprs.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Alternative representations</span>代替表現</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust allows you to specify alternative data layout strategies from the default.</span> Rustでは、デフォルトから代替データレイアウト戦略を指定できます。</span> </p><br><br><br><br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">repr(C)</span> repr（C）</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is the most important <code>repr</code> .</span>これが最も重要である<code>repr</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It has fairly simple intent: do what C does.</span>それはかなり単純な意図を持っています：Cがすることをします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The order, size, and alignment of fields is exactly what you would expect from C or C++.</span>フィールドの順序、サイズ、および配置は、CまたはC ++から期待されるものとまったく同じです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Any type you expect to pass through an FFI boundary should have <code>repr(C)</code> , as C is the lingua-franca of the programming world.</span> FFI境界を通過すると予想されるすべてのタイプは、Cがプログラミング世界の言語独語であるため、 <code>repr(C)</code>持つ必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is also necessary to soundly do more elaborate tricks with data layout such as reinterpreting values as a different type.</span>これは、値を別のタイプとして再解釈するなど、データレイアウトでもっと精巧なやり方をするためにも必要です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, the interaction with Rust&#39;s more exotic data layout features must be kept in mind.</span>しかし、Rustのよりエキゾチックなデータレイアウト機能との相互作用を念頭に置く必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Due to its dual purpose as &quot;for FFI&quot; and &quot;for layout control&quot;, <code>repr(C)</code> can be applied to types that will be nonsensical or problematic if passed through the FFI boundary.</span> &quot;FFI&quot;と &quot;レイアウト制御&quot;の2つの目的のために、 <code>repr(C)</code>は、FFI境界を通過すると無意味な、または問題のある型に適用できます。</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">ZSTs are still zero-sized, even though this is not a standard behavior in</span>これは標準的な動作ではありませんが、ZSTはまだゼロサイズです。</span> </div><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">C, and is explicitly contrary to the behavior of an empty type in C++, which still consumes a byte of space.</span> Cであり、C ++の空の型の動作に明示的に反しています。これはまだ1バイトの空き領域を消費します。</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">DST pointers (fat pointers), tuples, and enums with fields are not a concept in C, and as such are never FFI-safe.</span>フィールドを持つDSTポインタ（タイルポインタ）、タプル、および列挙型はCの概念ではないため、決してFFIセーフではありません。</span> </div><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If <code>T</code> is an <a href=#2ffi.html#the-nullable-pointer-optimization>FFI-safe non-nullable pointer type</a> , <code>Option&lt;T&gt;</code> is guaranteed to have the same layout and ABI as <code>T</code> and is therefore also FFI-safe.</span> <code>T</code>が<a href=#2ffi.html#the-nullable-pointer-optimization>FFIで安全な非null型ポインタ型である</a>場合、 <code>Option&lt;T&gt;</code>は<code>T</code>と同じレイアウトとABIを持つことが保証され、したがってFFIセーフでもあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As of this writing, this covers <code>&amp;</code> , <code>&amp;mut</code> , and function pointers, all of which can never be null.</span>この記事の執筆時点では、これは<code>&amp;</code> 、 <code>&amp;mut</code> 、および関数ポインタを対象としています。</span> </div><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Tuple structs are like structs with regards to <code>repr(C)</code> , as the only difference from a struct is that the fields aren&#39;t named.</span>構造体との唯一の違いは、フィールドの名前が付けられていないということであるから、Tuple構造体は<code>repr(C)</code>に関するstructと似ています。</span> </div><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is equivalent to one of <code>repr(u*)</code> (see the next section) for enums.</span>これはenumの<code>repr(u*)</code> （次のセクションを参照<code>repr(u*)</code> 1つに相当します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The</span>ザ</span> </div><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">chosen size is the default enum size for the target platform&#39;s C application binary interface (ABI).</span>選択されたサイズは、ターゲットプラットフォームのCアプリケーションバイナリインタフェース（ABI）のデフォルトの列挙型サイズです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that enum representation in C is implementation defined, so this is really a &quot;best guess&quot;.</span> Cの列挙表現は実装定義であることに注意してください。これは実際には「最良の推測」です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In particular, this may be incorrect when the C code of interest is compiled with certain flags.</span>特に、関心のあるCコードが特定のフラグでコンパイルされていると、これは正しくない可能性があります。</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Field-less enums with <code>repr(C)</code> or <code>repr(u*)</code> still may not be set to an</span> <code>repr(C)</code>または<code>repr(u*)</code>持つフィールドレスのenumは、まだ</span> </div><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">integer value without a corresponding variant, even though this is permitted behavior in C or C++.</span>たとえこれがCまたはC ++で許可された動作であっても、対応するバリアントのない整数値です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It is undefined behavior to (unsafely) construct an instance of an enum that does not match one of its variants.</span>そのバリエーションの1つと一致しないenumのインスタンスを（不安全に）構築するのは未定義の動作です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">(This allows exhaustive matches to continue to be written and compiled as normal.)</span> （これにより、徹底的なマッチが引き続き作成され、通常通りコンパイルされます。）</span> </p><br><br><br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">repr(u <i>), repr(i</i> )</span> repr（u <i>）、repr（i</i> ）</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These specify the size to make a field-less enum.</span>これらは、フィールドレスの列挙型を作成するためのサイズを指定します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If the discriminant overflows the integer it has to fit in, it will produce a compile-time error.</span>判別式が整数にオーバーフローした場合、それは適合する必要があります。コンパイル時にエラーが発生します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can manually ask Rust to allow this by setting the overflowing element to explicitly be 0. However Rust will not allow you to create an enum where two variants have the same discriminant.</span>オーバーフローする要素を明示的に0に設定することで、Rustに手動で問い合わせることができます。ただし、Rustでは、2つのバリアントが同じ判別式を持つ列挙型を作成することはできません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The term &quot;field-less enum&quot; only means that the enum doesn&#39;t have data in any of its variants.</span> 「フィールドレスの列挙型」という用語は、その列挙型がそのバリ​​アントのいずれにもデータを持たないことを意味します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A field-less enum without a <code>repr(u*)</code> or <code>repr(C)</code> is still a Rust native type, and does not have a stable ABI representation.</span> <code>repr(u*)</code>または<code>repr(C)</code>ないフィールドレスの列挙型は、まだRustのネイティブ型であり、安定したABI表現を持っていません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Adding a <code>repr</code> causes it to be treated exactly like the specified integer size for ABI purposes.</span> <code>repr</code>を追加すると、ABIの目的で指定された整数サイズとまったく同じように扱われます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Any enum with fields is a Rust type with no guaranteed ABI (even if the only data is <code>PhantomData</code> or something else with zero size).</span>フィールドを持つ列挙型は、（たとえ唯一のデータが<code>PhantomData</code>か、サイズがゼロのものであっても）ABIを保証しないRust型です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Adding an explicit <code>repr</code> to an enum suppresses the null-pointer optimization.</span> enumに明示的な<code>repr</code>を追加すると、NULLポインタの最適化が抑制されます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These reprs have no effect on a struct.</span>これらのreprsは構造体に影響を与えません。</span> </p><br><br><br><br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">repr(packed)</span> repr（パック）</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>repr(packed)</code> forces Rust to strip any padding, and only align the type to a byte.</span> <code>repr(packed)</code>は、Rustにパディングを取り除き、その型を1バイトに整列させるだけです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This may improve the memory footprint, but will likely have other negative side-effects.</span>これは、メモリフットプリントを改善する可能性がありますが、おそらく他の負の副作用があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In particular, most architectures <i>strongly</i> prefer values to be aligned.</span>特に、ほとんどのアーキテクチャで<i>は</i> 、値を並べることを<i>強く</i>推奨しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This may mean the unaligned loads are penalized (x86), or even fault (some ARM chips).</span>これは、アライメントされていない負荷がペナルティ（x86）、または障害（ARMチップの一部）さえある可能性があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For simple cases like directly loading or storing a packed field, the compiler might be able to paper over alignment issues with shifts and masks.</span>パックされたフィールドを直接ロードまたは格納するような単純なケースでは、コンパイラはシフトとマスクのアライメントの問題を記録できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However if you take a reference to a packed field, it&#39;s unlikely that the compiler will be able to emit code to avoid an unaligned load.</span>しかし、パックされたフィールドへの参照を取ると、コンパイル時に非境界整列のロードを回避するためのコードを生成することはできません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><b>[As of Rust 1.0 this can cause undefined behavior.][ub loads]</b></span> <b>[Rust 1.0以降、これは未定義の動作を引き起こす可能性があります。] [ub loads]</b></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>repr(packed)</code> is not to be used lightly.</span> <code>repr(packed)</code>は軽く使用しないでください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Unless you have extreme requirements, this should not be used.</span>極端な要件がない限り、これは使用すべきではありません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This repr is a modifier on <code>repr(C)</code> and <code>repr(rust)</code> .</span>このreprは<code>repr(C)</code>と<code>repr(rust)</code>修飾語です。</span> </p><br> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a class=notranslate href=#1drop-flags.html>drop flags</a> <a class=notranslate href=#1https://github.com/rust-lang/rust/issues/27060>ub loads</a></span> <a class=notranslate href=#1drop-flags.html>drop flags</a> <a class=notranslate href=#1https://github.com/rust-lang/rust/issues/27060>ub loads</a></span><script>_addload(function(){_setupIW('com');_csi('en','ja','other-reprs.html');});</script>