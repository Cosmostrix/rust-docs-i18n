<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180723_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=exception-safety.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Exception Safety</span>例外の安全性</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Although programs should use unwinding sparingly, there&#39;s a lot of code that <i>can</i> panic.</span>プログラムでは巻き戻しを控えめに使用する必要があります<i>が、</i>パニックになるコードがたくさんあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you unwrap a None, index out of bounds, or divide by 0, your program will panic.</span> None、unwindを範囲外にするか、0で割ると、プログラムはパニックに陥ります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">On debug builds, every arithmetic operation can panic if it overflows.</span>デバッグビルドでは、すべての算術演算がオーバーフローするとパニックに陥ることがあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Unless you are very careful and tightly control what code runs, pretty much everything can unwind, and you need to be ready for it.</span>コードが実行されていることを非常に慎重に厳密に制御している場合を除き、ほとんどすべてが元に戻ることができ、準備が必要です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Being ready for unwinding is often referred to as <i>exception safety</i> in the broader programming world.</span>巻き戻しの準備が整っていることは、広範なプログラミングの世界で<i>例外安全性</i>と呼ばれることがよくあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In Rust, there are two levels of exception safety that one may concern themselves with:</span> Rustには、次の2つのレベルの例外安全性があります。</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In unsafe code, we <i>must</i> be exception safe to the point of not violating memory safety.</span>安全でないコードでは、メモリの安全性に違反しない点で例外セーフで<i>なければ</i>なりません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll call this <i>minimal</i> exception safety.</span>この<i>最小の</i>例外安全性と呼ぶことにします。</span> </div><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In safe code, it is <i>good</i> to be exception safe to the point of your program doing the right thing.</span>安全なコードでは、あなたのプログラムが正しいことを行う点で例外的な安全性があることは<i>良い</i>ことです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll call this <i>maximal</i> exception safety.</span>この<i>最大の</i>例外安全性と呼ぶことにします。</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As is the case in many places in Rust, Unsafe code must be ready to deal with bad Safe code when it comes to unwinding.</span> Rustの多くの場所でそうであるように、安全でないコードは、巻き戻しに関して悪いセーフコードを処理する準備ができている必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Code that transiently creates unsound states must be careful that a panic does not cause that state to be used.</span>一時的に不健全な状態を生成するコードは、パニックによってその状態が使用されないように注意する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Generally this means ensuring that only non-panicking code is run while these states exist, or making a guard that cleans up the state in the case of a panic.</span>一般的に、これは、これらの状態が存在する間、パニックでないコードだけが実行されることを保証すること、またはパニックの場合に状態をクリーンアップするガードを行うことを意味する。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This does not necessarily mean that the state a panic witnesses is a fully coherent state.</span>これは必ずしもパニックの証人が完全に一貫した状態であることを意味するものではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We need only guarantee that it&#39;s a <i>safe</i> state.</span> <i>安全な</i>状態であることを保証する必要があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Most Unsafe code is leaf-like, and therefore fairly easy to make exception-safe.</span>ほとんどの安全でないコードは葉のようなものなので、例外的に安全にするのはかなり簡単です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It controls all the code that runs, and most of that code can&#39;t panic.</span>実行されるすべてのコードを制御し、そのコードのほとんどはパニックに陥ることはありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However it is not uncommon for Unsafe code to work with arrays of temporarily uninitialized data while repeatedly invoking caller-provided code.</span>しかし、Unsafeコードが一時的に初期化されていないデータの配列で動作し、呼び出し元提供のコードを繰り返し呼び出すことは珍しいことではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Such code needs to be careful and consider exception safety.</span>そのようなコードは注意深く、例外安全性を考慮する必要があります。</span> </p><br><br><br><br><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Vec::push_all</span> Vec :: push_all</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>Vec::push_all</code> is a temporary hack to get extending a Vec by a slice reliably efficient without specialization.</span> <code>Vec::push_all</code>は、専門化せずにVecを確実に効率的に拡張するための一時的なハックです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here&#39;s a simple implementation:</span>ここに簡単な実装があります：</span> </p><br><div data-lang=rust,ignore><div data-l="impl&lt;T: Clone&gt; Vec&lt;T&gt; {"></div><div data-l="    fn push_all(&amp;mut self, to_push: &amp;[T]) {"></div><div data-l="        self.reserve(to_push.len());"></div><div data-l="        unsafe {"></div><div data-l="#            // can't overflow because we just reserved this"></div><div data-l="            // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">can&#39;t overflow because we just reserved this</span>我々はこれを予約しているのでオーバーフローすることはできません</span> </div><div data-l="            self.set_len(self.len() + to_push.len());"></div><div data-l=""></div><div data-l="            for (i, x) in to_push.iter().enumerate() {"></div><div data-l="                self.ptr().offset(i as isize).write(x.clone());"></div><div data-l="            }"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We bypass <code>push</code> in order to avoid redundant capacity and <code>len</code> checks on the Vec that we definitely know has capacity.</span>冗長容量を避けるために<code>push</code>をバイパスし、容量があることがわかっているVecの<code>len</code>チェックを行います。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The logic is totally correct, except there&#39;s a subtle problem with our code: it&#39;s not exception-safe!</span>ロジックは完全に正しいですが、例外的に安全ではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>set_len</code> , <code>offset</code> , and <code>write</code> are all fine;</span> <code>set_len</code> 、 <code>offset</code> 、 <code>write</code>はすべて問題ありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>clone</code> is the panic bomb we over-looked.</span> <code>clone</code>は私たちが見たパニック爆弾です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Clone is completely out of our control, and is totally free to panic.</span>クローンは完全に私たちのコントロールから外れており、完全にパニックになることはありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If it does, our function will exit early with the length of the Vec set too large.</span>そうであれば、Vecの長さを長くしすぎると機能が早期に終了します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If the Vec is looked at or dropped, uninitialized memory will be read!</span> Vecを見たりドロップしたりすると、初期化されていないメモリが読み込まれます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The fix in this case is fairly simple.</span>この場合の修正はかなり簡単です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we want to guarantee that the values we <i>did</i> clone are dropped, we can set the <code>len</code> every loop iteration.</span>我々はクローンをし<i>た</i>値がドロップされることを保証したい場合、我々は設定でき<code>len</code>すべてのループの繰り返しを。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we just want to guarantee that uninitialized memory can&#39;t be observed, we can set the <code>len</code> after the loop.</span>初期化されていないメモリを確認できないようにしたい場合は、ループの後に<code>len</code>を設定することができます。</span> </p><br><br><br><br><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">BinaryHeap::sift_up</span> BinaryHeap :: sift_up</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Bubbling an element up a heap is a bit more complicated than extending a Vec.</span>ヒープの要素をバブリングするのは、Vecを拡張するよりも少し複雑です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The pseudocode is as follows:</span>擬似コードは次のとおりです。</span> </p><br><div data-lang=text><div data-l="bubble_up(heap, index):"></div><div data-l="    while index != 0 &amp;&amp; heap[index] &lt; heap[parent(index)]:"></div><div data-l="        heap.swap(index, parent(index))"></div><div data-l="        index = parent(index)"></div><div data-l=""></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A literal transcription of this code to Rust is totally fine, but has an annoying performance characteristic: the <code>self</code> element is swapped over and over again uselessly.</span> Rustへのこのコードの文字通りの転写はまったく問題ありませんが、厄介なパフォーマンス特性があります。 <code>self</code>要素は無駄に何度も何度も入れ替えられています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We would rather have the following:</span>私たちはむしろ以下を持っています：</span> </p><br><div data-lang=text><div data-l="bubble_up(heap, index):"></div><div data-l="    let elem = heap[index]"></div><div data-l="    while index != 0 &amp;&amp; elem &lt; heap[parent(index)]:"></div><div data-l="        heap[index] = heap[parent(index)]"></div><div data-l="        index = parent(index)"></div><div data-l="    heap[index] = elem"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This code ensures that each element is copied as little as possible (it is in fact necessary that elem be copied twice in general).</span>このコードは、各要素ができるだけコピーされないようにします（実際には、elemを一般に2回コピーする必要があります）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However it now exposes some exception safety trouble!</span>しかし、今ではいくつかの例外的な安全上の問題があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">At all times, there exists two copies of one value.</span>いつでも、1つの価値の2つのコピーが存在します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we panic in this function something will be double-dropped.</span>この関数でパニックになると、何かが二重に落とされます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Unfortunately, we also don&#39;t have full control of the code: that comparison is user-defined!</span>残念ながら、コードの完全な制御権もありません。その比較はユーザー定義です！</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Unlike Vec, the fix isn&#39;t as easy here.</span> Vecとは異なり、ここでの修正は簡単ではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">One option is to break the user-defined code and the unsafe code into two separate phases:</span> 1つのオプションは、ユーザー定義コードと安全でないコードを2つの別々のフェーズに分割することです。</span> </p><br><div data-lang=text><div data-l="bubble_up(heap, index):"></div><div data-l="    let end_index = index;"></div><div data-l="    while end_index != 0 &amp;&amp; heap[end_index] &lt; heap[parent(end_index)]:"></div><div data-l="        end_index = parent(end_index)"></div><div data-l=""></div><div data-l="    let elem = heap[index]"></div><div data-l="    while index != end_index:"></div><div data-l="        heap[index] = heap[parent(index)]"></div><div data-l="        index = parent(index)"></div><div data-l="    heap[index] = elem"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If the user-defined code blows up, that&#39;s no problem anymore, because we haven&#39;t actually touched the state of the heap yet.</span>ユーザー定義コードが爆発した場合、実際にヒープの状態にまだ触れていないので、これはもう問題ありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Once we do start messing with the heap, we&#39;re working with only data and functions that we trust, so there&#39;s no concern of panics.</span>ヒープを使い始めると、私たちが信頼するデータと関数だけで作業しているので、パニックが起こる心配はありません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Perhaps you&#39;re not happy with this design.</span>おそらくあなたはこのデザインに満足していないでしょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Surely it&#39;s cheating!</span>確かにそれは浮気です！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">And we have to do the complex heap traversal <i>twice</i> !</span>複雑なヒープトラバーサルを<i>2回</i>実行する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Alright, let&#39;s bite the bullet.</span>さて、弾を噛んでみましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s intermix untrusted and unsafe code <i>for reals</i> .</span> <i>本当のために</i>信頼できないコードと安全でないコード<i>を</i>混ぜ合わせてみましょう。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If Rust had <code>try</code> and <code>finally</code> like in Java, we could do the following:</span>錆があったら<code>try</code>と<code>finally</code> 、Javaのように、私たちは次のことを行うことができます：</span> </p><br><div data-lang=text><div data-l="bubble_up(heap, index):"></div><div data-l="    let elem = heap[index]"></div><div data-l="    try:"></div><div data-l="        while index != 0 &amp;&amp; elem &lt; heap[parent(index)]:"></div><div data-l="            heap[index] = heap[parent(index)]"></div><div data-l="            index = parent(index)"></div><div data-l="    finally:"></div><div data-l="        heap[index] = elem"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The basic idea is simple: if the comparison panics, we just toss the loose element in the logically uninitialized index and bail out.</span>基本的な考え方は単純です：比較がパニックの場合、論理的に初期化されていないインデックスに緩い要素を投げつけて救済します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Anyone who observes the heap will see a potentially <i>inconsistent</i> heap, but at least it won&#39;t cause any double-drops!</span>ヒープを観察する人は、ヒープが<i>矛盾</i>する可能<i>性があり</i>ますが、少なくともダブルドロップは発生しません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If the algorithm terminates normally, then this operation happens to coincide precisely with the how we finish up regardless.</span>アルゴリズムが正常に終了した場合、この操作は、関係なく終了する方法と正確に一致します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Sadly, Rust has no such construct, so we&#39;re going to need to roll our own!</span>悲しいことに、Rustはそのような構造を持っていないので、我々は自分自身をロールバックする必要があるでしょう！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The way to do this is to store the algorithm&#39;s state in a separate struct with a destructor for the &quot;finally&quot; logic.</span>これを行う方法は、 &quot;finally&quot;ロジックのデストラクタを使用してアルゴリズムの状態を別の構造体に格納することです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Whether we panic or not, that destructor will run and clean up after us.</span>私たちがパニックであろうとなかろうと、そのデストラクタは私たちの後を走り、きれいになるでしょう。</span> </p><br><div data-lang=rust,ignore><div data-l="struct Hole&lt;'a, T: 'a&gt; {"></div><div data-l="    data: &amp;'a mut [T],"></div><div data-l="#//    /// `elt` is always `Some` from new until drop."></div><div data-l="    /// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>elt</code> is always <code>Some</code> from new until drop.</span> <code>elt</code>は常に新しい<code>Some</code>から落とす<code>Some</code>まであります。</span> </div><div data-l="    elt: Option&lt;T&gt;,"></div><div data-l="    pos: usize,"></div><div data-l=}></div><div data-l=""></div><div data-l="impl&lt;'a, T&gt; Hole&lt;'a, T&gt; {"></div><div data-l="    fn new(data: &amp;'a mut [T], pos: usize) -&gt; Self {"></div><div data-l="        unsafe {"></div><div data-l="            let elt = ptr::read(&amp;data[pos]);"></div><div data-l="            Hole {"></div><div data-l="                data: data,"></div><div data-l="                elt: Some(elt),"></div><div data-l="                pos: pos,"></div><div data-l="            }"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=""></div><div data-l="    fn pos(&amp;self) -&gt; usize { self.pos }"></div><div data-l=""></div><div data-l="    fn removed(&amp;self) -&gt; &amp;T { self.elt.as_ref().unwrap() }"></div><div data-l=""></div><div data-l="    unsafe fn get(&amp;self, index: usize) -&gt; &amp;T { &amp;self.data[index] }"></div><div data-l=""></div><div data-l="    unsafe fn move_to(&amp;mut self, index: usize) {"></div><div data-l="        let index_ptr: *const _ = &amp;self.data[index];"></div><div data-l="        let hole_ptr = &amp;mut self.data[self.pos];"></div><div data-l="        ptr::copy_nonoverlapping(index_ptr, hole_ptr, 1);"></div><div data-l="        self.pos = index;"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="impl&lt;'a, T&gt; Drop for Hole&lt;'a, T&gt; {"></div><div data-l="    fn drop(&amp;mut self) {"></div><div data-l="#        // fill the hole again"></div><div data-l="        // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">fill the hole again</span>もう一度穴を埋める</span> </div><div data-l="        unsafe {"></div><div data-l="            let pos = self.pos;"></div><div data-l="            ptr::write(&amp;mut self.data[pos], self.elt.take().unwrap());"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="impl&lt;T: Ord&gt; BinaryHeap&lt;T&gt; {"></div><div data-l="    fn sift_up(&amp;mut self, pos: usize) {"></div><div data-l="        unsafe {"></div><div data-l="#            // Take out the value at `pos` and create a hole."></div><div data-l="            // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Take out the value at <code>pos</code> and create a hole.</span> <code>pos</code>の値を取り出して穴を作ります。</span> </div><div data-l="            let mut hole = Hole::new(&amp;mut self.data, pos);"></div><div data-l=""></div><div data-l="            while hole.pos() != 0 {"></div><div data-l="                let parent = parent(hole.pos());"></div><div data-l="                if hole.removed() &lt;= hole.get(parent) { break }"></div><div data-l="                hole.move_to(parent);"></div><div data-l="            }"></div><div data-l="#            // Hole will be unconditionally filled here; panic or not!"></div><div data-l="            // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Hole will be unconditionally filled here;</span>穴はここで無条件に塗りつぶされます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">panic or not!</span>パニックかどうか！</span> </div><div data-l="        }"></div><div data-l="    }"></div><div data-l=}></div></div><script>_addload(function(){_setupIW('com');_csi('en','ja','exception-safety.html');});</script>