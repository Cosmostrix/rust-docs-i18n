<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180723_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=aliasing.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Aliasing</span>エイリアス</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">First off, let&#39;s get some important caveats out of this way:</span>まず、このようにいくつかの重要な警告を出しましょう：</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We will be using the broadest possible definition of aliasing for the sake</span>私たちは、できるだけ広い範囲でエイリアシングの定義を使用します</span> </div><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">of discussion.</span>議論の</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust&#39;s definition will probably be more restricted to factor in mutations and liveness.</span> Rustの定義はおそらく、突然変異と生存率の因子に限定されるだろう。</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We will be assuming a single-threaded, interrupt-free, execution.</span>私たちは、シングルスレッド、割り込みのない実行を想定しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We will also</span>我々はまた、</span> </div><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">be ignoring things like memory-mapped hardware.</span>メモリマップされたハードウェアのようなものは無視してください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust assumes these things don&#39;t happen unless you tell it otherwise.</span> Rustは、あなたがそうでないと言っていない限り、これらのことは起こらないと仮定します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For more details, see the <a href=#2concurrency.html>Concurrency Chapter</a> .</span>詳細については、「 <a href=#2concurrency.html>同時実行性」の章を</a>参照してください。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">With that said, here&#39;s our working definition: variables and pointers <i>alias</i> if they refer to overlapping regions of memory.</span>それで、ここでは私たちの働く定義です：変数とポインタはメモリの重複領域を参照する場合は<i>別名</i>です。</span> </p><br><br><br><br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Why Aliasing Matters</span>なぜエイリアスが重要なのか</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So why should we care about aliasing?</span>だから、なぜエイリアスを気にする必要がありますか？</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Consider this simple function:</span>この単純な関数を考えてみましょう：</span> </p><br><div data-lang=rust><div data-l="fn compute(input: &amp;u32, output: &amp;mut u32) {"></div><div data-l="    if *input &gt; 10 {"></div><div data-l="        *output = 1;"></div><div data-l="    }"></div><div data-l="    if *input &gt; 5 {"></div><div data-l="        *output *= 2;"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We would <i>like</i> to be able to optimize it to the following function:</span>私たちは、次の関数にそれを最適化できるようにし<i>たい</i>と思います。</span> </p><br><div data-lang=rust><div data-l="fn compute(input: &amp;u32, output: &amp;mut u32) {"></div><div data-l="#//    let cached_input = *input; // keep *input in a register"></div><div data-l="    let cached_input = *input; // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">keep *input in a register</span> *入力をレジスタに保持する</span> </div><div data-l="    if cached_input &gt; 10 {"></div><div data-l="#//        *output = 2;  // x &gt; 10 implies x &gt; 5, so double and exit immediately"></div><div data-l="        *output = 2;  // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">x &gt; 10 implies x &gt; 5, so double and exit immediately</span> x&gt; 10はx&gt; 5を意味するので、二重にして直ちに終了する</span> </div><div data-l="    } else if cached_input &gt; 5 {"></div><div data-l="        *output *= 2;"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In Rust, this optimization should be sound.</span> Rustでは、この最適化は健全でなければなりません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For almost any other language, it wouldn&#39;t be (barring global analysis).</span>他のほとんどの言語については、（グローバルな分析を除いて）そうではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is because the optimization relies on knowing that aliasing doesn&#39;t occur, which most languages are fairly liberal with.</span>これは、最適化がエイリアシングが発生しないことを知ることに依存しているためです。ほとんどの言語はかなり自由です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Specifically, we need to worry about function arguments that make <code>input</code> and <code>output</code> overlap, such as <code>compute(&amp;x, &amp;mut x)</code> .</span>具体的には、 <code>compute(&amp;x, &amp;mut x)</code>ように、 <code>input</code>と<code>output</code>オーバーラップを行う関数の引数について心配する必要があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">With that input, we could get this execution:</span>その入力で、この実行を得ることができます：</span> </p><br><div data-lang=rust,ignore><div data-l="#                    //  input ==  output == 0xabad1dea"></div><div data-l="#                    // *input == *output == 20"></div><div data-l="                    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">input == output == 0xabad1dea <i>input ==</i> output == 20</span>入力==出力== 0xabad1の<i>入力==</i>出力== 20</span> </div><div data-l="#//if *input &gt; 10 {    // true  (*input == 20)"></div><div data-l="if *input &gt; 10 {    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">true (*input == 20)</span> true（* input == 20）</span> </div><div data-l="#//    *output = 1;    // also overwrites *input, because they are the same"></div><div data-l="    *output = 1;    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">also overwrites *input, because they are the same</span> *入力も上書きされます</span> </div><div data-l=}></div><div data-l="#//if *input &gt; 5 {     // false (*input == 1)"></div><div data-l="if *input &gt; 5 {     // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">false (*input == 1)</span> false（* input == 1）</span> </div><div data-l="    *output *= 2;"></div><div data-l=}></div><div data-l="#                    // *input == *output == 1"></div><div data-l="                    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><i>input ==</i> output == 1</span> <i>入力==</i>出力== 1</span> </div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Our optimized function would produce <code>*output == 2</code> for this input, so the correctness of our optimization relies on this input being impossible.</span>最適化された関数はこの入力に対して<code>*output == 2</code>を生成するので、最適化の正確さはこの入力が不可能であることに依存します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In Rust we know this input should be impossible because <code>&amp;mut</code> isn&#39;t allowed to be aliased.</span> Rustでは、 <code>&amp;mut</code>がエイリアス化されていないため、この入力は不可能であることがわかります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So we can safely reject its possibility and perform this optimization.</span>したがって、その可能性を拒否し、この最適化を実行することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In most other languages, this input would be entirely possible, and must be considered.</span>ほとんどの言語では、この入力は完全に可能であり、考慮する必要があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is why alias analysis is important: it lets the compiler perform useful optimizations!</span>これがエイリアス解析が重要な理由です。コンパイラは有用な最適化を実行できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Some examples:</span>いくつかの例：</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">keeping values in registers by proving no pointers access the value&#39;s memory</span>ポインタが値のメモリにアクセスしていないことを証明してレジスタに値を保持する</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">eliminating reads by proving some memory hasn&#39;t been written to since last we read it</span>私たちが最後に読んで以来、いくつかのメモリが書かれていないことを証明することによって、読取りを排除する</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">eliminating writes by proving some memory is never read before the next write to it</span>いくつかのメモリを証明することによって書き込みを消去することは、次の書き込みの前には決して読み込まれません</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">moving or reordering reads and writes by proving they don&#39;t depend on each other</span>お互いに依存しないことを証明することによって読み書きを移動または並べ替える</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These optimizations also tend to prove the soundness of bigger optimizations such as loop vectorization, constant propagation, and dead code elimination.</span>これらの最適化はまた、ループベクトル化、定数伝搬、およびデッドコード除去などのより大きな最適化の健全性を証明する傾向があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In the previous example, we used the fact that <code>&amp;mut u32</code> can&#39;t be aliased to prove that writes to <code>*output</code> can&#39;t possibly affect <code>*input</code> .</span>前の例では、 <code>&amp;mut u32</code>は、 <code>*output</code>への書き込みが<code>*input</code>影響する可能性があることを証明するために別名指定することはできません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This let us cache <code>*input</code> in a register, eliminating a read.</span>これは、 <code>*input</code>をレジスタにキャッシュさせ、読み込みを排除します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">By caching this read, we knew that the the write in the <code>&gt; 10</code> branch couldn&#39;t affect whether we take the <code>&gt; 5</code> branch, allowing us to also eliminate a read-modify-write (doubling <code>*output</code> ) when <code>*input &gt; 10</code> .</span>この読み込みをキャッシュすることで、 <code>&gt; 10</code>ブランチの書き込みが<code>&gt; 5</code>ブランチを取るかどうかに影響を及ぼさず、 <code>*input &gt; 10</code>ときにリード・モディファイ・ライト（ダブリング<code>*output</code> ）を排除できることが分かりました。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The key thing to remember about alias analysis is that writes are the primary hazard for optimizations.</span>エイリアス分析について覚えておくべき重要なことは、書き込みが最適化の主要な危険であることです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That is, the only thing that prevents us from moving a read to any other part of the program is the possibility of us re-ordering it with a write to the same location.</span>つまり、プログラムの他の部分に読み込みを移動させないようにする唯一の方法は、同じ場所への書き込みでプログラムを並べ替えることです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For instance, we have no concern for aliasing in the following modified version of our function, because we&#39;ve moved the only write to <code>*output</code> to the very end of our function.</span>例えば、次の関数の修正版ではエイリアシングに関心がありません。なぜなら、 <code>*output</code>だけを関数の最後に移動したからです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This allows us to freely reorder the reads of <code>*input</code> that occur before it:</span>これにより、前に出現した<code>*input</code>の読みを自由に並べ替えることができます：</span> </p><br><div data-lang=rust><div data-l="fn compute(input: &amp;u32, output: &amp;mut u32) {"></div><div data-l="    let mut temp = *output;"></div><div data-l="    if *input &gt; 10 {"></div><div data-l="        temp = 1;"></div><div data-l="    }"></div><div data-l="    if *input &gt; 5 {"></div><div data-l="        temp *= 2;"></div><div data-l="    }"></div><div data-l="    *output = temp;"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;re still relying on alias analysis to assume that <code>temp</code> doesn&#39;t alias <code>input</code> , but the proof is much simpler: the value of a local variable can&#39;t be aliased by things that existed before it was declared.</span> <code>temp</code>は<code>input</code>エイリアスではないと仮定してエイリアス解析を<code>temp</code>してい<code>input</code>が、証明ははるかに簡単です。ローカル変数の値は、宣言される前に存在していたものによってエイリアス化することはできません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is an assumption every language freely makes, and so this version of the function could be optimized the way we want in any language.</span>これはすべての言語が自由に作れることを前提としているので、このバージョンの関数はどの言語でも最適な方法で最適化できます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is why the definition of &quot;alias&quot; that Rust will use likely involves some notion of liveness and mutation: we don&#39;t actually care if aliasing occurs if there aren&#39;t any actual writes to memory happening.</span>これは、Rustが使用する「エイリアス」の定義が、生存性や変異の概念を含む可能性があるためです。メモリへの実際の書き込みがない場合、エイリアシングが発生するかどうかは実際には気にしません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Of course, a full aliasing model for Rust must also take into consideration things like function calls (which may mutate things we don&#39;t see), raw pointers (which have no aliasing requirements on their own), and UnsafeCell (which lets the referent of an <code>&amp;</code> be mutated).</span>もちろん、Rustの完全なエイリアシングモデルでは、関数呼び出し（わからないものを変更する可能性があります）、生ポインタ（独自のエイリアシング要件はありません）、UnsafeCellの<code>&amp;</code>変異されます）。</span> </p><br><br><br><script>_addload(function(){_setupIW('com');_csi('en','ja','aliasing.html');});</script>