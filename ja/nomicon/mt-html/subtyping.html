<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180723_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=subtyping.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Subtyping and Variance</span>サブタイプと差異</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Subtyping is a relationship between types that allows statically typed languages to be a bit more flexible and permissive.</span>サブタイプとは、静的に型指定された言語を少し柔軟性と許容性があるようにするタイプ間の関係です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The most common and easy to understand example of this can be found in languages with inheritance.</span>最も一般的で分かりやすい例は、継承のある言語で見つけることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Consider an Animal type which has an <code>eat()</code> method, and a Cat type which extends Animal, adding a <code>meow()</code> method.</span> <code>eat()</code>メソッドを持つAnimal型と<code>meow()</code>するCat型を考え、 <code>meow()</code>メソッドを追加します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Without subtyping, if someone were to write a <code>feed(Animal)</code> function, they wouldn&#39;t be able to pass a Cat to this function, because a Cat isn&#39;t <i>exactly</i> an Animal.</span>誰かが書き込みをした場合にサブタイプがなければ、 <code>feed(Animal)</code>機能を猫は<i>まさに</i>動物ではないので、彼らは、この関数に猫を渡すことができないだろう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But being able to pass a Cat where an Animal is expected seems fairly reasonable.</span>しかし、Animalが期待されるCatを渡すことができることはかなり合理的です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">After all, a Cat is just an Animal <i>and more</i> .</span>結局のところ、猫はただの動物で<i>あり、それ以上</i>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Something having extra features that can be ignored shouldn&#39;t be any impediment to using it!</span>無視できる余分な機能を持っているものは、それを使うことに何の障害もないはずです！</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is exactly what subtyping lets us do.</span>これはサブタイピングが私たちにできることです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because a Cat is an Animal <i>and more</i> we say that Cat is a <i>subtype</i> of Animal.</span>猫は動物で<i>あり</i> 、猫は動物の<i>亜型</i>であるといっています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We then say that anywhere a value of a certain type is expected, a value with a subtype can also be supplied.</span>次に、特定の型の値が期待される場所であればどこでも、サブ型の値を指定することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Ok actually it&#39;s a lot more complicated and subtle than that, but that&#39;s the basic intuition that gets you by in 99% of the cases.</span>実際、それはそれよりずっと複雑で微妙ですが、それは99％のケースであなたを得る基本的な直感です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll cover why it&#39;s <i>only</i> 99% later in this section.</span>なぜこのセクションでは99％ <i>しかないの</i>かを説明します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Although Rust doesn&#39;t have any notion of structural inheritance, it <i>does</i> include subtyping.</span> Rustには構造上の継承という概念はありませんが、サブタイプ<i>も</i>含まれます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In Rust, subtyping derives entirely from lifetimes.</span> Rustでは、サブタイプは完全に生涯から派生しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Since lifetimes are regions of code, we can partially order them based on the <i>contains</i> (outlives) relationship.</span>ライフタイムはコードの領域なので、 <i>contains</i> （outlives）関係に基づいて部分的に順序付けを行うことができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Subtyping on lifetimes is in terms of that relationship: if <code>&#39;big: &#39;small</code> (&quot;big contains small&quot; or &quot;big outlives small&quot;), then <code>&#39;big</code> is a subtype of <code>&#39;small</code> .</span>生存期間のサブタイプ化は、その関係の観点から行われます。「大きい」 <code>&#39;big: &#39;small</code> 」（「大きなものが小さい」または「大きいものが小さい」）の場合、 <code>&#39;big</code> <code>&#39;small</code>は<code>&#39;small</code>サブタイプです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is a large source of confusion, because it seems backwards to many: the bigger region is a <i>subtype</i> of the smaller region.</span>これは混乱の大きな原因です。なぜなら、それは多くの人に逆行しているように見えるからです。より大きな領域は、より小さな領域の<i>サブタイプ</i>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But it makes sense if you consider our Animal example: <i>Cat</i> is an Animal <i>and more</i> , just as <code>&#39;big</code> is <code>&#39;small</code> <i>and more</i> .</span>あなたが私たちの動物の例を考えてみた場合しかし、それは理にかなっている： <i>猫は</i>同じように、動物<i>とより</i>である<code>&#39;big</code>ある<code>&#39;small</code> <i>とより</i> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Put another way, if someone wants a reference that lives for <code>&#39;small</code> , usually what they actually mean is that they want a reference that lives for <i>at least</i> <code>&#39;small</code> .</span>別の言い方をすれば、誰かが<code>&#39;small</code>ために生きる参照を望んでいるのであれば、彼らが実際に意味することは<i>、少なくとも</i> <code>&#39;small</code>生活を送る参照が欲しいということです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">They don&#39;t actually care if the lifetimes match exactly.</span>生涯が正確に一致するかどうかは実際には気にしません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For this reason <code>&#39;static</code> , the forever lifetime, is a subtype of every lifetime.</span>この理由から、 <code>&#39;static</code>永遠の生涯<code>&#39;static</code>は、あらゆる生涯のサブタイプです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Higher-ranked lifetimes are also subtypes of every concrete lifetime.</span>ランクの高いランクは、すべての具体的な生涯のサブタイプです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is because taking an arbitrary lifetime is strictly more general than taking a specific one.</span>これは、任意の生涯を取ることは、特定の生涯を取ることよりも厳密に一般的であるからです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">(The typed-ness of lifetimes is a fairly arbitrary construct that some disagree with. However it simplifies our analysis to treat lifetimes and types uniformly.)</span> （型定義された生涯は、それに反するいくつかのものはかなり恣意的な構造ですが、生涯と型を一様に扱うために分析を単純化します）。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However you can&#39;t write a function that takes a value of type <code>&#39;a</code> !</span>しかし、タイプ<code>&#39;a</code> ！ <code>&#39;a</code>値をとる関数を書くことはできません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Lifetimes are always just part of another type, so we need a way of handling that.</span>生涯は常に他のタイプの一部に過ぎません。したがって、その処理方法が必要です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To handle it, we need to talk about <i>variance</i> .</span>それを処理するには、 <i>分散</i>について話す必要があります。</span> </p><br><br><br><br><br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Variance</span>分散</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Variance is where things get a bit complicated.</span>差異は物事が少し複雑になるところです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Variance is a property that <i>type constructors</i> have with respect to their arguments.</span>分散は、 <i>型コンストラクタ</i>が引数に関して持つプロパティです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A type constructor in Rust is a generic type with unbound arguments.</span> Rustの型コンストラクタは、バインドされていない引数を持つジェネリック型です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For instance <code>Vec</code> is a type constructor that takes a <code>T</code> and returns a <code>Vec&lt;T&gt;</code> .</span>例えば、 <code>Vec</code>は<code>T</code>をとり、 <code>Vec&lt;T&gt;</code>を返す型コンストラクタです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>&amp;</code> and <code>&amp;mut</code> are type constructors that take two inputs: a lifetime, and a type to point to.</span> <code>&amp;</code>と<code>&amp;mut</code>は、2つの入力を取るタイプのコンストラクタです：生涯とポイントする型です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A type constructor F&#39;s <i>variance</i> is how the subtyping of its inputs affects the subtyping of its outputs.</span>タイプコンストラクタFの<i>分散</i>は、入力のサブタイプがその出力のサブタイプにどのように影響するかです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There are three kinds of variance in Rust:</span> Rustには3種類の分散があります：</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">F is <i>covariant</i> over <code>T</code> if <code>T</code> being a subtype of <code>U</code> implies <code>F&lt;T&gt;</code> is a subtype of <code>F&lt;U&gt;</code> (subtyping &quot;passes through&quot;)</span> Fは上<i>共変</i>である<code>T</code>場合<code>T</code>のサブタイプである<code>U</code>意味<code>F&lt;T&gt;</code>のサブタイプである<code>F&lt;U&gt;</code> （サブタイプ「通過します」）</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">F is <i>contravariant</i> over <code>T</code> if <code>T</code> being a subtype of <code>U</code> implies <code>F&lt;U&gt;</code> is a subtype of <code>F&lt;T&gt;</code> (subtyping is &quot;inverted&quot;)</span> Fは、上に<i>反変</i>された<code>T</code>場合<code>T</code>のサブタイプである<code>U</code>意味<code>F&lt;U&gt;</code>のサブタイプである<code>F&lt;T&gt;</code>サブタイプが「反転」されます）</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">F is <i>invariant</i> over <code>T</code> otherwise (no subtyping relation can be derived)</span> Fは<code>T</code>以外では<i>不変</i>である（サブタイプの関係は得られない）</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It should be noted that covariance is <i>far</i> more common and important than contravariance in Rust.</span>共分散は、Rustの反動よりも<i>はるか</i>に一般的で重要であることに注意してください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The existence of contravariance in Rust can mostly be ignored.</span> Rustのcontravarianceの存在は、ほとんど無視することができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Some important variances (which we will explain in detail below):</span>いくつかの重要な差異（以下で詳しく説明します）：</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>&amp;&#39;a T</code> is covariant over <code>&#39;a</code> and <code>T</code> (as is <code>*const T</code> by metaphor)</span> <code>&amp;&#39;a T</code>は<code>&#39;a</code>と<code>T</code>上で共変する（metaphorによって<code>*const T</code>同じように）</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>&amp;&#39;a mut T</code> is covariant over <code>&#39;a</code> but invariant over <code>T</code></span> <code>&amp;&#39;a mut T</code>は共変で<code>&#39;a</code>が、 <code>T</code>に対しては不変である</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>fn(T) -&gt; U</code> is <b>contra</b> variant over <code>T</code> , but covariant over <code>U</code></span> <code>fn(T) -&gt; U</code>は<code>T</code>よりも<b>反対の</b>形であるが、 <code>U</code></span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>Box</code> , <code>Vec</code> , and all other collections are covariant over the types of their contents</span> <code>Box</code> 、 <code>Vec</code> 、および他のすべてのコレクションは、その内容のタイプに対して共変です</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>UnsafeCell&lt;T&gt;</code> , <code>Cell&lt;T&gt;</code> , <code>RefCell&lt;T&gt;</code> , <code>Mutex&lt;T&gt;</code> and all other interior mutability types are invariant over T (as is <code>*mut T</code> by metaphor)</span> <code>UnsafeCell&lt;T&gt;</code> 、 <code>Cell&lt;T&gt;</code> 、 <code>RefCell&lt;T&gt;</code> 、 <code>Mutex&lt;T&gt;</code>および他のすべての内部の可変型は、Tを超えて不変である（メタ<code>*mut T</code>によって<code>*mut T</code>である）</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To understand why these variances are correct and desirable, we will consider several examples.</span>これらの差異が正しい理由と望ましい理由を理解するために、いくつかの例を検討します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We have already covered why <code>&amp;&#39;a T</code> should be covariant over <code>&#39;a</code> when introducing subtyping: it&#39;s desirable to be able to pass longer-lived things where shorter-lived things are needed.</span>我々はすでにサブタイピングを導入<code>&#39;a</code>ときに<code>&amp;&#39;a T</code>が共変型でなければならない理由について議論しました。より短命なものが必要な場合には長命のものを渡すことが望ましいです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Similar reasoning applies to why it should be covariant over T: it&#39;s reasonable to be able to pass <code>&amp;&amp;&#39;static str</code> where an <code>&amp;&amp;&#39;a str</code> is expected.</span>同様の推論は、なぜそれがTよりも共変でなければならないかにも当てはまり<code>&amp;&amp;&#39;static str</code> 。 <code>&amp;&amp;&#39;a str</code>が期待される場所で<code>&amp;&amp;&#39;static str</code>を渡すことは合理的です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The additional level of indirection doesn&#39;t change the desire to be able to pass longer lived things where shorter lived things are expected.</span>付加的な間接的なレベルは、より短い生存物が期待されるより長い生存物を通過させたいという欲求を変えない。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However this logic doesn&#39;t apply to <code>&amp;mut</code> .</span>しかし、このロジックは<code>&amp;mut</code>は適用されません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To see why <code>&amp;mut</code> should be invariant over T, consider the following code:</span> <code>&amp;mut</code>がTに対して不変でなければならない理由を調べるには、次のコードを考えてみましょう：</span> </p><br><div data-lang=rust,ignore><div data-l="fn overwrite&lt;T: Copy&gt;(input: &amp;mut T, new: &amp;mut T) {"></div><div data-l="    *input = *new;"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let mut forever_str: &amp;'static str = &quot;hello&quot;;"></div><div data-l="    {"></div><div data-l="        let string = String::from(&quot;world&quot;);"></div><div data-l="        overwrite(&amp;mut forever_str, &amp;mut &amp;*string);"></div><div data-l="    }"></div><div data-l="#    // Oops, printing free'd memory"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Oops, printing free&#39;d memory</span>メモリの空き領域を印刷しています</span> </div><div data-l="    println!(&quot;{}&quot;, forever_str);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The signature of <code>overwrite</code> is clearly valid: it takes mutable references to two values of the same type, and overwrites one with the other.</span> <code>overwrite</code>の署名は明らかに有効です。同じ型の2つの値への参照を変更し、一方を他方に上書きします。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But, if <code>&amp;mut T</code> was covariant over T, then <code>&amp;mut &amp;&#39;static str</code> would be a subtype of <code>&amp;mut &amp;&#39;a str</code> , since <code>&amp;&#39;static str</code> is a subtype of <code>&amp;&#39;a str</code> .</span>しかし、 <code>&amp;mut T</code>がTに対して共変すると、 <code>&amp;mut &amp;&#39;static str</code>は<code>&amp;mut &amp;&#39;a str</code>のサブタイプになり<code>&amp;&#39;a str</code> 。なぜなら<code>&amp;&#39;static str</code>は<code>&amp;&#39;static str</code>のサブタイプです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Therefore the lifetime of <code>forever_str</code> would successfully be &quot;shrunk&quot; down to the shorter lifetime of <code>string</code> , and <code>overwrite</code> would be called successfully.</span>したがって、 <code>forever_str</code>有効期間は<code>string</code>寿命が短くなるまで「縮小」され、 <code>overwrite</code>は正常に呼び出されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>string</code> would subsequently be dropped, and <code>forever_str</code> would point to freed memory when we print it!</span> <code>string</code>はその後削除され、 <code>forever_str</code>は解放されたメモリを指します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Therefore <code>&amp;mut</code> should be invariant.</span>したがって、 <code>&amp;mut</code>は不変でなければなりません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is the general theme of variance vs invariance: if variance would allow you to store a short-lived value in a longer-lived slot, then invariance must be used.</span>これは、分散と不変性の一般的なテーマです。分散を使用すると長命の値を短命のスロットに保存できる場合は、不変量を使用する必要があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">More generally, the soundness of subtyping and variance is based on the idea that its ok to forget details, but with mutable references there&#39;s always someone (the original value being referenced) that remembers the forgotten details and will assume that those details haven&#39;t changed.</span>より一般的には、サブタイプ化と分散の健全性は、その細かいことを忘れてしまうという考えに基づいていますが、変更可能な参照では、忘れられた細部を覚えている人物（元の値が参照されます） 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we do something to invalidate those details, the original location can behave unsoundly.</span>これらの細部を無効にするために何かを行うと、元の場所は不運にも動作します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However it <i>is</i> sound for <code>&amp;&#39;a mut T</code> to be covariant over <code>&#39;a</code> .</span>しかし、それ<i>は</i> <code>&amp;&#39;a mut T</code>が共変する<code>&#39;a</code>ために<code>&amp;&#39;a mut T</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The key difference between <code>&#39;a</code> and T is that <code>&#39;a</code> is a property of the reference itself, while T is something the reference is borrowing.</span> <code>&#39;a</code>とTの主な違いは、 <code>&#39;a</code>は参照自体のプロパティであり、Tは参照が借用しているものであるということです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you change T&#39;s type, then the source still remembers the original type.</span> Tの型を変更すると、ソースは元の型を覚えています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However if you change the lifetime&#39;s type, no one but the reference knows this information, so it&#39;s fine.</span>しかし、あなたが生涯のタイプを変更した場合、リファレンス以外の誰もこの情報を知っていないので、それは問題ありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Put another way: <code>&amp;&#39;a mut T</code> owns <code>&#39;a</code> , but only <i>borrows</i> T.</span>別の言い方を<code>&#39;a</code> 、 <code>&#39;a</code> <code>&amp;&#39;a mut T</code>は<code>&#39;a</code>所有し<code>&#39;a</code> 、 <code>&amp;&#39;a mut T</code>を<i>借りる</i>だけです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>Box</code> and <code>Vec</code> are interesting cases because they&#39;re covariant, but you can definitely store values in them!</span> <code>Box</code>と<code>Vec</code>は共変なので面白いケースですが、あなたは間違いなく値を保存することができます！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is where Rust&#39;s typesystem allows it to be a bit more clever than others.</span>これは、Rustの型システムによって、他の型よりも少し巧妙なものになります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To understand why it&#39;s sound for owning containers to be covariant over their contents, we must consider the two ways in which a mutation may occur: by-value or by-reference.</span>コンテナに内容を共変させることが妥当である理由を理解するためには、バイナリまたはバイ・リファレンスという2つの方法が考えられます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If mutation is by-value, then the old location that remembers extra details is moved out of, meaning it can&#39;t use the value anymore.</span>突然変異が副作用である場合、余分な詳細を記憶している古い場所は移動されます。つまり、それ以上値を使用できません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So we simply don&#39;t need to worry about anyone remembering dangerous details.</span>だから、危険な詳細を覚えている人を心配する必要はありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Put another way, applying subtyping when passing by-value <i>destroys details forever</i> .</span>別の言い方をすれば、by-value <i>を</i>渡すときにサブタイプを適用<i>すると、ディテールが永遠に破棄</i>され<i>ます</i> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, this compiles and is fine:</span>たとえば、これはコンパイルされ、うまくいきます：</span> </p><br><div data-lang=rust><div data-l="fn get_box&lt;'a&gt;(str: &amp;'a str) -&gt; Box&lt;&amp;'a str&gt; {"></div><div data-l="#    // String literals are `&amp;'static str`s, but it's fine for us to"></div><div data-l="#    // &quot;forget&quot; this and let the caller think the string won't live that long."></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">String literals are <code>&amp;&#39;static str</code> s, but it&#39;s fine for us to &quot;forget&quot; this and let the caller think the string won&#39;t live that long.</span>文字列リテラルは<code>&amp;&#39;static str</code>ですが、これを &quot;忘れ&quot;て呼び出し元が文字列がそれほど長くは生きていないと思うようにするのは良いことです。</span> </div><div data-l="    Box::new(&quot;hello&quot;)"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If mutation is by-reference, then our container is passed as <code>&amp;mut Vec&lt;T&gt;</code> .</span>突然変異が参照によって行われる場合、コンテナは<code>&amp;mut Vec&lt;T&gt;</code>として渡されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But <code>&amp;mut</code> is invariant over its value, so <code>&amp;mut Vec&lt;T&gt;</code> is actually invariant over <code>T</code> .</span>しかし、 <code>&amp;mut</code>はその値に対して不変であるため、 <code>&amp;mut Vec&lt;T&gt;</code>は実際には<code>T</code>に対して不変である。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So the fact that <code>Vec&lt;T&gt;</code> is covariant over <code>T</code> doesn&#39;t matter at all when mutating by-reference.</span>だから、という事実<code>Vec&lt;T&gt;</code>オーバー共変である<code>T</code>参照による変異ときは全く関係ありません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But being covariant still allows <code>Box</code> and <code>Vec</code> to be weakened when shared immutably.</span>しかし、共変のままであれば、 <code>Box</code>と<code>Vec</code>は不変に共有されると弱体化することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So you can pass a <code>&amp;Vec&lt;&amp;&#39;static str&gt;</code> where a <code>&amp;Vec&lt;&amp;&#39;a str&gt;</code> is expected.</span>したがって、 <code>&amp;Vec&lt;&amp;&#39;static str&gt;</code>が必要<code>&amp;Vec&lt;&amp;&#39;static str&gt;</code>を渡すことができ<code>&amp;Vec&lt;&amp;&#39;a str&gt;</code> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The invariance of the cell types can be seen as follows: <code>&amp;</code> is like an <code>&amp;mut</code> for a cell, because you can still store values in them through an <code>&amp;</code> .</span>細胞種の不変性は、以下のように見ることができます： <code>&amp;</code>のようです<code>&amp;mut</code>それでも介してそれらの値を格納できるので、セルの<code>&amp;</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Therefore cells must be invariant to avoid lifetime smuggling.</span>したがって、セルは生涯の密輸を避けるために不変でなければならない。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>fn</code> is the most subtle case because they have mixed variance, and in fact are the only source of <b>contra</b> variance.</span> <code>fn</code>は分散が混じっており、実際には<b>コントラ</b>分散の唯一の原因であるため、最も微妙なケースです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To see why <code>fn(T) -&gt; U</code> should be contravariant over T, consider the following function signature:</span>なぜ、 <code>fn(T) -&gt; U</code>がTに対して反変であるべきかを知るために、以下の関数シグネチャを考えてみよう。</span> </p><br><div data-lang=rust,ignore><div data-l="#// 'a is derived from some parent scope"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">&#39;a is derived from some parent scope</span> &#39;aは親スコープから派生したものです</span> </div><div data-l="fn foo(&amp;'a str) -&gt; usize;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This signature claims that it can handle any <code>&amp;str</code> that lives at least as long as <code>&#39;a</code> .</span>この署名は、少なくとも<code>&#39;a</code>同じ長さ<code>&#39;a</code>すべての<code>&amp;str</code>を処理できることを主張してい<code>&amp;str</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Now if this signature was <b>co</b> variant over <code>&amp;&#39;a str</code> , that would mean</span>今、この署名が<code>&amp;&#39;a str</code> <b>共</b>変種であった場合、それは</span> </p><br><div data-lang=rust,ignore><div data-l="fn foo(&amp;'static str) -&gt; usize;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">could be provided in its place, as it would be a subtype.</span>それがサブタイプであるため、その場所に提供することができる。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However this function has a stronger requirement: it says that it can only handle <code>&amp;&#39;static str</code> s, and nothing else.</span>しかし、この関数はより強力な要件を持っています：それは<code>&amp;&#39;static str</code>だけを扱うことができ、他には何もありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Giving <code>&amp;&#39;a str</code> s to it would be unsound, as it&#39;s free to assume that what it&#39;s given lives forever.</span>寄付<code>&amp;&#39;a str</code> 、それが永遠の命を与えられているものと仮定して自由だとしてそれにSは、不健全でしょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Therefore functions definitely shouldn&#39;t be <b>co</b> variant over their arguments.</span>そのための機能は、間違いなくその引数を超える<b>コ</b>バリアントであってはなりません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However if we flip it around and use <b>contra</b> variance, it <i>does</i> work!</span>私たちは周りにそれを反転し、 <b>コントラ</b>分散を使用している場合しかし、それは動作<i>しません</i> ！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If something expects a function which can handle strings that live forever, it makes perfect sense to instead provide a function that can handle strings that live for <i>less</i> than forever.</span>何かが永遠に生きる文字列を扱うことができると期待しているのであれば、永遠より<i>少ない</i>文字列を処理できる関数を提供するのが理にかなっています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So</span>そう</span> </p><br><div data-lang=rust,ignore><div data-l="fn foo(&amp;'a str) -&gt; usize;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">can be passed where</span>どこに渡すことができます</span> </p><br><div data-lang=rust,ignore><div data-l="fn foo(&amp;'static str) -&gt; usize;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">is expected.</span>期待されています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To see why <code>fn(T) -&gt; U</code> should be <b>co</b> variant over U, consider the following function signature:</span>なぜ<code>fn(T) -&gt; U</code>上の<b>共</b>変であるべきかを知るために、以下の関数シグネチャを考えてみよう。</span> </p><br><div data-lang=rust,ignore><div data-l="#// 'a is derived from some parent scope"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">&#39;a is derived from some parent scope</span> &#39;aは親スコープから派生したものです</span> </div><div data-l="fn foo(usize) -&gt; &amp;'a str;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This signature claims that it will return something that outlives <code>&#39;a</code> .</span>この署名は、それが生存するものを返すと主張して<code>&#39;a</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It is therefore completely reasonable to provide</span>したがって、</span> </p><br><div data-lang=rust,ignore><div data-l="fn foo(usize) -&gt; &amp;'static str;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">in its place, as it does indeed return things that outlive <code>&#39;a</code> .</span>それは確かに物事を返さないように、その場所に、より長生きいます<code>&#39;a</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Therefore functions are covariant over their return type.</span>したがって、関数はその戻り型に対して共変です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>*const</code> has the exact same semantics as <code>&amp;</code> , so variance follows.</span> <code>*const</code>は<code>&amp;</code>と全く同じセマンティクスを持っているので、分散が続く。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>*mut</code> on the other hand can dereference to an <code>&amp;mut</code> whether shared or not, so it is marked as invariant just like cells.</span>一方、 <code>*mut</code>は、共有されているかどうかにかかわらず、 <code>&amp;mut</code>逆参照することができるので、セルと同じように不変としてマークされます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is all well and good for the types the standard library provides, but how is variance determined for type that <i>you</i> define?</span>これは、標準ライブラリが提供する型のすべてに適してい<i>ますが、</i>定義する型に対してどのように分散が決定されますか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A struct, informally speaking, inherits the variance of its fields.</span>構造体は非形式的に言えば、そのフィールドの分散を継承します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If a struct <code>Foo</code> has a generic argument <code>A</code> that is used in a field <code>a</code> , then Foo&#39;s variance over <code>A</code> is exactly <code>a</code> &#39;s variance.</span>構造体場合<code>Foo</code> 、一般的な引数がある<code>A</code>分野で使用され、その後、オーバーフーの差異<code>a</code> <code>A</code>正確であるの分散。 <code>a</code></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However if <code>A</code> is used in multiple fields:</span>ただし、 <code>A</code>が複数のフィールドで使用されている場合は、</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If all uses of A are covariant, then Foo is covariant over A</span> Aのすべての用途が共変である場合、FooはAに対して共変する</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If all uses of A are contravariant, then Foo is contravariant over A</span> Aのすべての使用が反変である場合、FooはAに対して反変です</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Otherwise, Foo is invariant over A</span>さもなければ、FooはAに対して不変である</span> </div><br><div data-lang=rust><div data-l="use std::cell::Cell;"></div><div data-l=""></div><div data-l="struct Foo&lt;'a, 'b, A: 'a, B: 'b, C, D, E, F, G, H, In, Out, Mixed&gt; {"></div><div data-l="#//    a: &amp;'a A,     // covariant over 'a and A"></div><div data-l="    a: &amp;'a A,     // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">covariant over &#39;a and A</span> AとAの共変量</span> </div><div data-l="#//    b: &amp;'b mut B, // covariant over 'b and invariant over B"></div><div data-l="    b: &amp;'b mut B, // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">covariant over &#39;b and invariant over B</span> B上の共変およびB上の不変</span> </div><div data-l=""></div><div data-l="#//    c: *const C,  // covariant over C"></div><div data-l="    c: *const C,  // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">covariant over C</span> Cとの共変量</span> </div><div data-l="#//    d: *mut D,    // invariant over D"></div><div data-l="    d: *mut D,    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">invariant over D</span>不変のD</span> </div><div data-l=""></div><div data-l="#//    e: E,         // covariant over E"></div><div data-l="    e: E,         // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">covariant over E</span> E上の共変量</span> </div><div data-l="#//    f: Vec&lt;F&gt;,    // covariant over F"></div><div data-l="    f: Vec&lt;F&gt;,    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">covariant over F</span> F上の共変量</span> </div><div data-l="#//    g: Cell&lt;G&gt;,   // invariant over G"></div><div data-l="    g: Cell&lt;G&gt;,   // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">invariant over G</span>不変のG</span> </div><div data-l=""></div><div data-l="#//    h1: H,        // would also be variant over H except..."></div><div data-l="    h1: H,        // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">would also be variant over H except...</span>を除いてH以上の変形も...</span> </div><div data-l="#//    h2: Cell&lt;H&gt;,  // invariant over H, because invariance wins all conflicts"></div><div data-l="    h2: Cell&lt;H&gt;,  // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">invariant over H, because invariance wins all conflicts</span>不変性がすべての競合を勝ち取るので、Hより不変である</span> </div><div data-l=""></div><div data-l="#//    i: fn(In) -&gt; Out,       // contravariant over In, covariant over Out"></div><div data-l="    i: fn(In) -&gt; Out,       // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">contravariant over In, covariant over Out</span> In上の反変、Out上の共変</span> </div><div data-l=""></div><div data-l="#//    k1: fn(Mixed) -&gt; usize, // would be contravariant over Mixed except.."></div><div data-l="    k1: fn(Mixed) -&gt; usize, // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">would be contravariant over Mixed except..</span>ミックスド以外では反乱的であろう。</span> </div><div data-l="#//    k2: Mixed,              // invariant over Mixed, because invariance wins all conflicts"></div><div data-l="    k2: Mixed,              // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">invariant over Mixed, because invariance wins all conflicts</span>不変がすべての競合を勝ち取るため、混合よりも不変</span> </div><div data-l=}></div></div><script>_addload(function(){_setupIW('com');_csi('en','ja','subtyping.html');});</script>