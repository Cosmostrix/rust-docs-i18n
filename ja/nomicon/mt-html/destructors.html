<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180723_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=destructors.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Destructors</span>デストラクタ</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">What the language <i>does</i> provide is full-blown automatic destructors through the <code>Drop</code> trait, which provides the following method:</span>言語<i>が</i>提供しているのは、 <code>Drop</code>属性を使用した完全な自動デストラクタです。これは、次の方法を提供します。</span> </p><br><div data-lang=rust,ignore><div data-l="fn drop(&amp;mut self);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This method gives the type time to somehow finish what it was doing.</span>このメソッドは、それがやっていたことを何とかして終了する型の時間を与えます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><b>After `drop` is run, Rust will recursively try to drop all of the fields of `self`.</b></span> <b>`drop`が実行された後、Rustは` self`のすべてのフィールドを再帰的に削除しようとします。</b></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is a convenience feature so that you don&#39;t have to write &quot;destructor boilerplate&quot; to drop children.</span>これは便利な機能なので、子を削除するために「デストラクタ定型文」を書く必要はありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If a struct has no special logic for being dropped other than dropping its children, then it means <code>Drop</code> doesn&#39;t need to be implemented at all!</span>構造体に子をドロップする以外にドロップされる特別なロジックがない場合、 <code>Drop</code>はまったく実装する必要がないことを意味します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><b>There is no stable way to prevent this behavior in Rust 1.0.</b></span> <b>Rust 1.0でこの動作を防止する安定した方法はありません。</b></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that taking <code>&amp;mut self</code> means that even if you could suppress recursive Drop, Rust will prevent you from eg moving fields out of self.</span> <code>&amp;mut self</code>を取ることは、たとえあなたが再帰的なドロップを抑制することができたとしても、Rustはフィールドを自分自身から移動させないようにします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For most types, this is totally fine.</span>ほとんどのタイプでは、これはまったく問題ありません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For instance, a custom implementation of <code>Box</code> might write <code>Drop</code> like this:</span>例えば、 <code>Box</code>カスタム実装では、以下のように<code>Drop</code>書くことができます：</span> </p><br><div data-lang=rust><div data-l="#![feature(ptr_internals, allocator_api, unique)]"></div><div data-l=""></div><div data-l="use std::alloc::{Alloc, Global, GlobalAlloc, Layout};"></div><div data-l="use std::mem;"></div><div data-l="use std::ptr::{drop_in_place, NonNull, Unique};"></div><div data-l=""></div><div data-l="struct Box&lt;T&gt;{ ptr: Unique&lt;T&gt; }"></div><div data-l=""></div><div data-l="impl&lt;T&gt; Drop for Box&lt;T&gt; {"></div><div data-l="    fn drop(&amp;mut self) {"></div><div data-l="        unsafe {"></div><div data-l="            drop_in_place(self.ptr.as_ptr());"></div><div data-l="            let c: NonNull&lt;T&gt; = self.ptr.into();"></div><div data-l="            Global.dealloc(c.cast(), Layout::new::&lt;T&gt;())"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=}></div><div data-l="# fn main() {}"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">and this works fine because when Rust goes to drop the <code>ptr</code> field it just sees a <a class=notranslate href=#4Unique>Unique</a> that has no actual <code>Drop</code> implementation.</span> Rustが<code>ptr</code>フィールドをドロップすると、実際の<code>Drop</code>実装がない<a class=notranslate href=#4Unique>Unique</a>が表示されるため、これはうまく<code>ptr</code>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Similarly nothing can use-after-free the <code>ptr</code> because when drop exits, it becomes inaccessible.</span>同様に、ドロップが終了するとアクセスできないため、 <code>ptr</code>解放してから使用することはできません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However this wouldn&#39;t work:</span>しかし、これはうまくいかないでしょう：</span> </p><br><div data-lang=rust><div data-l="#![feature(allocator_api, ptr_internals, unique)]"></div><div data-l=""></div><div data-l="use std::alloc::{Alloc, Global, GlobalAlloc, Layout};"></div><div data-l="use std::ptr::{drop_in_place, Unique, NonNull};"></div><div data-l="use std::mem;"></div><div data-l=""></div><div data-l="struct Box&lt;T&gt;{ ptr: Unique&lt;T&gt; }"></div><div data-l=""></div><div data-l="impl&lt;T&gt; Drop for Box&lt;T&gt; {"></div><div data-l="    fn drop(&amp;mut self) {"></div><div data-l="        unsafe {"></div><div data-l="            drop_in_place(self.ptr.as_ptr());"></div><div data-l="            let c: NonNull&lt;T&gt; = self.ptr.into();"></div><div data-l="            Global.dealloc(c.cast(), Layout::new::&lt;T&gt;());"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="struct SuperBox&lt;T&gt; { my_box: Box&lt;T&gt; }"></div><div data-l=""></div><div data-l="impl&lt;T&gt; Drop for SuperBox&lt;T&gt; {"></div><div data-l="    fn drop(&amp;mut self) {"></div><div data-l="        unsafe {"></div><div data-l="#            // Hyper-optimized: deallocate the box's contents for it"></div><div data-l="#            // without `drop`ing the contents"></div><div data-l="            // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Hyper-optimized: deallocate the box&#39;s contents for it without <code>drop</code> ing the contents</span>ハイパー最適化：内容を<code>drop</code>ことなくボックスのコンテンツの割り当てを解除する</span> </div><div data-l="            let c: NonNull&lt;T&gt; = self.my_box.ptr.into();"></div><div data-l="            Global.dealloc(c.cast::&lt;u8&gt;(), Layout::new::&lt;T&gt;());"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=}></div><div data-l="# fn main() {}"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">After we deallocate the <code>box</code> &#39;s ptr in SuperBox&#39;s destructor, Rust will happily proceed to tell the box to Drop itself and everything will blow up with use-after-frees and double-frees.</span>スーパー<code>box</code>のデストラクタで<code>box</code>のptrの割り当てを解除した後、Rustは喜んでボックスをドロップするように進み、すべてが使用後に解放され、ダブルフリーになります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that the recursive drop behavior applies to all structs and enums regardless of whether they implement Drop.</span>再帰ドロップ動作は、Dropを実装するかどうかに関係なく、すべての構造体と列挙型に適用されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Therefore something like</span>したがって、</span> </p><br><div data-lang=rust><div data-l="struct Boxy&lt;T&gt; {"></div><div data-l="    data1: Box&lt;T&gt;,"></div><div data-l="    data2: Box&lt;T&gt;,"></div><div data-l="    info: u32,"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">will have its data1 and data2&#39;s fields destructors whenever it &quot;would&quot; be dropped, even though it itself doesn&#39;t implement Drop.</span> drop自体がドロップを実装していなくても、ドロップされるたびにそのdata1とdata2のフィールドはデストラクタになります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We say that such a type <i>needs Drop</i> , even though it is not itself Drop.</span>私たちは、そのようなタイプ<i>はドロップ</i>ではないと言っていますが、それはドロップではありません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Similarly,</span>同様に、</span> </p><br><div data-lang=rust><div data-l="enum Link {"></div><div data-l="    Next(Box&lt;Link&gt;),"></div><div data-l="    None,"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">will have its inner Box field dropped if and only if an instance stores the Next variant.</span>インスタンスに次のバリアントが格納されている場合にのみ、その内部ボックスフィールドが削除されます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In general this works really nicely because you don&#39;t need to worry about adding/removing drops when you refactor your data layout.</span>一般に、これは本当にうまく動作します。なぜなら、データレイアウトをリファクタリングするときにドロップの追加/削除を心配する必要がないからです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Still there&#39;s certainly many valid usecases for needing to do trickier things with destructors.</span>確かに、デストラクタでやっかいなことをする必要があるため、多くの有効な用途があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The classic safe solution to overriding recursive drop and allowing moving out of Self during <code>drop</code> is to use an Option:</span>再帰的なドロップをオーバーライドし、 <code>drop</code>中にSelfから移動することを可能にする古典的な安全なソリューションは、Option：</span> </p><br><div data-lang=rust><div data-l="#![feature(allocator_api, ptr_internals, unique)]"></div><div data-l=""></div><div data-l="use std::alloc::{Alloc, GlobalAlloc, Global, Layout};"></div><div data-l="use std::ptr::{drop_in_place, Unique, NonNull};"></div><div data-l="use std::mem;"></div><div data-l=""></div><div data-l="struct Box&lt;T&gt;{ ptr: Unique&lt;T&gt; }"></div><div data-l=""></div><div data-l="impl&lt;T&gt; Drop for Box&lt;T&gt; {"></div><div data-l="    fn drop(&amp;mut self) {"></div><div data-l="        unsafe {"></div><div data-l="            drop_in_place(self.ptr.as_ptr());"></div><div data-l="            let c: NonNull&lt;T&gt; = self.ptr.into();"></div><div data-l="            Global.dealloc(c.cast(), Layout::new::&lt;T&gt;());"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="struct SuperBox&lt;T&gt; { my_box: Option&lt;Box&lt;T&gt;&gt; }"></div><div data-l=""></div><div data-l="impl&lt;T&gt; Drop for SuperBox&lt;T&gt; {"></div><div data-l="    fn drop(&amp;mut self) {"></div><div data-l="        unsafe {"></div><div data-l="#            // Hyper-optimized: deallocate the box's contents for it"></div><div data-l="#            // without `drop`ing the contents. Need to set the `box`"></div><div data-l="#            // field as `None` to prevent Rust from trying to Drop it."></div><div data-l="            // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Hyper-optimized: deallocate the box&#39;s contents for it without <code>drop</code> ing the contents.</span>ハイパー最適化：内容を<code>drop</code>ことなくボックスのコンテンツの割り当てを解除します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Need to set the <code>box</code> field as <code>None</code> to prevent Rust from trying to Drop it.</span>錆がドロップしようとするのを防ぐには、 <code>box</code>フィールドを<code>None</code>に設定する必要があり<code>box</code> 。</span> </div><div data-l="            let my_box = self.my_box.take().unwrap();"></div><div data-l="            let c: NonNull&lt;T&gt; = my_box.ptr.into();"></div><div data-l="            Global.dealloc(c.cast(), Layout::new::&lt;T&gt;());"></div><div data-l="            mem::forget(my_box);"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=}></div><div data-l="# fn main() {}"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However this has fairly odd semantics: you&#39;re saying that a field that <i>should</i> always be Some <i>may</i> be None, just because that happens in the destructor.</span>しかし、これはかなり奇妙な意味を持っている：あなたは、常にいくつかを<i>あるべき</i>分野はそれがデストラクタで起こるという理由だけで、Noneになる<i>かもしれ</i>ませんことを言っています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Of course this conversely makes a lot of sense: you can call arbitrary methods on self during the destructor, and this should prevent you from ever doing so after deinitializing the field.</span>もちろん、これは逆に意味があります。デストラクタ中に自分自身に任意のメソッドを呼び出すことができます。これにより、フィールドの初期化を解除した後も、これを実行できなくなります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Not that it will prevent you from producing any other arbitrarily invalid state in there.</span>そうでないと、そこに他の任意の無効な状態が生成されるのを防ぎます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">On balance this is an ok choice.</span>バランスのとれたこれは良い選択です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Certainly what you should reach for by default.</span>確かにあなたはデフォルトで何を手に入れるべきですか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, in the future we expect there to be a first-class way to announce that a field shouldn&#39;t be automatically dropped.</span>しかし、将来的には、フィールドが自動的に削除されるべきでないことを発表するファーストクラスの方法が存在することが期待されます。</span> </p><br> <a class=notranslate href=#1phantom-data.html>Unique</a><script>_addload(function(){_setupIW('com');_csi('en','ja','destructors.html');});</script>