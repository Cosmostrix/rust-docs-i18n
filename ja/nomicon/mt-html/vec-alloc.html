<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180723_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=vec-alloc.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Allocating Memory</span>メモリの割り当て</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Using Unique throws a wrench in an important feature of Vec (and indeed all of the std collections): an empty Vec doesn&#39;t actually allocate at all.</span>ユニークを使用すると、Vecの重要な機能（そして実際にはすべてのstdコレクション）にレンチがスローされます。空のVecは実際にはまったく割り当てません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So if we can&#39;t allocate, but also can&#39;t put a null pointer in <code>ptr</code> , what do we do in <code>Vec::new</code> ?</span>だから私たちが割り当てることはできませんが、 <code>ptr</code>にnullポインタを置くことができない場合、 <code>Vec::new</code>何をしますか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Well, we just put some other garbage in there!</span>さて、そこに他のゴミを置くだけです！</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is perfectly fine because we already have <code>cap == 0</code> as our sentinel for no allocation.</span>これは完全にうまくいきます。なぜなら、割り振られていないとしても、私たちの目標は<code>cap == 0</code>からです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We don&#39;t even need to handle it specially in almost any code because we usually need to check if <code>cap &gt; len</code> or <code>len &gt; 0</code> anyway.</span>とにかく<code>cap &gt; len</code>か<code>len &gt; 0</code>かどうかを確認する必要があるので、ほとんどすべてのコードで特別に扱う必要はあり<code>len &gt; 0</code>ん。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The recommended Rust value to put here is <code>mem::align_of::&lt;T&gt;()</code> .</span>ここに入れる推奨Rust値は<code>mem::align_of::&lt;T&gt;()</code>です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Unique provides a convenience for this: <code>Unique::empty()</code> .</span> Uniqueはこれに便利です： <code>Unique::empty()</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There are quite a few places where we&#39;ll want to use <code>empty</code> because there&#39;s no real allocation to talk about but <code>null</code> would make the compiler do bad things.</span>私たちが<code>empty</code>を使用したい場所はかなりあります。なぜなら、実際の割り当ては話せませんが、 <code>null</code>はコンパイラに悪いことをさせるからです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So:</span>そう：</span> </p><br><div data-lang=rust,ignore><div data-l="#![feature(alloc, heap_api)]"></div><div data-l=""></div><div data-l="use std::mem;"></div><div data-l=""></div><div data-l="impl&lt;T&gt; Vec&lt;T&gt; {"></div><div data-l="    fn new() -&gt; Self {"></div><div data-l="        assert!(mem::size_of::&lt;T&gt;() != 0, &quot;We're not ready to handle ZSTs&quot;);"></div><div data-l="        Vec { ptr: Unique::empty(), len: 0, cap: 0 }"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">I slipped in that assert there because zero-sized types will require some special handling throughout our code, and I want to defer the issue for now.</span>ゼロサイズの型はコード全体で特別な処理を必要とするので、私はそこで主張していますが、今はその問題を延期したいと思います。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Without this assert, some of our early drafts will do some Very Bad Things.</span>この主張がなければ、私たちの初期ドラフトのいくつかは非常に悪いことをするでしょう。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Next we need to figure out what to actually do when we <i>do</i> want space.</span>次に私たちは宇宙をしたい<i>ん</i>ときに実際に何をすべきかを把握する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For that, we&#39;ll need to use the rest of the heap APIs.</span>そのためには、残りのヒープAPIを使用する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These basically allow us to talk directly to Rust&#39;s allocator (jemalloc by default).</span>これらは、基本的に私たちがRustのアロケータ（デフォルトではjemalloc）と直接話すことを可能にします。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ll also need a way to handle out-of-memory (OOM) conditions.</span>また、メモリ不足（OOM）条件を処理する方法も必要です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The standard library calls <code>std::alloc::oom()</code> , which in turn calls the the <code>oom</code> langitem.</span>標準ライブラリは<code>std::alloc::oom()</code>を呼び出し、 <code>oom</code> langitemを呼び出します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">By default this just aborts the program by executing an illegal cpu instruction.</span>デフォルトでは、これは不正なcpu命令を実行することによってプログラムを中止します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The reason we abort and don&#39;t panic is because unwinding can cause allocations to happen, and that seems like a bad thing to do when your allocator just came back with &quot;hey I don&#39;t have any more memory&quot;.</span>私たちが中止して慌てない理由は、巻き戻しが割り振りを引き起こす可能性があるからです。アロケータがちょうど「これ以上の記憶を持っていません」と戻ってきたとき、それは悪いことです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Of course, this is a bit silly since most platforms don&#39;t actually run out of memory in a conventional way.</span>もちろん、これはちょっとばかげています。これは、ほとんどのプラットフォームでは、従来の方法で実際にメモリが使い果たされていないからです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Your operating system will probably kill the application by another means if you legitimately start using up all the memory.</span>合法的にすべてのメモリを使い切ってしまうと、あなたのオペレーティングシステムはおそらく別の手段でアプリケーションを強制終了します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The most likely way we&#39;ll trigger OOM is by just asking for ludicrous quantities of memory at once (eg half the theoretical address space).</span>私たちがOOMを起動させる最も可能性のある方法は、一度に奇妙な量のメモリ（例えば、理論上のアドレス空間の半分）を求めることだけです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As such it&#39;s <i>probably</i> fine to panic and nothing bad will happen.</span>このように恐慌するの<i>は</i>大丈夫ですが、悪いことは起こりません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Still, we&#39;re trying to be like the standard library as much as possible, so we&#39;ll just kill the whole program.</span>それでも、私たちはできるだけ標準ライブラリのようにしようとしているので、プログラム全体を殺すだけです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Okay, now we can write growing.</span>さて、今私たちは成長を書くことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Roughly, we want to have this logic:</span>おおよそ、私たちはこの論理を持ちたいと思っています：</span> </p><br><div data-lang=text><div data-l="if cap == 0:"></div><div data-l="    allocate()"></div><div data-l="    cap = 1"></div><div data-l=else:></div><div data-l="    reallocate()"></div><div data-l="    cap *= 2"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But Rust&#39;s only supported allocator API is so low level that we&#39;ll need to do a fair bit of extra work.</span>しかし、RustのサポートされているアロケータAPIは低レベルなので、かなりの余分な作業をする必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We also need to guard against some special conditions that can occur with really large allocations or empty allocations.</span>また、本当に大量の割り当てや空の割り当てで発生する可能性のある特殊な条件に対しても警戒する必要があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In particular, <code>ptr::offset</code> will cause us a lot of trouble, because it has the semantics of LLVM&#39;s GEP inbounds instruction.</span>特に、 <code>ptr::offset</code>は、LLVMのGEPインバウンド命令のセマンティクスを持っているため、私たちに多くの問題を引き起こします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you&#39;re fortunate enough to not have dealt with this instruction, here&#39;s the basic story with GEP: alias analysis, alias analysis, alias analysis.</span>あなたがこの命令を扱っていないほど幸運であれば、GEPの基本的な話はエイリアス分析、エイリアス分析、エイリアス分析です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It&#39;s super important to an optimizing compiler to be able to reason about data dependencies and aliasing.</span>データの依存関係やエイリアシングを推論できるように最適化コンパイラにとって非常に重要です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As a simple example, consider the following fragment of code:</span>簡単な例として、次のコードを考えてみましょう。</span> </p><br><div data-lang=rust><div data-l="# let x = &amp;mut 0;"></div><div data-l="# let y = &amp;mut 0;"></div><div data-l="*x *= 7;"></div><div data-l="*y *= 3;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If the compiler can prove that <code>x</code> and <code>y</code> point to different locations in memory, the two operations can in theory be executed in parallel (by eg loading them into different registers and working on them independently).</span>コンパイラが<code>x</code>と<code>y</code>がメモリ内の別の場所を指していることを証明できれば、理論的には2つの演算を並列に実行することができます（別々のレジスタにロードして独立に処理するなど）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However the compiler can&#39;t do this in general because if x and y point to the same location in memory, the operations need to be done to the same value, and they can&#39;t just be merged afterwards.</span>しかし、コンパイラは一般にこれを行うことはできません。なぜなら、xとyがメモリ内の同じ場所を指す場合、操作は同じ値にする必要があり、後でマージすることはできないからです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When you use GEP inbounds, you are specifically telling LLVM that the offsets you&#39;re about to do are within the bounds of a single &quot;allocated&quot; entity.</span> GEPインバウンドを使用するときは、あなたがしようとしているオフセットが単一の「割り当て済み」エンティティの範囲内にあることをLLVMに具体的に伝えています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The ultimate payoff being that LLVM can assume that if two pointers are known to point to two disjoint objects, all the offsets of those pointers are <i>also</i> known to not alias (because you won&#39;t just end up in some random place in memory).</span> LLVMは、2つのポインタが2つのディスジョイントオブジェクトを指すことがわかっている場合、それらのポインタのすべてのオフセット<i>も</i>エイリアスではないことがわかっているということができます（メモリのランダムな場所で終わるわけではないため）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">LLVM is heavily optimized to work with GEP offsets, and inbounds offsets are the best of all, so it&#39;s important that we use them as much as possible.</span> LLVMはGEPオフセットを扱うために大きく最適化されており、インバウンドオフセットが最善であるため、可能な限り使用することが重要です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So that&#39;s what GEP&#39;s about, how can it cause us trouble?</span>そういうわけで、GEPはどういう意味ですか、それがどうやって私たちのトラブルを引き起こすのですか？</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The first problem is that we index into arrays with unsigned integers, but GEP (and as a consequence <code>ptr::offset</code> ) takes a signed integer.</span>最初の問題は、符号なし整数で配列にインデックスを付けることですが、GEP（および結果として<code>ptr::offset</code> ）は符号付き整数をとります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This means that half of the seemingly valid indices into an array will overflow GEP and actually go in the wrong direction!</span>これは、一見アレイの有効なインデックスの半分がGEPをオーバーフローし、実際に間違った方向に向かうことを意味します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As such we must limit all allocations to <code>isize::MAX</code> elements.</span>したがって、すべての割り当てを<code>isize::MAX</code>要素に限定する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This actually means we only need to worry about byte-sized objects, because eg <code>&gt; isize::MAX</code> <code>u16</code> s will truly exhaust all of the system&#39;s memory.</span>実際には、 <code>&gt; isize::MAX</code> <code>u16</code> sは本当にシステムのすべてのメモリを<code>&gt; isize::MAX</code>ため、バイトサイズのオブジェクトについて心配する必要があるだけです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However in order to avoid subtle corner cases where someone reinterprets some array of <code>&lt; isize::MAX</code> objects as bytes, std limits all allocations to <code>isize::MAX</code> bytes.</span>しかし、 <code>&lt; isize::MAX</code>オブジェクトのある配列をバイトとして再解釈する微妙なコーナーケースを避けるために、stdはすべての割り当てを<code>isize::MAX</code>バイトに制限します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">On all 64-bit targets that Rust currently supports we&#39;re artificially limited to significantly less than all 64 bits of the address space (modern x64 platforms only expose 48-bit addressing), so we can rely on just running out of memory first.</span> Rustが現在サポートしているすべての64ビットターゲットでは、人為的にアドレス空間の64ビットすべてよりも大幅に制限されています（最新のx64プラットフォームでは48ビットのアドレス指定のみが公開されています）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However on 32-bit targets, particularly those with extensions to use more of the address space (PAE x86 or x32), it&#39;s theoretically possible to successfully allocate more than <code>isize::MAX</code> bytes of memory.</span>しかし、32ビットターゲット、特にアドレス空間（PAE x86またはx32）の多くを使用する拡張機能を持つターゲットでは、 <code>isize::MAX</code>バイト以上のメモリを正常に割り当てることは理論的に可能です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However since this is a tutorial, we&#39;re not going to be particularly optimal here, and just unconditionally check, rather than use clever platform-specific <code>cfg</code> s.</span>しかし、これはチュートリアルなので、プラットフォーム固有の巧妙な<code>cfg</code>使用するのではなく、ここでは特に最適化するつもりはなく、無条件にチェックするだけです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The other corner-case we need to worry about is empty allocations.</span>私たちが心配する必要があるもう一つのケースは空の割り当てです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There will be two kinds of empty allocations we need to worry about: <code>cap = 0</code> for all T, and <code>cap &gt; 0</code> for zero-sized types.</span>私たちが心配する必要がある2種類の空割当てがあります。すべてのTに対して<code>cap = 0</code> <code>cap &gt; 0</code> 、ゼロサイズのタイプに対して<code>cap &gt; 0</code>です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These cases are tricky because they come down to what LLVM means by &quot;allocated&quot;.</span>これらのケースは、LLVMが意味するものが「割り当てられた」ものであるため、扱いにくいものです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">LLVM&#39;s notion of an allocation is significantly more abstract than how we usually use it.</span> LLVMの配分という概念は、我々が通常それを使用する方法よりもはるかに抽象的です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because LLVM needs to work with different languages&#39; semantics and custom allocators, it can&#39;t really intimately understand allocation.</span> LLVMは異なる言語のセマンティクスとカスタムアロケータで動作する必要があるため、割り当てを本当に親密に理解することはできません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Instead, the main idea behind allocation is &quot;doesn&#39;t overlap with other stuff&quot;.</span>代わりに、割り当ての背後にある主なアイデアは「他のものと重複しない」ことです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That is, heap allocations, stack allocations, and globals don&#39;t randomly overlap.</span>つまり、ヒープ割り当て、スタック割り当て、およびグローバルはランダムに重複しません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Yep, it&#39;s about alias analysis.</span>はい、エイリアス分析についてです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As such, Rust can technically play a bit fast and loose with the notion of an allocation as long as it&#39;s <i>consistent</i> .</span>このように、Rustは、 <i>一貫し</i>ている限り、割当の概念を用いて技術的には少し速くて緩やかに演奏することができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Getting back to the empty allocation case, there are a couple of places where we want to offset by 0 as a consequence of generic code.</span>空の割り当てケースに戻って、ジェネリックコードの結果として0でオフセットしたい場所がいくつかあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The question is then: is it consistent to do so?</span>問題は次のようなものです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For zero-sized types, we have concluded that it is indeed consistent to do a GEP inbounds offset by an arbitrary number of elements.</span>ゼロサイズの型については、任意の数の要素によってGEPのインバウンドオフセットが実際に一貫していると結論付けました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is a runtime no-op because every element takes up no space, and it&#39;s fine to pretend that there&#39;s infinite zero-sized types allocated at <code>0x01</code> .</span>これは実行時の操作ではありません。なぜなら、すべての要素がスペースを取らず、無限のゼロサイズの型が<code>0x01</code>割り当てられているように<code>0x01</code>ません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">No allocator will ever allocate that address, because they won&#39;t allocate <code>0x00</code> and they generally allocate to some minimal alignment higher than a byte.</span>アロケータは<code>0x00</code>を割り振らず、一般に1バイト以上の最小アラインメントに割り当てるため、アロケータはそのアドレスを割り当てません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Also generally the whole first page of memory is protected from being allocated anyway (a whole 4k, on many platforms).</span>また、メモリの最初のページ全体は、とにかく割り当てられないように保護されています（多くのプラットフォームで4k全体）。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However what about for positive-sized types?</span>しかし、正のサイズのタイプはどうですか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That one&#39;s a bit trickier.</span>それは少しトリッキーです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In principle, you can argue that offsetting by 0 gives LLVM no information: either there&#39;s an element before the address or after it, but it can&#39;t know which.</span>原則として、0でオフセットするとLLVMに情報が与えられないと主張することができます。住所の前または後に要素がありますが、どちらがどちらかを知ることはできません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However we&#39;ve chosen to conservatively assume that it may do bad things.</span>しかし、私たちは、それが悪いことをするかもしれないと控えめに仮定しました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As such we will guard against this case explicitly.</span>このように、我々はこの事件に対して明白に警戒する。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><i>Phew</i></span> <i>Phew</i></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Ok with all the nonsense out of the way, let&#39;s actually allocate some memory:</span>さて、すべてのナンセンスで、実際にいくつかのメモリを割り当てましょう：</span> </p><br><div data-lang=rust,ignore><div data-l="use std::alloc::oom;"></div><div data-l=""></div><div data-l="fn grow(&amp;mut self) {"></div><div data-l="#    // this is all pretty delicate, so let's say it's all unsafe"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">this is all pretty delicate, so let&#39;s say it&#39;s all unsafe</span>これはすべてかなり繊細なので、すべて安全ではないと言いましょう</span> </div><div data-l="    unsafe {"></div><div data-l="#        // current API requires us to specify size and alignment manually."></div><div data-l="        // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">current API requires us to specify size and alignment manually.</span>現在のAPIでは、手動でサイズと配置を指定する必要があります。</span> </div><div data-l="        let align = mem::align_of::&lt;T&gt;();"></div><div data-l="        let elem_size = mem::size_of::&lt;T&gt;();"></div><div data-l=""></div><div data-l="        let (new_cap, ptr) = if self.cap == 0 {"></div><div data-l="            let ptr = heap::allocate(elem_size, align);"></div><div data-l="            (1, ptr)"></div><div data-l="        } else {"></div><div data-l="#            // as an invariant, we can assume that `self.cap &lt; isize::MAX`,"></div><div data-l="#            // so this doesn't need to be checked."></div><div data-l="            // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">as an invariant, we can assume that <code>self.cap &lt; isize::MAX</code> , so this doesn&#39;t need to be checked.</span> invariantとして、 <code>self.cap &lt; isize::MAX</code>と仮定できるので、これはチェックする必要はありません。</span> </div><div data-l="            let new_cap = self.cap * 2;"></div><div data-l="#            // Similarly this can't overflow due to previously allocating this"></div><div data-l="            // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Similarly this can&#39;t overflow due to previously allocating this</span>同様に、これを以前に割り当てたためにオーバーフローすることはありません</span> </div><div data-l="            let old_num_bytes = self.cap * elem_size;"></div><div data-l=""></div><div data-l="#            // check that the new allocation doesn't exceed `isize::MAX` at all"></div><div data-l="#            // regardless of the actual size of the capacity. This combines the"></div><div data-l="#            // `new_cap &lt;= isize::MAX` and `new_num_bytes &lt;= usize::MAX` checks"></div><div data-l="#            // we need to make. We lose the ability to allocate e.g. 2/3rds of"></div><div data-l="#            // the address space with a single Vec of i16's on 32-bit though."></div><div data-l="#            // Alas, poor Yorick -- I knew him, Horatio."></div><div data-l="            // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">check that the new allocation doesn&#39;t exceed <code>isize::MAX</code> at all regardless of the actual size of the capacity.</span>容量の実際のサイズに関係なく、新しい割り当てが<code>isize::MAX</code>を超えないことを確認してください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This combines the <code>new_cap &lt;= isize::MAX</code> and <code>new_num_bytes &lt;= usize::MAX</code> checks we need to make.</span>これは、 <code>new_cap &lt;= isize::MAX</code>と<code>new_num_bytes &lt;= usize::MAX</code>チェックを<code>new_num_bytes &lt;= usize::MAX</code>て行います。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We lose the ability to allocate eg 2/3rds of the address space with a single Vec of i16&#39;s on 32-bit though.</span>私たちは32ビットでi16の1つのVecで例えばアドレス空間の2/3を割り当てる能力を失う。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Alas, poor Yorick -- I knew him, Horatio.</span>ああ、貧しいヨリック - 私は彼を知っていた、ホラティオ。</span> </div><div data-l="            assert!(old_num_bytes &lt;= (::std::isize::MAX as usize) / 2,"></div><div data-l="                    &quot;capacity overflow&quot;);"></div><div data-l=""></div><div data-l="            let new_num_bytes = old_num_bytes * 2;"></div><div data-l="            let ptr = heap::reallocate(self.ptr.as_ptr() as *mut _,"></div><div data-l="                                        old_num_bytes,"></div><div data-l="                                        new_num_bytes,"></div><div data-l="                                        align);"></div><div data-l="            (new_cap, ptr)"></div><div data-l="        };"></div><div data-l=""></div><div data-l="#        // If allocate or reallocate fail, we'll get `null` back"></div><div data-l="        // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If allocate or reallocate fail, we&#39;ll get <code>null</code> back</span> allocateまたはreallocateが失敗すると、 <code>null</code>戻されます。</span> </div><div data-l="        if ptr.is_null() { oom(); }"></div><div data-l=""></div><div data-l="        self.ptr = Unique::new(ptr as *mut _);"></div><div data-l="        self.cap = new_cap;"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Nothing particularly tricky here.</span>ここで特に難しいものはありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Just computing sizes and alignments and doing some careful multiplication checks.</span>ちょうどサイズとアラインメントを計算し、慎重な乗算チェックを行います。</span> </p><br><script>_addload(function(){_setupIW('com');_csi('en','ja','vec-alloc.html');});</script>