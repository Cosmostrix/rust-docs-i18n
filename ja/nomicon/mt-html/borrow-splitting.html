<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180723_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=borrow-splitting.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Splitting Borrows</span>分割借り</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The mutual exclusion property of mutable references can be very limiting when working with a composite structure.</span>変更可能な参照の相互排除プロパティは、複合構造を使用して作業する場合、非常に制限される可能性があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The borrow checker understands some basic stuff, but will fall over pretty easily.</span>借用チェッカーはいくつかの基本的なことを理解していますが、かなり簡単に落ちます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It does understand structs sufficiently to know that it&#39;s possible to borrow disjoint fields of a struct simultaneously.</span>それは構造体の独立したフィールドを同時に借りることが可能であることを知るために構造体を十分に理解しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So this works today:</span>それで今日はうまくいく：</span> </p><br><div data-lang=rust><div data-l="struct Foo {"></div><div data-l="    a: i32,"></div><div data-l="    b: i32,"></div><div data-l="    c: i32,"></div><div data-l=}></div><div data-l=""></div><div data-l="let mut x = Foo {a: 0, b: 0, c: 0};"></div><div data-l="let a = &amp;mut x.a;"></div><div data-l="let b = &amp;mut x.b;"></div><div data-l="let c = &amp;x.c;"></div><div data-l="*b += 1;"></div><div data-l="let c2 = &amp;x.c;"></div><div data-l="*a += 10;"></div><div data-l="println!(&quot;{} {} {} {}&quot;, a, b, c, c2);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However borrowck doesn&#39;t understand arrays or slices in any way, so this doesn&#39;t work:</span>しかし、borrowckは何らかの形で配列やスライスを理解していないので、これはうまくいきません：</span> </p><br><div data-lang=rust,ignore><div data-l="let mut x = [1, 2, 3];"></div><div data-l="let a = &amp;mut x[0];"></div><div data-l="let b = &amp;mut x[1];"></div><div data-l="println!(&quot;{} {}&quot;, a, b);"></div></div><br><div data-lang=text><div data-l="&lt;anon&gt;:4:14: 4:18 error: cannot borrow `x[..]` as mutable more than once at a time"></div><div data-l="&lt;anon&gt;:4 let b = &amp;mut x[1];"></div><div data-l="                      ^~~~"></div><div data-l="&lt;anon&gt;:3:14: 3:18 note: previous borrow of `x[..]` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `x[..]` until the borrow ends"></div><div data-l="&lt;anon&gt;:3 let a = &amp;mut x[0];"></div><div data-l="                      ^~~~"></div><div data-l="&lt;anon&gt;:6:2: 6:2 note: previous borrow ends here"></div><div data-l="&lt;anon&gt;:1 fn main() {"></div><div data-l="&lt;anon&gt;:2 let mut x = [1, 2, 3];"></div><div data-l="&lt;anon&gt;:3 let a = &amp;mut x[0];"></div><div data-l="&lt;anon&gt;:4 let b = &amp;mut x[1];"></div><div data-l="&lt;anon&gt;:5 println!(&quot;{} {}&quot;, a, b);"></div><div data-l="&lt;anon&gt;:6 }"></div><div data-l="         ^"></div><div data-l="error: aborting due to 2 previous errors"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">While it was plausible that borrowck could understand this simple case, it&#39;s pretty clearly hopeless for borrowck to understand disjointness in general container types like a tree, especially if distinct keys actually <i>do</i> map to the same value.</span>借り手がこの単純なケースを理解することは可能ですが、特に、別個のキーが実際に同じ値にマップされている場合は、借り手がツリーのような一般的なコンテナタイプのディスジョイントを理解することは明らかに望ましくあり<i>ません</i> 。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In order to &quot;teach&quot; borrowck that what we&#39;re doing is ok, we need to drop down to unsafe code.</span>私たちがやっていることが大丈夫だということを借り手に教えるには、安全でないコードに落とす必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For instance, mutable slices expose a <code>split_at_mut</code> function that consumes the slice and returns two mutable slices.</span>例えば、可変スライスは、スライスを消費し、2つの可変スライスを返す<code>split_at_mut</code>関数を公開します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">One for everything to the left of the index, and one for everything to the right.</span> 1つはインデックスの左側にあり、もう1つはすべて右側にあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Intuitively we know this is safe because the slices don&#39;t overlap, and therefore alias.</span>直感的にわかるように、スライスは重複しないため、エイリアスは安全です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However the implementation requires some unsafety:</span>しかし、実装には、いくつかの安全性が要求されます。</span> </p><br><div data-lang=rust,ignore><div data-l="fn split_at_mut(&amp;mut self, mid: usize) -&gt; (&amp;mut [T], &amp;mut [T]) {"></div><div data-l="    let len = self.len();"></div><div data-l="    let ptr = self.as_mut_ptr();"></div><div data-l="    assert!(mid &lt;= len);"></div><div data-l="    unsafe {"></div><div data-l="        (from_raw_parts_mut(ptr, mid),"></div><div data-l="         from_raw_parts_mut(ptr.offset(mid as isize), len - mid))"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is actually a bit subtle.</span>これは実際には少し微妙です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So as to avoid ever making two <code>&amp;mut</code> &#39;s to the same value, we explicitly construct brand-new slices through raw pointers.</span> 2つの<code>&amp;mut</code>同じ値にすることを避けるために、我々は明示的に生ポインタを使って真新しいスライスを構築します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However more subtle is how iterators that yield mutable references work.</span>しかし、より微妙なことは、変更可能な参照を生成するイテレータがどのように機能するかです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The iterator trait is defined as follows:</span>イテレータの特性は次のように定義されます。</span> </p><br><div data-lang=rust><div data-l="trait Iterator {"></div><div data-l="    type Item;"></div><div data-l=""></div><div data-l="    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Given this definition, Self::Item has <i>no</i> connection to <code>self</code> .</span>この定義が与えられると、Self :: Itemは<code>self</code>へ<i>の</i>接続を持ち<i>ません</i> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This means that we can call <code>next</code> several times in a row, and hold onto all the results <i>concurrently</i> .</span>つまり、 <code>next</code>の行を何度も呼び出すことができ、すべての結果を<i>同時に</i>保持することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is perfectly fine for by-value iterators, which have exactly these semantics.</span>これは正確にこれらのセマンティクスを持つバイナリイテレータにとってはまったく問題ありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It&#39;s also actually fine for shared references, as they admit arbitrarily many references to the same thing (although the iterator needs to be a separate object from the thing being shared).</span>実際には共有参照の場合も同じですが、同じことを複数の参照にすることは可能です（ただし、イテレータは共有オブジェクトとは別のオブジェクトである必要があります）。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But mutable references make this a mess.</span>しかし、変更可能な参照はこれを混乱させます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">At first glance, they might seem completely incompatible with this API, as it would produce multiple mutable references to the same object!</span>一見すると、同じオブジェクトへの複数の変更可能な参照を生成するため、このAPIと完全に互換性がないように見えるかもしれません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However it actually <i>does</i> work, exactly because iterators are one-shot objects.</span>しかし、イテレータはワンショットオブジェクトなので、実際に<i>は</i>動作します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Everything an IterMut yields will be yielded at most once, so we don&#39;t actually ever yield multiple mutable references to the same piece of data.</span> IterMutがもたらすすべてのものはたかだか1回しか返されないので、同じデータに複数の可変参照を実際に渡すことはありません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Perhaps surprisingly, mutable iterators don&#39;t require unsafe code to be implemented for many types!</span>多分、驚くべきことに、可変反復子は、安全でないコードを多くの型に対して実装する必要はありません！</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For instance here&#39;s a singly linked list:</span>例えば、ここには単独でリンクされたリストがあります：</span> </p><br><div data-lang=rust><div data-l="# fn main() {}"></div><div data-l="type Link&lt;T&gt; = Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;;"></div><div data-l=""></div><div data-l="struct Node&lt;T&gt; {"></div><div data-l="    elem: T,"></div><div data-l="    next: Link&lt;T&gt;,"></div><div data-l=}></div><div data-l=""></div><div data-l="pub struct LinkedList&lt;T&gt; {"></div><div data-l="    head: Link&lt;T&gt;,"></div><div data-l=}></div><div data-l=""></div><div data-l="pub struct IterMut&lt;'a, T: 'a&gt;(Option&lt;&amp;'a mut Node&lt;T&gt;&gt;);"></div><div data-l=""></div><div data-l="impl&lt;T&gt; LinkedList&lt;T&gt; {"></div><div data-l="    fn iter_mut(&amp;mut self) -&gt; IterMut&lt;T&gt; {"></div><div data-l="        IterMut(self.head.as_mut().map(|node| &amp;mut **node))"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="impl&lt;'a, T&gt; Iterator for IterMut&lt;'a, T&gt; {"></div><div data-l="    type Item = &amp;'a mut T;"></div><div data-l=""></div><div data-l="    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {"></div><div data-l="        self.0.take().map(|node| {"></div><div data-l="            self.0 = node.next.as_mut().map(|node| &amp;mut **node);"></div><div data-l="            &amp;mut node.elem"></div><div data-l="        })"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here&#39;s a mutable slice:</span>ここには可変スライスがあります：</span> </p><br><div data-lang=rust><div data-l="# fn main() {}"></div><div data-l="use std::mem;"></div><div data-l=""></div><div data-l="pub struct IterMut&lt;'a, T: 'a&gt;(&amp;'a mut[T]);"></div><div data-l=""></div><div data-l="impl&lt;'a, T&gt; Iterator for IterMut&lt;'a, T&gt; {"></div><div data-l="    type Item = &amp;'a mut T;"></div><div data-l=""></div><div data-l="    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {"></div><div data-l="        let slice = mem::replace(&amp;mut self.0, &amp;mut []);"></div><div data-l="        if slice.is_empty() { return None; }"></div><div data-l=""></div><div data-l="        let (l, r) = slice.split_at_mut(1);"></div><div data-l="        self.0 = r;"></div><div data-l="        l.get_mut(0)"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="impl&lt;'a, T&gt; DoubleEndedIterator for IterMut&lt;'a, T&gt; {"></div><div data-l="    fn next_back(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {"></div><div data-l="        let slice = mem::replace(&amp;mut self.0, &amp;mut []);"></div><div data-l="        if slice.is_empty() { return None; }"></div><div data-l=""></div><div data-l="        let new_len = slice.len() - 1;"></div><div data-l="        let (l, r) = slice.split_at_mut(new_len);"></div><div data-l="        self.0 = l;"></div><div data-l="        r.get_mut(0)"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">And here&#39;s a binary tree:</span>ここにバイナリツリーがあります：</span> </p><br><div data-lang=rust><div data-l="# fn main() {}"></div><div data-l="use std::collections::VecDeque;"></div><div data-l=""></div><div data-l="type Link&lt;T&gt; = Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;;"></div><div data-l=""></div><div data-l="struct Node&lt;T&gt; {"></div><div data-l="    elem: T,"></div><div data-l="    left: Link&lt;T&gt;,"></div><div data-l="    right: Link&lt;T&gt;,"></div><div data-l=}></div><div data-l=""></div><div data-l="pub struct Tree&lt;T&gt; {"></div><div data-l="    root: Link&lt;T&gt;,"></div><div data-l=}></div><div data-l=""></div><div data-l="struct NodeIterMut&lt;'a, T: 'a&gt; {"></div><div data-l="    elem: Option&lt;&amp;'a mut T&gt;,"></div><div data-l="    left: Option&lt;&amp;'a mut Node&lt;T&gt;&gt;,"></div><div data-l="    right: Option&lt;&amp;'a mut Node&lt;T&gt;&gt;,"></div><div data-l=}></div><div data-l=""></div><div data-l="enum State&lt;'a, T: 'a&gt; {"></div><div data-l="    Elem(&amp;'a mut T),"></div><div data-l="    Node(&amp;'a mut Node&lt;T&gt;),"></div><div data-l=}></div><div data-l=""></div><div data-l="pub struct IterMut&lt;'a, T: 'a&gt;(VecDeque&lt;NodeIterMut&lt;'a, T&gt;&gt;);"></div><div data-l=""></div><div data-l="impl&lt;T&gt; Tree&lt;T&gt; {"></div><div data-l="    pub fn iter_mut(&amp;mut self) -&gt; IterMut&lt;T&gt; {"></div><div data-l="        let mut deque = VecDeque::new();"></div><div data-l="        self.root.as_mut().map(|root| deque.push_front(root.iter_mut()));"></div><div data-l="        IterMut(deque)"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="impl&lt;T&gt; Node&lt;T&gt; {"></div><div data-l="    pub fn iter_mut(&amp;mut self) -&gt; NodeIterMut&lt;T&gt; {"></div><div data-l="        NodeIterMut {"></div><div data-l="            elem: Some(&amp;mut self.elem),"></div><div data-l="            left: self.left.as_mut().map(|node| &amp;mut **node),"></div><div data-l="            right: self.right.as_mut().map(|node| &amp;mut **node),"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l=""></div><div data-l="impl&lt;'a, T&gt; Iterator for NodeIterMut&lt;'a, T&gt; {"></div><div data-l="    type Item = State&lt;'a, T&gt;;"></div><div data-l=""></div><div data-l="    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {"></div><div data-l="        match self.left.take() {"></div><div data-l="            Some(node) =&gt; Some(State::Node(node)),"></div><div data-l="            None =&gt; match self.elem.take() {"></div><div data-l="                Some(elem) =&gt; Some(State::Elem(elem)),"></div><div data-l="                None =&gt; match self.right.take() {"></div><div data-l="                    Some(node) =&gt; Some(State::Node(node)),"></div><div data-l="                    None =&gt; None,"></div><div data-l="                }"></div><div data-l="            }"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="impl&lt;'a, T&gt; DoubleEndedIterator for NodeIterMut&lt;'a, T&gt; {"></div><div data-l="    fn next_back(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {"></div><div data-l="        match self.right.take() {"></div><div data-l="            Some(node) =&gt; Some(State::Node(node)),"></div><div data-l="            None =&gt; match self.elem.take() {"></div><div data-l="                Some(elem) =&gt; Some(State::Elem(elem)),"></div><div data-l="                None =&gt; match self.left.take() {"></div><div data-l="                    Some(node) =&gt; Some(State::Node(node)),"></div><div data-l="                    None =&gt; None,"></div><div data-l="                }"></div><div data-l="            }"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="impl&lt;'a, T&gt; Iterator for IterMut&lt;'a, T&gt; {"></div><div data-l="    type Item = &amp;'a mut T;"></div><div data-l="    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {"></div><div data-l="        loop {"></div><div data-l="            match self.0.front_mut().and_then(|node_it| node_it.next()) {"></div><div data-l="                Some(State::Elem(elem)) =&gt; return Some(elem),"></div><div data-l="                Some(State::Node(node)) =&gt; self.0.push_front(node.iter_mut()),"></div><div data-l="                None =&gt; if let None = self.0.pop_front() { return None },"></div><div data-l="            }"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="impl&lt;'a, T&gt; DoubleEndedIterator for IterMut&lt;'a, T&gt; {"></div><div data-l="    fn next_back(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {"></div><div data-l="        loop {"></div><div data-l="            match self.0.back_mut().and_then(|node_it| node_it.next_back()) {"></div><div data-l="                Some(State::Elem(elem)) =&gt; return Some(elem),"></div><div data-l="                Some(State::Node(node)) =&gt; self.0.push_back(node.iter_mut()),"></div><div data-l="                None =&gt; if let None = self.0.pop_back() { return None },"></div><div data-l="            }"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">All of these are completely safe and work on stable Rust!</span>これらのすべては完全に安全で、安定した錆に取り組んでいます！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This ultimately falls out of the simple struct case we saw before: Rust understands that you can safely split a mutable reference into subfields.</span>これは最終的に私が見たシンプルな構造体のケースから逸脱しています。Rustは、可変参照を安全にサブフィールドに分割できることを理解しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can then encode permanently consuming a reference via Options (or in the case of slices, replacing with an empty slice).</span>その後、オプションを使用してリファレンスを消費する（またはスライスの場合は空のスライスに置き換えて）永久にエンコードすることができます。</span> </p><script>_addload(function(){_setupIW('com');_csi('en','ja','borrow-splitting.html');});</script>