<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180723_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=dropck.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Drop Check</span>ドロップチェック</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We have seen how lifetimes provide us some fairly simple rules for ensuring that we never read dangling references.</span>私たちは、生涯がどのように私たちにダングリングリファレンスを読んでいないことを保証するためのかなり簡単なルールを提供しているかを見てきました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However up to this point we have only ever interacted with the <i>outlives</i> relationship in an inclusive manner.</span>しかし、現時点までに包括的な方法で<i>アウトライフの</i>関係と交流してきました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That is, when we talked about <code>&#39;a: &#39;b</code> , it was ok for <code>&#39;a</code> to live <i>exactly</i> as long as <code>&#39;b</code> .</span>それは我々がの話するとき、ある<code>&#39;a: &#39;b</code>のために、それはOKだった<code>&#39;a</code> <i>正確に</i>限り、生きるために<code>&#39;b</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">At first glance, this seems to be a meaningless distinction.</span>一見すると、これは無意味な区別のようです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Nothing ever gets dropped at the same time as another, right?</span>他の時間と同じ時間に落とされることはありませんか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is why we used the following desugaring of <code>let</code> statements:</span>これが、 <code>let</code>文の以下のような理由からです。</span> </p><br><div data-lang=rust,ignore><div data-l="let x;"></div><div data-l="let y;"></div></div><br><div data-lang=rust,ignore><div data-l={></div><div data-l="    let x;"></div><div data-l="    {"></div><div data-l="        let y;"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Each creates its own scope, clearly establishing that one drops before the other.</span>それぞれは独自のスコープを作成し、一方が他方に先んじることを明示します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, what if we do the following?</span>しかし、私たちが次のことをすればどうなるでしょうか？</span> </p><br><div data-lang=rust,ignore><div data-l="let (x, y) = (vec![], vec![]);"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Does either value strictly outlive the other?</span>どちらか一方の値が他方の値よりも長生きしていますか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The answer is in fact <i>no</i> , neither value strictly outlives the other.</span>答えは実際には<i>いいえ</i> 、どちらの値も厳密には他の値よりも長くはなりません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Of course, one of x or y will be dropped before the other, but the actual order is not specified.</span>もちろん、xまたはyのいずれかが他のものの前に落とされますが、実際の順序は指定されません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Tuples aren&#39;t special in this regard;</span>タプルはこの点で特別なものではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">composite structures just don&#39;t guarantee their destruction order as of Rust 1.0.</span>複合構造はRust 1.0の破壊順序を保証するものではありません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We <i>could</i> specify this for the fields of built-in composites like tuples and structs.</span>タプルや構造体のような組み込み複合体のフィールドにこれを指定する<i>ことができ</i>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, what about something like Vec?</span>しかし、Vecのようなものはどうですか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Vec has to manually drop its elements via pure-library code.</span> Vecは純粋なライブラリコードを使って要素を手動でドロップしなければなりません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In general, anything that implements Drop has a chance to fiddle with its innards during its final death knell.</span>一般的に、ドロップを実装するものは、最終的な死の刻みの中で、その内臓とバイディングするチャンスがあります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Therefore the compiler can&#39;t sufficiently reason about the actual destruction order of the contents of any type that implements Drop.</span>したがって、コンパイラは、Dropを実装するすべての型の内容の実際の破棄順序について十分に理由を付けることはできません。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So why do we care?</span>ではなぜ私たちは気にしますか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We care because if the type system isn&#39;t careful, it could accidentally make dangling pointers.</span>タイプシステムが慎重でないと、誤ってペンダントがつぶれてしまう可能性があるので注意してください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Consider the following simple program:</span>以下の簡単なプログラムを考えてみましょう。</span> </p><br><div data-lang=rust><div data-l="struct Inspector&lt;'a&gt;(&amp;'a u8);"></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let (inspector, days);"></div><div data-l="    days = Box::new(1);"></div><div data-l="    inspector = Inspector(&amp;days);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This program is totally sound and compiles today.</span>このプログラムは完全に健全で今日コンパイルされています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The fact that <code>days</code> does not <i>strictly</i> outlive <code>inspector</code> doesn&#39;t matter.</span> <code>days</code>が<i>厳密に</i> <code>inspector</code>よりも長生きしないという事実は重要ではない。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As long as the <code>inspector</code> is alive, so is days.</span> <code>inspector</code>が生きている限り、それは日です。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However if we add a destructor, the program will no longer compile!</span>しかし、デストラクタを追加すると、プログラムはコンパイルされなくなります。</span> </p><br><div data-lang=rust,ignore><div data-l="struct Inspector&lt;'a&gt;(&amp;'a u8);"></div><div data-l=""></div><div data-l="impl&lt;'a&gt; Drop for Inspector&lt;'a&gt; {"></div><div data-l="    fn drop(&amp;mut self) {"></div><div data-l="        println!(&quot;I was only {} days from retirement!&quot;, self.0);"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let (inspector, days);"></div><div data-l="    days = Box::new(1);"></div><div data-l="    inspector = Inspector(&amp;days);"></div><div data-l="#    // Let's say `days` happens to get dropped first."></div><div data-l="#    // Then when Inspector is dropped, it will try to read free'd memory!"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s say <code>days</code> happens to get dropped first.</span>最初に落ちる<code>days</code>があるとしましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Then when Inspector is dropped, it will try to read free&#39;d memory!</span>インスペクタが落とされたら、それは自由なメモリを読み込もうとします！</span> </div><div data-l=}></div></div><br><div data-lang=text><div data-l="error: `days` does not live long enough"></div><div data-l="  --&gt; &lt;anon&gt;:15:1"></div><div data-l="   |"></div><div data-l="12 |     inspector = Inspector(&amp;days);"></div><div data-l="   |                            ---- borrow occurs here"></div><div data-l=...></div><div data-l="15 | }"></div><div data-l="   | ^ `days` dropped here while still borrowed"></div><div data-l="   |"></div><div data-l="   = note: values in a scope are dropped in the opposite order they are created"></div><div data-l=""></div><div data-l="error: aborting due to previous error"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Implementing <code>Drop</code> lets the <code>Inspector</code> execute some arbitrary code during its death.</span> <code>Drop</code>実装することで、 <code>Inspector</code>は死に至る間に任意のコードを実行することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This means it can potentially observe that types that are supposed to live as long as it does actually were destroyed first.</span>つまり、最初に実際に破壊されている限り、生きているはずのタイプを潜在的に観察することができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Interestingly, only generic types need to worry about this.</span>興味深いことに、ジェネリック型だけがこれについて心配する必要があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If they aren&#39;t generic, then the only lifetimes they can harbor are <code>&#39;static</code> , which will truly live <i>forever</i> .</span>彼らが一般的でない場合、彼らが抱くことができる唯一の生涯は<code>&#39;static</code>であり、本当に<i>永遠に</i>生きるでしょ<i>う</i> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is why this problem is referred to as <i>sound generic drop</i> .</span>これが、この問題を<i>健全な一般的なドロップ</i>と呼ぶ理由です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Sound generic drop is enforced by the <i>drop checker</i> .</span>健全な一般的なドロップは、 <i>ドロップチェッカー</i>によって強制されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As of this writing, some of the finer details of how the drop checker validates types is totally up in the air.</span>この記事の執筆時点では、ドロップ・チェッカーがタイプを検証する方法の細かい詳細のいくつかは、全面的に上がっています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However The Big Rule is the subtlety that we have focused on this whole section:</span>しかし、ビッグ・ルールはこの全セクションに焦点を当てた微妙なものです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><b>For a generic type to soundly implement drop, its generics arguments must strictly outlive it.</b></span> <b>ジェネリック型が健全にdropを実装するためには、ジェネリック型の引数は厳密にそれよりも長くなければなりません。</b></span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Obeying this rule is (usually) necessary to satisfy the borrow checker;</span>このルールに従うことは、（通常）借用チェッカーを満たすために必要です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">obeying it is sufficient but not necessary to be sound.</span>それに従うことは十分ですが、健全である必要はありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That is, if your type obeys this rule then it&#39;s definitely sound to drop.</span>つまり、あなたのタイプがこのルールに従えば、間違いなく落ちるはずです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The reason that it is not always necessary to satisfy the above rule is that some Drop implementations will not access borrowed data even though their type gives them the capability for such access.</span>上記のルールを必ずしも満たす必要はないという理由は、Dropの実装によっては、借用されたデータにそのタイプがアクセスできるようになっていてもアクセスできないためです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, this variant of the above <code>Inspector</code> example will never access borrowed data:</span>たとえば、上記の<code>Inspector</code>例のこの変形は、借用したデータには決してアクセスしません。</span> </p><br><div data-lang=rust,ignore><div data-l="struct Inspector&lt;'a&gt;(&amp;'a u8, &amp;'static str);"></div><div data-l=""></div><div data-l="impl&lt;'a&gt; Drop for Inspector&lt;'a&gt; {"></div><div data-l="    fn drop(&amp;mut self) {"></div><div data-l="        println!(&quot;Inspector(_, {}) knows when *not* to inspect.&quot;, self.1);"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let (inspector, days);"></div><div data-l="    days = Box::new(1);"></div><div data-l="    inspector = Inspector(&amp;days, &quot;gadget&quot;);"></div><div data-l="#    // Let's say `days` happens to get dropped first."></div><div data-l="#    // Even when Inspector is dropped, its destructor will not access the"></div><div data-l="#    // borrowed `days`."></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s say <code>days</code> happens to get dropped first.</span>最初に落ちる<code>days</code>があるとしましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Even when Inspector is dropped, its destructor will not access the borrowed <code>days</code> .</span>インスペクタが落とされても、デストラクタは借用<code>days</code>アクセスしません。</span> </div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Likewise, this variant will also never access borrowed data:</span>同様に、この亜種は借用したデータにもアクセスしません。</span> </p><br><div data-lang=rust,ignore><div data-l="use std::fmt;"></div><div data-l=""></div><div data-l="struct Inspector&lt;T: fmt::Display&gt;(T, &amp;'static str);"></div><div data-l=""></div><div data-l="impl&lt;T: fmt::Display&gt; Drop for Inspector&lt;T&gt; {"></div><div data-l="    fn drop(&amp;mut self) {"></div><div data-l="        println!(&quot;Inspector(_, {}) knows when *not* to inspect.&quot;, self.1);"></div><div data-l="    }"></div><div data-l=}></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let (inspector, days): (Inspector&lt;&amp;u8&gt;, Box&lt;u8&gt;);"></div><div data-l="    days = Box::new(1);"></div><div data-l="    inspector = Inspector(&amp;days, &quot;gadget&quot;);"></div><div data-l="#    // Let's say `days` happens to get dropped first."></div><div data-l="#    // Even when Inspector is dropped, its destructor will not access the"></div><div data-l="#    // borrowed `days`."></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s say <code>days</code> happens to get dropped first.</span>最初に落ちる<code>days</code>があるとしましょう。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Even when Inspector is dropped, its destructor will not access the borrowed <code>days</code> .</span>インスペクタが落とされても、デストラクタは借用<code>days</code>アクセスしません。</span> </div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, <i>both</i> of the above variants are rejected by the borrow checker during the analysis of <code>fn main</code> , saying that <code>days</code> does not live long enough.</span>しかし、 <code>fn main</code>の分析中に、上記の<i>両方</i>のバリエーションが借用チェッカーによって拒否され、 <code>days</code>が十分に長くは生きていないと言っています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The reason is that the borrow checking analysis of <code>main</code> does not know about the internals of each <code>Inspector</code> &#39;s <code>Drop</code> implementation.</span>その理由は、 <code>main</code> borrow checkingの分析では、 <code>Inspector</code>の<code>Drop</code>実装の内部についてはわからないからです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As far as the borrow checker knows while it is analyzing <code>main</code> , the body of an inspector&#39;s destructor might access that borrowed data.</span>借用チェッカーが<code>main</code>解析中に知っている限り、インスペクタのデストラクタの本体はその借用したデータにアクセスする可能性があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Therefore, the drop checker forces all borrowed data in a value to strictly outlive that value.</span>したがって、ドロップチェッカーは、すべての借用データを強制的にその値よりも長く維持するようにします。</span> </p><br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">An Escape Hatch</span>エスケープハッチ</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The precise rules that govern drop checking may be less restrictive in the future.</span>ドロップチェックを管理する正確なルールは、今後制限の少ないものになります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The current analysis is deliberately conservative and trivial;</span>現在の分析は、故意に保守的で簡単です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">it forces all borrowed data in a value to outlive that value, which is certainly sound.</span>その値の中のすべての借用データを強制的にその値よりも長くすることを強制します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Future versions of the language may make the analysis more precise, to reduce the number of cases where sound code is rejected as unsafe.</span>将来のバージョンの言語では、サウンドコードが安全でないとして拒否されるケースの数を減らすために、解析をより正確に行うことができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This would help address cases such as the two <code>Inspector</code> s above that know not to inspect during destruction.</span>これは、破壊中に検査しないことを知っている上記の2人の<code>Inspector</code>のような場合に役立ちます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In the meantime, there is an unstable attribute that one can use to assert (unsafely) that a generic type&#39;s destructor is <i>guaranteed</i> to not access any expired data, even if its type gives it the capability to do so.</span>その間に、ジェネリック型のデストラクタは、たとえその型がそれを行う能力を与えても、期限切れのデータにアクセスしないことが<i>保証さ</i>れている（不安全な）ことをアサーションするために使用できる不安定な属性があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That attribute is called <code>may_dangle</code> and was introduced in <a href=#3rfc1327>RFC 1327</a> .</span>その属性は<code>may_dangle</code>と呼ばれ、 <a href=#3rfc1327>RFC 1327で</a>導入され<a href=#3rfc1327>ました</a> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">To deploy it on the <code>Inspector</code> example from above, we would write:</span>上記の<code>Inspector</code>例に展開するには、次のように記述します。</span> </p><br><div data-lang=rust,ignore><div data-l="struct Inspector&lt;'a&gt;(&amp;'a u8, &amp;'static str);"></div><div data-l=""></div><div data-l="unsafe impl&lt;#[may_dangle] 'a&gt; Drop for Inspector&lt;'a&gt; {"></div><div data-l="    fn drop(&amp;mut self) {"></div><div data-l="        println!(&quot;Inspector(_, {}) knows when *not* to inspect.&quot;, self.1);"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Use of this attribute requires the <code>Drop</code> impl to be marked <code>unsafe</code> because the compiler is not checking the implicit assertion that no potentially expired data (eg <code>self.0</code> above) is accessed.</span>この属性を使用すると、コンパイラーは潜在的に期限切れのデータ（上記の<code>self.0</code> ）にアクセスしないという暗黙のアサーションをチェックし<code>unsafe</code>ため、 <code>Drop</code> implが<code>unsafe</code>とマークする必要があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The attribute can be applied to any number of lifetime and type parameters.</span>この属性は、任意の数の生存時間および型パラメータに適用することができる。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In the following example, we assert that we access no data behind a reference of lifetime <code>&#39;b</code> and that the only uses of <code>T</code> will be moves or drops, but omit the attribute from <code>&#39;a</code> and <code>U</code> , because we do access data with that lifetime and that type:</span>次の例では、生存時間<code>&#39;b</code>参照の背後にあるデータにはアクセスしないと主張し、 <code>T</code>の唯一の使用は移動または削除ですが、 <code>&#39;a</code>および<code>&#39;a</code> <code>U</code> <code>&#39;a</code>の属性は省略します。そのタイプ：</span> </p><br><div data-lang=rust,ignore><div data-l="use std::fmt::Display;"></div><div data-l=""></div><div data-l="struct Inspector&lt;'a, 'b, T, U: Display&gt;(&amp;'a u8, &amp;'b u8, T, U);"></div><div data-l=""></div><div data-l="unsafe impl&lt;'a, #[may_dangle] 'b, #[may_dangle] T, U: Display&gt; Drop for Inspector&lt;'a, 'b, T, U&gt; {"></div><div data-l="    fn drop(&amp;mut self) {"></div><div data-l="        println!(&quot;Inspector({}, _, _, {})&quot;, self.0, self.3);"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It is sometimes obvious that no such access can occur, like the case above.</span>上記のようなアクセスが発生しないことが時々明らかです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, when dealing with a generic type parameter, such access can occur indirectly.</span>しかし、ジェネリック型パラメータを扱う場合、そのようなアクセスは間接的に発生する可能性があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Examples of such indirect access are:</span>このような間接アクセスの例は次のとおりです。</span> </p><br><div data-b=" *"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">invoking a callback,</span>コールバックを呼び出す、</span> </div><div data-b=" *"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">via a trait method call.</span> traitメソッド呼び出しを介して</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">(Future changes to the language, such as impl specialization, may add other avenues for such indirect access.)</span> （implの専門化のような将来の言語の変更は、間接的なアクセスのための他の手段を追加する可能性があります。）</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here is an example of invoking a callback:</span>コールバックを呼び出す例を次に示します。</span> </p><br><div data-lang=rust,ignore><div data-l="struct Inspector&lt;T&gt;(T, &amp;'static str, Box&lt;for &lt;'r&gt; fn(&amp;'r T) -&gt; String&gt;);"></div><div data-l=""></div><div data-l="impl&lt;T&gt; Drop for Inspector&lt;T&gt; {"></div><div data-l="    fn drop(&amp;mut self) {"></div><div data-l="#        // The `self.2` call could access a borrow e.g. if `T` is `&amp;'a _`."></div><div data-l="        // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>self.2</code> call could access a borrow eg if <code>T</code> is <code>&amp;&#39;a _</code> .</span> <code>self.2</code>呼び出しは、例えば<code>T</code>が<code>&amp;&#39;a _</code>場合、 <code>self.2</code>アクセスすることができます。</span> </div><div data-l="        println!(&quot;Inspector({}, {}) unwittingly inspects expired data.&quot;,"></div><div data-l="                 (self.2)(&amp;self.0), self.1);"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here is an example of a trait method call:</span>以下は、traitメソッド呼び出しの例です：</span> </p><br><div data-lang=rust,ignore><div data-l="use std::fmt;"></div><div data-l=""></div><div data-l="struct Inspector&lt;T: fmt::Display&gt;(T, &amp;'static str);"></div><div data-l=""></div><div data-l="impl&lt;T: fmt::Display&gt; Drop for Inspector&lt;T&gt; {"></div><div data-l="    fn drop(&amp;mut self) {"></div><div data-l="#        // There is a hidden call to `&lt;T as Display&gt;::fmt` below, which"></div><div data-l="#        // could access a borrow e.g. if `T` is `&amp;'a _`"></div><div data-l="        // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There is a hidden call to <code>&lt;T as Display&gt;::fmt</code> below, which could access a borrow eg if <code>T</code> is <code>&amp;&#39;a _</code></span>下の<code>&lt;T as Display&gt;::fmt</code>への隠し呼び出しがあります。これは、 <code>T</code>が<code>&amp;&#39;a _</code></span> </div><div data-l="        println!(&quot;Inspector({}, {}) unwittingly inspects expired data.&quot;,"></div><div data-l="                 self.0, self.1);"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">And of course, all of these accesses could be further hidden within some other method invoked by the destructor, rather than being written directly within it.</span>もちろん、これらのアクセスはすべて、デストラクタによって呼び出される他のメソッドの中に隠される可能性があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In all of the above cases where the <code>&amp;&#39;a u8</code> is accessed in the destructor, adding the <code>#[may_dangle]</code> attribute makes the type vulnerable to misuse that the borrower checker will not catch, inviting havoc.</span>上記のすべての場合<code>&amp;&#39;a u8</code>がアクセスされた場合、 <code>#[may_dangle]</code>属性を追加すると、借り手のチェッカーがキャッチしないような誤用を受けやすくなります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It is better to avoid adding the attribute.</span>属性の追加を避ける方が良いでしょう。</span> </p><br><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Is that all about drop checker?</span>それはすべてのドロップチェッカーについてですか？</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It turns out that when writing unsafe code, we generally don&#39;t need to worry at all about doing the right thing for the drop checker.</span>安全でないコードを書くときには、一般的に落としチェッカーのための正しいことを心配する必要はありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However there is one special case that you need to worry about, which we will look at in the next section.</span>しかし、あなたが心配する必要がある特別なケースが1つあります。これについては、次のセクションで説明します。</span> </p><br> <a class=notranslate href=#1https://github.com/rust-lang/rfcs/blob/master/text/1327-dropck-param-eyepatch.md>rfc1327</a><script>_addload(function(){_setupIW('com');_csi('en','ja','dropck.html');});</script>