<!DOCTYPE html>
<h1><code>Option</code></h1>
<br>
<p>Sometimes it's desirable to catch the failure of some parts of a program
instead of calling <code>panic€</code>; this can be accomplished using the <code>Option</code> enum.</p>
<br>
<p>The <code>Option&lt;T&gt;</code> enum has two variants:</p>
<br>
<div data-b="*"><code>None</code>, to indicate failure or lack of value, and</div>
<div data-b="*"><code>Some(value)</code>, a tuple struct that wraps a <code>value</code> with type <code>T</code>.</div>
<br>
<div data-lang="rust,editable,ignore,mdbook-runnable"><div data-l="#// An integer division that doesn't `panic!`"></div><div data-l="// ">An integer division that doesn't <code>panic€</code></div><div data-l="fn checked_division(dividend: i32, divisor: i32) -&gt; Option&lt;i32&gt; {"></div><div data-l="    if divisor == 0 {"></div><div data-l="#        // Failure is represented as the `None` variant"></div><div data-l="        // ">Failure is represented as the <code>None</code> variant</div><div data-l="        None"></div><div data-l="    } else {"></div><div data-l="#        // Result is wrapped in a `Some` variant"></div><div data-l="        // ">Result is wrapped in a <code>Some</code> variant</div><div data-l="        Some(dividend / divisor)"></div><div data-l="    }"></div><div data-l="}"></div><div data-l=""></div><div data-l="#// This function handles a division that may not succeed"></div><div data-l="// ">This function handles a division that may not succeed</div><div data-l="fn try_division(dividend: i32, divisor: i32) {"></div><div data-l="#    // `Option` values can be pattern matched, just like other enums"></div><div data-l="    // "><code>Option</code> values can be pattern matched, just like other enums</div><div data-l="    match checked_division(dividend, divisor) {"></div><div data-l="        None =&gt; println!(&quot;{} / {} failed!&quot;, dividend, divisor),"></div><div data-l="        Some(quotient) =&gt; {"></div><div data-l="            println!(&quot;{} / {} = {}&quot;, dividend, divisor, quotient)"></div><div data-l="        },"></div><div data-l="    }"></div><div data-l="}"></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    try_division(4, 2);"></div><div data-l="    try_division(1, 0);"></div><div data-l=""></div><div data-l="#    // Binding `None` to a variable needs to be type annotated"></div><div data-l="    // ">Binding <code>None</code> to a variable needs to be type annotated</div><div data-l="    let none: Option&lt;i32&gt; = None;"></div><div data-l="    let _equivalent_none = None::&lt;i32&gt;;"></div><div data-l=""></div><div data-l="    let optional_float = Some(0f32);"></div><div data-l=""></div><div data-l="#    // Unwrapping a `Some` variant will extract the value wrapped."></div><div data-l="    // ">Unwrapping a <code>Some</code> variant will extract the value wrapped.</div><div data-l="    println!(&quot;{:?} unwraps to {:?}&quot;, optional_float, optional_float.unwrap());"></div><div data-l=""></div><div data-l="#    // Unwrapping a `None` variant will `panic!`"></div><div data-l="    // ">Unwrapping a <code>None</code> variant will <code>panic€</code></div><div data-l="    println!(&quot;{:?} unwraps to {:?}&quot;, none, none.unwrap());"></div><div data-l="}"></div></div>