<!DOCTYPE html>
<h1>Strings</h1>
<br>
<p>There are two types of strings in Rust: <code>String</code> and <code>&amp;str</code>.</p>
<br>
<p>A <code>String</code> is stored as a vector of bytes (<code>Vec&lt;u8&gt;</code>), but guaranteed to
always be a valid UTF-8 sequence. <code>String</code> is heap allocated, growable and not
null terminated.</p>
<br>
<p><code>&amp;str</code> is a slice (<code>&amp;[u8]</code>) that always points to a valid UTF-8 sequence, and
can be used to view into a <code>String</code>, just like <code>&amp;[T]</code> is a view into <code>Vec&lt;T&gt;</code>.</p>
<br>
<div data-lang="rust,editable"><div data-l="fn main() {"></div><div data-l="#    // (all the type annotations are superfluous)"></div><div data-l="#    // A reference to a string allocated in read only memory"></div><div data-l="    // ">(all the type annotations are superfluous) A reference to a string allocated in read only memory</div><div data-l="    let pangram: &amp;'static str = &quot;the quick brown fox jumps over the lazy dog&quot;;"></div><div data-l="    println!(&quot;Pangram: {}&quot;, pangram);"></div><div data-l=""></div><div data-l="#    // Iterate over words in reverse, no new string is allocated"></div><div data-l="    // ">Iterate over words in reverse, no new string is allocated</div><div data-l="    println!(&quot;Words in reverse&quot;);"></div><div data-l="    for word in pangram.split_whitespace().rev() {"></div><div data-l="        println!(&quot;&gt; {}&quot;, word);"></div><div data-l="    }"></div><div data-l=""></div><div data-l="#    // Copy chars into a vector, sort and remove duplicates"></div><div data-l="    // ">Copy chars into a vector, sort and remove duplicates</div><div data-l="    let mut chars: Vec&lt;char&gt; = pangram.chars().collect();"></div><div data-l="    chars.sort();"></div><div data-l="    chars.dedup();"></div><div data-l=""></div><div data-l="#    // Create an empty and growable `String`"></div><div data-l="    // ">Create an empty and growable <code>String</code></div><div data-l="    let mut string = String::new();"></div><div data-l="    for c in chars {"></div><div data-l="#        // Insert a char at the end of string"></div><div data-l="        // ">Insert a char at the end of string</div><div data-l="        string.push(c);"></div><div data-l="#        // Insert a string at the end of string"></div><div data-l="        // ">Insert a string at the end of string</div><div data-l="        string.push_str(&quot;, &quot;);"></div><div data-l="    }"></div><div data-l=""></div><div data-l="#    // The trimmed string is a slice to the original string, hence no new"></div><div data-l="#    // allocation is performed"></div><div data-l="    // ">The trimmed string is a slice to the original string, hence no new allocation is performed</div><div data-l="    let chars_to_trim: &amp;[char] = &amp;[' ', ','];"></div><div data-l="    let trimmed_str: &amp;str = string.trim_matches(chars_to_trim);"></div><div data-l="    println!(&quot;Used characters: {}&quot;, trimmed_str);"></div><div data-l=""></div><div data-l="#    // Heap allocate a string"></div><div data-l="    // ">Heap allocate a string</div><div data-l="    let alice = String::from(&quot;I like dogs&quot;);"></div><div data-l="#    // Allocate new memory and store the modified string there"></div><div data-l="    // ">Allocate new memory and store the modified string there</div><div data-l="    let bob: String = alice.replace(&quot;dog&quot;, &quot;cat&quot;);"></div><div data-l=""></div><div data-l="    println!(&quot;Alice says: {}&quot;, alice);"></div><div data-l="    println!(&quot;Bob says: {}&quot;, bob);"></div><div data-l="}"></div></div>
<br>
<p>More <code>str</code>/<code>String</code> methods can be found under the
<a class="notranslate" href="#3str">std::str</a> and
<a class="notranslate" href="#3string">std::string</a>
modules</p>
<br>
<h2>Literals and escapes</h2>
<br>
<p>There are multiple ways to write string literals with special characters in them.
All result in a similar <code>&amp;str</code> so it's best to use the form that is the most
convenient to write. Similarly there are multiple ways to write byte string literals,
which all result in <code>&amp;[u8; N]</code>.</p>
<br>
<p>Generally special characters are escaped with a backslash character: <code>\</code>.
This way you can add any character to your string, even unprintable ones
and ones that you don't know how to type. If you want a literal backslash,
escape it with another one: <code>\\</code></p>
<br>
<p>String or character literal delimiters occuring within a literal must be escaped: <code>&quot;\&quot;&quot;</code>, <code>'\''</code>.</p>
<br>
<div data-lang="rust,editable"><div data-l="fn main() {"></div><div data-l="#    // You can use escapes to write bytes by their hexadecimal values..."></div><div data-l="    // ">You can use escapes to write bytes by their hexadecimal values...</div><div data-l="    let byte_escape = &quot;I'm writing \x52\x75\x73\x74!&quot;;"></div><div data-l="    println!(&quot;What are you doing\x3F (\\x3F means ?) {}&quot;, byte_escape);"></div><div data-l=""></div><div data-l="#    // ...or Unicode code points."></div><div data-l="    // ">...or Unicode code points.</div><div data-l="    let unicode_codepoint = &quot;\u{211D}&quot;;"></div><div data-l="    let character_name = &quot;\&quot;DOUBLE-STRUCK CAPITAL R\&quot;&quot;;"></div><div data-l=""></div><div data-l="    println!(&quot;Unicode character {} (U+211D) is called {}&quot;,"></div><div data-l="                unicode_codepoint, character_name );"></div><div data-l=""></div><div data-l=""></div><div data-l="    let long_string = &quot;String literals"></div><div data-l="                        can span multiple lines."></div><div data-l="                        The linebreak and indentation here -&gt;\"></div><div data-l="                        &lt;- can be escaped too!&quot;;"></div><div data-l="    println!(&quot;{}&quot;, long_string);"></div><div data-l="}"></div></div>
<br>
<p>Sometimes there are just too many characters that need to be escaped or it's just
much more convenient to write a string out as-is. This is where raw string literals come into play.</p>
<br>
<div data-lang="rust, editable"><div data-l="fn main() {"></div><div data-l="    let raw_str = r&quot;Escapes don't work here: \x3F \u{211D}&quot;;"></div><div data-l="    println!(&quot;{}&quot;, raw_str);"></div><div data-l=""></div><div data-l="#    // If you need quotes in a raw string, add a pair of #s"></div><div data-l="    // ">If you need quotes in a raw string, add a pair of #s</div><div data-l="    let quotes = r#&quot;And then I said: &quot;There is no escape!&quot;&quot;#;"></div><div data-l="    println!(&quot;{}&quot;, quotes);"></div><div data-l=""></div><div data-l="#    // If you need &quot;# in your string, just use more #s in the delimiter."></div><div data-l="#    // There is no limit for the number of #s you can use."></div><div data-l="    // ">If you need &quot;# in your string, just use more #s in the delimiter. There is no limit for the number of #s you can use.</div><div data-l="    let longer_delimiter = r###&quot;A string with &quot;# in it. And even &quot;##!&quot;###;"></div><div data-l="    println!(&quot;{}&quot;, longer_delimiter);"></div><div data-l="}"></div></div>
<br>
<p>Want a string that's not UTF-8? (Remember, <code>str</code> and <code>String</code> must be valid UTF-8)
Or maybe you want an array of bytes that's mostly text? Byte strings to the rescue!</p>
<br>
<div data-lang="rust, editable"><div data-l="use std::str;"></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="#    // Note that this is not actually a &amp;str"></div><div data-l="    // ">Note that this is not actually a &amp;str</div><div data-l="    let bytestring: &amp;[u8; 20] = b&quot;this is a bytestring&quot;;"></div><div data-l=""></div><div data-l="#    // Byte arrays don't have Display so printing them is a bit limited"></div><div data-l="    // ">Byte arrays don't have Display so printing them is a bit limited</div><div data-l="    println!(&quot;A bytestring: {:?}&quot;, bytestring);"></div><div data-l=""></div><div data-l="#    // Bytestrings can have byte escapes..."></div><div data-l="    // ">Bytestrings can have byte escapes...</div><div data-l="    let escaped = b&quot;\x52\x75\x73\x74 as bytes&quot;;"></div><div data-l="#    // ...but no unicode escapes"></div><div data-l="#    // let escaped = b&quot;\u{211D} is not allowed&quot;;"></div><div data-l="    // ">...but no unicode escapes let escaped = b&quot;\u{211D} is not allowed&quot;;</div><div data-l="    println!(&quot;Some escaped bytes: {:?}&quot;, escaped);"></div><div data-l=""></div><div data-l=""></div><div data-l="#    // Raw bytestrings work just like raw strings"></div><div data-l="    // ">Raw bytestrings work just like raw strings</div><div data-l="    let raw_bytestring = br&quot;\u{211D} is not escaped here&quot;;"></div><div data-l="    println!(&quot;{:?}&quot;, raw_bytestring);"></div><div data-l=""></div><div data-l="#    // Converting a byte array to str can fail"></div><div data-l="    // ">Converting a byte array to str can fail</div><div data-l="    if let Ok(my_str) = str::from_utf8(raw_bytestring) {"></div><div data-l="        println!(&quot;And the same as text: '{}'&quot;, my_str);"></div><div data-l="    }"></div><div data-l=""></div><div data-l="    let quotes = br#&quot;You can also use &quot;fancier&quot; formatting, \"></div><div data-l="                    like with normal raw strings&quot;#;"></div><div data-l=""></div><div data-l="#    // Bytestrings don't have to be UTF-8"></div><div data-l="    // ">Bytestrings don't have to be UTF-8</div><div data-l="#//    let shift_jis = b&quot;\x82\xe6\x82\xa8\x82\xb1\x82&quot;; // &quot;ようこそ&quot; in SHIFT-JIS"></div><div data-l="    let shift_jis = b&quot;\x82\xe6\x82\xa8\x82\xb1\x82&quot;; // ">&quot;ようこそ&quot; in SHIFT-JIS</div><div data-l=""></div><div data-l="#    // But then they can't always be converted to str"></div><div data-l="    // ">But then they can't always be converted to str</div><div data-l="    match str::from_utf8(shift_jis) {"></div><div data-l="        Ok(my_str) =&gt; println!(&quot;Conversion successful: '{}'&quot;, my_str),"></div><div data-l="        Err(e) =&gt; println!(&quot;Conversion failed: {:?}&quot;, e),"></div><div data-l="    };"></div><div data-l="}"></div></div>
<br>
<p>For conversions between character encodings check out the <a class="notranslate" href="#3encoding-crate">encoding</a> crate.</p>
<br>
<p>A more detailed listing of the ways to write string literals and escape characters
is given in the <a href="#3tokens">'Tokens' chapter</a> of the Rust Reference.</p>
<br>
<a class="notranslate" href="#1https://doc.rust-lang.org/std/str/">str</a>
<a class="notranslate" href="#1https://doc.rust-lang.org/std/string/">string</a>
<a class="notranslate" href="#1https://doc.rust-lang.org/reference/tokens.html">tokens</a>
<a class="notranslate" href="#1https://crates.io/crates/encoding">encoding-crate</a>