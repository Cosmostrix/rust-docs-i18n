<!DOCTYPE html>
<h1>Box, stack and heap</h1>
<br>
<p>All values in Rust are stack allocated by default. Values can be <i>boxed</i>
(allocated in the heap) by creating a <code>Box&lt;T&gt;</code>. A box is a smart pointer to a
heap allocated value of type <code>T</code>. When a box goes out of scope, its destructor
is called, the inner object is destroyed, and the memory in the heap is freed.</p>
<br>
<p>Boxed values can be dereferenced using the <code>*</code> operator; this removes one layer
of indirection. </p>
<br>
<div data-lang="rust,editable"><div data-l="use std::mem;"></div><div data-l=""></div><div data-l="#[allow(dead_code)]"></div><div data-l="#[derive(Debug, Clone, Copy)]"></div><div data-l="struct Point {"></div><div data-l="    x: f64,"></div><div data-l="    y: f64,"></div><div data-l="}"></div><div data-l=""></div><div data-l="#[allow(dead_code)]"></div><div data-l="struct Rectangle {"></div><div data-l="    p1: Point,"></div><div data-l="    p2: Point,"></div><div data-l="}"></div><div data-l=""></div><div data-l="fn origin() -&gt; Point {"></div><div data-l="    Point { x: 0.0, y: 0.0 }"></div><div data-l="}"></div><div data-l=""></div><div data-l="fn boxed_origin() -&gt; Box&lt;Point&gt; {"></div><div data-l="#    // Allocate this point in the heap, and return a pointer to it"></div><div data-l="    // ">Allocate this point in the heap, and return a pointer to it</div><div data-l="    Box::new(Point { x: 0.0, y: 0.0 })"></div><div data-l="}"></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="#    // (all the type annotations are superfluous)"></div><div data-l="#    // Stack allocated variables"></div><div data-l="    // ">(all the type annotations are superfluous) Stack allocated variables</div><div data-l="    let point: Point = origin();"></div><div data-l="    let rectangle: Rectangle = Rectangle {"></div><div data-l="        p1: origin(),"></div><div data-l="        p2: Point { x: 3.0, y: 4.0 }"></div><div data-l="    };"></div><div data-l=""></div><div data-l="#    // Heap allocated rectangle"></div><div data-l="    // ">Heap allocated rectangle</div><div data-l="    let boxed_rectangle: Box&lt;Rectangle&gt; = Box::new(Rectangle {"></div><div data-l="        p1: origin(),"></div><div data-l="        p2: origin()"></div><div data-l="    });"></div><div data-l=""></div><div data-l="#    // The output of functions can be boxed"></div><div data-l="    // ">The output of functions can be boxed</div><div data-l="    let boxed_point: Box&lt;Point&gt; = Box::new(origin());"></div><div data-l=""></div><div data-l="#    // Double indirection"></div><div data-l="    // ">Double indirection</div><div data-l="    let box_in_a_box: Box&lt;Box&lt;Point&gt;&gt; = Box::new(boxed_origin());"></div><div data-l=""></div><div data-l="    println!(&quot;Point occupies {} bytes in the stack&quot;,"></div><div data-l="             mem::size_of_val(&amp;point));"></div><div data-l="    println!(&quot;Rectangle occupies {} bytes in the stack&quot;,"></div><div data-l="             mem::size_of_val(&amp;rectangle));"></div><div data-l=""></div><div data-l="#    // box size = pointer size"></div><div data-l="    // ">box size = pointer size</div><div data-l="    println!(&quot;Boxed point occupies {} bytes in the stack&quot;,"></div><div data-l="             mem::size_of_val(&amp;boxed_point));"></div><div data-l="    println!(&quot;Boxed rectangle occupies {} bytes in the stack&quot;,"></div><div data-l="             mem::size_of_val(&amp;boxed_rectangle));"></div><div data-l="    println!(&quot;Boxed box occupies {} bytes in the stack&quot;,"></div><div data-l="             mem::size_of_val(&amp;box_in_a_box));"></div><div data-l=""></div><div data-l="#    // Copy the data contained in `boxed_point` into `unboxed_point`"></div><div data-l="    // ">Copy the data contained in <code>boxed_point</code> into <code>unboxed_point</code></div><div data-l="    let unboxed_point: Point = *boxed_point;"></div><div data-l="    println!(&quot;Unboxed point occupies {} bytes in the stack&quot;,"></div><div data-l="             mem::size_of_val(&amp;unboxed_point));"></div><div data-l="}"></div></div>