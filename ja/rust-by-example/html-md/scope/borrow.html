<!DOCTYPE html>
<h1>Borrowing</h1>
<br>
<p>Most of the time, we'd like to access data without taking ownership over
it. To accomplish this, Rust uses a <i>borrowing</i> mechanism. Instead of
passing objects by value (<code>T</code>), objects can be passed by reference (<code>&amp;T</code>).</p>
<br>
<p>The compiler statically guarantees (via its borrow checker) that references 
<i>always</i> point to valid objects. That is, while references to an object
exist, the object cannot be destroyed.</p>
<br>
<div data-lang="rust,editable,ignore,mdbook-runnable"><div data-l="#// This function takes ownership of a box and destroys it"></div><div data-l="// ">This function takes ownership of a box and destroys it</div><div data-l="fn eat_box_i32(boxed_i32: Box&lt;i32&gt;) {"></div><div data-l="    println!(&quot;Destroying box that contains {}&quot;, boxed_i32);"></div><div data-l="}"></div><div data-l=""></div><div data-l="#// This function borrows an i32"></div><div data-l="// ">This function borrows an i32</div><div data-l="fn borrow_i32(borrowed_i32: &amp;i32) {"></div><div data-l="    println!(&quot;This int is: {}&quot;, borrowed_i32);"></div><div data-l="}"></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="#    // Create a boxed i32, and a stacked i32"></div><div data-l="    // ">Create a boxed i32, and a stacked i32</div><div data-l="    let boxed_i32 = Box::new(5_i32);"></div><div data-l="    let stacked_i32 = 6_i32;"></div><div data-l=""></div><div data-l="#    // Borrow the contents of the box. Ownership is not taken,"></div><div data-l="#    // so the contents can be borrowed again."></div><div data-l="    // ">Borrow the contents of the box. Ownership is not taken, so the contents can be borrowed again.</div><div data-l="    borrow_i32(&amp;boxed_i32);"></div><div data-l="    borrow_i32(&amp;stacked_i32);"></div><div data-l=""></div><div data-l="    {"></div><div data-l="#        // Take a reference to the data contained inside the box"></div><div data-l="        // ">Take a reference to the data contained inside the box</div><div data-l="        let _ref_to_i32: &amp;i32 = &amp;boxed_i32;"></div><div data-l=""></div><div data-l="#        // Error!"></div><div data-l="#        // Can't destroy `boxed_i32` while the inner value is borrowed."></div><div data-l="        // ">Error! Can't destroy <code>boxed_i32</code> while the inner value is borrowed.</div><div data-l="        eat_box_i32(boxed_i32);"></div><div data-l="#        // FIXME ^ Comment out this line"></div><div data-l="        // ">FIXME ^ Comment out this line</div><div data-l=""></div><div data-l="#        // `_ref_to_i32` goes out of scope and is no longer borrowed."></div><div data-l="        // "><code>_ref_to_i32</code> goes out of scope and is no longer borrowed.</div><div data-l="    }"></div><div data-l=""></div><div data-l="#    // `boxed_i32` can now give up ownership to `eat_box` and be destroyed"></div><div data-l="    // "><code>boxed_i32</code> can now give up ownership to <code>eat_box</code> and be destroyed</div><div data-l="    eat_box_i32(boxed_i32);"></div><div data-l="}"></div></div>