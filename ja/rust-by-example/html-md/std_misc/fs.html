<!DOCTYPE html>
<h1>Filesystem Operations</h1>
<br>
<p>The <code>std::fs</code> module contains several functions that deal with the filesystem.</p>
<br>
<div data-lang="rust,ignore"><div data-l="use std::fs;"></div><div data-l="use std::fs::{File, OpenOptions};"></div><div data-l="use std::io;"></div><div data-l="use std::io::prelude::*;"></div><div data-l="use std::os::unix;"></div><div data-l="use std::path::Path;"></div><div data-l=""></div><div data-l="#// A simple implementation of `% cat path`"></div><div data-l="// ">A simple implementation of <code>% cat path</code></div><div data-l="fn cat(path: &amp;Path) -&gt; io::Result&lt;String&gt; {"></div><div data-l="    let mut f = File::open(path)?;"></div><div data-l="    let mut s = String::new();"></div><div data-l="    match f.read_to_string(&amp;mut s) {"></div><div data-l="        Ok(_) =&gt; Ok(s),"></div><div data-l="        Err(e) =&gt; Err(e),"></div><div data-l="    }"></div><div data-l="}"></div><div data-l=""></div><div data-l="#// A simple implementation of `% echo s &gt; path`"></div><div data-l="// ">A simple implementation of <code>% echo s &gt; path</code></div><div data-l="fn echo(s: &amp;str, path: &amp;Path) -&gt; io::Result&lt;()&gt; {"></div><div data-l="    let mut f = File::create(path)?;"></div><div data-l=""></div><div data-l="    f.write_all(s.as_bytes())"></div><div data-l="}"></div><div data-l=""></div><div data-l="#// A simple implementation of `% touch path` (ignores existing files)"></div><div data-l="// ">A simple implementation of <code>% touch path</code> (ignores existing files)</div><div data-l="fn touch(path: &amp;Path) -&gt; io::Result&lt;()&gt; {"></div><div data-l="    match OpenOptions::new().create(true).write(true).open(path) {"></div><div data-l="        Ok(_) =&gt; Ok(()),"></div><div data-l="        Err(e) =&gt; Err(e),"></div><div data-l="    }"></div><div data-l="}"></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    println!(&quot;`mkdir a`&quot;);"></div><div data-l="#    // Create a directory, returns `io::Result&lt;()&gt;`"></div><div data-l="    // ">Create a directory, returns <code>io::Result&lt;()&gt;</code></div><div data-l="    match fs::create_dir(&quot;a&quot;) {"></div><div data-l="        Err(why) =&gt; println!(&quot;! {:?}&quot;, why.kind()),"></div><div data-l="        Ok(_) =&gt; {},"></div><div data-l="    }"></div><div data-l=""></div><div data-l="    println!(&quot;`echo hello &gt; a/b.txt`&quot;);"></div><div data-l="#    // The previous match can be simplified using the `unwrap_or_else` method"></div><div data-l="    // ">The previous match can be simplified using the <code>unwrap_or_else</code> method</div><div data-l="    echo(&quot;hello&quot;, &amp;Path::new(&quot;a/b.txt&quot;)).unwrap_or_else(|why| {"></div><div data-l="        println!(&quot;! {:?}&quot;, why.kind());"></div><div data-l="    });"></div><div data-l=""></div><div data-l="    println!(&quot;`mkdir -p a/c/d`&quot;);"></div><div data-l="#    // Recursively create a directory, returns `io::Result&lt;()&gt;`"></div><div data-l="    // ">Recursively create a directory, returns <code>io::Result&lt;()&gt;</code></div><div data-l="    fs::create_dir_all(&quot;a/c/d&quot;).unwrap_or_else(|why| {"></div><div data-l="        println!(&quot;! {:?}&quot;, why.kind());"></div><div data-l="    });"></div><div data-l=""></div><div data-l="    println!(&quot;`touch a/c/e.txt`&quot;);"></div><div data-l="    touch(&amp;Path::new(&quot;a/c/e.txt&quot;)).unwrap_or_else(|why| {"></div><div data-l="        println!(&quot;! {:?}&quot;, why.kind());"></div><div data-l="    });"></div><div data-l=""></div><div data-l="    println!(&quot;`ln -s ../b.txt a/c/b.txt`&quot;);"></div><div data-l="#    // Create a symbolic link, returns `io::Result&lt;()&gt;`"></div><div data-l="    // ">Create a symbolic link, returns <code>io::Result&lt;()&gt;</code></div><div data-l="    if cfg!(target_family = &quot;unix&quot;) {"></div><div data-l="        unix::fs::symlink(&quot;../b.txt&quot;, &quot;a/c/b.txt&quot;).unwrap_or_else(|why| {"></div><div data-l="        println!(&quot;! {:?}&quot;, why.kind());"></div><div data-l="        });"></div><div data-l="    }"></div><div data-l=""></div><div data-l="    println!(&quot;`cat a/c/b.txt`&quot;);"></div><div data-l="    match cat(&amp;Path::new(&quot;a/c/b.txt&quot;)) {"></div><div data-l="        Err(why) =&gt; println!(&quot;! {:?}&quot;, why.kind()),"></div><div data-l="        Ok(s) =&gt; println!(&quot;&gt; {}&quot;, s),"></div><div data-l="    }"></div><div data-l=""></div><div data-l="    println!(&quot;`ls a`&quot;);"></div><div data-l="#    // Read the contents of a directory, returns `io::Result&lt;Vec&lt;Path&gt;&gt;`"></div><div data-l="    // ">Read the contents of a directory, returns <code>io::Result&lt;Vec&lt;Path&gt;&gt;</code></div><div data-l="    match fs::read_dir(&quot;a&quot;) {"></div><div data-l="        Err(why) =&gt; println!(&quot;! {:?}&quot;, why.kind()),"></div><div data-l="        Ok(paths) =&gt; for path in paths {"></div><div data-l="            println!(&quot;&gt; {:?}&quot;, path.unwrap().path());"></div><div data-l="        },"></div><div data-l="    }"></div><div data-l=""></div><div data-l="    println!(&quot;`rm a/c/e.txt`&quot;);"></div><div data-l="#    // Remove a file, returns `io::Result&lt;()&gt;`"></div><div data-l="    // ">Remove a file, returns <code>io::Result&lt;()&gt;</code></div><div data-l="    fs::remove_file(&quot;a/c/e.txt&quot;).unwrap_or_else(|why| {"></div><div data-l="        println!(&quot;! {:?}&quot;, why.kind());"></div><div data-l="    });"></div><div data-l=""></div><div data-l="    println!(&quot;`rmdir a/c/d`&quot;);"></div><div data-l="#    // Remove an empty directory, returns `io::Result&lt;()&gt;`"></div><div data-l="    // ">Remove an empty directory, returns <code>io::Result&lt;()&gt;</code></div><div data-l="    fs::remove_dir(&quot;a/c/d&quot;).unwrap_or_else(|why| {"></div><div data-l="        println!(&quot;! {:?}&quot;, why.kind());"></div><div data-l="    });"></div><div data-l="}"></div><div data-l=""></div></div>
<br>
<p>Here's the expected successful output:</p>
<br>
<div data-lang="bash"><div data-l="$ rustc fs.rs &amp;&amp; ./fs"></div><div data-l="`mkdir a`"></div><div data-l="`echo hello &gt; a/b.txt`"></div><div data-l="`mkdir -p a/c/d`"></div><div data-l="`touch a/c/e.txt`"></div><div data-l="`ln -s ../b.txt a/c/b.txt`"></div><div data-l="`cat a/c/b.txt`"></div><div data-l="&gt; hello"></div><div data-l="`ls a`"></div><div data-l="&gt; &quot;a/b.txt&quot;"></div><div data-l="&gt; &quot;a/c&quot;"></div><div data-l="`rm a/c/e.txt`"></div><div data-l="`rmdir a/c/d`"></div></div>
<br>
<p>And the final state of the <code>a</code> directory is:</p>
<br>
<div data-lang="text"><div data-l="$ tree a"></div><div data-l="a"></div><div data-l="|-- b.txt"></div><div data-l="`-- c"></div><div data-l="    `-- b.txt -&gt; ../b.txt"></div><div data-l=""></div><div data-l="1 directory, 2 files"></div></div>
<br>
<p>An alternative way to define the function <code>cat</code> is with <code>?</code> notation:</p>
<br>
<div data-lang="rust,ignore"><div data-l="fn cat(path: &amp;Path) -&gt; io::Result&lt;String&gt; {"></div><div data-l="    let mut f = File::open(path)?;"></div><div data-l="    let mut s = String::new();"></div><div data-l="    f.read_to_string(&amp;mut s)?;"></div><div data-l="    Ok(s)"></div><div data-l="}"></div></div>
<br>
<h3>See also:</h3>
<br>
<p><a class="notranslate" href="#3cfg"><code>cfgâ‚¬</code></a></p>
<br>
<a class="notranslate" href="#1attribute/cfg.html">cfg</a>