<!DOCTYPE html>
<h1>Testcase: map-reduce</h1>
<br>
<p>Rust makes it very easy to parallelise data processing, without many of the headaches traditionally associated with such an attempt.</p>
<br>
<p>The standard library provides great threading primitives out of the box.
These, combined with Rust's concept of Ownership and aliasing rules, automatically prevent
data races.</p>
<br>
<p>The aliasing rules (one writable reference XOR many readable references) automatically prevent
you from manipulating state that is visible to other threads. (Where synchronisation is needed,
there are synchronisation
primitives like <code>Mutex</code>es or <code>Channel</code>s.)</p>
<br>
<p>In this example, we will calculate the sum of all digits in a block of numbers.
We will do this by parcelling out chunks of the block into different threads. Each thread will sum
its tiny block of digits, and subsequently we will sum the intermediate sums produced by each
thread.</p>
<br>
<p>Note that, although we're passing references across thread boundaries, Rust understands that we're
only passing read-only references, and that thus no unsafety or data races can occur. Because
we're <code>move</code>-ing the data segments into the thread, Rust will also ensure the data is kept alive
until the threads exit, so no dangling pointers occur.</p>
<br>
<div data-lang="rust,editable"><div data-l="use std::thread;"></div><div data-l=""></div><div data-l="#// This is the `main` thread"></div><div data-l="// ">This is the <code>main</code> thread</div><div data-l="fn main() {"></div><div data-l=""></div><div data-l="#    // This is our data to process."></div><div data-l="#    // We will calculate the sum of all digits via a threaded  map-reduce algorithm."></div><div data-l="#    // Each whitespace separated chunk will be handled in a different thread."></div><div data-l="    // ">This is our data to process. We will calculate the sum of all digits via a threaded  map-reduce algorithm. Each whitespace separated chunk will be handled in a different thread.</div><div data-l="    //"></div><div data-l="#    // TODO: see what happens to the output if you insert spaces!"></div><div data-l="    // ">TODO: see what happens to the output if you insert spaces!</div><div data-l="    let data = &quot;86967897737416471853297327050364959"></div><div data-l="11861322575564723963297542624962850"></div><div data-l="70856234701860851907960690014725639"></div><div data-l="38397966707106094172783238747669219"></div><div data-l="52380795257888236525459303330302837"></div><div data-l="58495327135744041048897885734297812"></div><div data-l="69920216438980873548808413720956532"></div><div data-l="16278424637452589860345374828574668&quot;;"></div><div data-l=""></div><div data-l="#    // Make a vector to hold the child-threads which we will spawn."></div><div data-l="    // ">Make a vector to hold the child-threads which we will spawn.</div><div data-l="    let mut children = vec![];"></div><div data-l=""></div><div data-l="    /*************************************************************************"></div><div data-l="     * &quot;Map&quot; phase"></div><div data-l="     *"></div><div data-l="     * Divide our data into segments, and apply initial processing"></div><div data-l="     ************************************************************************/"></div><div data-l=""></div><div data-l="#    // split our data into segments for individual calculation"></div><div data-l="#    // each chunk will be a reference (&amp;str) into the actual data"></div><div data-l="    // ">split our data into segments for individual calculation each chunk will be a reference (&amp;str) into the actual data</div><div data-l="    let chunked_data = data.split_whitespace();"></div><div data-l=""></div><div data-l="#    // Iterate over the data segments."></div><div data-l="#    // .enumerate() adds the current loop index to whatever is iterated"></div><div data-l="#    // the resulting tuple &quot;(index, element)&quot; is then immediately"></div><div data-l="#    // &quot;destructured&quot; into two variables, &quot;i&quot; and &quot;data_segment&quot; with a"></div><div data-l="#    // &quot;destructuring assignment&quot;"></div><div data-l="    // ">Iterate over the data segments. .enumerate() adds the current loop index to whatever is iterated the resulting tuple &quot;(index, element)&quot; is then immediately &quot;destructured&quot; into two variables, &quot;i&quot; and &quot;data_segment&quot; with a &quot;destructuring assignment&quot;</div><div data-l="    for (i, data_segment) in chunked_data.enumerate() {"></div><div data-l="        println!(&quot;data segment {} is \&quot;{}\&quot;&quot;, i, data_segment);"></div><div data-l=""></div><div data-l="#        // Process each data segment in a separate thread"></div><div data-l="        // ">Process each data segment in a separate thread</div><div data-l="        //"></div><div data-l="#        // spawn() returns a handle to the new thread,"></div><div data-l="#        // which we MUST keep to access the returned value"></div><div data-l="        // ">spawn() returns a handle to the new thread, which we MUST keep to access the returned value</div><div data-l="        //"></div><div data-l="#        // 'move || -&gt; u32' is syntax for a closure that:"></div><div data-l="#        // * takes no arguments ('||')"></div><div data-l="#        // * takes ownership of its captured variables ('move') and"></div><div data-l="#        // * returns an unsigned 32-bit integer ('-&gt; u32')"></div><div data-l="        // ">'move || -&gt; u32' is syntax for a closure that: * takes no arguments ('||') * takes ownership of its captured variables ('move') and * returns an unsigned 32-bit integer ('-&gt; u32')</div><div data-l="        //"></div><div data-l="#        // Rust is smart enough to infer the '-&gt; u32' from"></div><div data-l="#        // the closure itself so we could have left that out."></div><div data-l="        // ">Rust is smart enough to infer the '-&gt; u32' from the closure itself so we could have left that out.</div><div data-l="        //"></div><div data-l="#        // TODO: try removing the 'move' and see what happens"></div><div data-l="        // ">TODO: try removing the 'move' and see what happens</div><div data-l="        children.push(thread::spawn(move || -&gt; u32 {"></div><div data-l="#            // Calculate the intermediate sum of this segment:"></div><div data-l="            // ">Calculate the intermediate sum of this segment:</div><div data-l="            let result = data_segment"></div><div data-l="#                        // iterate over the characters of our segment.."></div><div data-l="                        // ">iterate over the characters of our segment..</div><div data-l="                        .chars()"></div><div data-l="#                        // .. convert text-characters to their number value.."></div><div data-l="                        // ">.. convert text-characters to their number value..</div><div data-l="                        .map(|c| c.to_digit(10).expect(&quot;should be a digit&quot;))"></div><div data-l="#                        // .. and sum the resulting iterator of numbers"></div><div data-l="                        // ">.. and sum the resulting iterator of numbers</div><div data-l="                        .sum();"></div><div data-l=""></div><div data-l="#            // println! locks stdout, so no text-interleaving occurs"></div><div data-l="            // ">println! locks stdout, so no text-interleaving occurs</div><div data-l="            println!(&quot;processed segment {}, result={}&quot;, i, result);"></div><div data-l=""></div><div data-l="#            // &quot;return&quot; not needed, because Rust is an &quot;expression language&quot;, the"></div><div data-l="#            // last evaluated expression in each block is automatically its value."></div><div data-l="            // ">&quot;return&quot; not needed, because Rust is an &quot;expression language&quot;, the last evaluated expression in each block is automatically its value.</div><div data-l="            result"></div><div data-l=""></div><div data-l="        }));"></div><div data-l="    }"></div><div data-l=""></div><div data-l=""></div><div data-l="    /*************************************************************************"></div><div data-l="     * &quot;Reduce&quot; phase"></div><div data-l="     *"></div><div data-l="     * Collect our intermediate results, and combine them into a final result"></div><div data-l="     ************************************************************************/"></div><div data-l=""></div><div data-l="#    // collect each thread's intermediate results into a new Vec"></div><div data-l="    // ">collect each thread's intermediate results into a new Vec</div><div data-l="    let mut intermediate_sums = vec![];"></div><div data-l="    for child in children {"></div><div data-l="#        // collect each child thread's return-value"></div><div data-l="        // ">collect each child thread's return-value</div><div data-l="        let intermediate_sum = child.join().unwrap();"></div><div data-l="        intermediate_sums.push(intermediate_sum);"></div><div data-l="    }"></div><div data-l=""></div><div data-l="#    // combine all intermediate sums into a single final sum."></div><div data-l="    // ">combine all intermediate sums into a single final sum.</div><div data-l="    //"></div><div data-l="#    // we use the &quot;turbofish&quot; ::&lt;&gt; to provide sum() with a type hint."></div><div data-l="    // ">we use the &quot;turbofish&quot; ::<> to provide sum() with a type hint.</div><div data-l="    //"></div><div data-l="#    // TODO: try without the turbofish, by instead explicitly"></div><div data-l="#    // specifying the type of final_result"></div><div data-l="    // ">TODO: try without the turbofish, by instead explicitly specifying the type of final_result</div><div data-l="    let final_result = intermediate_sums.iter().sum::&lt;u32&gt;();"></div><div data-l=""></div><div data-l="    println!(&quot;Final sum result: {}&quot;, final_result);"></div><div data-l="}"></div><div data-l=""></div><div data-l=""></div></div>
<br>
<h3>Assignments</h3>
<p>It is not wise to let our number of threads depend on user inputted data.
What if the user decides to insert a lot of spaces? Do we <s>really</s> want to spawn 2,000 threads?
Modify the program so that the data is always chunked into a limited number of chunks,
defined by a static constant at the beginning of the program.</p>
<br>
<h3>See also:</h3>
<div data-b="*"><a class="notranslate" href="#3thread">Threads</a></div>
<div data-b="*"><a class="notranslate" href="#3vectors">vectors</a> and <a class="notranslate" href="#3iterators">iterators</a></div>
<div data-b="*"><a class="notranslate" href="#3closures">closures</a>, <a class="notranslate" href="#3move">move</a> semantics and <a href="#3move_closure"><code>move</code> closures</a></div>
<div data-b="*"><a class="notranslate" href="#3destructuring">destructuring</a> assignments</div>
<div data-b="*"><a href="#3turbofish">turbofish notation</a> to help type inference</div>
<div data-b="*"><a href="#3unwrap">unwrap vs. expect</a></div>
<div data-b="*"><a class="notranslate" href="#3enumerate">enumerate</a></div>
<br>
<a class="notranslate" href="#1std_misc/threads.html">thread</a>
<a class="notranslate" href="#1std/vec.html">vectors</a>
<a class="notranslate" href="#1trait/iter.html">iterators</a>
<a class="notranslate" href="#1https://doc.rust-lang.org/book/second-edition/ch18-03-pattern-syntax.html#destructuring-to-break-apart-values">destructuring</a>
<a class="notranslate" href="#1fn/closures.html">closures</a>
<a class="notranslate" href="#1scope/move.html">move</a>
<a class="notranslate" href="#1https://doc.rust-lang.org/book/second-edition/ch13-01-closures.html#closures-can-capture-their-environment">move_closure</a>
<a class="notranslate" href="#1https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.collect">turbofish</a>
<a class="notranslate" href="#1error/option_unwrap.html">unwrap</a>
<a class="notranslate" href="#1https://doc.rust-lang.org/book/loops.html#enumerate">enumerate</a>