<!DOCTYPE html>
<h1>Pipes</h1>
<br>
<p>The <code>std::Child</code> struct represents a running child process, and exposes the
<code>stdin</code>, <code>stdout</code> and <code>stderr</code> handles for interaction with the underlying
process via pipes.</p>
<br>
<div data-lang="rust,ignore"><div data-l="use std::error::Error;"></div><div data-l="use std::io::prelude::*;"></div><div data-l="use std::process::{Command, Stdio};"></div><div data-l=""></div><div data-l="static PANGRAM: &amp;'static str ="></div><div data-l="&quot;the quick brown fox jumped over the lazy dog\n&quot;;"></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="#    // Spawn the `wc` command"></div><div data-l="    // ">Spawn the <code>wc</code> command</div><div data-l="    let process = match Command::new(&quot;wc&quot;)"></div><div data-l="                                .stdin(Stdio::piped())"></div><div data-l="                                .stdout(Stdio::piped())"></div><div data-l="                                .spawn() {"></div><div data-l="        Err(why) =&gt; panic!(&quot;couldn't spawn wc: {}&quot;, why.description()),"></div><div data-l="        Ok(process) =&gt; process,"></div><div data-l="    };"></div><div data-l=""></div><div data-l="#    // Write a string to the `stdin` of `wc`."></div><div data-l="    // ">Write a string to the <code>stdin</code> of <code>wc</code>.</div><div data-l="    //"></div><div data-l="#    // `stdin` has type `Option&lt;ChildStdin&gt;`, but since we know this instance"></div><div data-l="#    // must have one, we can directly `unwrap` it."></div><div data-l="    // "><code>stdin</code> has type <code>Option&lt;ChildStdin&gt;</code>, but since we know this instance must have one, we can directly <code>unwrap</code> it.</div><div data-l="    match process.stdin.unwrap().write_all(PANGRAM.as_bytes()) {"></div><div data-l="        Err(why) =&gt; panic!(&quot;couldn't write to wc stdin: {}&quot;,"></div><div data-l="                           why.description()),"></div><div data-l="        Ok(_) =&gt; println!(&quot;sent pangram to wc&quot;),"></div><div data-l="    }"></div><div data-l=""></div><div data-l="#    // Because `stdin` does not live after the above calls, it is `drop`ed,"></div><div data-l="#    // and the pipe is closed."></div><div data-l="    // ">Because <code>stdin</code> does not live after the above calls, it is <code>drop</code>ed, and the pipe is closed.</div><div data-l="    //"></div><div data-l="#    // This is very important, otherwise `wc` wouldn't start processing the"></div><div data-l="#    // input we just sent."></div><div data-l="    // ">This is very important, otherwise <code>wc</code> wouldn't start processing the input we just sent.</div><div data-l=""></div><div data-l="#    // The `stdout` field also has type `Option&lt;ChildStdout&gt;` so must be unwrapped."></div><div data-l="    // ">The <code>stdout</code> field also has type <code>Option&lt;ChildStdout&gt;</code> so must be unwrapped.</div><div data-l="    let mut s = String::new();"></div><div data-l="    match process.stdout.unwrap().read_to_string(&amp;mut s) {"></div><div data-l="        Err(why) =&gt; panic!(&quot;couldn't read wc stdout: {}&quot;,"></div><div data-l="                           why.description()),"></div><div data-l="        Ok(_) =&gt; print!(&quot;wc responded with:\n{}&quot;, s),"></div><div data-l="    }"></div><div data-l="}"></div></div>