<!DOCTYPE html>
<h1>Associated types</h1>
<br>
<p>The use of &quot;Associated types&quot; improves the overall readability of code 
by moving inner types locally into a trait as <i>output</i> types. Syntax
for the <code>trait</code> definition is as follows:</p>
<br>
<div data-lang="rust"><div data-l="#// `A` and `B` are defined in the trait via the `type` keyword."></div><div data-l="#// (Note: `type` in this context is different from `type` when used for"></div><div data-l="#// aliases)."></div><div data-l="// "><code>A</code> and <code>B</code> are defined in the trait via the <code>type</code> keyword. (Note: <code>type</code> in this context is different from <code>type</code> when used for aliases).</div><div data-l="trait Contains {"></div><div data-l="    type A;"></div><div data-l="    type B;"></div><div data-l=""></div><div data-l="#    // Updated syntax to refer to these new types generically."></div><div data-l="    // ">Updated syntax to refer to these new types generically.</div><div data-l="    fn contains(&amp;self, &amp;Self::A, &amp;Self::B) -&gt; bool;"></div><div data-l="}"></div></div>
<br>
<p>Note that functions that use the <code>trait</code> <code>Contains</code> are no longer required
to express <code>A</code> or <code>B</code> at all:</p>
<br>
<div data-lang="rust,ignore"><div data-l="#// Without using associated types"></div><div data-l="// ">Without using associated types</div><div data-l="fn difference&lt;A, B, C&gt;(container: &amp;C) -&gt; i32 where"></div><div data-l="    C: Contains&lt;A, B&gt; { ... }"></div><div data-l=""></div><div data-l="#// Using associated types"></div><div data-l="// ">Using associated types</div><div data-l="fn difference&lt;C: Contains&gt;(container: &amp;C) -&gt; i32 { ... }"></div></div>
<br>
<p>Let's rewrite the example from the previous section using associated types:</p>
<br>
<div data-lang="rust,editable"><div data-l="struct Container(i32, i32);"></div><div data-l=""></div><div data-l="#// A trait which checks if 2 items are stored inside of container."></div><div data-l="#// Also retrieves first or last value."></div><div data-l="// ">A trait which checks if 2 items are stored inside of container. Also retrieves first or last value.</div><div data-l="trait Contains {"></div><div data-l="#    // Define generic types here which methods will be able to utilize."></div><div data-l="    // ">Define generic types here which methods will be able to utilize.</div><div data-l="    type A;"></div><div data-l="    type B;"></div><div data-l=""></div><div data-l="    fn contains(&amp;self, &amp;Self::A, &amp;Self::B) -&gt; bool;"></div><div data-l="    fn first(&amp;self) -&gt; i32;"></div><div data-l="    fn last(&amp;self) -&gt; i32;"></div><div data-l="}"></div><div data-l=""></div><div data-l="impl Contains for Container {"></div><div data-l="#    // Specify what types `A` and `B` are. If the `input` type"></div><div data-l="#    // is `Container(i32, i32)`, the `output` types are determined"></div><div data-l="#    // as `i32` and `i32`."></div><div data-l="    // ">Specify what types <code>A</code> and <code>B</code> are. If the <code>input</code> type is <code>Container(i32, i32)</code>, the <code>output</code> types are determined as <code>i32</code> and <code>i32</code>.</div><div data-l="    type A = i32;"></div><div data-l="    type B = i32;"></div><div data-l=""></div><div data-l="#    // `&amp;Self::A` and `&amp;Self::B` are also valid here."></div><div data-l="    // "><code>&amp;Self::A</code> and <code>&amp;Self::B</code> are also valid here.</div><div data-l="    fn contains(&amp;self, number_1: &amp;i32, number_2: &amp;i32) -&gt; bool {"></div><div data-l="        (&amp;self.0 == number_1) &amp;&amp; (&amp;self.1 == number_2)"></div><div data-l="    }"></div><div data-l="#    // Grab the first number."></div><div data-l="    // ">Grab the first number.</div><div data-l="    fn first(&amp;self) -&gt; i32 { self.0 }"></div><div data-l=""></div><div data-l="#    // Grab the last number."></div><div data-l="    // ">Grab the last number.</div><div data-l="    fn last(&amp;self) -&gt; i32 { self.1 }"></div><div data-l="}"></div><div data-l=""></div><div data-l="fn difference&lt;C: Contains&gt;(container: &amp;C) -&gt; i32 {"></div><div data-l="    container.last() - container.first()"></div><div data-l="}"></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let number_1 = 3;"></div><div data-l="    let number_2 = 10;"></div><div data-l=""></div><div data-l="    let container = Container(number_1, number_2);"></div><div data-l=""></div><div data-l="    println!(&quot;Does container contain {} and {}: {}&quot;,"></div><div data-l="        &amp;number_1, &amp;number_2,"></div><div data-l="        container.contains(&amp;number_1, &amp;number_2));"></div><div data-l="    println!(&quot;First number: {}&quot;, container.first());"></div><div data-l="    println!(&quot;Last number: {}&quot;, container.last());"></div><div data-l="    "></div><div data-l="    println!(&quot;The difference is: {}&quot;, difference(&amp;container));"></div><div data-l="}"></div></div>