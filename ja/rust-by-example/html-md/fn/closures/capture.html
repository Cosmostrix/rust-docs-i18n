<!DOCTYPE html>
<h1>Capturing</h1>
<br>
<p>Closures are inherently flexible and will do what the functionality requires
to make the closure work without annotation. This allows capturing to
flexibly adapt to the use case, sometimes moving and sometimes borrowing.
Closures can capture variables:</p>
<br>
<div data-b="*">by reference: <code>&amp;T</code></div>
<div data-b="*">by mutable reference: <code>&amp;mut T</code></div>
<div data-b="*">by value: <code>T</code></div>
<br>
<p>They preferentially capture variables by reference and only go lower when
required.</p>
<br>
<div data-lang="rust,editable"><div data-l="fn main() {"></div><div data-l="    use std::mem;"></div><div data-l="    "></div><div data-l="    let color = &quot;green&quot;;"></div><div data-l=""></div><div data-l="#    // A closure to print `color` which immediately borrows (`&amp;`)"></div><div data-l="#    // `color` and stores the borrow and closure in the `print`"></div><div data-l="#    // variable. It will remain borrowed until `print` goes out of"></div><div data-l="#    // scope. `println!` only requires `by reference` so it doesn't"></div><div data-l="#    // impose anything more restrictive."></div><div data-l="    // ">A closure to print <code>color</code> which immediately borrows (<code>&amp;</code>) <code>color</code> and stores the borrow and closure in the <code>print</code> variable. It will remain borrowed until <code>print</code> goes out of scope. <code>println€</code> only requires <code>by reference</code> so it doesn't impose anything more restrictive.</div><div data-l="    let print = || println!(&quot;`color`: {}&quot;, color);"></div><div data-l=""></div><div data-l="#    // Call the closure using the borrow."></div><div data-l="    // ">Call the closure using the borrow.</div><div data-l="    print();"></div><div data-l="    print();"></div><div data-l=""></div><div data-l="    let mut count = 0;"></div><div data-l=""></div><div data-l="#    // A closure to increment `count` could take either `&amp;mut count`"></div><div data-l="#    // or `count` but `&amp;mut count` is less restrictive so it takes"></div><div data-l="#    // that. Immediately borrows `count`."></div><div data-l="    // ">A closure to increment <code>count</code> could take either <code>&amp;mut count</code> or <code>count</code> but <code>&amp;mut count</code> is less restrictive so it takes that. Immediately borrows <code>count</code>.</div><div data-l="    //"></div><div data-l="#    // A `mut` is required on `inc` because a `&amp;mut` is stored inside."></div><div data-l="#    // Thus, calling the closure mutates the closure which requires"></div><div data-l="#    // a `mut`."></div><div data-l="    // ">A <code>mut</code> is required on <code>inc</code> because a <code>&amp;mut</code> is stored inside. Thus, calling the closure mutates the closure which requires a <code>mut</code>.</div><div data-l="    let mut inc = || {"></div><div data-l="        count += 1;"></div><div data-l="        println!(&quot;`count`: {}&quot;, count);"></div><div data-l="    };"></div><div data-l=""></div><div data-l="#    // Call the closure."></div><div data-l="    // ">Call the closure.</div><div data-l="    inc();"></div><div data-l="    inc();"></div><div data-l=""></div><div data-l="    //let _reborrow = &amp;mut count;"></div><div data-l="#    // ^ TODO: try uncommenting this line."></div><div data-l="    // ">^ TODO: try uncommenting this line.</div><div data-l="    "></div><div data-l="#    // A non-copy type."></div><div data-l="    // ">A non-copy type.</div><div data-l="    let movable = Box::new(3);"></div><div data-l=""></div><div data-l="#    // `mem::drop` requires `T` so this must take by value. A copy type"></div><div data-l="#    // would copy into the closure leaving the original untouched."></div><div data-l="#    // A non-copy must move and so `movable` immediately moves into"></div><div data-l="#    // the closure."></div><div data-l="    // "><code>mem::drop</code> requires <code>T</code> so this must take by value. A copy type would copy into the closure leaving the original untouched. A non-copy must move and so <code>movable</code> immediately moves into the closure.</div><div data-l="    let consume = || {"></div><div data-l="        println!(&quot;`movable`: {:?}&quot;, movable);"></div><div data-l="        mem::drop(movable);"></div><div data-l="    };"></div><div data-l=""></div><div data-l="#    // `consume` consumes the variable so this can only be called once."></div><div data-l="    // "><code>consume</code> consumes the variable so this can only be called once.</div><div data-l="    consume();"></div><div data-l="    //consume();"></div><div data-l="#    // ^ TODO: Try uncommenting this line."></div><div data-l="    // ">^ TODO: Try uncommenting this line.</div><div data-l="}"></div></div>
<br>
<p>Using <code>move</code> before vertical pipes forces closure
to take ownership of captured variables:</p>
<br>
<div data-lang="rust,editable"><div data-l="fn main() {"></div><div data-l="#    // `Vec` has non-copy semantics."></div><div data-l="    // "><code>Vec</code> has non-copy semantics.</div><div data-l="    let haystack = vec![1, 2, 3];"></div><div data-l=""></div><div data-l="    let contains = move |needle| haystack.contains(needle);"></div><div data-l=""></div><div data-l="    println!(&quot;{}&quot;, contains(&amp;1));"></div><div data-l="    println!(&quot;{}&quot;, contains(&amp;4));"></div><div data-l=""></div><div data-l="#    // `println!(&quot;There're {} elements in vec&quot;, haystack.len());`"></div><div data-l="#    // ^ Uncommenting above line will result in compile-time error"></div><div data-l="#    // because borrow checker doesn't allow re-using variable after it"></div><div data-l="#    // has been moved."></div><div data-l="    // "><code>println€(&quot;There're {} elements in vec&quot;, haystack.len());</code> ^ Uncommenting above line will result in compile-time error because borrow checker doesn't allow re-using variable after it has been moved.</div><div data-l="    "></div><div data-l="#    // Removing `move` from closure's signature will cause closure"></div><div data-l="#    // to borrow _haystack_ variable immutably, hence _haystack_ is still"></div><div data-l="#    // available and uncommenting above line will not cause an error."></div><div data-l="    // ">Removing <code>move</code> from closure's signature will cause closure to borrow <s>haystack</s> variable immutably, hence <s>haystack</s> is still available and uncommenting above line will not cause an error.</div><div data-l="}"></div></div>
<br>
<h3>See also:</h3>
<br>
<p><a class="notranslate" href="#3box"><code>Box</code></a> and <a class="notranslate" href="#3drop"><code>std::mem::drop</code></a></p>
<br>
<a class="notranslate" href="#1std/box.html">box</a>
<a class="notranslate" href="#1https://doc.rust-lang.org/std/mem/fn.drop.html">drop</a>