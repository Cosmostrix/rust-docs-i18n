<!DOCTYPE html>
<h1>Casting</h1>
<br>
<p>Rust provides no implicit type conversion (coercion) between primitive types.
But, explicit type conversion (casting) can be performed using the <code>as</code> keyword.</p>
<br>
<p>Rules for converting between integral types follow C conventions generally,
except in cases where C has undefined behavior. The behavior of all casts
between integral types is well defined in Rust.</p>
<br>
<div data-lang="rust,editable,ignore,mdbook-runnable"><div data-l="#// Suppress all warnings from casts which overflow."></div><div data-l="// ">Suppress all warnings from casts which overflow.</div><div data-l="#![allow(overflowing_literals)]"></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let decimal = 65.4321_f32;"></div><div data-l=""></div><div data-l="#    // Error! No implicit conversion"></div><div data-l="    // ">Error! No implicit conversion</div><div data-l="    let integer: u8 = decimal;"></div><div data-l="#    // FIXME ^ Comment out this line"></div><div data-l="    // ">FIXME ^ Comment out this line</div><div data-l=""></div><div data-l="#    // Explicit conversion"></div><div data-l="    // ">Explicit conversion</div><div data-l="    let integer = decimal as u8;"></div><div data-l="    let character = integer as char;"></div><div data-l=""></div><div data-l="    println!(&quot;Casting: {} -&gt; {} -&gt; {}&quot;, decimal, integer, character);"></div><div data-l=""></div><div data-l="#    // when casting any value to an unsigned type, T,"></div><div data-l="#    // std::T::MAX + 1 is added or subtracted until the value"></div><div data-l="#    // fits into the new type"></div><div data-l="    // ">when casting any value to an unsigned type, T, std::T::MAX + 1 is added or subtracted until the value fits into the new type</div><div data-l=""></div><div data-l="#    // 1000 already fits in a u16"></div><div data-l="    // ">1000 already fits in a u16</div><div data-l="    println!(&quot;1000 as a u16 is: {}&quot;, 1000 as u16);"></div><div data-l=""></div><div data-l="#    // 1000 - 256 - 256 - 256 = 232"></div><div data-l="#    // Under the hood, the first 8 least significant bits (LSB) are kept,"></div><div data-l="#    // while the rest towards the most significant bit (MSB) get truncated."></div><div data-l="    // ">1000 - 256 - 256 - 256 = 232 Under the hood, the first 8 least significant bits (LSB) are kept, while the rest towards the most significant bit (MSB) get truncated.</div><div data-l="    println!(&quot;1000 as a u8 is : {}&quot;, 1000 as u8);"></div><div data-l="#    // -1 + 256 = 255"></div><div data-l="    // ">-1 + 256 = 255</div><div data-l="    println!(&quot;  -1 as a u8 is : {}&quot;, (-1i8) as u8);"></div><div data-l=""></div><div data-l="#    // For positive numbers, this is the same as the modulus"></div><div data-l="    // ">For positive numbers, this is the same as the modulus</div><div data-l="    println!(&quot;1000 mod 256 is : {}&quot;, 1000 % 256);"></div><div data-l=""></div><div data-l="#    // When casting to a signed type, the (bitwise) result is the same as"></div><div data-l="#    // first casting to the corresponding unsigned type. If the most significant"></div><div data-l="#    // bit of that value is 1, then the value is negative."></div><div data-l="    // ">When casting to a signed type, the (bitwise) result is the same as first casting to the corresponding unsigned type. If the most significant bit of that value is 1, then the value is negative.</div><div data-l=""></div><div data-l="#    // Unless it already fits, of course."></div><div data-l="    // ">Unless it already fits, of course.</div><div data-l="    println!(&quot; 128 as a i16 is: {}&quot;, 128 as i16);"></div><div data-l="#    // 128 as u8 -&gt; 128, whose two's complement in eight bits is:"></div><div data-l="    // ">128 as u8 -&gt; 128, whose two's complement in eight bits is:</div><div data-l="    println!(&quot; 128 as a i8 is : {}&quot;, 128 as i8);"></div><div data-l=""></div><div data-l="#    // repeating the example above"></div><div data-l="#    // 1000 as u8 -&gt; 232"></div><div data-l="    // ">repeating the example above 1000 as u8 -&gt; 232</div><div data-l="    println!(&quot;1000 as a u8 is : {}&quot;, 1000 as u8);"></div><div data-l="#    // and the two's complement of 232 is -24"></div><div data-l="    // ">and the two's complement of 232 is -24</div><div data-l="    println!(&quot; 232 as a i8 is : {}&quot;, 232 as i8);"></div><div data-l="}"></div></div>