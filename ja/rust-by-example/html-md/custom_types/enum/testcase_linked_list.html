<!DOCTYPE html>
<h1>Testcase: linked-list</h1>
<br>
<p>A common use for <code>enums</code> is to create a linked-list:</p>
<br>
<div data-lang="rust,editable"><div data-l="use List::*;"></div><div data-l=""></div><div data-l="enum List {"></div><div data-l="#    // Cons: Tuple struct that wraps an element and a pointer to the next node"></div><div data-l="    // ">Cons: Tuple struct that wraps an element and a pointer to the next node</div><div data-l="    Cons(u32, Box&lt;List&gt;),"></div><div data-l="#    // Nil: A node that signifies the end of the linked list"></div><div data-l="    // ">Nil: A node that signifies the end of the linked list</div><div data-l="    Nil,"></div><div data-l="}"></div><div data-l=""></div><div data-l="#// Methods can be attached to an enum"></div><div data-l="// ">Methods can be attached to an enum</div><div data-l="impl List {"></div><div data-l="#    // Create an empty list"></div><div data-l="    // ">Create an empty list</div><div data-l="    fn new() -&gt; List {"></div><div data-l="#        // `Nil` has type `List`"></div><div data-l="        // "><code>Nil</code> has type <code>List</code></div><div data-l="        Nil"></div><div data-l="    }"></div><div data-l=""></div><div data-l="#    // Consume a list, and return the same list with a new element at its front"></div><div data-l="    // ">Consume a list, and return the same list with a new element at its front</div><div data-l="    fn prepend(self, elem: u32) -&gt; List {"></div><div data-l="#        // `Cons` also has type List"></div><div data-l="        // "><code>Cons</code> also has type List</div><div data-l="        Cons(elem, Box::new(self))"></div><div data-l="    }"></div><div data-l=""></div><div data-l="#    // Return the length of the list"></div><div data-l="    // ">Return the length of the list</div><div data-l="    fn len(&amp;self) -&gt; u32 {"></div><div data-l="#        // `self` has to be matched, because the behavior of this method"></div><div data-l="#        // depends on the variant of `self`"></div><div data-l="#        // `self` has type `&amp;List`, and `*self` has type `List`, matching on a"></div><div data-l="#        // concrete type `T` is preferred over a match on a reference `&amp;T`"></div><div data-l="        // "><code>self</code> has to be matched, because the behavior of this method depends on the variant of <code>self</code> <code>self</code> has type <code>&amp;List</code>, and <code>*self</code> has type <code>List</code>, matching on a concrete type <code>T</code> is preferred over a match on a reference <code>&amp;T</code></div><div data-l="        match *self {"></div><div data-l="#            // Can't take ownership of the tail, because `self` is borrowed;"></div><div data-l="#            // instead take a reference to the tail"></div><div data-l="            // ">Can't take ownership of the tail, because <code>self</code> is borrowed; instead take a reference to the tail</div><div data-l="            Cons(_, ref tail) =&gt; 1 + tail.len(),"></div><div data-l="#            // Base Case: An empty list has zero length"></div><div data-l="            // ">Base Case: An empty list has zero length</div><div data-l="            Nil =&gt; 0"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l=""></div><div data-l="#    // Return representation of the list as a (heap allocated) string"></div><div data-l="    // ">Return representation of the list as a (heap allocated) string</div><div data-l="    fn stringify(&amp;self) -&gt; String {"></div><div data-l="        match *self {"></div><div data-l="            Cons(head, ref tail) =&gt; {"></div><div data-l="#                // `format!` is similar to `print!`, but returns a heap"></div><div data-l="#                // allocated string instead of printing to the console"></div><div data-l="                // "><code>format€</code> is similar to <code>print€</code>, but returns a heap allocated string instead of printing to the console</div><div data-l="                format!(&quot;{}, {}&quot;, head, tail.stringify())"></div><div data-l="            },"></div><div data-l="            Nil =&gt; {"></div><div data-l="                format!(&quot;Nil&quot;)"></div><div data-l="            },"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l="}"></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="#    // Create an empty linked list"></div><div data-l="    // ">Create an empty linked list</div><div data-l="    let mut list = List::new();"></div><div data-l=""></div><div data-l="#    // Prepend some elements"></div><div data-l="    // ">Prepend some elements</div><div data-l="    list = list.prepend(1);"></div><div data-l="    list = list.prepend(2);"></div><div data-l="    list = list.prepend(3);"></div><div data-l=""></div><div data-l="#    // Show the final state of the list"></div><div data-l="    // ">Show the final state of the list</div><div data-l="    println!(&quot;linked list has length: {}&quot;, list.len());"></div><div data-l="    println!(&quot;{}&quot;, list.stringify());"></div><div data-l="}"></div></div>
<br>
<h3>See also:</h3>
<br>
<p><a class="notranslate" href="#3box"><code>Box</code></a> and <a class="notranslate" href="#3methods">methods</a></p>
<br>
<a class="notranslate" href="#1std/box.html">box</a>
<a class="notranslate" href="#1fn/methods.html">methods</a>