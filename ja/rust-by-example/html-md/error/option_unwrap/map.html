<!DOCTYPE html>
<h1>Combinators: <code>map</code></h1>
<br>
<p><code>match</code> is a valid method for handling <code>Option</code>s. However, you may 
eventually find heavy usage tedious, especially with operations only valid 
with an input. In these cases, <a class="notranslate" href="#3combinators">combinators</a> can be used to 
manage control flow in a modular fashion.</p>
<br>
<p><code>Option</code> has a built in method called <code>map()</code>, a combinator for the simple 
mapping of <code>Some -&gt; Some</code> and <code>None -&gt; None</code>. Multiple <code>map()</code> calls can be 
chained together for even more flexibility.</p>
<br>
<p>In the following example, <code>process()</code> replaces all functions previous
to it while staying compact.</p>
<br>
<div data-lang="rust,editable"><div data-l="#![allow(dead_code)]"></div><div data-l=""></div><div data-l="#[derive(Debug)] enum Food { Apple, Carrot, Potato }"></div><div data-l=""></div><div data-l="#[derive(Debug)] struct Peeled(Food);"></div><div data-l="#[derive(Debug)] struct Chopped(Food);"></div><div data-l="#[derive(Debug)] struct Cooked(Food);"></div><div data-l=""></div><div data-l="#// Peeling food. If there isn't any, then return `None`."></div><div data-l="#// Otherwise, return the peeled food."></div><div data-l="// ">Peeling food. If there isn't any, then return <code>None</code>. Otherwise, return the peeled food.</div><div data-l="fn peel(food: Option&lt;Food&gt;) -&gt; Option&lt;Peeled&gt; {"></div><div data-l="    match food {"></div><div data-l="        Some(food) =&gt; Some(Peeled(food)),"></div><div data-l="        None       =&gt; None,"></div><div data-l="    }"></div><div data-l="}"></div><div data-l=""></div><div data-l="#// Chopping food. If there isn't any, then return `None`."></div><div data-l="#// Otherwise, return the chopped food."></div><div data-l="// ">Chopping food. If there isn't any, then return <code>None</code>. Otherwise, return the chopped food.</div><div data-l="fn chop(peeled: Option&lt;Peeled&gt;) -&gt; Option&lt;Chopped&gt; {"></div><div data-l="    match peeled {"></div><div data-l="        Some(Peeled(food)) =&gt; Some(Chopped(food)),"></div><div data-l="        None               =&gt; None,"></div><div data-l="    }"></div><div data-l="}"></div><div data-l=""></div><div data-l="#// Cooking food. Here, we showcase `map()` instead of `match` for case handling."></div><div data-l="// ">Cooking food. Here, we showcase <code>map()</code> instead of <code>match</code> for case handling.</div><div data-l="fn cook(chopped: Option&lt;Chopped&gt;) -&gt; Option&lt;Cooked&gt; {"></div><div data-l="    chopped.map(|Chopped(food)| Cooked(food))"></div><div data-l="}"></div><div data-l=""></div><div data-l="#// A function to peel, chop, and cook food all in sequence."></div><div data-l="#// We chain multiple uses of `map()` to simplify the code."></div><div data-l="// ">A function to peel, chop, and cook food all in sequence. We chain multiple uses of <code>map()</code> to simplify the code.</div><div data-l="fn process(food: Option&lt;Food&gt;) -&gt; Option&lt;Cooked&gt; {"></div><div data-l="    food.map(|f| Peeled(f))"></div><div data-l="        .map(|Peeled(f)| Chopped(f))"></div><div data-l="        .map(|Chopped(f)| Cooked(f))"></div><div data-l="}"></div><div data-l=""></div><div data-l="#// Check whether there's food or not before trying to eat it!"></div><div data-l="// ">Check whether there's food or not before trying to eat it!</div><div data-l="fn eat(food: Option&lt;Cooked&gt;) {"></div><div data-l="    match food {"></div><div data-l="        Some(food) =&gt; println!(&quot;Mmm. I love {:?}&quot;, food),"></div><div data-l="        None       =&gt; println!(&quot;Oh no! It wasn't edible.&quot;),"></div><div data-l="    }"></div><div data-l="}"></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let apple = Some(Food::Apple);"></div><div data-l="    let carrot = Some(Food::Carrot);"></div><div data-l="    let potato = None;"></div><div data-l=""></div><div data-l="    let cooked_apple = cook(chop(peel(apple)));"></div><div data-l="    let cooked_carrot = cook(chop(peel(carrot)));"></div><div data-l="#    // Let's try the simpler looking `process()` now."></div><div data-l="    // ">Let's try the simpler looking <code>process()</code> now.</div><div data-l="    let cooked_potato = process(potato);"></div><div data-l=""></div><div data-l="    eat(cooked_apple);"></div><div data-l="    eat(cooked_carrot);"></div><div data-l="    eat(cooked_potato);"></div><div data-l="}"></div></div>
<br>
<h3>See also:</h3>
<br>
<p><a class="notranslate" href="#3closures">closures</a>, <a class="notranslate" href="#3option"><code>Option</code></a>, <a class="notranslate" href="#3map"><code>Option::map()</code></a></p>
<br>
<a class="notranslate" href="#1https://doc.rust-lang.org/book/glossary.html#combinators">combinators</a>
<a class="notranslate" href="#1fn/closures.html">closures</a>
<a class="notranslate" href="#1https://doc.rust-lang.org/std/option/enum.Option.html">option</a>
<a class="notranslate" href="#1https://doc.rust-lang.org/std/option/enum.Option.html#method.map">map</a>