<!DOCTYPE html>
<h1><code>map</code> for <code>Result</code></h1>
<br>
<p>Panicking in the previous example's <code>multiply</code> does not make for robust code.
Generally, we want to return the error to the caller so it can decide what is
the right way to respond to errors.</p>
<br>
<p>We first need to know what kind of error type we are dealing with. To determine
the <code>Err</code> type, we look to <a class="notranslate" href="#3parse"><code>parse()</code></a>, which is implemented with the
<a class="notranslate" href="#3from_str"><code>FromStr</code></a> trait for <a class="notranslate" href="#3i32"><code>i32</code></a>. As a result, the <code>Err</code> type is
specified as <a class="notranslate" href="#3parse_int_error"><code>ParseIntError</code></a>.</p>
<br>
<p>In the example below, the straightforward <code>match</code> statement leads to code
that is overall more cumbersome.</p>
<br>
<div data-lang="rust,editable"><div data-l="use std::num::ParseIntError;"></div><div data-l=""></div><div data-l="#// With the return type rewritten, we use pattern matching without `unwrap()`."></div><div data-l="// ">With the return type rewritten, we use pattern matching without <code>unwrap()</code>.</div><div data-l="fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {"></div><div data-l="    match first_number_str.parse::&lt;i32&gt;() {"></div><div data-l="        Ok(first_number)  =&gt; {"></div><div data-l="            match second_number_str.parse::&lt;i32&gt;() {"></div><div data-l="                Ok(second_number)  =&gt; {"></div><div data-l="                    Ok(first_number * second_number)"></div><div data-l="                },"></div><div data-l="                Err(e) =&gt; Err(e),"></div><div data-l="            }"></div><div data-l="        },"></div><div data-l="        Err(e) =&gt; Err(e),"></div><div data-l="    }"></div><div data-l="}"></div><div data-l=""></div><div data-l="fn print(result: Result&lt;i32, ParseIntError&gt;) {"></div><div data-l="    match result {"></div><div data-l="        Ok(n)  =&gt; println!(&quot;n is {}&quot;, n),"></div><div data-l="        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),"></div><div data-l="    }"></div><div data-l="}"></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="#    // This still presents a reasonable answer."></div><div data-l="    // ">This still presents a reasonable answer.</div><div data-l="    let twenty = multiply(&quot;10&quot;, &quot;2&quot;);"></div><div data-l="    print(twenty);"></div><div data-l=""></div><div data-l="#    // The following now provides a much more helpful error message."></div><div data-l="    // ">The following now provides a much more helpful error message.</div><div data-l="    let tt = multiply(&quot;t&quot;, &quot;2&quot;);"></div><div data-l="    print(tt);"></div><div data-l="}"></div></div>
<br>
<p>Luckily, <code>Option</code>'s <code>map</code>, <code>and_then</code>, and many other combinators are also
implemented for <code>Result</code>. <a class="notranslate" href="#3result"><code>Result</code></a> contains a complete listing.</p>
<br>
<div data-lang="rust,editable"><div data-l="use std::num::ParseIntError;"></div><div data-l=""></div><div data-l="#// As with `Option`, we can use combinators such as `map()`."></div><div data-l="#// This function is otherwise identical to the one above and reads:"></div><div data-l="#// Modify n if the value is valid, otherwise pass on the error."></div><div data-l="// ">As with <code>Option</code>, we can use combinators such as <code>map()</code>. This function is otherwise identical to the one above and reads: Modify n if the value is valid, otherwise pass on the error.</div><div data-l="fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {"></div><div data-l="    first_number_str.parse::&lt;i32&gt;().and_then(|first_number| {"></div><div data-l="        second_number_str.parse::&lt;i32&gt;().map(|second_number| first_number * second_number)"></div><div data-l="    })"></div><div data-l="}"></div><div data-l=""></div><div data-l="fn print(result: Result&lt;i32, ParseIntError&gt;) {"></div><div data-l="    match result {"></div><div data-l="        Ok(n)  =&gt; println!(&quot;n is {}&quot;, n),"></div><div data-l="        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),"></div><div data-l="    }"></div><div data-l="}"></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="#    // This still presents a reasonable answer."></div><div data-l="    // ">This still presents a reasonable answer.</div><div data-l="    let twenty = multiply(&quot;10&quot;, &quot;2&quot;);"></div><div data-l="    print(twenty);"></div><div data-l=""></div><div data-l="#    // The following now provides a much more helpful error message."></div><div data-l="    // ">The following now provides a much more helpful error message.</div><div data-l="    let tt = multiply(&quot;t&quot;, &quot;2&quot;);"></div><div data-l="    print(tt);"></div><div data-l="}"></div></div>
<br>
<a class="notranslate" href="#1https://doc.rust-lang.org/std/primitive.str.html#method.parse">parse</a>
<a class="notranslate" href="#1https://doc.rust-lang.org/std/str/trait.FromStr.html">from_str</a>
<a class="notranslate" href="#1https://doc.rust-lang.org/std/primitive.i32.html">i32</a>
<a class="notranslate" href="#1https://doc.rust-lang.org/std/num/struct.ParseIntError.html">parse_int_error</a>
<a class="notranslate" href="#1https://doc.rust-lang.org/std/result/enum.Result.html">result</a>