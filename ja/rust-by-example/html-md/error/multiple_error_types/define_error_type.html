<!DOCTYPE html>
<h1>Defining an error type</h1>
<br>
<p>Sometimes it simplifies the code to mask all of the different errors with a
single type of error.  We'll show this with a custom error.</p>
<br>
<p>Rust allows us to define our own error types. In general, a &quot;good&quot; error type:</p>
<br>
<div data-b="*">Represents different errors with the same type</div>
<div data-b="*">Presents nice error messages to the user</div>
<div data-b="*">Is easy to compare with other types</div>
<div data-b="    -">Good: <code>Err(EmptyVec)</code></div>
<div data-b="    -">Bad: <code>Err(&quot;Please use a vector with at least one element&quot;.to_owned())</code></div>
<div data-b="*">Can hold information about the error</div>
<div data-b="    -">Good: <code>Err(BadChar(c, position))</code></div>
<div data-b="    -">Bad: <code>Err(&quot;+ cannot be used here&quot;.to_owned())</code></div>
<div data-b="*">Composes well with other errors</div>
<br>
<div data-lang="rust,editable"><div data-l="use std::error;"></div><div data-l="use std::fmt;"></div><div data-l="use std::num::ParseIntError;"></div><div data-l=""></div><div data-l="type Result&lt;T&gt; = std::result::Result&lt;T, DoubleError&gt;;"></div><div data-l=""></div><div data-l="#[derive(Debug, Clone)]"></div><div data-l="#// Define our error types. These may be customized for our error handling cases."></div><div data-l="#// Now we will be able to write our own errors, defer to an underlying error"></div><div data-l="#// implementation, or do something in between."></div><div data-l="// ">Define our error types. These may be customized for our error handling cases. Now we will be able to write our own errors, defer to an underlying error implementation, or do something in between.</div><div data-l="struct DoubleError;"></div><div data-l=""></div><div data-l="#// Generation of an error is completely separate from how it is displayed."></div><div data-l="#// There's no need to be concerned about cluttering complex logic with the display style."></div><div data-l="// ">Generation of an error is completely separate from how it is displayed. There's no need to be concerned about cluttering complex logic with the display style.</div><div data-l="//"></div><div data-l="#// Note that we don't store any extra info about the errors. This means we can't state"></div><div data-l="#// which string failed to parse without modifying our types to carry that information."></div><div data-l="// ">Note that we don't store any extra info about the errors. This means we can't state which string failed to parse without modifying our types to carry that information.</div><div data-l="impl fmt::Display for DoubleError {"></div><div data-l="    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {"></div><div data-l="        write!(f, &quot;invalid first item to double&quot;)"></div><div data-l="    }"></div><div data-l="}"></div><div data-l=""></div><div data-l="#// This is important for other errors to wrap this one."></div><div data-l="// ">This is important for other errors to wrap this one.</div><div data-l="impl error::Error for DoubleError {"></div><div data-l="    fn description(&amp;self) -&gt; &amp;str {"></div><div data-l="        &quot;invalid first item to double&quot;"></div><div data-l="    }"></div><div data-l=""></div><div data-l="    fn cause(&amp;self) -&gt; Option&lt;&amp;error::Error&gt; {"></div><div data-l="#        // Generic error, underlying cause isn't tracked."></div><div data-l="        // ">Generic error, underlying cause isn't tracked.</div><div data-l="        None"></div><div data-l="    }"></div><div data-l="}"></div><div data-l=""></div><div data-l="fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Result&lt;i32&gt; {"></div><div data-l="    vec.first()"></div><div data-l="#       // Change the error to our new type."></div><div data-l="       // ">Change the error to our new type.</div><div data-l="       .ok_or(DoubleError)"></div><div data-l="       .and_then(|s| s.parse::&lt;i32&gt;()"></div><div data-l="#            // Update to the new error type here also."></div><div data-l="            // ">Update to the new error type here also.</div><div data-l="            .map_err(|_| DoubleError)"></div><div data-l="            .map(|i| 2 * i))"></div><div data-l="}"></div><div data-l=""></div><div data-l="fn print(result: Result&lt;i32&gt;) {"></div><div data-l="    match result {"></div><div data-l="        Ok(n)  =&gt; println!(&quot;The first doubled is {}&quot;, n),"></div><div data-l="        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),"></div><div data-l="    }"></div><div data-l="}"></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let numbers = vec![&quot;42&quot;, &quot;93&quot;, &quot;18&quot;];"></div><div data-l="    let empty = vec![];"></div><div data-l="    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];"></div><div data-l=""></div><div data-l="    print(double_first(numbers));"></div><div data-l="    print(double_first(empty));"></div><div data-l="    print(double_first(strings));"></div><div data-l="}"></div></div>