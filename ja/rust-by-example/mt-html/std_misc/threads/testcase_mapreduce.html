<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180730_RC02/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=testcase_mapreduce.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Testcase: map-reduce</span>テストケース：map-reduce</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust makes it very easy to parallelise data processing, without many of the headaches traditionally associated with such an attempt.</span>錆は、伝統的にそのような試みに関連した頭痛の多くを伴わずに、データ処理を並列化することを非常に容易にする。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The standard library provides great threading primitives out of the box.</span>標準ライブラリは、すぐに使える素晴らしいスレッドプリミティブを提供します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These, combined with Rust&#39;s concept of Ownership and aliasing rules, automatically prevent data races.</span>これらはRustの所有権とエイリアスルールのコンセプトと組み合わせて、データ競合を自動的に防止します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The aliasing rules (one writable reference XOR many readable references) automatically prevent you from manipulating state that is visible to other threads.</span>エイリアスのルール（1つの書き込み可能な参照XOR多くの読み取り可能な参照）は自動的に、他のスレッドから見える状態を操作できなくなります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">(Where synchronisation is needed, there are synchronisation primitives like <code>Mutex</code> es or <code>Channel</code> s.)</span> （同期が必要な場合は、 <code>Mutex</code> esや<code>Channel</code> sなどの同期プリミティブがあります。）</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In this example, we will calculate the sum of all digits in a block of numbers.</span>この例では、数値のブロック内のすべての桁の合計を計算します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We will do this by parcelling out chunks of the block into different threads.</span>ブロックのチャンクを別のスレッドに分割することでこれを行います。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Each thread will sum its tiny block of digits, and subsequently we will sum the intermediate sums produced by each thread.</span>各スレッドは、その小さな桁のブロックを合計し、その後、各スレッドによって生成された中間合計を合計します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that, although we&#39;re passing references across thread boundaries, Rust understands that we&#39;re only passing read-only references, and that thus no unsafety or data races can occur.</span>スレッド境界を越えて参照を渡していますが、Rustは読み取り専用の参照のみを渡していることを理解しているため、安全でないかデータ競合が発生する可能性はありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because we&#39;re <code>move</code> -ing the data segments into the thread, Rust will also ensure the data is kept alive until the threads exit, so no dangling pointers occur.</span>データセグメントをスレッドに<code>move</code>ため、Rustはスレッドが終了するまでデータが確実に保持されるようにして、ぶら下がりポインタが発生しないようにします。</span> </p><br><div data-lang=rust,editable><div data-l="use std::thread;"></div><div data-l=""></div><div data-l="#// This is the `main` thread"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is the <code>main</code> thread</span>これが<code>main</code>スレッドです</span> </div><div data-l="fn main() {"></div><div data-l=""></div><div data-l="#    // This is our data to process."></div><div data-l="#    // We will calculate the sum of all digits via a threaded  map-reduce algorithm."></div><div data-l="#    // Each whitespace separated chunk will be handled in a different thread."></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is our data to process.</span>これが処理するデータです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We will calculate the sum of all digits via a threaded map-reduce algorithm.</span>私たちはスレッドマップ削減アルゴリズムを使ってすべての数字の合計を計算します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Each whitespace separated chunk will be handled in a different thread.</span>各空白で区切られたチャンクは、別のスレッドで処理されます。</span> </div><div data-l="    //"></div><div data-l="#    // TODO: see what happens to the output if you insert spaces!"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">TODO: see what happens to the output if you insert spaces!</span> TODO：スペースを挿入すると、出力に何が起こるかを確認してください！</span> </div><div data-l="    let data = &quot;86967897737416471853297327050364959"></div><div data-l=11861322575564723963297542624962850></div><div data-l=70856234701860851907960690014725639></div><div data-l=38397966707106094172783238747669219></div><div data-l=52380795257888236525459303330302837></div><div data-l=58495327135744041048897885734297812></div><div data-l=69920216438980873548808413720956532></div><div data-l=16278424637452589860345374828574668&quot;;></div><div data-l=""></div><div data-l="#    // Make a vector to hold the child-threads which we will spawn."></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Make a vector to hold the child-threads which we will spawn.</span>生成する子スレッドを保持するベクトルを作成します。</span> </div><div data-l="    let mut children = vec![];"></div><div data-l=""></div><div data-l="    /*************************************************************************"></div><div data-l="     * &quot;Map&quot; phase"></div><div data-l="     *"></div><div data-l="     * Divide our data into segments, and apply initial processing"></div><div data-l="     ************************************************************************/"></div><div data-l=""></div><div data-l="#    // split our data into segments for individual calculation"></div><div data-l="#    // each chunk will be a reference (&amp;str) into the actual data"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">split our data into segments for individual calculation each chunk will be a reference (&amp;str) into the actual data</span>個々の計算のために私たちのデータをセグメントに分割します。各チャンクは実際のデータへの参照（＆str）になります</span> </div><div data-l="    let chunked_data = data.split_whitespace();"></div><div data-l=""></div><div data-l="#    // Iterate over the data segments."></div><div data-l="#    // .enumerate() adds the current loop index to whatever is iterated"></div><div data-l="#    // the resulting tuple &quot;(index, element)&quot; is then immediately"></div><div data-l="#    // &quot;destructured&quot; into two variables, &quot;i&quot; and &quot;data_segment&quot; with a"></div><div data-l="#    // &quot;destructuring assignment&quot;"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Iterate over the data segments.</span>データセグメントを反復処理します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">.enumerate() adds the current loop index to whatever is iterated the resulting tuple &quot;(index, element)&quot; is then immediately &quot;destructured&quot; into two variables, &quot;i&quot; and &quot;data_segment&quot; with a &quot;destructuring assignment&quot;</span> .enumerate（）は、現在のループインデックスを、結果のタプル &quot;（index、element）&quot;が反復されるものに追加します。 &quot;destructuring assignment&quot;を伴う &quot;i&quot;と &quot;data_segment&quot;</span> </div><div data-l="    for (i, data_segment) in chunked_data.enumerate() {"></div><div data-l="        println!(&quot;data segment {} is \&quot;{}\&quot;&quot;, i, data_segment);"></div><div data-l=""></div><div data-l="#        // Process each data segment in a separate thread"></div><div data-l="        // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Process each data segment in a separate thread</span>別のスレッドで各データセグメントを処理する</span> </div><div data-l="        //"></div><div data-l="#        // spawn() returns a handle to the new thread,"></div><div data-l="#        // which we MUST keep to access the returned value"></div><div data-l="        // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">spawn() returns a handle to the new thread, which we MUST keep to access the returned value</span> spawn（）は新しいスレッドへのハンドルを返します。返された値にアクセスするためにはそれを保持しなければなりません</span> </div><div data-l="        //"></div><div data-l="#        // 'move || -&gt; u32' is syntax for a closure that:"></div><div data-l="#        // * takes no arguments ('||')"></div><div data-l="#        // * takes ownership of its captured variables ('move') and"></div><div data-l="#        // * returns an unsigned 32-bit integer ('-&gt; u32')"></div><div data-l="        // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">&#39;move ||</span> &#39;移動||</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">-&gt; u32&#39; is syntax for a closure that: * takes no arguments (&#39;||&#39;) * takes ownership of its captured variables (&#39;move&#39;) and * returns an unsigned 32-bit integer (&#39;-&gt; u32&#39;)</span> - &gt; u32 &#39;は、引数を取らない（&#39; || &#39;）*はキャプチャされた変数（&#39; move &#39;）の所有権を持ち、*は符号なし32ビット整数（&#39;  - &gt; u32 &#39;）を返すクロージャの構文です</span> </div><div data-l="        //"></div><div data-l="#        // Rust is smart enough to infer the '-&gt; u32' from"></div><div data-l="#        // the closure itself so we could have left that out."></div><div data-l="        // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust is smart enough to infer the &#39;-&gt; u32&#39; from the closure itself so we could have left that out.</span>錆は、クロージャ自身から &#39; - &gt; u32&#39;を推論するのに十分なほどスマートです。</span> </div><div data-l="        //"></div><div data-l="#        // TODO: try removing the 'move' and see what happens"></div><div data-l="        // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">TODO: try removing the &#39;move&#39; and see what happens</span> TODO： &#39;移動&#39;を削除して何が起こるかを確認してください</span> </div><div data-l="        children.push(thread::spawn(move || -&gt; u32 {"></div><div data-l="#            // Calculate the intermediate sum of this segment:"></div><div data-l="            // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Calculate the intermediate sum of this segment:</span>このセグメントの中間合計を計算します。</span> </div><div data-l="            let result = data_segment"></div><div data-l="#                        // iterate over the characters of our segment.."></div><div data-l="                        // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">iterate over the characters of our segment..</span>私たちのセグメントの文字を繰り返します。</span> </div><div data-l="                        .chars()"></div><div data-l="#                        // .. convert text-characters to their number value.."></div><div data-l="                        // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">.. convert text-characters to their number value..</span> ..テキスト文字を数値に変換する..</span> </div><div data-l="                        .map(|c| c.to_digit(10).expect(&quot;should be a digit&quot;))"></div><div data-l="#                        // .. and sum the resulting iterator of numbers"></div><div data-l="                        // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">.. and sum the resulting iterator of numbers</span> ..そして得られた数の反復子</span> </div><div data-l="                        .sum();"></div><div data-l=""></div><div data-l="#            // println! locks stdout, so no text-interleaving occurs"></div><div data-l="            // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">println!</span> println！</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">locks stdout, so no text-interleaving occurs</span> stdoutをロックするので、テキストインターリーブは起こりません</span> </div><div data-l="            println!(&quot;processed segment {}, result={}&quot;, i, result);"></div><div data-l=""></div><div data-l="#            // &quot;return&quot; not needed, because Rust is an &quot;expression language&quot;, the"></div><div data-l="#            // last evaluated expression in each block is automatically its value."></div><div data-l="            // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">&quot;return&quot; not needed, because Rust is an &quot;expression language&quot;, the last evaluated expression in each block is automatically its value.</span> Rustは &quot;式言語&quot;なので、 &quot;return&quot;は必要ありません。各ブロックの最後に評価された式は自動的にその値になります。</span> </div><div data-l="            result"></div><div data-l=""></div><div data-l="        }));"></div><div data-l="    }"></div><div data-l=""></div><div data-l=""></div><div data-l="    /*************************************************************************"></div><div data-l="     * &quot;Reduce&quot; phase"></div><div data-l="     *"></div><div data-l="     * Collect our intermediate results, and combine them into a final result"></div><div data-l="     ************************************************************************/"></div><div data-l=""></div><div data-l="#    // collect each thread's intermediate results into a new Vec"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">collect each thread&#39;s intermediate results into a new Vec</span>各スレッドの中間結果を新しいVecに集める</span> </div><div data-l="    let mut intermediate_sums = vec![];"></div><div data-l="    for child in children {"></div><div data-l="#        // collect each child thread's return-value"></div><div data-l="        // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">collect each child thread&#39;s return-value</span>各子スレッドの戻り値を収集する</span> </div><div data-l="        let intermediate_sum = child.join().unwrap();"></div><div data-l="        intermediate_sums.push(intermediate_sum);"></div><div data-l="    }"></div><div data-l=""></div><div data-l="#    // combine all intermediate sums into a single final sum."></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">combine all intermediate sums into a single final sum.</span>すべての中間合計を1つの最終的な合計にまとめます。</span> </div><div data-l="    //"></div><div data-l="#    // we use the &quot;turbofish&quot; ::&lt;&gt; to provide sum() with a type hint."></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">we use the &quot;turbofish&quot; ::&lt;&gt; to provide sum() with a type hint.</span>私たちは &quot;turbofish&quot; :: &lt;&gt;を使用して、sum（）に型ヒントを提供します。</span> </div><div data-l="    //"></div><div data-l="#    // TODO: try without the turbofish, by instead explicitly"></div><div data-l="#    // specifying the type of final_result"></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">TODO: try without the turbofish, by instead explicitly specifying the type of final_result</span> TODO：turbofishを使わずに、代わりにfinal_resultの型を明示的に指定する</span> </div><div data-l="    let final_result = intermediate_sums.iter().sum::&lt;u32&gt;();"></div><div data-l=""></div><div data-l="    println!(&quot;Final sum result: {}&quot;, final_result);"></div><div data-l="}"></div><div data-l=""></div><div data-l=""></div></div><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Assignments</span>割り当て</span> </h3><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It is not wise to let our number of threads depend on user inputted data.</span>私たちのスレッド数をユーザーが入力したデータに依存させるのは賢明ではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">What if the user decides to insert a lot of spaces?</span>ユーザーが多くのスペースを挿入することを決定したらどうなりますか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Do we <s>really</s> want to spawn 2,000 threads?</span>私たちは<s>本当に</s> 2,000スレッドを生成したいのですか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Modify the program so that the data is always chunked into a limited number of chunks, defined by a static constant at the beginning of the program.</span>プログラムの始めに静的な定数で定義された限られた数のチャンクにデータが常にチャンクされるように、プログラムを修正します。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">See also:</span>参照：</span> </h3><div data-b="*"> <a class="notranslate" href="#3thread">Threads</a> </div> <div data-b="*"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a class="notranslate" href="#3vectors">vectors</a> and <a class="notranslate" href="#3iterators">iterators</a></span> <a class="notranslate" href="#3vectors">vectors</a>と<a class="notranslate" href="#3iterators">iterators</a></span> </div><div data-b="*"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a class="notranslate" href="#3closures">closures</a> , <a class="notranslate" href="#3move">move</a> semantics and <a href="#3move_closure"><code>move</code> closures</a></span> <a class="notranslate" href="#3closures">closures</a> 、 <a class="notranslate" href="#3move">move</a>セマンティクスと<a href="#3move_closure"><code>move</code>クロージャ</a></span> </div><div data-b="*"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a class="notranslate" href="#3destructuring">destructuring</a> assignments</span> <a class="notranslate" href="#3destructuring">destructuring</a>割り当て</span> </div><div data-b="*"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a href="#3turbofish">turbofish notation</a> to help type inference</span>型推論を支援する<a href="#3turbofish">ターボフィッシュ表記法</a></span> </div><div data-b="*"> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a href="#3unwrap">unwrap vs. expect</a></span> <a href="#3unwrap">アンラップ対期待</a></span> </div><div data-b="*"> <a class="notranslate" href="#3enumerate">enumerate</a> </div> <br> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><a class="notranslate" href="#1std_misc/threads.html">thread</a> <a class="notranslate" href="#1std/vec.html">vectors</a> <a class="notranslate" href="#1trait/iter.html">iterators</a> <a class="notranslate" href="#1https://doc.rust-lang.org/book/second-edition/ch18-03-pattern-syntax.html#destructuring-to-break-apart-values">destructuring</a> <a class="notranslate" href="#1fn/closures.html">closures</a> <a class="notranslate" href="#1scope/move.html">move</a> <a class="notranslate" href="#1https://doc.rust-lang.org/book/second-edition/ch13-01-closures.html#closures-can-capture-their-environment">move_closure</a> <a class="notranslate" href="#1https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.collect">turbofish</a> <a class="notranslate" href="#1error/option_unwrap.html">unwrap</a> <a class="notranslate" href="#1https://doc.rust-lang.org/book/loops.html#enumerate">enumerate</a></span> <a class="notranslate" href="#1std_misc/threads.html">thread</a> <a class="notranslate" href="#1std/vec.html">vectors</a> <a class="notranslate" href="#1trait/iter.html">iterators</a> <a class="notranslate" href="#1https://doc.rust-lang.org/book/second-edition/ch18-03-pattern-syntax.html#destructuring-to-break-apart-values">destructuring</a> <a class="notranslate" href="#1fn/closures.html">closures</a> <a class="notranslate" href="#1scope/move.html">move</a> <a class="notranslate" href="#1https://doc.rust-lang.org/book/second-edition/ch13-01-closures.html#closures-can-capture-their-environment">move_closure</a> <a class="notranslate" href="#1https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.collect">turbofish</a> <a class="notranslate" href="#1error/option_unwrap.html">unwrap</a> <a class="notranslate" href="#1https://doc.rust-lang.org/book/loops.html#enumerate">enumerate</a></span><script>_addload(function(){_setupIW('com');_csi('en','ja','testcase_mapreduce.html');});</script>