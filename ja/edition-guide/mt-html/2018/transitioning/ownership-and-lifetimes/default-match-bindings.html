<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180723_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=default-match-bindings.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Default match bindings</span>デフォルトのマッチバインディング</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Have you ever had a borrowed <code>Option&lt;T&gt;</code> and tried to match on it?</span>あなたは借用された<code>Option&lt;T&gt;</code>を持っていて、それにマッチさせようとしましたか？</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You probably wrote this:</span>あなたはおそらくこれを書きました：</span> </p><br><div data-lang=rust,ignore><div data-l="let s: &amp;Option&lt;String&gt; = &amp;Some(&quot;hello&quot;.to_string());"></div><div data-l=""></div><div data-l="match s {"></div><div data-l="    Some(s) =&gt; println!(&quot;s is: {}&quot;, s),"></div><div data-l="    _ =&gt; (),"></div><div data-l=};></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In Rust 2015, this would fail to compile, and you would have to write the following instead:</span> Rust 2015では、これはコンパイルに失敗し、以下のように書く必要があります。</span> </p><br><div data-lang=rust,ignore><div data-l="#// Rust 2015"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust 2015</span> 2015年の錆</span> </div><div data-l=""></div><div data-l="let s: &amp;Option&lt;String&gt; = &amp;Some(&quot;hello&quot;.to_string());"></div><div data-l=""></div><div data-l="match s {"></div><div data-l="    &amp;Some(ref s) =&gt; println!(&quot;s is: {}&quot;, s),"></div><div data-l="    _ =&gt; (),"></div><div data-l=};></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Rust 2018, by contrast, will infer the <code>&amp;</code> s and <code>ref</code> s, and your original code will Just Work.</span>対照的に、Rust 2018は<code>&amp;</code> sと<code>ref</code>を推測し、元のコードはJust Workとなります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This affects not just <code>match</code> , but patterns everywhere, such as in <code>let</code> statements, closure arguments, and <code>for</code> loops.</span>これは、単に<code>match</code>だけ<code>match</code>なく、 <code>let</code>文、クロージャ引数、 <code>for</code>ループなどのあらゆるところでパターンに影響<code>for</code>ます。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">More details</span>詳細</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The mental model of patterns has shifted a bit with this change, to bring it into line with other aspects of the language.</span>パターンの精神モデルは、言語の他の側面と一致させるために、この変更で少しシフトしました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, when writing a <code>for</code> loop, you can iterate over borrowed contents of a collection by borrowing the collection itself:</span>たとえば、 <code>for</code>ループを記述する<code>for</code> 、コレクション自体を借用して、コレクションの借用されたコンテンツを反復処理できます。</span> </p><br><div data-lang=rust,ignore><div data-l="let my_vec: Vec&lt;i32&gt; = vec![0, 1, 2];"></div><div data-l=""></div><div data-l="for x in &amp;my_vec { ... }"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The idea is that an <code>&amp;T</code> can be understood as a <i>borrowed view of `T`</i> , and so when you iterate, match, or otherwise destructure a <code>&amp;T</code> you get a borrowed view of its internals as well.</span>その考え方は、 <code>&amp;T</code>が<i>`T &#39;の借用ビュー</i>として理解できるということです。したがって、あなたが反復、マッチング、または他の方法で<code>&amp;T</code>を破壊すると、内部の借用ビューも取得されます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">More formally, patterns have a &quot;binding mode,&quot; which is either by value ( <code>x</code> ), by reference ( <code>ref x</code> ), or by mutable reference ( <code>ref mut x</code> ).</span>より形式的には、パターンは、値（ <code>x</code> ）、参照（ <code>ref x</code> ）、または変更可能な参照（ <code>ref mut x</code> ）のいずれかである「結合モード」を持ちます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In Rust 2015, <code>match</code> always started in by-value mode, and required you to explicitly write <code>ref</code> or <code>ref mut</code> in patterns to switch to a borrowing mode.</span> Rust 2015では、 <code>match</code>常にby-valueモードで開始されており、借用モードに切り替えるために<code>ref</code>または<code>ref mut</code>をパターンで明示的に書く必要がありました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In Rust 2018, the type of the value being matched informs the binding mode, so that if you match against an <code>&amp;Option&lt;String&gt;</code> with a <code>Some</code> variant, you are put into <code>ref</code> mode automatically, giving you a borrowed view of the internal data.</span> Rust 2018では、一致する値のタイプによってバインディングモードが通知されるため、 <code>&amp;Option&lt;String&gt;</code>と<code>Some</code>バリアントを照合すると、自動的に<code>ref</code>モードになり、内部データの借用ビューが得られます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Similarly, <code>&amp;mut Option&lt;String&gt;</code> would give you a <code>ref mut</code> view.</span>同様に、 <code>&amp;mut Option&lt;String&gt;</code>を使用すると、 <code>ref mut</code>ビューが得られます。</span> </p><script>_addload(function(){_setupIW('com');_csi('en','ja','default-match-bindings.html');});</script>