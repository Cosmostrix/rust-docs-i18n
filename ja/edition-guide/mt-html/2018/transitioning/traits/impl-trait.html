<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180723_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=impl-trait.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhi1BDLmdbWiRXYMNxkaJ7TdmUrvmA" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h1> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">impl Trait</span>インプット特性</span> </h1><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>impl Trait</code> is the new way to specify unnamed but concrete types that implement a specific trait.</span> <code>impl Trait</code>は、特定の特性を実装する名前のない具体的な型を指定する新しい方法です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There are two places you can put it: argument position, and return position.</span>あなたが置くことができる場所は、引数の位置と戻り位置の2つです。</span> </p><br><div data-lang=rust,ignore><div data-l="trait Trait {}"></div><div data-l=""></div><div data-l="#// argument position"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">argument position</span>引数の位置</span> </div><div data-l="fn foo(arg: impl Trait) {"></div><div data-l=}></div><div data-l=""></div><div data-l="#// return position"></div><div data-l="// "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">return position</span>戻り位置</span> </div><div data-l="fn foo() -&gt; impl Trait {"></div><div data-l=}></div></div><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Argument Position</span>引数の位置</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In argument position, this feature is quite simple.</span>引数の位置では、この機能は非常に単純です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">These two forms are almost the same:</span>これらの2つの形式はほぼ同じです。</span> </p><br><div data-lang=rust,ignore><div data-l="trait Trait {}"></div><div data-l=""></div><div data-l="fn foo&lt;T: Trait&gt;(arg: T) {"></div><div data-l=}></div><div data-l=""></div><div data-l="fn foo(arg: impl Trait) {"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That is, it&#39;s a slightly shorter syntax for a generic type parameter.</span>つまり、ジェネリック型パラメータのシンタックスが少し短くなっています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It means, &quot; <code>arg</code> is an argument that takes any type that implements the <code>Trait</code> trait.&quot;</span>それは「意味<code>arg</code>実装する任意のタイプとる引数である<code>Trait</code>形質を。」</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, there&#39;s also an important technical difference between <code>T: Trait</code> and <code>impl Trait</code> here.</span>しかし、間の重要な技術的な違いもあります<code>T: Trait</code>と<code>impl Trait</code>ここでは。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When you write the former, you can specify the type of <code>T</code> at the call site with turbo-fish syntax as with <code>foo::&lt;usize&gt;(1)</code> .</span>前者を書くときは、 <code>foo::&lt;usize&gt;(1)</code>ようにturbo-fish構文を使ってコールサイトで<code>T</code>のタイプを指定することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In the case of <code>impl Trait</code> , if it is used anywhere in the function definition, then you can&#39;t use turbo-fish at all.</span> <code>impl Trait</code>の場合、関数定義のどこでも使用されていれば、ターボフィッシュはまったく使用できません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Therefore, you should be mindful that changing both from and to <code>impl Trait</code> can constitute a breaking change for the users of your code.</span>したがって、 <code>impl Trait</code>を<code>impl Trait</code>から<code>impl Trait</code>変えることは、あなたのコードのユーザにとって大きな変化をもたらす可能性があることに注意してください。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Return Position</span>戻り位置</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In return position, this feature is more interesting.</span>戻り位置では、この機能はより面白いです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It means &quot;I am returning some type that implements the <code>Trait</code> trait, but I&#39;m not going to tell you exactly what the type is.&quot;</span>それは、「私は、 <code>Trait</code>形質を実装するいくつかの型を返していますが、型が何であるかを正確に伝えるつもりはありません」という意味です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Before <code>impl Trait</code> , you could do this with trait objects:</span> <code>impl Trait</code>前に、traitオブジェクトでこれを行うことができます：</span> </p><br><div data-lang=rust><div data-l="trait Trait {}"></div><div data-l=""></div><div data-l="impl Trait for i32 {}"></div><div data-l=""></div><div data-l="fn returns_a_trait_object() -&gt; Box&lt;dyn Trait&gt; {"></div><div data-l="    Box::new(5)"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, this has some overhead: the <code>Box&lt;T&gt;</code> means that there&#39;s a heap allocation here, and this will use dynamic dispatch.</span>しかし、これにはいくつかのオーバーヘッドがあります<code>Box&lt;T&gt;</code>はここにヒープ割り当てがあることを意味し、動的ディスパッチを使用します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">See the <a class=notranslate href="#4`dyn Trait`">`dyn Trait`</a> section for an explanation of this syntax.</span>この構文の説明については、 <a class=notranslate href="#4`dyn Trait`">`dyn Trait`</a>セクションを参照してください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But we only ever return one possible thing here, the <code>Box&lt;i32&gt;</code> .</span>しかし、私たちは一つの可能​​なもの、 <code>Box&lt;i32&gt;</code>返すだけです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This means that we&#39;re paying for dynamic dispatch, even though we don&#39;t use it!</span>これは、たとえそれを使用していないとしても、動的なディスパッチを支払うことを意味します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">With <code>impl Trait</code> , the code above could be written like this:</span> <code>impl Trait</code>では、上のコードは次のように書くことができます：</span> </p><br><div data-lang=rust><div data-l="trait Trait {}"></div><div data-l=""></div><div data-l="impl Trait for i32 {}"></div><div data-l=""></div><div data-l="fn returns_a_trait_object() -&gt; impl Trait {"></div><div data-l="    5"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here, we have no <code>Box&lt;T&gt;</code> , no trait object, and no dynamic dispatch.</span>ここでは、 <code>Box&lt;T&gt;</code> 、Traitオブジェクト、および動的ディスパッチはありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But we still can obscure the <code>i32</code> return type.</span>しかし私はまだ<code>i32</code>戻り値の型をあいまいにすることができます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">With <code>i32</code> , this isn&#39;t super useful.</span> <code>i32</code>では、これは非常に便利ではありません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">But there&#39;s one major place in Rust where this is much more useful: closures.</span>しかし、Rustにはこれがはるかに便利な1つの主要な場所があります：閉鎖。</span> </p><br> <a class=notranslate href=#12018/transitioning/traits/dyn-trait.html>`dyn Trait`</a> <br> <h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>impl Trait</code> and closures</span> <code>impl Trait</code>とクロージャ</span> </h3><br><blockquote><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If you need to catch up on closures, check out <a href=#2https://doc.rust-lang.org/book/second-edition/ch13-01-closures.html>their chapter in the book</a> .</span>閉鎖に追いつく必要がある場合<a href=#2https://doc.rust-lang.org/book/second-edition/ch13-01-closures.html>は、本の章を参照して</a>ください。</span> </p></blockquote><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In Rust, closures have a unique, un-writable type.</span> Rustでは、クロージャーは一意で書き込み不可能なタイプです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">They do implement the <code>Fn</code> family of traits, however.</span>しかし彼らは、 <code>Fn</code>ファミリーの形質を導入してい<code>Fn</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This means that previously, the only way to return a closure from a function was to use a trait object:</span>これは、これまで、関数からクロージャを返す唯一の方法は、traitオブジェクトを使用することでした：</span> </p><br><div data-lang=rust><div data-l="fn returns_closure() -&gt; Box&lt;dyn Fn(i32) -&gt; i32&gt; {"></div><div data-l="    Box::new(|x| x + 1)"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You couldn&#39;t write the type of the closure, only use the <code>Fn</code> trait.</span>クロージャーのタイプを書くことはできず、 <code>Fn</code>特性のみを使用し<code>Fn</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That means that the trait object is necessary.</span>つまり、特性オブジェクトが必要です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, with <code>impl Trait</code> :</span>しかしながら、 <code>impl Trait</code> ：</span> </p><br><div data-lang=rust><div data-l="fn returns_closure() -&gt; impl Fn(i32) -&gt; i32 {"></div><div data-l="    |x| x + 1"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can now return closures by value, just like any other type!</span>他の型と同じように、クロージャを値で返すことができるようになりました。</span> </p><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">More details</span>詳細</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The above is all you need to know to get going with <code>impl Trait</code> , but for some more nitty-gritty details: type parameters and <code>impl Trait</code> in argument position are universals (universally quantified types).</span>上のものは、インプ<code>impl Trait</code>を使うために知る必要があるのですが、いくつかのより詳細な詳細については、型パラメータとインプリメント引数位置の<code>impl Trait</code>はユニバーサル（普遍的な定量型）です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Meanwhile, <code>impl Trait</code> in return position are existentials (existentially quantified types).</span>一方、リターン位置の<code>impl Trait</code>は、存在する（現存する定量化された型）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Okay, maybe that&#39;s a bit too jargon-heavy.</span>さて、あまりにも専門用語が重すぎるかもしれません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s step back.</span>元気に戻ろう。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Consider this function:</span>この関数を考えてみましょう：</span> </p><br><div data-lang=rust,ignore><div data-l="fn foo&lt;T: Trait&gt;(x: T) {"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When you call it, you set the type, <code>T</code> .</span>あなたがそれを呼び出すと、タイプ<code>T</code>を設定します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">&quot;you&quot; being the caller here.</span> &quot;あなた&quot;はここに発信者です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This signature says &quot;I accept any type that implements Trait.&quot;</span>このシグネチャは「私はTraitを実装するすべての型を受け入れる」と述べています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">(&quot;any type&quot; == universal in the jargon)</span> （「任意のタイプ」==専門用語の普遍的な）</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This version:</span>このバージョン：</span> </p><br><div data-lang=rust,ignore><div data-l="fn foo&lt;T: Trait&gt;() -&gt; T {"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">is similar, but also different.</span>類似しているが、異なっている。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You, the caller, provide the type you want, <code>T</code> , and then the function returns it.</span>呼び出し元は、必要な型<code>T</code> 、関数がそれを返します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You can see this in Rust today with things like parse or collect:</span>あなたは今日、Rustでこれをparseやcollectのようなもので見ることができます：</span> </p><br><div data-lang=rust,ignore><div data-l="let x: i32 = &quot;5&quot;.parse()?;"></div><div data-l="let x: u64 = &quot;5&quot;.parse()?;"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here, <code>.parse</code> has this signature:</span>ここでは、 <code>.parse</code>は次のシグネチャがあります。</span> </p><br><div data-lang=rust,ignore><div data-l="pub fn parse&lt;F&gt;(&amp;self) -&gt; Result&lt;F, &lt;F as FromStr&gt;::Err&gt; where"></div><div data-l="    F: FromStr,"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Same general idea, though with a result type and <code>FromStr</code> has an associated type... anyway, you can see how <code>F</code> is in the return position here.</span>同じ一般的な考え方ですが、結果の型と<code>FromStr</code>には関連する型があります...とにかく、ここで<code>F</code>がどのように戻り位置にあるかを見ることができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So you have the ability to choose.</span>あなたは選択する能力があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">With <code>impl Trait</code> , you&#39;re saying &quot;hey, some type exists that implements this trait, but I&#39;m not gonna tell you what it is.&quot;</span> <code>impl Trait</code>では、「ねえ、この特性を実現するいくつかのタイプが存在しますが、私はそれが何であるか教えてくれません」と言っています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">(&quot;existential&quot; in the jargon, &quot;some type exists&quot;).</span> （専門用語の「実在性」、「何らかのタイプが存在する」）。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">So now, the caller can&#39;t choose, and the function itself gets to choose.</span>だから今、呼び出し側は選択することはできません、関数自体を選択します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">If we tried to define parse with <code>Result&lt;impl F,...</code> as the return type, it wouldn&#39;t work.</span> <code>Result&lt;impl F,...</code>を戻り値の型として構文解析を定義しようとすると、動作しません。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Using <code>impl Trait</code> in more places</span>より多くの場所で<code>impl Trait</code>を使用する</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">As previously mentioned, as a start, you will only be able to use <code>impl Trait</code> as the argument or return type of a free or inherent function.</span>前述したように、最初は、自由<code>impl Trait</code>または固有の関数の引数または戻り値の型として<code>impl Trait</code>を使用することしかできません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, <code>impl Trait</code> can&#39;t be used inside implementations of traits, nor can it be used as the type of a let binding or inside a type alias.</span>しかし、 <code>impl Trait</code>は形質の実装の中で使用することはできず、レットバインディングのタイプとしても、タイプエイリアスの内部としても使用することはできません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Some of these restrictions will eventually be lifted.</span>これらの制限の一部は最終的に解除されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For more information, see the <a href=#2https://github.com/rust-lang/rust/issues/34511>tracking issue on <code>impl Trait</code></a> .</span>詳細については、 <a href=#2https://github.com/rust-lang/rust/issues/34511><code>impl Trait</code>トラッキングの問題を</a>参照してください。</span> </p><script>_addload(function(){_setupIW('com');_csi('en','ja','impl-trait.html');});</script>