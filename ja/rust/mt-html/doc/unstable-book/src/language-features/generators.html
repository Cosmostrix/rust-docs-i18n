<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180723_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=generators.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhgQ4ezENlkxSVYGeAHMYQ9vf0ngJQ" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h1> <code>generators</code> </h1> <br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The tracking issue for this feature is: <a class=notranslate href=#4#43122>#43122</a></span>この機能の追跡に関する問題は次の<a class=notranslate href=#4#43122>#43122</a>です。 <a class=notranslate href=#4#43122>#43122</a></span> </p><br> <a class=notranslate href=#1https://github.com/rust-lang/rust/issues/43122>#43122</a> <br> <p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">------------------------</span> ------------------------</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>generators</code> feature gate in Rust allows you to define generator or coroutine literals.</span> <code>generators</code>はRustのゲート機能を使用して、ジェネレータまたはコルーチンのリテラルを定義することができます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A generator is a &quot;resumable function&quot; that syntactically resembles a closure but compiles to much different semantics in the compiler itself.</span>ジェネレータは、構文的にはクロージャに似ていますが、コンパイラ自体のさまざまなセマンティクスにコンパイルする「再開可能な関数」です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The primary feature of a generator is that it can be suspended during execution to be resumed at a later date.</span>ジェネレータの主な機能は、実行中に中断して後で再開できることです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Generators use the <code>yield</code> keyword to &quot;return&quot;, and then the caller can <code>resume</code> a generator to resume execution just after the <code>yield</code> keyword.</span>発電機は使用<code>yield</code> 「戻る」するキーワードを、その後、呼び出し側はでき<code>resume</code>直後の実行を再開するために発電機を<code>yield</code>キーワード。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Generators are an extra-unstable feature in the compiler right now.</span>ジェネレータは、コンパイラで今や余計に不安定な機能です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Added in <a class=notranslate href="#4RFC 2033">RFC 2033</a> they&#39;re mostly intended right now as a information/constraint gathering phase.</span> <a class=notranslate href="#4RFC 2033">RFC 2033</a>に追加されたのは、情報/制約の収集フェーズとして現在主に意図されています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The intent is that experimentation can happen on the nightly compiler before actual stabilization.</span>実際の安定化の前に夜間コンパイラで実験を行うことが意図されています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A further RFC will be required to stabilize generators/coroutines and will likely contain at least a few small tweaks to the overall design.</span>ジェネレータ/コルーチンを安定化させるためには、さらにRFCが必要であり、全体的な設計に少なくともわずかな調整が含まれる可能性が高くなります。</span> </p><br> <a class=notranslate href=#1https://github.com/rust-lang/rfcs/pull/2033>RFC 2033</a> <br> <p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A syntactical example of a generator is:</span>ジェネレータの構文例は次のとおりです。</span> </p><br><div data-lang=rust><div data-l="#![feature(generators, generator_trait)]"></div><div data-l=""></div><div data-l="use std::ops::{Generator, GeneratorState};"></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let mut generator = || {"></div><div data-l="        yield 1;"></div><div data-l="        return &quot;foo&quot;"></div><div data-l="    };"></div><div data-l=""></div><div data-l="    match unsafe { generator.resume() } {"></div><div data-l="        GeneratorState::Yielded(1) =&gt; {}"></div><div data-l="        _ =&gt; panic!(&quot;unexpected value from resume&quot;),"></div><div data-l="    }"></div><div data-l="    match unsafe { generator.resume() } {"></div><div data-l="        GeneratorState::Complete(&quot;foo&quot;) =&gt; {}"></div><div data-l="        _ =&gt; panic!(&quot;unexpected value from resume&quot;),"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Generators are closure-like literals which can contain a <code>yield</code> statement.</span>ジェネレータは、 <code>yield</code>文を含むことができるクロージャのようなリテラルです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>yield</code> statement takes an optional expression of a value to yield out of the generator.</span> <code>yield</code>文は、ジェネレータから出力される値の任意の式を取ります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">All generator literals implement the <code>Generator</code> trait in the <code>std::ops</code> module.</span>すべてのジェネレータリテラルは、 <code>Generator</code>特性を<code>std::ops</code>モジュールに実装します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Generator</code> trait has one main method, <code>resume</code> , which resumes execution of the generator at the previous suspension point.</span> <code>Generator</code>特性には、以前のサスペンドポイントでジェネレータの実行を再開する1つのメインメソッド<code>resume</code>があります。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">An example of the control flow of generators is that the following example prints all numbers in order:</span>ジェネレータの制御フローの例は、次の例ではすべての数値を順に出力しています。</span> </p><br><div data-lang=rust><div data-l="#![feature(generators, generator_trait)]"></div><div data-l=""></div><div data-l="use std::ops::Generator;"></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let mut generator = || {"></div><div data-l="        println!(&quot;2&quot;);"></div><div data-l="        yield;"></div><div data-l="        println!(&quot;4&quot;);"></div><div data-l="    };"></div><div data-l=""></div><div data-l="    println!(&quot;1&quot;);"></div><div data-l="    unsafe { generator.resume() };"></div><div data-l="    println!(&quot;3&quot;);"></div><div data-l="    unsafe { generator.resume() };"></div><div data-l="    println!(&quot;5&quot;);"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">At this time the main intended use case of generators is an implementation primitive for async/await syntax, but generators will likely be extended to ergonomic implementations of iterators and other primitives in the future.</span>現時点では、ジェネレータの主な使用目的はasync / await構文の実装プリミティブですが、ジェネレータはイテレータや他のプリミティブの人間工学的な実装に拡張される可能性があります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Feedback on the design and usage is always appreciated!</span>デザインと使用方法に関するフィードバックは常に高く評価されています。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Generator</code> trait</span> <code>Generator</code>特性</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Generator</code> trait in <code>std::ops</code> currently looks like:</span> <code>std::ops</code>の<code>Generator</code>特性は、次のようになります。</span> </p><br><div data-lang=""><div data-l="# #![feature(generator_trait)]"></div><div data-l="# use std::ops::GeneratorState;"></div><div data-l=""></div><div data-l="pub trait Generator {"></div><div data-l="    type Yield;"></div><div data-l="    type Return;"></div><div data-l="    unsafe fn resume(&amp;mut self) -&gt; GeneratorState&lt;Self::Yield, Self::Return&gt;;"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Generator::Yield</code> type is the type of values that can be yielded with the <code>yield</code> statement.</span> <code>Generator::Yield</code>型は、 <code>yield</code>文で<code>yield</code>できる値の型です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Generator::Return</code> type is the returned type of the generator.</span> <code>Generator::Return</code>型は<code>Generator::Return</code>の返される型です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is typically the last expression in a generator&#39;s definition or any value passed to <code>return</code> in a generator.</span>これは通常、ジェネレータの定義の最後の式、またはジェネレータで<code>return</code>れる値です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>resume</code> function is the entry point for executing the <code>Generator</code> itself.</span> <code>resume</code>機能は、 <code>Generator</code>自体を実行するためのエントリポイントです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The return value of <code>resume</code> , <code>GeneratorState</code> , looks like:</span> <code>resume</code>の戻り値、 <code>GeneratorState</code>は次のようになります。</span> </p><br><div data-lang=""><div data-l="pub enum GeneratorState&lt;Y, R&gt; {"></div><div data-l="    Yielded(Y),"></div><div data-l="    Complete(R),"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Yielded</code> variant indicates that the generator can later be resumed.</span> <code>Yielded</code>バリアントは、後でジェネレータを再開できることを示します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This corresponds to a <code>yield</code> point in a generator.</span>これは、発電機の<code>yield</code>点に相当します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The <code>Complete</code> variant indicates that the generator is complete and cannot be resumed again.</span> <code>Complete</code>バリアントは、ジェネレータが完了しており、再び再開できないことを示します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Calling <code>resume</code> after a generator has returned <code>Complete</code> will likely result in a panic of the program.</span>ジェネレータが<code>Complete</code>を返した後に<code>resume</code>を呼び出すと、プログラムがパニックに陥る可能性があります。</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Closure-like semantics</span>クロージャー様セマンティクス</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The closure-like syntax for generators alludes to the fact that they also have closure-like semantics.</span>ジェネレータのクロージャのような構文は、クロージャのようなセマンティクスも持っているという事実を暗示しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Namely:</span>すなわち：</span> </p><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When created, a generator executes no code.</span>作成されると、ジェネレータはコードを実行しません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">A closure literal does not actually execute any of the closure&#39;s code on construction, and similarly a generator literal does not execute any code inside the generator when constructed.</span>クロージャリテラルは実際にはクロージャのコードを実行しませんし、同様にジェネレータリテラルは生成時にジェネレータ内部のコードを実行しません。</span> </div><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Generators can capture outer variables by reference or by move, and this can be tweaked with the <code>move</code> keyword at the beginning of the closure.</span>ジェネレータは、参照または移動によって外部変数を取得できます。これは、クロージャの開始時に<code>move</code>キーワードを使用して調整できます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Like closures all generators will have an implicit environment which is inferred by the compiler.</span>クロージャのように、すべてのジェネレータはコンパイラによって推論される暗黙の環境を持ちます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Outer variables can be moved into a generator for use as the generator progresses.</span>外部変数をジェネレータに移動して、ジェネレータが進むにつれて使用することができます。</span> </div><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Generator literals produce a value with a unique type which implements the <code>std::ops::Generator</code> trait.</span>ジェネレータのリテラルは、 <code>std::ops::Generator</code>特性を実装するユニークな型の値を生成します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This allows actual execution of the generator through the <code>Generator::resume</code> method as well as also naming it in return types and such.</span>これにより<code>Generator::resume</code>メソッドを介して<code>Generator::resume</code>実際に実行することができます。</span> </div><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Traits like <code>Send</code> and <code>Sync</code> are automatically implemented for a <code>Generator</code> depending on the captured variables of the environment.</span>環境のキャプチャされた変数に応じて、 <code>Send</code>や<code>Sync</code>ような特性が<code>Generator</code>に対して自動的に実装されます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Unlike closures, generators also depend on variables live across suspension points.</span>クロージャとは異なり、ジェネレータはサスペンドポイントを越えて生きる変数にも依存します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This means that although the ambient environment may be <code>Send</code> or <code>Sync</code> , the generator itself may not be due to internal variables live across <code>yield</code> points being not- <code>Send</code> or not- <code>Sync</code> .</span>これは、周囲の環境がされてもよいことを意味<code>Send</code>または<code>Sync</code>内部変数は全体のライブに、発電機自体が原因ではないかもしれない<code>yield</code> not-ある点<code>Send</code>またはnot- <code>Sync</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that generators, like closures, do not implement traits like <code>Copy</code> or <code>Clone</code> automatically.</span>クロージャのようなジェネレータは、 <code>Copy</code>や<code>Clone</code>ような特徴を自動的に実装しないことに注意してください。</span> </div><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Whenever a generator is dropped it will drop all captured environment variables.</span>ジェネレータがドロップされると、キャプチャされたすべての環境変数が削除されます。</span> </div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note that unlike closures generators at this time cannot take any arguments.</span>この時点でクロージャジェネレータとは異なり、引数を取ることはできません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">That is, generators must always look like <code>|| { ... }</code></span>つまり、ジェネレータは常に、 <code>|| { ... }</code></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left"><code>|| { ... }</code> .</span> <code>|| { ... }</code> 。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This restriction may be lifted at a future date, the design is ongoing!</span>この制限は、今後の予定で解除される可能性があり、デザインは継続中です！</span> </p><br><h3> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Generators as state machines</span>状態機械としての発電機</span> </h3><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">In the compiler, generators are currently compiled as state machines.</span>コンパイラでは、現在、ジェネレータは状態マシンとしてコンパイルされています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Each <code>yield</code> expression will correspond to a different state that stores all live variables over that suspension point.</span>各<code>yield</code>式は、その中断ポイント上のすべてのライブ変数を格納する別の状態に対応します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Resumption of a generator will dispatch on the current state and then execute internally until a <code>yield</code> is reached, at which point all state is saved off in the generator and a value is returned.</span>ジェネレータの再開は、現在の状態でディスパッチし、次に<code>yield</code>に達するまで内部的に実行します。この時点で、すべての状態がジェネレータに保存され、値が返されます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s take a look at an example to see what&#39;s going on here:</span>ここで何が起こっているのかを見てみましょう：</span> </p><br><div data-lang=rust><div data-l="#![feature(generators, generator_trait)]"></div><div data-l=""></div><div data-l="use std::ops::Generator;"></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let ret = &quot;foo&quot;;"></div><div data-l="    let mut generator = move || {"></div><div data-l="        yield 1;"></div><div data-l="        return ret"></div><div data-l="    };"></div><div data-l=""></div><div data-l="    unsafe { generator.resume() };"></div><div data-l="    unsafe { generator.resume() };"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This generator literal will compile down to something similar to:</span>このジェネレータのリテラルは、次のようなものにコンパイルされます。</span> </p><br><div data-lang=rust><div data-l="#![feature(generators, generator_trait)]"></div><div data-l=""></div><div data-l="use std::ops::{Generator, GeneratorState};"></div><div data-l=""></div><div data-l="fn main() {"></div><div data-l="    let ret = &quot;foo&quot;;"></div><div data-l="    let mut generator = {"></div><div data-l="        enum __Generator {"></div><div data-l="            Start(&amp;'static str),"></div><div data-l="            Yield1(&amp;'static str),"></div><div data-l="            Done,"></div><div data-l="        }"></div><div data-l=""></div><div data-l="        impl Generator for __Generator {"></div><div data-l="            type Yield = i32;"></div><div data-l="            type Return = &amp;'static str;"></div><div data-l=""></div><div data-l="            unsafe fn resume(&amp;mut self) -&gt; GeneratorState&lt;i32, &amp;'static str&gt; {"></div><div data-l="                use std::mem;"></div><div data-l="                match mem::replace(self, __Generator::Done) {"></div><div data-l="                    __Generator::Start(s) =&gt; {"></div><div data-l="                        *self = __Generator::Yield1(s);"></div><div data-l="                        GeneratorState::Yielded(1)"></div><div data-l="                    }"></div><div data-l=""></div><div data-l="                    __Generator::Yield1(s) =&gt; {"></div><div data-l="                        *self = __Generator::Done;"></div><div data-l="                        GeneratorState::Complete(s)"></div><div data-l="                    }"></div><div data-l=""></div><div data-l="                    __Generator::Done =&gt; {"></div><div data-l="                        panic!(&quot;generator resumed after completion&quot;)"></div><div data-l="                    }"></div><div data-l="                }"></div><div data-l="            }"></div><div data-l="        }"></div><div data-l=""></div><div data-l="        __Generator::Start(ret)"></div><div data-l="    };"></div><div data-l=""></div><div data-l="    unsafe { generator.resume() };"></div><div data-l="    unsafe { generator.resume() };"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Notably here we can see that the compiler is generating a fresh type, <code>__Generator</code> in this case.</span>特にここでは、この場合コンパイラが新しい型の<code>__Generator</code>生成していることがわかります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This type has a number of states (represented here as an <code>enum</code> ) corresponding to each of the conceptual states of the generator.</span>この型は、ジェネレータの概念的な状態のそれぞれに対応するいくつかの状態（ここでは<code>enum</code>として表されます）を持ちます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">At the beginning we&#39;re closing over our outer variable <code>foo</code> and then that variable is also live over the <code>yield</code> point, so it&#39;s stored in both states.</span>最初は外部変数<code>foo</code>をクローズしていますが、その変数も<code>yield</code>点を超えているので、両方の状態に格納されています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">When the generator starts it&#39;ll immediately yield 1, but it saves off its state just before it does so indicating that it has reached the yield point.</span>発電機が始動すると直ちに1が出力されますが、降圧ポイントに達した直前にその状態を保存します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Upon resuming again we&#39;ll execute the <code>return ret</code> which returns the <code>Complete</code> state.</span>再開すると、 <code>Complete</code>状態を返す<code>return ret</code>を実行します。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Here we can also note that the <code>Done</code> state, if resumed, panics immediately as it&#39;s invalid to resume a completed generator.</span>ここでは、完了したジェネレータを再開するのが無効であるため、 <code>Done</code>状態が再開された場合は即座にパニック状態になることにも注意してください。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">It&#39;s also worth noting that this is just a rough desugaring, not a normative specification for what the compiler does.</span>これは、コンパイラが何をするのかに関する規範的な仕様ではなく、大雑把なものです。</span> </p><script>_addload(function(){_setupIW('com');_csi('en','ja','generators.html');});</script>