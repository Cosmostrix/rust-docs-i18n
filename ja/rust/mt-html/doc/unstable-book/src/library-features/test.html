<!DOCTYPE html><html lang=ja-x-mtfrom-en><head><script>(function(){(function(){function e(a){this.t={};this.tick=function(a,c,b){this.t[a]=[void 0!=b?b:(new Date).getTime(),c];if(void 0==b)try{window.console.timeStamp("CSI/"+a)}catch(h){}};this.tick("start",null,a)}var a;if(window.performance)var d=(a=window.performance.timing)&&a.responseStart;var f=0<d?new e(d):new e;window.jstiming={Timer:e,load:f};if(a){var c=a.navigationStart;0<c&&d>=c&&(window.jstiming.srt=d-c)}if(a){var b=window.jstiming.load;0<c&&d>=c&&(b.tick("_wtsrt",void 0,c),b.tick("wtsrt_","_wtsrt",
d),b.tick("tbsd_","wtsrt_"))}try{a=null,window.chrome&&window.chrome.csi&&(a=Math.floor(window.chrome.csi().pageT),b&&0<c&&(b.tick("_tbnd",void 0,window.chrome.csi().startE),b.tick("tbnd_","_tbnd",c))),null==a&&window.gtbExternal&&(a=window.gtbExternal.pageT()),null==a&&window.external&&(a=window.external.pageT,b&&0<c&&(b.tick("_tbnd",void 0,window.external.startE),b.tick("tbnd_","_tbnd",c))),a&&(window.jstiming.pt=a)}catch(g){}})();}).call(window);
</script><script src="https://translate.googleusercontent.com/translate/releases/twsfe_w_20180723_RC00/r/js/translate_c.js"></script><script>_intlStrings._originalText = "英語の原文テキスト:";_intlStrings._interfaceDirection="ltr";_intlStrings._interfaceAlign="left";_intlStrings._langpair="en|ja";_intlStrings._feedbackUrl="https://translate.google.com/translate_suggestion";_intlStrings._currentBy="%1$s に %2$s により翻訳されました";_intlStrings._unknown="不明";_intlStrings._suggestTranslation="翻訳を改善する"  ;_intlStrings._submit="送信";_intlStrings._suggestThanks="Google 翻訳の改善にご協力いただきありがとうございました。";_intlStrings._reverse=false;_intlStrings._staticContentPath="https://www.gstatic.com/translate/infowindow/";</script><style type="text/css">.google-src-text {display: none !important} .google-src-active-text {display: block!important;color:black!important; font-size:12px!important;font-family:arial,sans-serif!important}.google-src-active-text a {font-size:12px!important}.google-src-active-text a:link {color:#00c!important;text-decoration:underline!important}.google-src-active-text a:visited {color:purple!important;text-decoration:underline!important}.google-src-active-text a:active {color:red!important;text-decoration:underline!important}</style><meta http-equiv="X-Translated-By" content="Google"><link href=test.html hreflang=en rel="alternate machine-translated-from"><base href="" target=_top /></head><body><iframe src="https://translate.google.com/translate_un?hl=ja&prev=_t&sl=en&tl=ja&lang=en&usg=ALkJrhgQ4ezENlkxSVYGeAHMYQ9vf0ngJQ" width=0 height=0 frameborder=0 style="width:0px;height:0px;border:0px;display:none;"></iframe><h1> <code>test</code> </h1> <br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The tracking issue for this feature is: None.</span>この機能のトラッキングに関する問題は次のとおりです。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">------------------------</span> ------------------------</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The internals of the <code>test</code> crate are unstable, behind the <code>test</code> flag.</span> <code>test</code>クレートの内部は、 <code>test</code>フラグの後ろでは不安定です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The most widely used part of the <code>test</code> crate are benchmark tests, which can test the performance of your code.</span> <code>test</code>クレートの最も広く使用されている部分は、コードのパフォーマンスをテストできるベンチマーク・テストです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Let&#39;s make our <code>src/lib.rs</code> look like this (comments elided):</span> <code>src/lib.rs</code>を次のように見てみましょう（コメントは<code>src/lib.rs</code>されました）：</span> </p><br><div data-lang=rust,ignore><div data-l=#![feature(test)]></div><div data-l=""></div><div data-l="extern crate test;"></div><div data-l=""></div><div data-l="pub fn add_two(a: i32) -&gt; i32 {"></div><div data-l="    a + 2"></div><div data-l=}></div><div data-l=""></div><div data-l=#[cfg(test)]></div><div data-l="mod tests {"></div><div data-l="    use super::*;"></div><div data-l="    use test::Bencher;"></div><div data-l=""></div><div data-l="    #[test]"></div><div data-l="    fn it_works() {"></div><div data-l="        assert_eq!(4, add_two(2));"></div><div data-l="    }"></div><div data-l=""></div><div data-l="    #[bench]"></div><div data-l="    fn bench_add_two(b: &amp;mut Bencher) {"></div><div data-l="        b.iter(|| add_two(2));"></div><div data-l="    }"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note the <code>test</code> feature gate, which enables this unstable feature.</span>この不安定な機能を有効にする<code>test</code>フィーチャゲートに注意してください。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We&#39;ve imported the <code>test</code> crate, which contains our benchmarking support.</span>ベンチマークサポートが含まれている<code>test</code>箱をインポートしました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We have a new function as well, with the <code>bench</code> attribute.</span> <code>bench</code>アトリビュートを持つ新しい関数も用意されています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Unlike regular tests, which take no arguments, benchmark tests take a <code>&amp;mut Bencher</code> .</span>引数を取らない通常のテストとは異なり、ベンチマークテストでは<code>&amp;mut Bencher</code>ます。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This <code>Bencher</code> provides an <code>iter</code> method, which takes a closure.</span>この<code>Bencher</code>は、クロージャをとる<code>iter</code>メソッドを提供しています。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This closure contains the code we&#39;d like to benchmark.</span>このクロージャには、ベンチマークするコードが含まれています。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">We can run benchmark tests with <code>cargo bench</code> :</span> <code>cargo bench</code>ベンチマークテストを実行できます：</span> </p><br><div data-lang=bash><div data-l="$ cargo bench"></div><div data-l="   Compiling adder v0.0.1 (file:///home/steve/tmp/adder)"></div><div data-l="     Running target/release/adder-91b3e234d4ed382a"></div><div data-l=""></div><div data-l="running 2 tests"></div><div data-l="test tests::it_works ... ignored"></div><div data-l="test tests::bench_add_two ... bench:         1 ns/iter (+/- 0)"></div><div data-l=""></div><div data-l="test result: ok. 0 passed; 0 failed; 1 ignored; 1 measured"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Our non-benchmark test was ignored.</span>私たちの非ベンチマークテストは無視されました。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">You may have noticed that <code>cargo bench</code> takes a bit longer than <code>cargo test</code> .</span>あなたは、 <code>cargo bench</code>が<code>cargo test</code>よりも少し時間がかかることに気づいたかもしれません。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This is because Rust runs our benchmark a number of times, and then takes the average.</span>これは、Rustがベンチマークを何度も実行してから平均を取るためです。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Because we&#39;re doing so little work in this example, we have a <code>1 ns/iter (+/- 0)</code> , but this would show the variance if there was one.</span>この例ではほとんど仕事をしていないので、 <code>1 ns/iter (+/- 0)</code>ですが、これがあれば分散が表示されます。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Advice on writing benchmarks:</span>ベンチマークの作成に関するアドバイス：</span> </p><br><br><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Move setup code outside the <code>iter</code> loop;</span>セットアップコードを<code>iter</code>ループの外に移動します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">only put the part you want to measure inside</span>あなたが内部で測定したい部分だけを置く</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Make the code do &quot;the same thing&quot; on each iteration;</span>各繰り返しでコードを「同じこと」にする。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">do not accumulate or change state</span>累積したり状態を変えたりしない</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Make the outer function idempotent too;</span>外側関数を冪等元にします。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">the benchmark runner is likely to run it many times</span>ベンチマークランナーは何度もそれを実行する可能性が高い</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Make the inner <code>iter</code> loop short and fast so benchmark runs are fast and the calibrator can adjust the run-length at fine resolution</span>内側の<code>iter</code>ループを短く高速にして、ベンチマークの実行が速く、キャリブレータがランレングスを細かい解像度で調整できるようにする</span> </div><div data-b=*> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Make the code in the <code>iter</code> loop do something simple, to assist in pinpointing performance improvements (or regressions)</span> <code>iter</code>ループのコードを単純化して、パフォーマンスの改善（または回帰）を正確に特定できるようにします。</span> </div><br><h2> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Gotcha: optimizations</span> Gotcha：最適化</span> </h2><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">There&#39;s another tricky part to writing benchmarks: benchmarks compiled with optimizations activated can be dramatically changed by the optimizer so that the benchmark is no longer benchmarking what one expects.</span>ベンチマークの作成には別の手間があります。最適化を有効にしてコンパイルしたベンチマークは、オプティマイザによって劇的に変更されるため、ベンチマークはもはやベンチマークのベンチマークではなくなります。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">For example, the compiler might recognize that some calculation has no external effects and remove it entirely.</span>たとえば、コンパイラは、一部の計算に外部効果がなく、完全に削除することを認識することがあります。</span> </p><br><div data-lang=rust,ignore><div data-l=#![feature(test)]></div><div data-l=""></div><div data-l="extern crate test;"></div><div data-l="use test::Bencher;"></div><div data-l=""></div><div data-l=#[bench]></div><div data-l="fn bench_xor_1000_ints(b: &amp;mut Bencher) {"></div><div data-l="    b.iter(|| {"></div><div data-l="        (0..1000).fold(0, |old, new| old ^ new);"></div><div data-l="    });"></div><div data-l=}></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">gives the following results</span>次の結果が得られます</span> </p><br><div data-lang=text><div data-l="running 1 test"></div><div data-l="test bench_xor_1000_ints ... bench:         0 ns/iter (+/- 0)"></div><div data-l=""></div><div data-l="test result: ok. 0 passed; 0 failed; 0 ignored; 1 measured"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">The benchmarking runner offers two ways to avoid this.</span>ベンチマーキングランナーは、これを回避する2つの方法を提供します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Either, the closure that the <code>iter</code> method receives can return an arbitrary value which forces the optimizer to consider the result used and ensures it cannot remove the computation entirely.</span>どちらの場合でも、 <code>iter</code>メソッドが受け取るクロージャは、オプティマイザに使用された結果を考慮させる任意の値を返すことができ、完全に計算を削除できないことを保証します。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">This could be done for the example above by adjusting the <code>b.iter</code> call to</span>上記の例では、 <code>b.iter</code>呼び出しを<code>b.iter</code>ように調整することでこれを行うことができます。</span> </p><br><div data-lang=rust><div data-l="# struct X;"></div><div data-l="# impl X { fn iter&lt;T, F&gt;(&amp;self, _: F) where F: FnMut() -&gt; T {} } let b = X;"></div><div data-l="b.iter(|| {"></div><div data-l="#    // Note lack of `;` (could also use an explicit `return`)."></div><div data-l="    // "> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Note lack of <code>;</code></span>注意が欠けている<code>;</code></span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">(could also use an explicit <code>return</code> ).</span> （明示的な<code>return</code>使用することもできます）。</span> </div><div data-l="    (0..1000).fold(0, |old, new| old ^ new)"></div><div data-l=});></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Or, the other option is to call the generic <code>test::black_box</code> function, which is an opaque &quot;black box&quot; to the optimizer and so forces it to consider any argument as used.</span>あるいは、もう一つのオプションは、オプティマイザに対して不透明な &quot;ブラックボックス&quot;である一般的な<code>test::black_box</code>関数を呼び出すことです。</span> </p><br><div data-lang=rust><div data-l=#![feature(test)]></div><div data-l=""></div><div data-l="extern crate test;"></div><div data-l=""></div><div data-l="# fn main() {"></div><div data-l="# struct X;"></div><div data-l="# impl X { fn iter&lt;T, F&gt;(&amp;self, _: F) where F: FnMut() -&gt; T {} } let b = X;"></div><div data-l="b.iter(|| {"></div><div data-l="    let n = test::black_box(1000);"></div><div data-l=""></div><div data-l="    (0..n).fold(0, |a, b| a ^ b)"></div><div data-l=})></div><div data-l="# }"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Neither of these read or modify the value, and are very cheap for small values.</span>これらのどちらも値を読み取ったり変更したりすることはなく、小さな値に対しては非常に安価です。</span> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Larger values can be passed indirectly to reduce overhead (eg <code>black_box(&amp;huge_struct)</code> ).</span>オーバーヘッドを減らすために、より大きな値を間接的に渡すことができます（例： <code>black_box(&amp;huge_struct)</code> ）。</span> </p><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">Performing either of the above changes gives the following benchmarking results</span>上記の変更のいずれかを実行すると、次のベンチマーク結果が得られます。</span> </p><br><div data-lang=text><div data-l="running 1 test"></div><div data-l="test bench_xor_1000_ints ... bench:       131 ns/iter (+/- 3)"></div><div data-l=""></div><div data-l="test result: ok. 0 passed; 0 failed; 0 ignored; 1 measured"></div></div><br><p> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"><span class="google-src-text" style="direction: ltr; text-align: left">However, the optimizer can still modify a testcase in an undesirable manner even when using either of the above.</span>しかし、オプティマイザは、上記のいずれかを使用しても、テストケースを望ましくない方法で修正することができます。</span> </p><script>_addload(function(){_setupIW('com');_csi('en','ja','test.html');});</script>