<!DOCTYPE html>
<h2>Transform CSV column</h2>
<br>
<p><a href="#3csv">!<a class="notranslate" href="#4csv-badge">csv-badge</a></a> <a href="#3serde">!<a class="notranslate" href="#4serde-badge">serde-badge</a></a> <a href="#3cat-encoding">!<a class="notranslate" href="#4cat-encoding-badge">cat-encoding-badge</a></a></p>
<br>
<p>Transform a CSV file containing a color name and a hex color into one with a
color name and an rgb color.  Utilizes the <a class="notranslate" href="#4csv">csv</a> crate to read and write the
csv file, and <a class="notranslate" href="#4serde">serde</a> to deserialize and serialize the rows to and from bytes.</p>
<br>
<p>See <a class="notranslate" href="#4`csv::Reader::deserialize`">`csv::Reader::deserialize`</a>, <a class="notranslate" href="#4`serde::Deserialize`">`serde::Deserialize`</a>, and <a class="notranslate" href="#4`std::str::FromStr`">`std::str::FromStr`</a></p>
<br>
<div data-lang="rust"><div data-l="extern crate csv;"></div><div data-l="# #[macro_use]"></div><div data-l="# extern crate error_chain;"></div><div data-l="#[macro_use]"></div><div data-l="extern crate serde_derive;"></div><div data-l="extern crate serde;"></div><div data-l=""></div><div data-l="use csv::{Reader, Writer};"></div><div data-l="use serde::{de, Deserialize, Deserializer};"></div><div data-l="use std::str::FromStr;"></div><div data-l="#"></div><div data-l="# error_chain! {"></div><div data-l="#    foreign_links {"></div><div data-l="#        CsvError(csv::Error);"></div><div data-l="#        ParseInt(std::num::ParseIntError);"></div><div data-l="#        CsvInnerError(csv::IntoInnerError&lt;Writer&lt;Vec&lt;u8&gt;&gt;&gt;);"></div><div data-l="#        IO(std::fmt::Error);"></div><div data-l="#        UTF8(std::string::FromUtf8Error);"></div><div data-l="#    }"></div><div data-l="# }"></div><div data-l=""></div><div data-l="#[derive(Debug)]"></div><div data-l="struct HexColor {"></div><div data-l="    red: u8,"></div><div data-l="    green: u8,"></div><div data-l="    blue: u8,"></div><div data-l="}"></div><div data-l=""></div><div data-l="#[derive(Debug, Deserialize)]"></div><div data-l="struct Row {"></div><div data-l="    color_name: String,"></div><div data-l="    color: HexColor,"></div><div data-l="}"></div><div data-l=""></div><div data-l="impl FromStr for HexColor {"></div><div data-l="    type Err = Error;"></div><div data-l=""></div><div data-l="    fn from_str(hex_color: &amp;str) -&gt; std::result::Result&lt;Self, Self::Err&gt; {"></div><div data-l="        let trimmed = hex_color.trim_matches('#');"></div><div data-l="        if trimmed.len() != 6 {"></div><div data-l="            Err(&quot;Invalid length of hex string&quot;.into())"></div><div data-l="        } else {"></div><div data-l="            Ok(HexColor {"></div><div data-l="                red: u8::from_str_radix(&amp;trimmed[..2], 16)?,"></div><div data-l="                green: u8::from_str_radix(&amp;trimmed[2..4], 16)?,"></div><div data-l="                blue: u8::from_str_radix(&amp;trimmed[4..6], 16)?,"></div><div data-l="            })"></div><div data-l="        }"></div><div data-l="    }"></div><div data-l="}"></div><div data-l=""></div><div data-l="impl&lt;'de&gt; Deserialize&lt;'de&gt; for HexColor {"></div><div data-l="    fn deserialize&lt;D&gt;(deserializer: D) -&gt; std::result::Result&lt;Self, D::Error&gt;"></div><div data-l="    where"></div><div data-l="        D: Deserializer&lt;'de&gt;,"></div><div data-l="    {"></div><div data-l="        let s = String::deserialize(deserializer)?;"></div><div data-l="        FromStr::from_str(&amp;s).map_err(de::Error::custom)"></div><div data-l="    }"></div><div data-l="}"></div><div data-l=""></div><div data-l="fn run() -&gt; Result&lt;()&gt; {"></div><div data-l="    let data = &quot;color_name,color"></div><div data-l="red,#ff0000"></div><div data-l="green,#00ff00"></div><div data-l="blue,#0000FF"></div><div data-l="periwinkle,#ccccff"></div><div data-l="magenta,#ff00ff&quot;"></div><div data-l="        .to_owned();"></div><div data-l="    let mut out = Writer::from_writer(vec![]);"></div><div data-l="    let mut reader = Reader::from_reader(data.as_bytes());"></div><div data-l="    for result in reader.deserialize::&lt;Row&gt;() {"></div><div data-l="        let res = result?;"></div><div data-l="        out.serialize(("></div><div data-l="            res.color_name,"></div><div data-l="            res.color.red,"></div><div data-l="            res.color.green,"></div><div data-l="            res.color.blue,"></div><div data-l="        ))?;"></div><div data-l="    }"></div><div data-l="    let written = String::from_utf8(out.into_inner()?)?;"></div><div data-l="    assert_eq!(Some(&quot;magenta,255,0,255&quot;), written.lines().last());"></div><div data-l="    println!(&quot;{}&quot;, written);"></div><div data-l="    Ok(())"></div><div data-l="}"></div><div data-l="#"></div><div data-l="# quick_main!(run);"></div></div>
<br>
<a class="notranslate" href="#1https://docs.rs/csv/\*/csv/struct.Reader.html#method.deserialize">`csv::Reader::deserialize`</a>
<a class="notranslate" href="#1https://docs.rs/csv/*/csv/fn.invalid_option.html">`csv::invalid_option`</a>
<a class="notranslate" href="#1https://docs.rs/serde/\*/serde/trait.Deserialize.html">`serde::Deserialize`</a>
<a class="notranslate" href="#1https://doc.rust-lang.org/std/str/trait.FromStr.html">`std::str::FromStr`</a>