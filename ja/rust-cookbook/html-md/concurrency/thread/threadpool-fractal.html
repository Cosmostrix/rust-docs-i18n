<!DOCTYPE html>
<h2>Draw fractal dispatching work to a thread pool</h2>
<br>
<p><a href="#3threadpool">!<a class="notranslate" href="#4threadpool-badge">threadpool-badge</a></a> <a href="#3num">!<a class="notranslate" href="#4num-badge">num-badge</a></a> <a href="#3num_cpus">!<a class="notranslate" href="#4num_cpus-badge">num_cpus-badge</a></a> <a href="#3image">!<a class="notranslate" href="#4image-badge">image-badge</a></a> <a href="#3cat-concurrency">!<a class="notranslate" href="#4cat-concurrency-badge">cat-concurrency-badge</a></a><a href="#3cat-science">!<a class="notranslate" href="#4cat-science-badge">cat-science-badge</a></a><a href="#3cat-rendering">!<a class="notranslate" href="#4cat-rendering-badge">cat-rendering-badge</a></a></p>
<br>
<p>This example generates an image by drawing a fractal from the <a class="notranslate" href="#4Julia set">Julia set</a>
with a thread pool for distributed computation.</p>
<br>
<p><a href="https://cloud.githubusercontent.com/assets/221000/26546700/9be34e80-446b-11e7-81dc-dd9871614ea1.png"><img src="https://cloud.githubusercontent.com/assets/221000/26546700/9be34e80-446b-11e7-81dc-dd9871614ea1.png" width="150" /></a></p>
<br>
<p>Allocate memory for output image of given width and height with <a class="notranslate" href="#4`ImageBuffer::new`">`ImageBuffer::new`</a>.
<a class="notranslate" href="#4`Rgb::from_channels`">`Rgb::from_channels`</a> calculates RGB pixel values.
Create <a class="notranslate" href="#4`ThreadPool`">`ThreadPool`</a> with thread count equal to number of cores with <a class="notranslate" href="#4`num_cpus::get`">`num_cpus::get`</a>.
<a class="notranslate" href="#4`ThreadPool::execute`">`ThreadPool::execute`</a> receives each pixel as a separate job.</p>
<br>
<p><a class="notranslate" href="#4`mpsc::channel`">`mpsc::channel`</a> receives the jobs and <a class="notranslate" href="#4`Receiver::recv`">`Receiver::recv`</a> retrieves them.
<a class="notranslate" href="#4`ImageBuffer::put_pixel`">`ImageBuffer::put_pixel`</a> uses the data to set the pixel color.
<a class="notranslate" href="#4`ImageBuffer::save`">`ImageBuffer::save`</a> writes the image to <code>output.png</code>.</p>
<br>
<div data-lang="rust,no_run"><div data-l="# #[macro_use]"></div><div data-l="# extern crate error_chain;"></div><div data-l="extern crate threadpool;"></div><div data-l="extern crate num;"></div><div data-l="extern crate num_cpus;"></div><div data-l="extern crate image;"></div><div data-l=""></div><div data-l="use std::sync::mpsc::{channel, RecvError};"></div><div data-l="use threadpool::ThreadPool;"></div><div data-l="use num::complex::Complex;"></div><div data-l="use image::{ImageBuffer, Pixel, Rgb};"></div><div data-l="#"></div><div data-l="# error_chain! {"></div><div data-l="#     foreign_links {"></div><div data-l="#         MpscRecv(RecvError);"></div><div data-l="#         Io(std::io::Error);"></div><div data-l="#     }"></div><div data-l="# }"></div><div data-l="#"></div><div data-l="#//# // Function converting intensity values to RGB"></div><div data-l="# // ">Function converting intensity values to RGB</div><div data-l="#//# // Based on http://www.efg2.com/Lab/ScienceAndEngineering/Spectra.htm"></div><div data-l="# // ">Based on http://www.efg2.com/Lab/ScienceAndEngineering/Spectra.htm</div><div data-l="# fn wavelength_to_rgb(wavelength: u32) -&gt; Rgb&lt;u8&gt; {"></div><div data-l="#     let wave = wavelength as f32;"></div><div data-l="#"></div><div data-l="#     let (r, g, b) = match wavelength {"></div><div data-l="#         380...439 =&gt; ((440. - wave) / (440. - 380.), 0.0, 1.0),"></div><div data-l="#         440...489 =&gt; (0.0, (wave - 440.) / (490. - 440.), 1.0),"></div><div data-l="#         490...509 =&gt; (0.0, 1.0, (510. - wave) / (510. - 490.)),"></div><div data-l="#         510...579 =&gt; ((wave - 510.) / (580. - 510.), 1.0, 0.0),"></div><div data-l="#         580...644 =&gt; (1.0, (645. - wave) / (645. - 580.), 0.0),"></div><div data-l="#         645...780 =&gt; (1.0, 0.0, 0.0),"></div><div data-l="#         _ =&gt; (0.0, 0.0, 0.0),"></div><div data-l="#     };"></div><div data-l="#"></div><div data-l="#     let factor = match wavelength {"></div><div data-l="#         380...419 =&gt; 0.3 + 0.7 * (wave - 380.) / (420. - 380.),"></div><div data-l="#         701...780 =&gt; 0.3 + 0.7 * (780. - wave) / (780. - 700.),"></div><div data-l="#         _ =&gt; 1.0,"></div><div data-l="#     };"></div><div data-l="#"></div><div data-l="#     let (r, g, b) = (normalize(r, factor), normalize(g, factor), normalize(b, factor));"></div><div data-l="#     Rgb::from_channels(r, g, b, 0)"></div><div data-l="# }"></div><div data-l="#"></div><div data-l="#//# // Maps Julia set distance estimation to intensity values"></div><div data-l="# // ">Maps Julia set distance estimation to intensity values</div><div data-l="# fn julia(c: Complex&lt;f32&gt;, x: u32, y: u32, width: u32, height: u32, max_iter: u32) -&gt; u32 {"></div><div data-l="#     let width = width as f32;"></div><div data-l="#     let height = height as f32;"></div><div data-l="#"></div><div data-l="#     let mut z = Complex {"></div><div data-l="#//#         // scale and translate the point to image coordinates"></div><div data-l="#         // ">scale and translate the point to image coordinates</div><div data-l="#         re: 3.0 * (x as f32 - 0.5 * width) / width,"></div><div data-l="#         im: 2.0 * (y as f32 - 0.5 * height) / height,"></div><div data-l="#     };"></div><div data-l="#"></div><div data-l="#     let mut i = 0;"></div><div data-l="#     for t in 0..max_iter {"></div><div data-l="#         if z.norm() &gt;= 2.0 {"></div><div data-l="#             break;"></div><div data-l="#         }"></div><div data-l="#         z = z * z + c;"></div><div data-l="#         i = t;"></div><div data-l="#     }"></div><div data-l="#     i"></div><div data-l="# }"></div><div data-l="#"></div><div data-l="#//# // Normalizes color intensity values within RGB range"></div><div data-l="# // ">Normalizes color intensity values within RGB range</div><div data-l="# fn normalize(color: f32, factor: f32) -&gt; u8 {"></div><div data-l="#     ((color * factor).powf(0.8) * 255.) as u8"></div><div data-l="# }"></div><div data-l=""></div><div data-l="fn run() -&gt; Result&lt;()&gt; {"></div><div data-l="    let (width, height) = (1920, 1080);"></div><div data-l="    let mut img = ImageBuffer::new(width, height);"></div><div data-l="    let iterations = 300;"></div><div data-l=""></div><div data-l="    let c = Complex::new(-0.8, 0.156);"></div><div data-l=""></div><div data-l="    let pool = ThreadPool::new(num_cpus::get());"></div><div data-l="    let (tx, rx) = channel();"></div><div data-l=""></div><div data-l="    for y in 0..height {"></div><div data-l="        let tx = tx.clone();"></div><div data-l="        pool.execute(move || for x in 0..width {"></div><div data-l="                         let i = julia(c, x, y, width, height, iterations);"></div><div data-l="                         let pixel = wavelength_to_rgb(380 + i * 400 / iterations);"></div><div data-l="                         tx.send((x, y, pixel)).expect(&quot;Could not send data!&quot;);"></div><div data-l="                     });"></div><div data-l="    }"></div><div data-l=""></div><div data-l="    for _ in 0..(width * height) {"></div><div data-l="        let (x, y, pixel) = rx.recv()?;"></div><div data-l="        img.put_pixel(x, y, pixel);"></div><div data-l="    }"></div><div data-l="    let _ = img.save(&quot;output.png&quot;)?;"></div><div data-l="    Ok(())"></div><div data-l="}"></div><div data-l="#"></div><div data-l="# quick_main!(run);"></div></div>
<br>
<a class="notranslate" href="#1https://docs.rs/image/*/image/struct.ImageBuffer.html#method.new">`ImageBuffer::new`</a>
<a class="notranslate" href="#1https://docs.rs/image/*/image/struct.ImageBuffer.html#method.put_pixel">`ImageBuffer::put_pixel`</a>
<a class="notranslate" href="#1https://docs.rs/image/*/image/struct.ImageBuffer.html#method.save">`ImageBuffer::save`</a>
<a class="notranslate" href="#1https://doc.rust-lang.org/std/sync/mpsc/fn.channel.html">`mpsc::channel`</a>
<a class="notranslate" href="#1https://docs.rs/num_cpus/*/num_cpus/fn.get.html">`num_cpus::get`</a>
<a class="notranslate" href="#1https://doc.rust-lang.org/std/sync/mpsc/struct.Receiver.html#method.recv">`Receiver::recv`</a>
<a class="notranslate" href="#1https://docs.rs/image/*/image/struct.Rgb.html#method.from_channels">`Rgb::from_channels`</a>
<a class="notranslate" href="#1https://docs.rs/threadpool/*/threadpool/struct.ThreadPool.html">`ThreadPool`</a>
<a class="notranslate" href="#1https://docs.rs/threadpool/*/threadpool/struct.ThreadPool.html#method.execute">`ThreadPool::execute`</a>
<br>
<a class="notranslate" href="#1https://en.wikipedia.org/wiki/Julia_set">Julia set</a>